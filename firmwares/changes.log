commit e7bb049f7734bf960ed07d0bea5e4a197dce7540
Author: Chuangcheng Peng <chuangcheng.peng@amlogic.com>
Date:   Wed Feb 20 16:12:18 2019 +0800

    dvb: support swdemux [1/3]
    
    PD#SWPL-2788
    
    Problem:
       support 4 demux at same time.
    
    Solution:
       support swdemux and swdsc.
    
    Verify:
       verify at r311 in android p.
    support:
    1. local ts play
    2. livetv play
    3. used one path(one tsinput->one demux->one asyncfifo)
    need to confirm:
    1.dsc feature.
    
    Change-Id: I50f03de6de7d0b3c0f2580db46f3e6e891296e74
    Signed-off-by: Chuangcheng Peng <chuangcheng.peng@amlogic.com>

diff --git a/drivers/stream_input/Makefile b/drivers/stream_input/Makefile
index 73dfd13..6518166 100644
--- a/drivers/stream_input/Makefile
+++ b/drivers/stream_input/Makefile
@@ -11,6 +11,8 @@ stream_input-objs	+=	parser/rmparser.o
 stream_input-objs	+=	subtitle/subtitle.o
 
 obj-$(CONFIG_AMLOGIC_DVB)   += parser/hw_demux/
+obj-$(CONFIG_AMLOGIC_DVB)   += parser/demux/
+obj-$(CONFIG_AMLOGIC_DVB)   += parser/dvb_ci/
 #obj-y 	+= 	tv_frontend/
 # obj-y	+=	box-frontend/avl6211/
 # obj-y	+=	box-frontend/atbm8881/
diff --git a/drivers/stream_input/parser/demux/Makefile b/drivers/stream_input/parser/demux/Makefile
new file mode 100644
index 0000000..c0df578
--- /dev/null
+++ b/drivers/stream_input/parser/demux/Makefile
@@ -0,0 +1,37 @@
+obj-m	+= aml_swdmx.o
+
+ccflags-y += -I$(srctree)/drivers/media/dvb-core -I$(srctree)/drivers/gpio -I$(srctree)/include
+
+aml_swdmx-objs += aml_dvb.o
+aml_swdmx-objs += aml_dsc.o
+aml_swdmx-objs += aml_dmx.o
+aml_swdmx-objs += aml_dmx_ext.o
+
+aml_swdmx-objs += sw_demux/swdmx_aes_cbc.o
+aml_swdmx-objs += sw_demux/swdmx_aes_ecb.o
+aml_swdmx-objs += sw_demux/swdmx_cb_list.o
+aml_swdmx-objs += sw_demux/swdmx_crc32.o
+aml_swdmx-objs += sw_demux/swdmx_demux.o
+aml_swdmx-objs += sw_demux/swdmx_descrambler.o
+aml_swdmx-objs += sw_demux/swdmx_dvbcsa2.o
+aml_swdmx-objs += sw_demux/swdmx_ts_parser.o
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_algo.o
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_block.o
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_bs_algo.o
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_bs_block.o
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_bs_key.o
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_bs_stream.o
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_key.o
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_stream.o
+
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_bs_transpose.o
+
+aml_swdmx-objs += sw_demux/dvbcsa2/dvbcsa_bs_transpose32.o
+
+aml_swdmx-objs += hw_demux/hwdemux.o
+aml_swdmx-objs += hw_demux/frontend.o
+aml_swdmx-objs += hw_demux/s2p.o
+aml_swdmx-objs += hw_demux/asyncfifo.o
+aml_swdmx-objs += hw_demux/hwdemux_inject.o
+
+#obj-y += dvb_ci/
diff --git a/drivers/stream_input/parser/demux/aml_dmx.c b/drivers/stream_input/parser/demux/aml_dmx.c
new file mode 100644
index 0000000..a5aa41d
--- /dev/null
+++ b/drivers/stream_input/parser/demux/aml_dmx.c
@@ -0,0 +1,957 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/crc32.h>
+#include <asm/uaccess.h>
+#include <asm/div64.h>
+
+//#include "aml_dvb.h"
+#include "aml_dmx.h"
+#include "aml_dmx_ext.h"
+//#include "hwdemux.h"
+
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+#define pr_inf(fmt, args...)   printk(KERN_DEBUG fmt, ## args)
+
+#define MAX_SEC_FEED_NUM 20
+#define MAX_TS_FEED_NUM 20
+#define MAX_FILTER_PER_SEC_FEED 8
+
+
+#define DMX_STATE_FREE      0
+#define DMX_STATE_ALLOCATED 1
+#define DMX_STATE_SET       2
+#define DMX_STATE_READY     3
+#define DMX_STATE_GO        4
+
+#define SWDMX_MAX_PID 0x1fff
+
+#define DMX_TYPE_TS  0
+#define DMX_TYPE_SEC 1
+#define DMX_TYPE_PES 2
+
+static int _dmx_write(struct aml_dmx *pdmx, const u8 *buf, size_t count);
+
+
+static inline void _invert_mode(struct dmx_section_filter *filter)
+{
+	int i;
+
+	for (i = 0; i < DMX_FILTER_SIZE; i++)
+		filter->filter_mode[i] ^= 0xff;
+}
+
+static int _dmx_open(struct dmx_demux *demux)
+{
+	struct aml_dmx *pdmx = (struct aml_dmx *)demux->priv;
+
+	if (pdmx->users >= MAX_SW_DEMUX_USERS)
+		return -EUSERS;
+
+	pdmx->users++;
+	return 0;
+}
+
+static int _dmx_close(struct dmx_demux *demux)
+{
+	struct aml_dmx *pdmx = (struct aml_dmx *)demux->priv;
+
+	if (pdmx->users == 0)
+		return -ENODEV;
+
+	pdmx->users--;
+
+	if (pdmx->users == 0) {
+		if (pdmx->used_hwdmx)
+			hwdmx_inject_destroy(pdmx->hwdmx);
+	}
+	//FIXME: release any unneeded resources if users==0
+	return 0;
+}
+
+static int _dmx_write_from_user(struct dmx_demux *demux, const char __user *buf, size_t count)
+{
+	struct aml_dmx *pdmx = (struct aml_dmx *)demux->priv;
+	void *p;
+	int ret = 0;
+
+	if (pdmx->used_hwdmx) {
+		ret = hwdmx_inject(pdmx->hwdmx, buf, count);
+		return ret;
+	}
+//	pr_inf("_dmx_write_from_user\n");
+	p = memdup_user(buf, count);
+	if (IS_ERR(p)) {
+		pr_error("get fail mem pointer\n");
+		return PTR_ERR(p);
+	}
+	ret = _dmx_write(pdmx, p, count);
+
+	kfree(p);
+
+	if (signal_pending(current))
+		return -EINTR;
+	return ret;
+}
+
+static struct sw_demux_sec_feed *_dmx_section_feed_alloc(struct aml_dmx *demux)
+{
+	int i;
+
+	for (i = 0; i < demux->sec_feed_num; i++)
+		if (demux->section_feed[i].state == DMX_STATE_FREE)
+			break;
+
+	if (i == demux->sec_feed_num)
+		return NULL;
+
+	demux->section_feed[i].state = DMX_STATE_ALLOCATED;
+
+	return &demux->section_feed[i];
+}
+
+static struct sw_demux_ts_feed *_dmx_ts_feed_alloc(struct aml_dmx *demux)
+{
+	int i;
+
+	for (i = 0; i < demux->ts_feed_num; i++)
+		if (demux->ts_feed[i].state == DMX_STATE_FREE)
+			break;
+
+	if (i == demux->ts_feed_num)
+		return NULL;
+
+	demux->ts_feed[i].state = DMX_STATE_ALLOCATED;
+
+	return &demux->ts_feed[i];
+}
+
+static struct sw_demux_sec_filter *_dmx_dmx_sec_filter_alloc(struct sw_demux_sec_feed *sec_feed)
+{
+	int i;
+
+	for (i = 0; i < MAX_FILTER_PER_SEC_FEED; i++)
+		if (sec_feed->filter[i].state == DMX_STATE_FREE)
+			break;
+
+	if (i == MAX_FILTER_PER_SEC_FEED)
+		return NULL;
+
+	sec_feed->filter[i].state = DMX_STATE_ALLOCATED;
+
+	return &sec_feed->filter[i];
+}
+#if 0
+static void prdump(const char* m, const void* data, uint32_t len) {
+	if (m)
+		pr_error("%s:\n", m);
+	if (data) {
+		size_t i = 0;
+		const unsigned char *c __attribute__((unused)) = data;
+		while (len >= 16) {
+			pr_error("%02x %02x %02x %02x %02x %02x %02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+					c[i], c[i+1], c[i+2], c[i+3], c[i+4], c[i+5], c[i+6], c[i+7],
+					c[i+8], c[i+9], c[i+10], c[i+11], c[i+12], c[i+13], c[i+14], c[i+15]);
+			len -= 16;
+			i += 16;
+		}
+		while (len >= 8) {
+			pr_error("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+					c[i], c[i+1], c[i+2], c[i+3], c[i+4], c[i+5], c[i+6], c[i+7]);
+			len -= 8;
+			i += 8;
+		}
+		while (len >= 4) {
+			printk("%02x %02x %02x %02x\n",
+					c[i], c[i+1], c[i+2], c[i+3]);
+			len -= 4;
+			i += 4;
+		}
+		while (len >= 1) {
+			pr_error("%02x ", c[i]);
+			len -= 1;
+			i += 1;
+		}
+	}
+}
+#endif
+static void _ts_pkt_cb (SWDMX_TsPacket *pkt, SWDMX_Ptr data)
+{
+//	prdump("ts_data", pkt->packet, 32);
+
+	struct dmx_ts_feed * source_feed = (struct dmx_ts_feed *)data;
+	struct sw_demux_ts_feed *ts_feed = (struct sw_demux_ts_feed *)data;
+
+	if (ts_feed->state != DMX_STATE_GO) {
+		return ;
+	}
+	if (ts_feed->ts_cb) {
+		ts_feed->ts_cb(pkt->packet,pkt->packet_len,NULL,0,source_feed);
+	}
+}
+static void _sec_cb (SWDMX_UInt8 *sec, SWDMX_Int len, SWDMX_Ptr data)
+{
+	struct dmx_section_filter *source_filter = (struct dmx_section_filter *)data;
+	struct sw_demux_sec_feed *sec_feed = (struct sw_demux_sec_feed *)source_filter->parent;
+
+//	prdump("sec_data", sec, 32);
+
+	if (sec_feed->state != DMX_STATE_GO) {
+		return ;
+	}
+
+	if (sec_feed->sec_cb) {
+		sec_feed->sec_cb(sec,len,NULL, 0,source_filter);
+	}
+}
+
+static int _dmx_ts_feed_set(struct dmx_ts_feed *ts_feed, u16 pid, int ts_type,
+			   enum dmx_ts_pes pes_type,
+			   size_t circular_buffer_size, ktime_t timeout)
+{
+	struct sw_demux_ts_feed *feed = (struct sw_demux_ts_feed *)ts_feed;
+	struct aml_dmx *demux = (struct aml_dmx *)ts_feed->parent->priv;
+
+	pr_inf("_dmx_ts_feed_set pid:0x%0x\n",pid);
+
+	if (pid >= SWDMX_MAX_PID)
+		return -EINVAL;
+
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	if (ts_type & TS_DECODER) {
+		if (pes_type >= DMX_PES_OTHER) {
+			mutex_unlock(demux->pmutex);
+			return -EINVAL;
+		}
+	}
+
+	feed->pid = pid;
+	feed->ts_type = ts_type;
+//	feed->type = DMX_TYPE_PES; //ts_type;
+	feed->pes_type = pes_type;
+	feed->state = DMX_STATE_READY;
+
+#if 0
+	feed->buffer_size = circular_buffer_size;
+
+	if (feed->buffer_size) {
+		feed->buffer = vmalloc(feed->buffer_size);
+		if (!feed->buffer) {
+			mutex_unlock(&demux->mutex);
+			return -ENOMEM;
+		}
+	}
+#endif
+
+	/*enable hw pid filter*/
+	if (demux->used_hwdmx)
+		hwdmx_set_pid(feed->tschan,feed->type, feed->pes_type, feed->pid);
+
+	mutex_unlock(demux->pmutex);
+
+	return 0;
+}
+
+static int _dmx_ts_feed_start_filtering(struct dmx_ts_feed *ts_feed)
+{
+	struct sw_demux_ts_feed *feed = (struct sw_demux_ts_feed *)ts_feed;
+	struct aml_dmx *demux = (struct aml_dmx *)ts_feed->parent->priv;
+	SWDMX_TsFilterParams  tsfp;
+
+	pr_inf("_dmx_ts_feed_start_filtering\n");
+	if (mutex_lock_interruptible(demux->pmutex)) {
+
+		pr_error("%s line:%d\n",__func__,__LINE__);
+		return -ERESTARTSYS;
+	}
+
+	if (feed->state != DMX_STATE_READY || feed->type != DMX_TYPE_TS) {
+		mutex_unlock(demux->pmutex);
+		return -EINVAL;
+	}
+
+	tsfp.pid = feed->pid;
+	swdmx_ts_filter_set_params(feed->tsf, &tsfp);
+	swdmx_ts_filter_add_ts_packet_cb(feed->tsf, _ts_pkt_cb, ts_feed);
+
+	if (swdmx_ts_filter_enable(feed->tsf) != SWDMX_OK) {
+		mutex_unlock(demux->pmutex);
+		return -EINVAL;
+	}
+
+	if (feed->type == TS_PACKET) {
+		dmx_ext_add_pvr_pid(demux->id, feed->pid);
+	}
+	spin_lock_irq(demux->pslock);
+	ts_feed->is_filtering = 1;
+	feed->state = DMX_STATE_GO;
+	spin_unlock_irq(demux->pslock);
+	mutex_unlock(demux->pmutex);
+
+	return 0;
+}
+
+static int _dmx_ts_feed_stop_filtering(struct dmx_ts_feed *ts_feed)
+{
+	struct sw_demux_ts_feed *feed = (struct sw_demux_ts_feed *)ts_feed;
+	struct aml_dmx *demux = (struct aml_dmx *)ts_feed->parent->priv;
+
+	pr_inf("_dmx_ts_feed_stop_filtering \n");
+	mutex_lock(demux->pmutex);
+
+	if (feed->state < DMX_STATE_GO) {
+		mutex_unlock(demux->pmutex);
+		return -EINVAL;
+	}
+
+	if (swdmx_ts_filter_disable(feed->tsf) != SWDMX_OK) {
+		mutex_unlock(demux->pmutex);
+		return -EINVAL;
+	}
+	if (feed->type == TS_PACKET) {
+		dmx_ext_remove_pvr_pid(demux->id, feed->pid);
+	}
+
+	spin_lock_irq(demux->pslock);
+	ts_feed->is_filtering = 0;
+	feed->state = DMX_STATE_ALLOCATED;
+	spin_unlock_irq(demux->pslock);
+	mutex_unlock(demux->pmutex);
+
+	return 0;
+}
+static int _dmx_section_feed_allocate_filter(struct dmx_section_feed *feed,
+					    struct dmx_section_filter **filter)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)feed->parent->priv;
+	struct sw_demux_sec_filter *sec_filter;
+
+	pr_inf("_dmx_section_feed_allocate_filter \n");
+
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	sec_filter = _dmx_dmx_sec_filter_alloc((struct sw_demux_sec_feed *)feed);
+	if (!sec_filter) {
+		mutex_unlock(demux->pmutex);
+		return -EBUSY;
+	}
+	sec_filter->secf = swdmx_demux_alloc_sec_filter(demux->swdmx);
+	if (!sec_filter->secf) {
+		sec_filter->state = DMX_STATE_FREE;
+		mutex_unlock(demux->pmutex);
+		return -EBUSY;
+	}
+	spin_lock_irq(demux->pslock);
+	*filter = &sec_filter->section_filter;
+	(*filter)->parent = feed;
+//	(*filter)->priv = sec_filter;
+	spin_unlock_irq(demux->pslock);
+	mutex_unlock(demux->pmutex);
+	return 0;
+}
+
+static int _dmx_section_feed_set(struct dmx_section_feed *feed,
+				u16 pid, size_t circular_buffer_size,
+				int check_crc)
+{
+	struct sw_demux_sec_feed *sec_feed = (struct sw_demux_sec_feed *)feed;
+	struct aml_dmx *demux = (struct aml_dmx *)feed->parent->priv;
+
+	pr_inf("_dmx_section_feed_set \n");
+
+	if (pid >= SWDMX_MAX_PID)
+		return -EINVAL;
+
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	sec_feed->pid = pid;
+	sec_feed->check_crc = check_crc;
+	sec_feed->type = DMX_TYPE_SEC;
+	sec_feed->state = DMX_STATE_READY;
+
+	/*enable hw pid filter*/
+	if (demux->used_hwdmx)
+		hwdmx_set_pid(sec_feed->secchan,sec_feed->type, 0, sec_feed->pid);
+
+	mutex_unlock(demux->pmutex);
+
+	return 0;
+}
+static int _dmx_section_feed_start_filtering(struct dmx_section_feed *feed)
+{
+	struct sw_demux_sec_feed *sec_feed = (struct sw_demux_sec_feed *)feed;
+	struct aml_dmx *demux = (struct aml_dmx *)feed->parent->priv;
+	SWDMX_SecFilterParams params;
+	int i = 0;
+	int start_flag = 0;
+
+	pr_inf("_dmx_section_feed_start_filtering\n");
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	if (feed->is_filtering) {
+		mutex_unlock(demux->pmutex);
+		return -EBUSY;
+	}
+	for (i=0; i<MAX_FILTER_PER_SEC_FEED; i++) {
+		if (sec_feed->filter[i].state == DMX_STATE_ALLOCATED) {
+			params.pid = sec_feed->pid;
+			params.crc32 = sec_feed->check_crc;
+
+			memcpy(&sec_feed->filter[i].section_filter.filter_value[1],&sec_feed->filter[i].section_filter.filter_value[3],SWDMX_SEC_FILTER_LEN-1);
+			memcpy(&sec_feed->filter[i].section_filter.filter_mask[1],&sec_feed->filter[i].section_filter.filter_mask[3],SWDMX_SEC_FILTER_LEN-1);
+			memcpy(&sec_feed->filter[i].section_filter.filter_mode[1],&sec_feed->filter[i].section_filter.filter_mode[3],SWDMX_SEC_FILTER_LEN-1);
+			_invert_mode(&sec_feed->filter[i].section_filter);
+
+			memcpy(params.value,sec_feed->filter[i].section_filter.filter_value,SWDMX_SEC_FILTER_LEN);
+			memcpy(params.mask,sec_feed->filter[i].section_filter.filter_mask,SWDMX_SEC_FILTER_LEN);
+			memcpy(params.mode,sec_feed->filter[i].section_filter.filter_mode,SWDMX_SEC_FILTER_LEN);
+
+			if (swdmx_sec_filter_set_params(sec_feed->filter[i].secf,&params) != SWDMX_OK) {
+				continue;
+			}
+
+			swdmx_sec_filter_add_section_cb(sec_feed->filter[i].secf, _sec_cb, &sec_feed->filter[i].section_filter);
+
+			if (swdmx_sec_filter_enable(sec_feed->filter[i].secf) != SWDMX_OK) {
+				continue;
+			}
+			sec_feed->filter[i].state = DMX_STATE_GO;
+			start_flag = 1;
+		}
+		else if (sec_feed->filter[i].state == DMX_STATE_READY) {
+			if (swdmx_sec_filter_enable(sec_feed->filter[i].secf) != SWDMX_OK) {
+				continue;
+			}
+			sec_feed->filter[i].state = DMX_STATE_GO;
+			start_flag = 1;
+		}
+	}
+	if (start_flag != 1) {
+		pr_error("%s fail \n",__FUNCTION__);
+		return -1;
+	}
+	sec_feed->state = DMX_STATE_GO;
+
+	spin_lock_irq(demux->pslock);
+	feed->is_filtering = 1;
+	spin_unlock_irq(demux->pslock);
+	mutex_unlock(demux->pmutex);
+
+	return 0;
+}
+
+static int _dmx_section_feed_stop_filtering(struct dmx_section_feed *feed)
+{
+	struct sw_demux_sec_feed *sec_feed = (struct sw_demux_sec_feed *)feed;
+	struct aml_dmx *demux = (struct aml_dmx *)feed->parent->priv;
+	int i = 0;
+	int start_flag = 0;
+
+	pr_inf("_dmx_section_feed_stop_filtering \n");
+
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	if (feed->is_filtering == 0) {
+		mutex_unlock(demux->pmutex);
+		return -EINVAL;
+	}
+	for (i=0; i<MAX_FILTER_PER_SEC_FEED; i++) {
+		if (sec_feed->filter[i].state == DMX_STATE_GO) {
+			if (swdmx_sec_filter_disable(sec_feed->filter[i].secf) != SWDMX_OK) {
+				continue;
+			}
+			sec_feed->filter[i].state = DMX_STATE_READY;
+			start_flag = 1;
+		}
+	}
+	if (start_flag != 1) {
+		pr_error("%s no found start filter \n",__FUNCTION__);
+		mutex_unlock(demux->pmutex);
+		return 0;
+	}
+
+	spin_lock_irq(demux->pslock);
+	feed->is_filtering = 0;
+	spin_unlock_irq(demux->pslock);
+	mutex_unlock(demux->pmutex);
+
+	return 0;
+}
+
+static int _dmx_section_feed_release_filter(struct dmx_section_feed *feed,
+					   struct dmx_section_filter *filter)
+{
+	struct sw_demux_sec_feed *sec_feed = (struct sw_demux_sec_feed *)feed;
+	struct aml_dmx *demux = (struct aml_dmx *)feed->parent->priv;
+	int i = 0;
+
+	pr_inf("_dmx_section_feed_release_filter\n");
+
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	if (sec_feed->type != DMX_TYPE_SEC) {
+		mutex_unlock(demux->pmutex);
+		return -EINVAL;
+	}
+	for (i=0; i<MAX_FILTER_PER_SEC_FEED; i++) {
+		if (sec_feed->filter[i].state != DMX_STATE_FREE && (&sec_feed->filter[i].section_filter) == filter) {
+			swdmx_sec_filter_free(sec_feed->filter[i].secf);
+			sec_feed->filter[i].secf = NULL;
+			memset(filter,0,sizeof(struct dmx_section_filter));
+			sec_feed->filter[i].state = DMX_STATE_FREE;
+			break;
+		}
+	}
+
+	mutex_unlock(demux->pmutex);
+
+	return 0;
+}
+
+static int _dmx_allocate_ts_feed(struct dmx_demux *dmx,
+				   struct dmx_ts_feed **ts_feed,
+				   dmx_ts_cb callback)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx->priv;
+	struct sw_demux_ts_feed *feed;
+
+	pr_inf("_dmx_allocate_ts_feed line:%d\n",__LINE__);
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	if (!(feed = _dmx_ts_feed_alloc(demux))) {
+		mutex_unlock(demux->pmutex);
+		pr_error("_dmx_allocate_ts_feed line:%d\n",__LINE__);
+		return -EBUSY;
+	}
+
+	feed->type = DMX_TYPE_TS;
+	feed->ts_cb = callback;
+
+	(*ts_feed) = &feed->ts_feed;
+	(*ts_feed)->parent = dmx;
+//	(*ts_feed)->priv = feed;
+	(*ts_feed)->is_filtering = 0;
+	(*ts_feed)->start_filtering = _dmx_ts_feed_start_filtering;
+	(*ts_feed)->stop_filtering = _dmx_ts_feed_stop_filtering;
+	(*ts_feed)->set = _dmx_ts_feed_set;
+
+	feed->tsf = swdmx_demux_alloc_ts_filter(demux->swdmx);
+	if (!feed->tsf)
+	{
+		pr_error("_dmx_allocate_ts_feed line:%d\n",__LINE__);
+		feed->state = DMX_STATE_FREE;
+		mutex_unlock(demux->pmutex);
+		return ERESTARTSYS;
+	}
+	if (demux->used_hwdmx) {
+		feed->tschan = hwdmx_alloc_chan(demux->hwdmx);
+		if (!feed->tschan) {
+			pr_error("hwdmx_alloc_chan fail line:%d\n",__LINE__);
+			swdmx_ts_filter_free(feed->tsf);
+			feed->state = DMX_STATE_FREE;
+			mutex_unlock(demux->pmutex);
+			return ERESTARTSYS;
+		}
+	}
+	mutex_unlock(demux->pmutex);
+
+	return 0;
+}
+
+static int _dmx_release_ts_feed(struct dmx_demux *dmx,
+				  struct dmx_ts_feed *ts_feed)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx->priv;
+	struct sw_demux_ts_feed *feed;
+
+	pr_inf(" _dmx_release_ts_feed\n");
+	if (!ts_feed) {
+		return 0;
+	}
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	feed = (struct sw_demux_ts_feed *)ts_feed;
+
+	if (demux->used_hwdmx)
+		hwdmx_free_chan(feed->tschan);
+	swdmx_ts_filter_free(feed->tsf);
+	feed->state = DMX_STATE_FREE;
+
+	mutex_unlock(demux->pmutex);
+	return 0;
+}
+
+static int _dmx_allocate_section_feed(struct dmx_demux *dmx,
+					struct dmx_section_feed **feed,
+					dmx_section_cb callback)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx->priv;
+	struct sw_demux_sec_feed *sec_feed;
+	int i;
+
+	pr_inf("_dmx_allocate_section_feed \n");
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	if (!(sec_feed = _dmx_section_feed_alloc(demux))) {
+		mutex_unlock(demux->pmutex);
+		return -EBUSY;
+	}
+
+	sec_feed->sec_filter_num = MAX_FILTER_PER_SEC_FEED;
+	sec_feed->filter = vmalloc(sizeof(struct sw_demux_sec_filter) * sec_feed->sec_filter_num);
+	if (!sec_feed->filter) {
+		mutex_unlock(demux->pmutex);
+		return -EBUSY;
+	}
+	for (i=0; i<sec_feed->sec_filter_num; i++) {
+		sec_feed->filter[i].state = DMX_STATE_FREE;
+	}
+	sec_feed->sec_cb = callback;
+	sec_feed->type = DMX_TYPE_SEC;
+
+	(*feed) = &sec_feed->sec_feed;
+	(*feed)->parent = dmx;
+//	(*feed)->priv = sec_feed;
+	(*feed)->is_filtering = 0;
+
+	(*feed)->set = _dmx_section_feed_set;
+	(*feed)->allocate_filter = _dmx_section_feed_allocate_filter;
+	(*feed)->start_filtering = _dmx_section_feed_start_filtering;
+	(*feed)->stop_filtering = _dmx_section_feed_stop_filtering;
+	(*feed)->release_filter = _dmx_section_feed_release_filter;
+
+	if (demux->used_hwdmx) {
+		sec_feed->secchan = hwdmx_alloc_chan(demux->hwdmx);
+		if (!sec_feed->secchan) {
+			pr_error("%s error\n",__FUNCTION__);
+		}
+	}
+	mutex_unlock(demux->pmutex);
+	return 0;
+}
+
+static int _dmx_release_section_feed(struct dmx_demux *dmx,
+				       struct dmx_section_feed *feed)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx->priv;
+	struct sw_demux_sec_feed *sec_feed;
+
+	pr_inf(" _dmx_release_section_feed\n");
+	if (mutex_lock_interruptible(demux->pmutex))
+		return -ERESTARTSYS;
+
+	sec_feed = (struct sw_demux_sec_feed *)feed;
+	sec_feed->state = DMX_STATE_FREE;
+
+	if (demux->used_hwdmx) {
+		if (sec_feed->secchan) {
+			hwdmx_free_chan(sec_feed->secchan);
+			sec_feed->secchan = NULL;
+		}
+	}
+	mutex_unlock(demux->pmutex);
+	return 0;
+}
+static int _dmx_add_frontend(struct dmx_demux *dmx,
+			       struct dmx_frontend *frontend)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx->priv;
+	struct list_head *head = &demux->frontend_list;
+
+	list_add(&(frontend->connectivity_list), head);
+
+	return 0;
+}
+
+static int _dmx_remove_frontend(struct dmx_demux *dmx,
+				  struct dmx_frontend *frontend)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx->priv;
+	struct list_head *pos, *n, *head = &demux->frontend_list;
+
+	list_for_each_safe(pos, n, head) {
+		if (DMX_FE_ENTRY(pos) == frontend) {
+			list_del(pos);
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static struct list_head *_dmx_get_frontends(struct dmx_demux *dmx)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx->priv;
+
+	if (list_empty(&demux->frontend_list))
+		return NULL;
+
+	return &demux->frontend_list;
+}
+
+static int _dmx_connect_frontend(struct dmx_demux *dmx,
+				   struct dmx_frontend *frontend)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx->priv;
+
+	if (dmx->frontend)
+		return -EINVAL;
+
+	mutex_lock(demux->pmutex);
+
+	dmx->frontend = frontend;
+	mutex_unlock(demux->pmutex);
+	return 0;
+}
+
+static int _dmx_disconnect_frontend(struct dmx_demux *dmx)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx;
+
+	mutex_lock(demux->pmutex);
+
+	dmx->frontend = NULL;
+	mutex_unlock(demux->pmutex);
+	return 0;
+}
+
+static int _dmx_get_pes_pids(struct dmx_demux *dmx, u16 * pids)
+{
+	struct aml_dmx *demux = (struct aml_dmx *)dmx;
+
+	memcpy(pids, demux->pids, 5 * sizeof(u16));
+	return 0;
+}
+static int _dmx_write(struct aml_dmx *pdmx, const u8 *buf, size_t count)
+{
+	int n = 0;
+
+	if (pdmx->tsp == NULL)
+	{
+		pr_error("_dmx_write invalid tsp\n");
+		return -1;
+	}
+
+	if (mutex_lock_interruptible(pdmx->pmutex))
+		return -ERESTARTSYS;
+
+	n = swdmx_ts_parser_run(pdmx->tsp, (SWDMX_UInt8 *)buf, count);
+	if (n != 0) {
+//		printk("call swdmx_ts_parser_run,len 0x%zx,Remaining len: 0x%0x\n",count,n);
+	}
+	mutex_unlock(pdmx->pmutex);
+
+	return n;
+}
+
+int dmx_init(struct aml_dmx *pdmx, struct dvb_adapter *dvb_adapter)
+{
+	int ret;
+	int i = 0;
+
+	pdmx->dmx.capabilities =
+		(DMX_TS_FILTERING | DMX_SECTION_FILTERING |
+		 DMX_MEMORY_BASED_FILTERING);
+	pdmx->dmx.priv = pdmx;
+
+	pdmx->ts_feed_num = MAX_TS_FEED_NUM;
+	pdmx->ts_feed = vmalloc(sizeof(struct sw_demux_ts_feed)*(pdmx->ts_feed_num));
+	if (!pdmx->ts_feed) {
+		return -ENOMEM;
+	}
+	for (i=0; i<pdmx->ts_feed_num; i++) {
+		pdmx->ts_feed[i].state = DMX_STATE_FREE;
+	}
+
+	pdmx->sec_feed_num = MAX_SEC_FEED_NUM;
+	pdmx->section_feed = vmalloc(sizeof(struct sw_demux_sec_feed)*(pdmx->sec_feed_num));
+	if (!pdmx->section_feed) {
+		vfree(pdmx->ts_feed);
+		pdmx->ts_feed = NULL;
+		return -ENOMEM;
+	}
+
+	for (i=0; i<pdmx->sec_feed_num; i++) {
+		pdmx->section_feed[i].state = DMX_STATE_FREE;
+	}
+	INIT_LIST_HEAD(&pdmx->frontend_list);
+
+	for (i = 0; i < DMX_PES_OTHER; i++) {
+		pdmx->pids[i] = 0xffff;
+	}
+
+	pdmx->used_hwdmx = 1;
+
+	pdmx->dmx.open = _dmx_open;
+	pdmx->dmx.close = _dmx_close;
+	pdmx->dmx.write = _dmx_write_from_user;
+	pdmx->dmx.allocate_ts_feed = _dmx_allocate_ts_feed;
+	pdmx->dmx.release_ts_feed = _dmx_release_ts_feed;
+	pdmx->dmx.allocate_section_feed = _dmx_allocate_section_feed;
+	pdmx->dmx.release_section_feed = _dmx_release_section_feed;
+
+	pdmx->dmx.add_frontend = _dmx_add_frontend;
+	pdmx->dmx.remove_frontend = _dmx_remove_frontend;
+	pdmx->dmx.get_frontends = _dmx_get_frontends;
+	pdmx->dmx.connect_frontend = _dmx_connect_frontend;
+	pdmx->dmx.disconnect_frontend = _dmx_disconnect_frontend;
+	pdmx->dmx.get_pes_pids = _dmx_get_pes_pids;
+
+	pdmx->dev.filternum = (MAX_TS_FEED_NUM+MAX_SEC_FEED_NUM);
+	pdmx->dev.demux = &pdmx->dmx;
+	pdmx->dev.capabilities = 0;
+	ret = dvb_dmxdev_init(&pdmx->dev, dvb_adapter);
+	if (ret < 0) {
+		pr_error("dvb_dmxdev_init failed: error %d\n", ret);
+		vfree(pdmx->ts_feed);
+		return -1;
+	}
+	pdmx->dev.dvr_dvbdev->writers = MAX_SW_DEMUX_USERS;
+
+	pdmx->mem_fe.source = DMX_MEMORY_FE;
+	ret = pdmx->dmx.add_frontend(&pdmx->dmx,&pdmx->mem_fe);
+	if (ret <0) {
+		pr_error("dvb_dmxdev_init add frontend: error %d\n", ret);
+		vfree(pdmx->ts_feed);
+		return -1;
+	}
+	pdmx->dmx.connect_frontend(&pdmx->dmx,&pdmx->mem_fe);
+	if (ret <0) {
+		pr_error("dvb_dmxdev_init connect frontend: error %d\n", ret);
+		vfree(pdmx->ts_feed);
+		return -1;
+	}
+	pdmx->buf_warning_level = 60;
+	pdmx->init = 1;
+//	dvb_net_init(dvb_adapter, &dmx->dvb_net, &pdmx->dmx);
+
+	return 0;
+
+}
+int dmx_destroy(struct aml_dmx *pdmx) {
+
+	if (pdmx->init) {
+		vfree(pdmx->ts_feed);
+	//	mutex_destroy(pdmx->mutex);
+
+		swdmx_demux_free(pdmx->swdmx);
+		dvb_dmxdev_release(&pdmx->dev);
+		pdmx->init = 0;
+	}
+	return 0;
+}
+int dmx_set_work_mode(struct aml_dmx *pdmx,int work_mode){
+
+	if (pdmx->init == 0) {
+		return -1;
+	}
+	pdmx->used_hwdmx = work_mode;
+	return 0;
+}
+int dmx_get_work_mode(struct aml_dmx *pdmx,int *work_mode){
+
+	if (pdmx->init == 0) {
+		return -1;
+	}
+	*work_mode = pdmx->used_hwdmx;
+	return 0;
+}
+
+int dmx_get_buf_warning_status(struct aml_dmx *pdmx, int *status){
+	int i = 0;
+	ssize_t free_mem = 0;
+	ssize_t total_mem = 0;
+
+	struct dmxdev *pdev = &pdmx->dev;
+
+	if (pdmx->init == 0) {
+		return -1;
+	}
+
+	for (i = 0; i < pdev->filternum; i++) {
+		if ((pdev->filter[i].state < DMXDEV_STATE_SET) ||
+			(pdev->filter[i].type != DMXDEV_TYPE_PES))
+			continue;
+
+		free_mem = dvb_ringbuffer_free(&pdev->filter[i].buffer);
+		total_mem = pdev->filter[i].buffer.size;
+
+		if ((total_mem-free_mem)*100/total_mem >= pdmx->buf_warning_level) {
+			*status = 1;
+			return 0;
+		}
+	}
+	*status = 0;
+	return 0;
+}
+
+int dmx_set_buf_warning_level(struct aml_dmx *pdmx, int level) {
+	pdmx->buf_warning_level = level;
+	return 0;
+}
+int dmx_write_sw_from_user(struct aml_dmx *pdmx, const char __user *buf, size_t count)
+{
+	void *p;
+	int ret = 0;
+
+	p = memdup_user(buf, count);
+	if (IS_ERR(p)) {
+		pr_error("get fail mem pointer\n");
+		return PTR_ERR(p);
+	}
+	ret = _dmx_write(pdmx, p, count);
+
+	kfree(p);
+
+	if (signal_pending(current))
+		return -EINTR;
+	return ret;
+}
+
diff --git a/drivers/stream_input/parser/demux/aml_dmx.h b/drivers/stream_input/parser/demux/aml_dmx.h
new file mode 100644
index 0000000..1246bc2
--- /dev/null
+++ b/drivers/stream_input/parser/demux/aml_dmx.h
@@ -0,0 +1,106 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _AML_DMX_H_
+#define _AML_DMX_H_
+
+#include "sw_demux/swdemux.h"
+#include "hw_demux/hwdemux.h"
+#include "demux.h"
+#include "dvbdev.h"
+#include <dmxdev.h>
+
+struct sw_demux_ts_feed {
+	struct dmx_ts_feed ts_feed;
+
+	SWDMX_TsFilter		 *tsf;
+	HWDMX_Chan			*tschan;
+//	HWDMX_TsFilter		 *hwtsf;
+	dmx_ts_cb ts_cb;
+	int type;
+	int ts_type;
+	int pes_type;
+	int pid;
+	int state;
+};
+
+struct sw_demux_sec_filter {
+	struct dmx_section_filter section_filter;
+
+	SWDMX_SecFilter 	 *secf;
+	int state;
+};
+
+struct sw_demux_sec_feed {
+	struct dmx_section_feed sec_feed;
+
+	int sec_filter_num;
+	struct sw_demux_sec_filter *filter;
+	HWDMX_Chan			*secchan;
+
+	dmx_section_cb sec_cb;
+	int pid;
+	int check_crc;
+	int type;
+	int state;
+};
+
+struct aml_dmx {
+	struct dmx_demux dmx;
+	struct dmxdev dev;
+	void *priv;
+	int id;
+
+	HWDMX_Demux		*hwdmx;
+	SWDMX_Demux     *swdmx;
+	SWDMX_TsParser  *tsp;
+
+	int used_hwdmx;
+
+	int ts_feed_num;
+	struct sw_demux_ts_feed *ts_feed;
+
+	int sec_feed_num;
+	struct sw_demux_sec_feed *section_feed;
+
+	struct list_head frontend_list;
+
+	u16 pids[DMX_PES_OTHER];
+
+	struct dmx_frontend  mem_fe;
+
+	int buf_warning_level; //percent, used/total, default is 60
+
+#define MAX_SW_DEMUX_USERS 10
+	int users;
+	struct mutex *pmutex;
+	spinlock_t *pslock;
+
+	int init;
+};
+
+int dmx_init(struct aml_dmx *pdmx,struct dvb_adapter *dvb_adapter);
+int dmx_destroy(struct aml_dmx *pdmx);
+int dmx_set_work_mode(struct aml_dmx *pdmx,int work_mode);
+int dmx_get_work_mode(struct aml_dmx *pdmx,int *work_mode);
+int dmx_get_buf_warning_status(struct aml_dmx *pdmx, int *status);
+int dmx_set_buf_warning_level(struct aml_dmx *pdmx, int level);
+int dmx_write_sw_from_user(struct aml_dmx *pdmx, const char __user *buf, size_t count);
+
+#endif
diff --git a/drivers/stream_input/parser/demux/aml_dmx_ext.c b/drivers/stream_input/parser/demux/aml_dmx_ext.c
new file mode 100644
index 0000000..b85e5ce
--- /dev/null
+++ b/drivers/stream_input/parser/demux/aml_dmx_ext.c
@@ -0,0 +1,328 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include "aml_dmx_ext.h"
+#include "aml_dvb.h"
+#include "aml_dmx.h"
+#include "hw_demux/hwdemux.h"
+#include "hw_demux/asyncfifo.h"
+
+struct dmx_ext {
+	int major_id;
+	int id;
+
+	struct mutex mutex;
+	wait_queue_head_t queue;
+	int update;
+	struct dmx_ext_param data;
+	int user;
+	int used;
+};
+#define DMX_EXT_NUM 			3
+static struct dmx_ext dmx_ext_data[DMX_EXT_NUM];
+
+#define WR_OPEN_FILE 	0
+#define RD_OPEN_FILE	1
+
+static int usercopy(struct file *file,
+		     unsigned int cmd, unsigned long arg,
+		     int (*func)(struct file *file,
+		     unsigned int cmd, void *arg))
+{
+	char    sbuf[128];
+	void    *mbuf = NULL;
+	void    *parg = NULL;
+	int     err  = -EINVAL;
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		/*
+		 * For this command, the pointer is actually an integer
+		 * argument.
+		 */
+		parg = (void *) arg;
+		break;
+	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		err = -EFAULT;
+		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+			goto out;
+		break;
+	}
+
+	/* call driver */
+	if ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)
+		err = -ENOTTY;
+
+	if (err < 0)
+		goto out;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd))
+	{
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			err = -EFAULT;
+		break;
+	}
+
+out:
+	kfree(mbuf);
+	return err;
+}
+
+int dmx_ext_open(struct inode *inode, struct file *file) {
+	struct dmx_ext *dmx_ext_dev=&dmx_ext_data[iminor(inode)];
+
+	mutex_lock(&dmx_ext_dev->mutex);
+	dmx_ext_dev->user++;
+	dmx_ext_dev->id = iminor(inode);
+	file->private_data = dmx_ext_dev;
+
+	mutex_unlock(&dmx_ext_dev->mutex);
+
+	return 0;
+}
+
+int dmx_ext_close(struct inode *inode, struct file *file) {
+	struct dmx_ext *dmx_ext_dev = file->private_data;
+	mutex_lock(&dmx_ext_dev->mutex);
+	dmx_ext_dev->user--;
+	if (dmx_ext_dev->user == 0)
+		dmx_ext_dev->used = 0;
+	mutex_unlock(&dmx_ext_dev->mutex);
+
+	return 0;
+}
+int dmx_ext_do_ioctl(struct file *file, unsigned int cmd,void *parg) {
+	struct dmx_ext *dmx_ext_dev = file->private_data;
+	mutex_lock(&dmx_ext_dev->mutex);
+	switch (cmd) {
+		case DMX_EXT_SET_ASYNCFIFO_PARAMS:
+			{
+				struct dmx_ext_asyncfifo_param *params = (struct dmx_ext_asyncfifo_param *)parg;
+
+				asyncfifo_set_security_buf(dmx_ext_dev->id, params->addr, params->size);
+			}
+			break;
+	}
+
+	mutex_unlock(&dmx_ext_dev->mutex);
+
+	return 0;
+}
+long dmx_ext_ioctl(struct file *file, unsigned int cmd,unsigned long arg) {
+	return usercopy(file, cmd, arg, dmx_ext_do_ioctl);
+}
+
+static unsigned int dmx_ext_poll(struct file *file, poll_table *wait) {
+	unsigned int mask = 0;
+	struct dmx_ext *dmx_ext_dev = file->private_data;
+
+	poll_wait(file, &dmx_ext_dev->queue, wait);
+
+	if (dmx_ext_dev->update)	{
+		mask |= (POLLIN | POLLRDNORM | POLLPRI);
+	} else {
+		mask |= (POLLIN | POLLRDNORM | POLLPRI | POLLERR);
+	}
+
+	return mask;
+}
+
+static ssize_t dmx_ext_read(struct file *file, char __user *buf, size_t count,
+			    loff_t *ppos){
+	int ret = 0;
+	struct dmx_ext *dmx_ext_dev = file->private_data;
+
+	if (dmx_ext_dev->update) {
+		ret = sizeof(struct dmx_ext_param);
+		if (copy_to_user(buf, &(dmx_ext_dev->data), ret))
+			return -EFAULT;
+		dmx_ext_dev->update = 0;
+	}
+	return ret;
+}
+static ssize_t dmx_ext_write(struct file *file, const char __user *buf,
+			     size_t count, loff_t *ppos) {
+	struct dmx_ext *dmx_ext_dev = file->private_data;
+	int ret = 0;
+	int id = dmx_ext_dev->id;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+
+	if ((file->f_flags & O_ACCMODE) != O_WRONLY)
+		return -EINVAL;
+	if (!dmx_ext_dev->used) {
+		return -ENODEV;
+	}
+	mutex_lock(&dmx_ext_dev->mutex);
+	ret = dmx_write_sw_from_user(&(dvb->dmx[id]), buf, count);
+	mutex_unlock(&dmx_ext_dev->mutex);
+
+	return ret;
+}
+static const struct file_operations device_fops =
+{
+	.owner = THIS_MODULE,
+	.open  = dmx_ext_open,
+	.release = dmx_ext_close,
+	.read = dmx_ext_read,
+	.write = dmx_ext_write,
+	.poll = dmx_ext_poll,
+	.unlocked_ioctl = dmx_ext_ioctl,
+};
+static struct class *dmx_ext_class = NULL;
+
+int dmx_ext_init(int id) {
+	int result;
+	struct device *clsdev;
+
+	memset(&dmx_ext_data[id], 0, sizeof(struct dmx_ext));
+
+	result=register_chrdev(0,"ext",&device_fops);
+	if (result<0){
+		printk("error:can not register the device\n");
+		return -1;
+	}
+	printk("init_dmx_ext success,id:%d\n",result);
+	dmx_ext_data[id].major_id = result;
+
+	if (dmx_ext_class == NULL ) {
+		dmx_ext_class = class_create(THIS_MODULE, "dmx_ext");
+		if (IS_ERR(dmx_ext_class)) {
+			printk("class create dmx_ext_class fail\n");
+			return -1;
+		}
+	}
+	clsdev = device_create(dmx_ext_class, NULL,
+			       MKDEV(dmx_ext_data[id].major_id, id),
+			       &dmx_ext_data[id], "dvb0.ext%d",id);
+	if (IS_ERR(clsdev)) {
+		printk("device_create dvb0.ext fail\n");
+		return PTR_ERR(clsdev);
+	}
+	mutex_init(&dmx_ext_data[id].mutex);
+	dmx_ext_data[id].id = id;
+	dmx_ext_data[id].used = 1;
+
+	return 0;
+}
+
+void dmx_ext_exit(int id) {
+	int i = 0;
+	int count = 0;
+
+	if (!dmx_ext_data[id].used)
+		return ;
+	device_destroy(dmx_ext_class, MKDEV(dmx_ext_data[id].major_id, id));
+	unregister_chrdev(dmx_ext_data[id].major_id,"ext");
+	dmx_ext_data[id].used = 0;
+
+	for (i = 0; i < DMX_EXT_NUM; i++) {
+		if (!dmx_ext_data[id].used)
+			count++;
+	}
+	if (count == DMX_EXT_NUM) {
+		class_destroy(dmx_ext_class);
+		dmx_ext_class = NULL;
+	}
+}
+int dmx_ext_add_pvr_pid(int id, int pid) {
+	int i = 0;
+	struct dmx_ext *dmx_ext_dev = &dmx_ext_data[id];
+
+	if (!dmx_ext_dev->used)
+		return 0;
+
+	for (i=0; i<dmx_ext_dev->data.pvr_count; i++) {
+		if (pid == dmx_ext_dev->data.pvr_pid[i]) {
+			return 0;
+		}
+	}
+	if (i == dmx_ext_dev->data.pvr_count && i < PVR_PID_NUM) {
+		dmx_ext_dev->data.pvr_pid[i] = pid;
+		dmx_ext_dev->data.pvr_count++;
+		dmx_ext_dev->update = 1;
+		wake_up(&dmx_ext_dev->queue);
+	}
+	return 0;
+}
+
+int dmx_ext_remove_pvr_pid(int id, int pid) {
+	int i = 0;
+	int k = 0;
+	struct dmx_ext *dmx_ext_dev = &dmx_ext_data[id];
+
+	if (!dmx_ext_dev->used)
+		return 0;
+
+	for (i = 0; i < dmx_ext_dev->data.pvr_count; i++) {
+		if (pid == dmx_ext_dev->data.pvr_pid[i]) {
+			break;
+		}
+	}
+	if (i != dmx_ext_dev->data.pvr_count) {
+		for (k=i; k < dmx_ext_dev->data.pvr_count; k++) {
+			if (k == dmx_ext_dev->data.pvr_count -1) {
+				dmx_ext_dev->data.pvr_pid[k] = 0;
+			} else {
+				dmx_ext_dev->data.pvr_pid[k] = dmx_ext_dev->data.pvr_pid[k+1];
+			}
+		}
+		dmx_ext_dev->data.pvr_count--;
+		wake_up(&dmx_ext_dev->queue);
+	}
+
+	return 0;
+}
diff --git a/drivers/stream_input/parser/demux/aml_dmx_ext.h b/drivers/stream_input/parser/demux/aml_dmx_ext.h
new file mode 100644
index 0000000..ef74049
--- /dev/null
+++ b/drivers/stream_input/parser/demux/aml_dmx_ext.h
@@ -0,0 +1,43 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _AML_DMX_EXT_H_
+#define _AML_DMX_EXT_H_
+
+struct dmx_ext_asyncfifo_param{
+	int size; 	/*secure buf size */
+	unsigned long addr;   /*secure buf addr */
+};
+
+#define DMX_EXT_SET_ASYNCFIFO_PARAMS	_IOW('o', 64, struct dmx_ext_asyncfifo_param)
+
+#define PVR_PID_NUM			32
+
+struct dmx_ext_param {
+	int cmd;
+	int pvr_count;
+	int pvr_pid[PVR_PID_NUM];
+};
+
+int dmx_ext_init(int id);
+void dmx_ext_exit(int id);
+int dmx_ext_add_pvr_pid(int id, int pid);
+int dmx_ext_remove_pvr_pid(int id, int pid);
+
+#endif
diff --git a/drivers/stream_input/parser/demux/aml_dsc.c b/drivers/stream_input/parser/demux/aml_dsc.c
new file mode 100644
index 0000000..636ceea
--- /dev/null
+++ b/drivers/stream_input/parser/demux/aml_dsc.c
@@ -0,0 +1,1073 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/reset.h>
+#include <linux/amlogic/media/utils/amstream.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/clk.h>
+#include <linux/dvb/ca.h>
+
+#include "hw_demux/dvb_reg.h"
+#include "aml_dsc.h"
+
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+#define pr_inf(fmt, args...)   printk(KERN_DEBUG fmt, ## args)
+
+#define DSC_CHANNEL_NUM 8
+
+#define DSC_STATE_FREE      0
+#define DSC_STATE_READY     3
+#define DSC_STATE_GO        4
+
+#define ENABLE_DEC_PL     7
+#define ENABLE_DES_PL_CLK 15
+#define CIPLUS_OUT_SEL    28
+#define CIPLUS_IN_SEL     26
+
+#define KEY_WR_AES_IV_B 5
+#define KEY_WR_AES_IV_A 4
+#define KEY_WR_AES_B    3
+#define KEY_WR_AES_A    2
+#define KEY_WR_DES_B    1
+#define KEY_WR_DES_A    0
+
+#define IDSA_MODE_BIT	31
+#define SM4_MODE		30
+#define CNTL_ENABLE     3
+#define AES_CBC_DISABLE 2
+#define AES_EN          1
+#define DES_EN          0
+
+#define AES_MSG_OUT_ENDIAN 24
+#define AES_MSG_IN_ENDIAN  20
+#define AES_KEY_ENDIAN  16
+#define DES_MSG_OUT_ENDIAN 8
+#define DES_MSG_IN_ENDIAN  4
+#define DES_KEY_ENDIAN  0
+
+#define ALGO_AES		0
+#define ALGO_SM4		1
+#define ALGO_DES		2
+
+#define DSC_COUNT         8
+
+#define CIPLUS_OUTPUT_AUTO 8
+static int ciplus_out_sel = CIPLUS_OUTPUT_AUTO;
+static int ciplus_out_auto_mode = 1;
+
+#if 0
+/*
+ * param:
+ * key:
+ *	16bytes IV key
+ * type:
+ *	AM_DSC_KEY_TYPE_AES_ODD    IV odd key
+ *	AM_DSC_KEY_TYPE_AES_EVEN  IV even key
+ */
+static void _ci_plus_set_iv(struct DescChannel *ch, enum ca_cw_type type,
+			u8 *key)
+{
+	unsigned int k0, k1, k2, k3;
+
+	k3 = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+	k2 = (key[4] << 24) | (key[5] << 16) | (key[6] << 8) | key[7];
+	k1 = (key[8] << 24) | (key[9] << 16) | (key[10] << 8) | key[11];
+	k0 = (key[12] << 24) | (key[13] << 16) | (key[14] << 8) | key[15];
+
+	if (type == CA_CW_AES_EVEN_IV ||
+		type == CA_CW_SM4_EVEN_IV) {
+		WRITE_MPEG_REG(CIPLUS_KEY0, k0);
+		WRITE_MPEG_REG(CIPLUS_KEY1, k1);
+		WRITE_MPEG_REG(CIPLUS_KEY2, k2);
+		WRITE_MPEG_REG(CIPLUS_KEY3, k3);
+		WRITE_MPEG_REG(CIPLUS_KEY_WR,
+			(ch->id << 9) | (1<<KEY_WR_AES_IV_A));
+	} else if (type == CA_CW_AES_ODD_IV ||
+			   type == CA_CW_SM4_ODD_IV) {
+		WRITE_MPEG_REG(CIPLUS_KEY0, k0);
+		WRITE_MPEG_REG(CIPLUS_KEY1, k1);
+		WRITE_MPEG_REG(CIPLUS_KEY2, k2);
+		WRITE_MPEG_REG(CIPLUS_KEY3, k3);
+		WRITE_MPEG_REG(CIPLUS_KEY_WR,
+			(ch->id << 9) | (1<<KEY_WR_AES_IV_B));
+	}
+}
+#endif
+/*
+ * Param:
+ * key_endian
+ *	S905D  7 for kl    0 for set key directly
+ * mode
+ *  0 for ebc
+ *  1 for cbc
+ */
+static void _ci_plus_config(int key_endian, int mode, int algo)
+{
+	unsigned int data;
+	unsigned int idsa_mode = 0;
+	unsigned int sm4_mode = 0;
+	unsigned int cbc_disable = 0;
+	unsigned int des_enable = 0;
+	unsigned int aes_enable = 1;
+
+	pr_error("%s mode:%d,alog:%d\n",__FUNCTION__,mode,algo);
+
+	if (get_cpu_type() < MESON_CPU_MAJOR_ID_SM1) {
+		WRITE_MPEG_REG(CIPLUS_ENDIAN,
+				(15 << AES_MSG_OUT_ENDIAN)
+				| (15 << AES_MSG_IN_ENDIAN)
+				| (key_endian << AES_KEY_ENDIAN)
+				|
+				(15 << DES_MSG_OUT_ENDIAN)
+				| (15 << DES_MSG_IN_ENDIAN)
+				| (key_endian << DES_KEY_ENDIAN)
+				);
+	} else {
+		WRITE_MPEG_REG(CIPLUS_ENDIAN, 0);
+	}
+
+	data = READ_MPEG_REG(CIPLUS_ENDIAN);
+
+	if (algo == ALGO_SM4) {
+		sm4_mode = 1;
+	} else if (algo ==  ALGO_AES){
+		sm4_mode = 0;
+	} else {
+		sm4_mode = 0;
+		des_enable = 1;
+	}
+
+	if (mode == IDSA_MODE) {
+		idsa_mode = 1;
+		cbc_disable = 0;
+	} else if (mode == CBC_MODE) {
+		cbc_disable = 0;
+	} else {
+		cbc_disable = 1;
+	}
+	pr_error("idsa_mode:%d sm4_mode:%d cbc_disable:%d aes_enable:%d des_enable:%d\n", \
+		idsa_mode,sm4_mode,cbc_disable,aes_enable,des_enable);
+
+	data =  (idsa_mode << IDSA_MODE_BIT) |
+			(sm4_mode << SM4_MODE ) |
+			(cbc_disable << AES_CBC_DISABLE) |
+			/*1 << AES_CBC_DISABLE     : ECB
+			 *0 << AES_CBC_DISABLE     : CBC
+			 */
+			(1 << CNTL_ENABLE) |
+			(aes_enable << AES_EN) |
+			(des_enable << DES_EN);
+
+	WRITE_MPEG_REG(CIPLUS_CONFIG, data);
+	data = READ_MPEG_REG(CIPLUS_CONFIG);
+	pr_error("CIPLUS_CONFIG is 0x%x\n",data);
+}
+
+
+/*
+ * Set output to demux set.
+ */
+static void _ci_plus_set_output(struct DescChannel *ch)
+{
+	struct aml_dsc *dsc = ch->dsc;
+	u32 data;
+	u32 in = 0, out = 0;
+	int set = 0;
+
+	if (dsc->id != 0) {
+		pr_error("Ciplus set output can only work at dsc0 device\n");
+		return;
+	}
+
+	switch (dsc->source) {
+	case  AM_TS_SRC_DMX0:
+		in = 0;
+		break;
+	case  AM_TS_SRC_DMX1:
+		in = 1;
+		break;
+	case  AM_TS_SRC_DMX2:
+		in = 2;
+		break;
+	default:
+		break;
+	}
+
+	if (ciplus_out_auto_mode == 1) {
+		switch (dsc->dst) {
+		case  AM_TS_SRC_DMX0:
+			out = 1;
+			break;
+		case  AM_TS_SRC_DMX1:
+			out = 2;
+			break;
+		case  AM_TS_SRC_DMX2:
+			out = 4;
+			break;
+		default:
+			break;
+		}
+		set = 1;
+		ciplus_out_sel = out;
+	} else if (ciplus_out_sel >= 0 && ciplus_out_sel <= 7) {
+		set = 1;
+		out = ciplus_out_sel;
+	} else {
+		pr_error("dsc ciplus out config is invalid\n");
+	}
+
+	if (set) {
+		/* Set ciplus input source ,
+		 * output set 0 means no output. ---> need confirm.
+		 * if output set 0 still affects dsc output, we need to disable
+		 * ciplus module.
+		 */
+		data = READ_MPEG_REG(STB_TOP_CONFIG);
+		data &= ~(3<<CIPLUS_IN_SEL);
+		data |= in << CIPLUS_IN_SEL;
+		data &= ~(7<<CIPLUS_OUT_SEL);
+		data |= out << CIPLUS_OUT_SEL;
+		WRITE_MPEG_REG(STB_TOP_CONFIG, data);
+		pr_inf("dsc ciplus in[%x] out[%x] %s\n", in, out,
+			(ciplus_out_auto_mode) ? "" : "force");
+	}
+
+}
+#if 0
+/*
+ * Ciplus output has high priority,
+ * disable it's output will let dsc output go.
+ */
+static void _ci_plus_disable_output(void)
+{
+	u32 data = 0;
+
+	data = READ_MPEG_REG(STB_TOP_CONFIG);
+	WRITE_MPEG_REG(STB_TOP_CONFIG, data &
+			~(7 << CIPLUS_OUT_SEL));
+}
+
+static void _ci_plus_enable(void)
+{
+	u32 data = 0;
+
+	data = READ_MPEG_REG(STB_TOP_CONFIG);
+	WRITE_MPEG_REG(CIPLUS_CONFIG,
+			(1 << CNTL_ENABLE)
+			| (1 << AES_EN)
+			| (1 << DES_EN));
+}
+#endif
+static void _ci_plus_disable(void)
+{
+	u32 data = 0;
+
+	WRITE_MPEG_REG(CIPLUS_CONFIG, 0);
+
+	data = READ_MPEG_REG(STB_TOP_CONFIG);
+	WRITE_MPEG_REG(STB_TOP_CONFIG, data &
+			~((1 << CIPLUS_IN_SEL) | (7 << CIPLUS_OUT_SEL)));
+/*	WRITE_MPEG_REG(CIPLUS_CONFIG,
+ *			(0 << CNTL_ENABLE) | (0 << AES_EN));
+ */
+}
+
+static int _hwdsc_ch_set_pid(struct DescChannel *ch, int pid)
+{
+	struct aml_dsc *dsc = ch->dsc;
+	int is_dsc2 = (dsc->id == 1) ? 1 : 0;
+	u32 data;
+
+	WRITE_MPEG_REG(TS_PL_PID_INDEX,
+			((ch->id & 0x0f) >> 1)+(is_dsc2 ? 4 : 0));
+	data = READ_MPEG_REG(TS_PL_PID_DATA);
+	if (ch->id & 1) {
+		data &= 0xFFFF0000;
+		data |= pid & 0x1fff;
+		if (ch->state == DSC_STATE_FREE)
+			data |= 1 << PID_MATCH_DISABLE_LOW;
+	} else {
+		data &= 0xFFFF;
+		data |= (pid & 0x1fff) << 16;
+		if (ch->state == DSC_STATE_FREE)
+			data |= 1 << PID_MATCH_DISABLE_HIGH;
+	}
+	WRITE_MPEG_REG(TS_PL_PID_INDEX,
+			((ch->id & 0x0f) >> 1)+(is_dsc2 ? 4 : 0));
+	WRITE_MPEG_REG(TS_PL_PID_DATA, data);
+	WRITE_MPEG_REG(TS_PL_PID_INDEX, 0);
+
+	if (ch->state != DSC_STATE_FREE)
+		pr_inf("set DSC %d ch %d PID %d\n", dsc->id, ch->id, pid);
+	else
+		pr_inf("disable DSC %d ch %d\n", dsc->id, ch->id);
+	return 0;
+}
+static int _hwdsc_set_aes_des_sm4_key(struct DescChannel *ch, int flags,
+			enum ca_cw_type type, u8 *key)
+{
+	unsigned int k0, k1, k2, k3;
+	int iv = 0, aes = 0, des = 0;
+	int ab_iv = 0, ab_aes = 0, ab_des = 0;
+	int from_kl = flags & CA_CW_FROM_KL;
+	int algo = 0;
+
+	if (!from_kl) {
+		if (get_cpu_type() < MESON_CPU_MAJOR_ID_SM1) {
+		k3 = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+		k2 = (key[4] << 24) | (key[5] << 16) | (key[6] << 8) | key[7];
+		k1 = (key[8] << 24) | (key[9] << 16) | (key[10] << 8) | key[11];
+		k0 = (key[12] << 24) | (key[13] << 16)
+			| (key[14] << 8) | key[15];
+		} else {
+		k0 = (key[0]) | (key[1] << 8) | (key[2] << 16) | (key[3] << 24);
+		k1 = (key[4]) | (key[5] << 8) | (key[6] << 16) | (key[7] << 24);
+		k2 = (key[8]) | (key[9] << 8) | (key[10] << 16)| (key[11] << 24);
+		k3 = (key[12])| (key[13] << 8)| (key[14] << 16)| (key[15] << 24);
+		}
+	} else
+		k0 = k1 = k2 = k3 = 0;
+
+	switch (type) {
+	case CA_CW_AES_EVEN:
+	case CA_CW_SM4_EVEN:
+		ab_aes = (from_kl) ? 0x2 : 0x1;
+		if (ch->mode == -1)
+			ch->mode = ECB_MODE;
+		aes = 1;
+		if (type == CA_CW_AES_EVEN)
+			algo = ALGO_AES;
+		else
+			algo = ALGO_SM4;
+		break;
+	case CA_CW_AES_ODD:
+	case CA_CW_SM4_ODD:
+		ab_aes = (from_kl) ? 0x1 : 0x2;
+		if (ch->mode == -1)
+			ch->mode = ECB_MODE;
+		aes = 1;
+		if (type == CA_CW_AES_ODD)
+			algo = ALGO_AES;
+		else
+			algo = ALGO_SM4;
+		break;
+	case CA_CW_AES_EVEN_IV:
+	case CA_CW_SM4_EVEN_IV:
+		ab_iv = 0x1;
+		if (ch->mode == -1)
+			ch->mode = CBC_MODE;
+		iv = 1;
+		if (type == CA_CW_AES_EVEN_IV)
+			algo = ALGO_AES;
+		else
+			algo = ALGO_SM4;
+		break;
+	case CA_CW_AES_ODD_IV:
+	case CA_CW_SM4_ODD_IV:
+		ab_iv = 0x2;
+		if (ch->mode == -1)
+			ch->mode = CBC_MODE;
+		iv = 1;
+		if (type == CA_CW_AES_ODD_IV)
+			algo = ALGO_AES;
+		else
+			algo = ALGO_SM4;
+		break;
+	case CA_CW_DES_EVEN:
+		ab_des = 0x1;
+		ch->mode = ECB_MODE;
+		des = 1;
+		algo = ALGO_DES;
+		break;
+	case CA_CW_DES_ODD:
+		ab_des = 0x2;
+		ch->mode = ECB_MODE;
+		algo = ALGO_DES;
+		des = 1;
+		break;
+	default:
+		break;
+	}
+
+	/* Set endian and cbc/ecb mode */
+	if (from_kl)
+		_ci_plus_config(7, ch->mode, algo);
+	else
+		_ci_plus_config(0, ch->mode, algo);
+
+	/* Write keys to work */
+	if (iv || aes) {
+		WRITE_MPEG_REG(CIPLUS_KEY0, k0);
+		WRITE_MPEG_REG(CIPLUS_KEY1, k1);
+		WRITE_MPEG_REG(CIPLUS_KEY2, k2);
+		WRITE_MPEG_REG(CIPLUS_KEY3, k3);
+	} else {/*des*/
+		WRITE_MPEG_REG(CIPLUS_KEY0, k2);
+		WRITE_MPEG_REG(CIPLUS_KEY1, k3);
+		WRITE_MPEG_REG(CIPLUS_KEY2, 0);
+		WRITE_MPEG_REG(CIPLUS_KEY3, 0);
+	}
+	WRITE_MPEG_REG(CIPLUS_KEY_WR,
+		(ch->id << 9) |
+				/* bit[11:9] the key of index,
+					need match PID index*/
+		((from_kl && des) ? (1 << 8) : 0) |
+				/* bit[8] des key use cw[127:64]*/
+		(0 << 7) |		/* bit[7] aes iv use cw*/
+		((from_kl && (aes || des)) ? (1 << 6) : 0) |
+				/* bit[6] aes/des key use cw*/
+				/* bit[5] write AES IV B value*/
+		(ab_iv << 4) |	/* bit[4] write AES IV A value*/
+				/* bit[3] write AES B key*/
+		(ab_aes << 2) | /* bit[2] write AES A key*/
+				/* bit[1] write DES B key*/
+		(ab_des));		/* bit[0] write DES A key*/
+
+	/*
+	pr_inf("k:%08x:%08x:%08x:%08x kl:%d aes:%d des:%d ab_iv:%d ab_aes:%d ab_des:%d id:%d mod:%d\n",
+		k0, k1, k2, k3,
+		from_kl, aes, des, ab_iv, ab_aes, ab_des, ch->id, ch->aes_mode);
+	*/
+	return 0;
+}
+
+static int _hwdsc_set_csa_key(struct DescChannel *ch, int flags,
+			enum ca_cw_type type, u8 *key)
+{
+	struct aml_dsc *dsc = ch->dsc;
+	int is_dsc2 = (dsc->id == 1) ? 1 : 0;
+	u16 k0, k1, k2, k3;
+	u32 key0, key1;
+	int reg; /*not sure if reg readable*/
+/*	u32 data;
+ *	u32 pid = 0x1fff;
+ */
+	int from_kl = flags & CA_CW_FROM_KL;
+/*  int pid = ch->pid; */
+
+	if (from_kl) {
+		k0 = k1 = k2 = k3 = 0;
+
+		/*dummy write to check if kl not working*/
+		key0 = key1 = 0;
+		WRITE_MPEG_REG(COMM_DESC_KEY0, key0);
+		WRITE_MPEG_REG(COMM_DESC_KEY1, key1);
+
+	/*tdes? :*/
+		if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) {
+			WRITE_MPEG_REG(COMM_DESC_KEY_RW,
+/*				(type ? (1 << 6) : (1 << 5)) | */
+				((1 << 5)) |
+				((ch->id + type * DSC_COUNT)+
+					(is_dsc2 ? 16 : 0)));
+		}
+		if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXL ||
+			get_cpu_type() == MESON_CPU_MAJOR_ID_GXM) {
+			pr_info("do kl..\n");
+			WRITE_MPEG_REG(COMM_DESC_KEY_RW,
+				(type ? (1 << 6) : (1 << 5)) | (1<<7) |
+				((ch->id + type * DSC_COUNT)+
+				 (is_dsc2 ? 16 : 0)));
+		}
+		reg = (type ? (1 << 6) : (1 << 5)) |
+				((ch->id + type * DSC_COUNT)+
+				 (is_dsc2 ? 16 : 0));
+	} else {
+		k0 = (key[0] << 8) | key[1];
+		k1 = (key[2] << 8) | key[3];
+		k2 = (key[4] << 8) | key[5];
+		k3 = (key[6] << 8) | key[7];
+
+		key0 = (k0 << 16) | k1;
+		key1 = (k2 << 16) | k3;
+		WRITE_MPEG_REG(COMM_DESC_KEY0, key0);
+		WRITE_MPEG_REG(COMM_DESC_KEY1, key1);
+		reg = (ch->id + type * DSC_COUNT)+(is_dsc2 ? 16 : 0);
+		WRITE_MPEG_REG(COMM_DESC_KEY_RW,reg);
+	}
+
+	return 0;
+}
+static int _get_dsc_key_work_mode(enum ca_cw_type cw_type)
+{
+	int work_mode = DVBCSA_MODE;
+
+	switch (cw_type) {
+	case CA_CW_DVB_CSA_EVEN:
+	case CA_CW_DVB_CSA_ODD:
+		work_mode = DVBCSA_MODE;
+		break;
+	case CA_CW_AES_EVEN:
+	case CA_CW_AES_ODD:
+	case CA_CW_AES_ODD_IV:
+	case CA_CW_AES_EVEN_IV:
+	case CA_CW_DES_EVEN:
+	case CA_CW_DES_ODD:
+	case CA_CW_SM4_EVEN:
+	case CA_CW_SM4_ODD:
+	case CA_CW_SM4_ODD_IV:
+	case CA_CW_SM4_EVEN_IV:
+		work_mode = CIPLUS_MODE;
+	default:
+		break;
+	}
+	return work_mode;
+}
+
+/* Check if there are channels run in previous mode(aes/dvbcsa)
+ * in dsc0/ciplus
+ */
+static void _dsc_ciplus_switch_check(struct DescChannel *ch,
+			enum ca_cw_type cw_type)
+{
+	struct aml_dsc *dsc = ch->dsc;
+	int work_mode = 0;
+	struct DescChannel *pch = NULL;
+	int i;
+
+	work_mode = _get_dsc_key_work_mode(cw_type);
+	if (dsc->work_mode == work_mode)
+		return;
+
+	dsc->work_mode = work_mode;
+
+	for (i = 0; i < dsc->channel_num; i++) {
+		pch = &dsc->channels[i];
+		if (pch->work_mode != work_mode && pch->work_mode != -1) {
+			pr_error("Dsc work mode changed,");
+			pr_error("but there are still some channels");
+			pr_error("run in different mode\n");
+		}
+	}
+}
+
+static void _dsc_channel_alloc(struct aml_dsc *dsc, int id, unsigned int pid)
+{
+	struct DescChannel *ch = &dsc->channels[id];
+
+	ch->state  = DSC_STATE_READY;
+	ch->work_mode = -1;
+	ch->id    = id;
+	ch->pid   = pid;
+	ch->set   = 0;
+	ch->mode = -1;
+
+	if (dsc->mode == SW_DSC_MODE) {
+		ch->chan = swdmx_descrambler_alloc_channel(dsc->swdsc);
+		if (!ch->chan) {
+			pr_error("swdmx_descrambler_alloc_channel fail\n");
+			return ;
+		}
+		if (swdmx_desc_channel_set_pid(ch->chan, ch->pid) != SWDMX_OK)
+			pr_error("swdmx_desc_channel_set_pid fail\n");
+	} else {
+		_hwdsc_ch_set_pid(ch, pid);
+	}
+}
+static void _dsc_channel_free(struct DescChannel *ch)
+{
+	struct aml_dsc *dsc = (struct aml_dsc *)ch->dsc;
+
+	if (ch->state == DSC_STATE_FREE)
+		return;
+
+	ch->state = DSC_STATE_FREE;
+
+	if (dsc->mode == SW_DSC_MODE) {
+		if (ch->chan) {
+			swdmx_desc_channel_disable(ch->chan);
+			/* this will free algo */
+			swdmx_desc_channel_free(ch->chan);
+			ch->chan = NULL;
+			ch->algo = NULL;
+		}
+	} else {
+		_hwdsc_ch_set_pid(ch, 0x1fff);
+		_ci_plus_disable();
+	}
+
+	ch->pid   = 0x1fff;
+	ch->set = 0;
+	ch->work_mode = -1;
+	ch->mode  = -1;
+}
+
+static void _dsc_reset(struct aml_dsc *dsc)
+{
+	int i;
+
+	for (i = 0; i < dsc->channel_num; i++)
+		_dsc_channel_free(&dsc->channels[i]);
+}
+static int _dsc_set_key(struct DescChannel *ch, int flags, enum ca_cw_type type,
+			u8 *key)
+{
+	int ret = 0;
+	struct aml_dsc *dsc = (struct aml_dsc *)ch->dsc;
+
+	if (ch->dsc == NULL)
+		return -1;
+
+	switch (type)
+	{
+		case CA_CW_DVB_CSA_EVEN:
+		case CA_CW_DVB_CSA_ODD:
+		{
+			if (dsc->mode == SW_DSC_MODE) {
+				if (!ch->algo) {
+					ch->algo = swdmx_dvbcsa2_algo_new();
+					if (!ch->algo) {
+						pr_error("swdmx_dvbcsa2_algo_new fail\n");
+						return -1;
+					}
+					swdmx_desc_channel_set_algo(ch->chan, ch->algo);
+				}
+				if (type == CA_CW_DVB_CSA_EVEN)
+					swdmx_desc_channel_set_param(ch->chan,SWDMX_DVBCSA2_PARAM_EVEN_KEY,key);
+				else
+					swdmx_desc_channel_set_param(ch->chan,SWDMX_DVBCSA2_PARAM_ODD_KEY,key);
+
+				if (ch->state == DSC_STATE_READY)
+				{
+					swdmx_desc_channel_enable(ch->chan);
+					ch->state = DSC_STATE_GO;
+				}
+			} else {
+				_ci_plus_disable();
+				ret = _hwdsc_set_csa_key(ch, flags, type, key);
+				if (ret != 0)
+					return ret;
+				/* Different with old mode, do change */
+				if (ch->work_mode == CIPLUS_MODE || ch->work_mode == -1) {
+					if (ch->work_mode == -1)
+						pr_error("Dsc set output and enable\n");
+					else
+						pr_error("Dsc set output change from ciplus\n");
+					ch->mode = ECB_MODE;
+					/*aml_ci_plus_disable();*/
+					ch->work_mode = DVBCSA_MODE;
+				}
+			}
+			break;
+		}
+		case CA_CW_AES_EVEN:
+		case CA_CW_AES_ODD:
+		case CA_CW_AES_EVEN_IV:
+		case CA_CW_AES_ODD_IV:
+		case CA_CW_DES_EVEN:
+		case CA_CW_DES_ODD:
+		case CA_CW_SM4_EVEN:
+		case CA_CW_SM4_ODD:
+		case CA_CW_SM4_EVEN_IV:
+		case CA_CW_SM4_ODD_IV:
+		{
+			if (dsc->mode == SW_DSC_MODE) {
+				if (!ch->algo) {
+					ch->algo = swdmx_aes_cbc_algo_new();
+					if (!ch->algo) {
+						pr_error("swdmx_dvbcsa2_algo_new fail\n");
+						return -1;
+					}
+					swdmx_desc_channel_set_algo(ch->chan, ch->algo);
+					swdmx_desc_channel_set_param(ch->chan, SWDMX_AES_CBC_PARAM_ALIGN, SWDMX_DESC_ALIGN_HEAD);
+				}
+				if (type == CA_CW_AES_EVEN) {
+					swdmx_desc_channel_set_param(ch->chan, SWDMX_AES_CBC_PARAM_EVEN_KEY, key);
+				}else if (type == CA_CW_AES_ODD) {
+					swdmx_desc_channel_set_param(ch->chan, SWDMX_AES_CBC_PARAM_ODD_KEY, key);
+				}else if (type == CA_CW_AES_EVEN_IV) {
+					swdmx_desc_channel_set_param(ch->chan, SWDMX_AES_CBC_PARAM_EVEN_IV, key);
+				}else{
+					swdmx_desc_channel_set_param(ch->chan, SWDMX_AES_CBC_PARAM_ODD_IV, key);
+				}
+				if (ch->state == DSC_STATE_READY)
+				{
+					swdmx_desc_channel_enable(ch->chan);
+					ch->state = DSC_STATE_GO;
+				}
+			}else {
+				_ci_plus_set_output(ch);
+				ret = _hwdsc_set_aes_des_sm4_key(ch, flags, type, key);
+				if (ret != 0)
+					return ret;
+				/* Different with old mode, do change */
+				if (ch->work_mode == DVBCSA_MODE || ch->work_mode == -1) {
+					if (ch->work_mode == -1)
+						pr_error("Ciplus set output and enable\n");
+					else
+						pr_error("Ciplus set output change from dsc\n");
+					ch->work_mode = CIPLUS_MODE;
+				}
+
+			}
+			break;
+		}
+		default:
+			break;
+	}
+	return 0;
+}
+static int _dsc_set_cw(struct aml_dsc *dsc, struct ca_descr_ex *d)
+{
+	struct DescChannel *ch;
+
+	if (d->index >= DSC_CHANNEL_NUM)
+		return -EINVAL;
+
+	ch = &dsc->channels[d->index];
+
+	switch (d->type) {
+	case CA_CW_DVB_CSA_EVEN:
+	case CA_CW_AES_EVEN:
+	case CA_CW_DES_EVEN:
+	case CA_CW_SM4_EVEN:
+		memcpy(ch->even, d->cw, DSC_KEY_SIZE_MAX);
+		break;
+	case CA_CW_DVB_CSA_ODD:
+	case CA_CW_AES_ODD:
+	case CA_CW_DES_ODD:
+	case CA_CW_SM4_ODD:
+		memcpy(ch->odd, d->cw, DSC_KEY_SIZE_MAX);
+		break;
+	case CA_CW_AES_EVEN_IV:
+	case CA_CW_SM4_EVEN_IV:
+		memcpy(ch->even_iv, d->cw, DSC_KEY_SIZE_MAX);
+		break;
+	case CA_CW_AES_ODD_IV:
+	case CA_CW_SM4_ODD_IV:
+		memcpy(ch->odd_iv, d->cw, DSC_KEY_SIZE_MAX);
+		break;
+	default:
+		break;
+	}
+
+	ch->set |= (1 << d->type) | (d->flags << 24);
+
+	if (d->mode == CA_DSC_IDSA) {
+		ch->mode = IDSA_MODE;
+	}
+
+	_dsc_set_key(ch, d->flags, d->type, d->cw);
+	_dsc_ciplus_switch_check(ch, d->type);
+
+	return 0;
+}
+static int _dvb_dsc_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	err = dvb_generic_open(inode, file);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+static int _dsc_set_pid(struct aml_dsc *dsc, ca_pid_t *pi) {
+	int i;
+	struct DescChannel *ch;
+	int ret = 0;
+
+	if (pi->index == -1) {
+		for (i = 0; i < dsc->channel_num; i++) {
+			ch = &dsc->channels[i];
+
+			if (ch->state != DSC_STATE_FREE && (ch->pid == pi->pid)) {
+				_dsc_channel_free(ch);
+				break;
+			}
+		}
+	} else if ((pi->index >= 0) && (pi->index < DSC_CHANNEL_NUM)) {
+		ch = &dsc->channels[pi->index];
+
+		if (pi->pid < 0x1fff) {
+			if (ch->state != DSC_STATE_FREE) {
+				_dsc_channel_free(ch);
+			}
+			_dsc_channel_alloc(dsc,
+			pi->index, pi->pid);
+
+		} else {
+			if (ch->state != DSC_STATE_FREE)
+				_dsc_channel_free(ch);
+		}
+	} else {
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int _dvb_dsc_do_ioctl(struct file *file, unsigned int cmd,
+			  void *parg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct aml_dsc *dsc = dvbdev->priv;
+	int ret = 0;
+
+	if (mutex_lock_interruptible(&dsc->mutex))
+		return -ERESTARTSYS;
+
+	switch (cmd) {
+	case CA_RESET:
+		_dsc_reset(dsc);
+		break;
+	case CA_GET_CAP: {
+		ca_caps_t *cap = parg;
+
+		cap->slot_num   = 1;
+		cap->slot_type  = CA_DESCR;
+		cap->descr_num  = DSC_CHANNEL_NUM;
+		cap->descr_type = 0;
+		break;
+	}
+	case CA_GET_SLOT_INFO: {
+		ca_slot_info_t *slot = parg;
+
+		slot->num   = 1;
+		slot->type  = CA_DESCR;
+		slot->flags = 0;
+		break;
+	}
+	case CA_GET_DESCR_INFO: {
+		ca_descr_info_t *descr = parg;
+
+		descr->num  = DSC_CHANNEL_NUM;
+		descr->type = 0;
+		break;
+	}
+	case CA_SET_DESCR: {
+		ca_descr_t    *d = parg;
+		struct ca_descr_ex  dex;
+
+		dex.index = d->index;
+		dex.type  = d->parity ? CA_CW_DVB_CSA_ODD : CA_CW_DVB_CSA_EVEN;
+		dex.flags = 0;
+		memcpy(dex.cw, d->cw, sizeof(d->cw));
+
+		ret = _dsc_set_cw(dsc, &dex);
+		break;
+	}
+	case CA_SET_PID: {
+		ca_pid_t *pi = parg;
+
+		ret = _dsc_set_pid(dsc,pi);
+
+		break;
+	}
+	case CA_SET_DESCR_EX: {
+		struct ca_descr_ex *d = parg;
+
+		ret = _dsc_set_cw(dsc, d);
+		break;
+	}
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&dsc->mutex);
+
+	return ret;
+}
+
+static int _dvb_dsc_usercopy(struct file *file,
+		     unsigned int cmd, unsigned long arg,
+		     int (*func)(struct file *file,
+		     unsigned int cmd, void *arg))
+{
+	char    sbuf[128];
+	void    *mbuf = NULL;
+	void    *parg = NULL;
+	int     err  = -EINVAL;
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		/*
+		 * For this command, the pointer is actually an integer
+		 * argument.
+		 */
+		parg = (void *) arg;
+		break;
+	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (mbuf == NULL)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		err = -EFAULT;
+		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+			goto out;
+		break;
+	}
+
+	/* call driver */
+	err = func(file, cmd, parg);
+	if (err == -ENOIOCTLCMD)
+		err = -ENOTTY;
+
+	if (err < 0)
+		goto out;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			err = -EFAULT;
+		break;
+	}
+
+out:
+	kfree(mbuf);
+	return err;
+}
+
+static long _dvb_dsc_ioctl(struct file *file, unsigned int cmd,
+			  unsigned long arg)
+{
+	return _dvb_dsc_usercopy(file, cmd, arg, _dvb_dsc_do_ioctl);
+}
+
+static int _dvb_dsc_release(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct aml_dsc *dsc = dvbdev->priv;
+
+	if (mutex_lock_interruptible(&dsc->mutex))
+		return -ERESTARTSYS;
+
+	_dsc_reset(dsc);
+
+	mutex_unlock(&dsc->mutex);
+
+	dvb_generic_release(inode, file);
+
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long _dvb_dsc_compat_ioctl(struct file *filp,
+			unsigned int cmd, unsigned long args)
+{
+	unsigned long ret;
+
+	args = (unsigned long)compat_ptr(args);
+	ret = _dvb_dsc_ioctl(filp, cmd, args);
+	return ret;
+}
+#endif
+
+
+static const struct file_operations dvb_dsc_fops = {
+	.owner = THIS_MODULE,
+	.read = NULL,
+	.write = NULL,
+	.unlocked_ioctl = _dvb_dsc_ioctl,
+	.open = _dvb_dsc_open,
+	.release = _dvb_dsc_release,
+	.poll = NULL,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= _dvb_dsc_compat_ioctl,
+#endif
+};
+
+static struct dvb_device dvbdev_dsc = {
+	.priv = NULL,
+	.users = 1,
+	.readers = 1,
+	.writers = 1,
+	.fops = &dvb_dsc_fops,
+};
+
+int dsc_init(struct aml_dsc *dsc, struct dvb_adapter *dvb_adapter)
+{
+	int i;
+
+	dsc->channel_num = DSC_CHANNEL_NUM;
+	dsc->channels = kmalloc(sizeof(struct DescChannel)*dsc->channel_num,GFP_KERNEL);
+	if (!dsc->channels) {
+		return -1;
+	}
+	for (i=0; i<dsc->channel_num; i++) {
+		dsc->channels[i].state = DSC_STATE_FREE;
+		dsc->channels[i].algo = NULL;
+		dsc->channels[i].dsc = (void *)dsc;
+		dsc->channels[i].set = 0;
+		dsc->channels[i].pid = 0x1fff;
+	}
+
+	dsc->mode = HW_DSC_MODE;
+
+	/*Register descrambler device */
+	return dvb_register_device(dvb_adapter, &dsc->dev,
+				  &dvbdev_dsc, dsc, DVB_DEVICE_CA, 0);
+}
+void dsc_release(struct aml_dsc *dsc)
+{
+	if (dsc->dev) {
+		kfree(dsc->channels);
+		dsc->channels = NULL;
+
+		dvb_unregister_device(dsc->dev);
+		dsc->dev = NULL;
+	}
+}
+
+int dsc_set_mode(struct aml_dsc *dsc, int mode) {
+
+	if (dsc->mode != mode) {
+		dsc->mode = mode;
+	}
+	return 0;
+}
+
+int dsc_get_mode(struct aml_dsc *dsc, int *mode) {
+
+	*mode = dsc->mode;
+	return 0;
+}
+
diff --git a/drivers/stream_input/parser/demux/aml_dsc.h b/drivers/stream_input/parser/demux/aml_dsc.h
new file mode 100644
index 0000000..14ae6fa
--- /dev/null
+++ b/drivers/stream_input/parser/demux/aml_dsc.h
@@ -0,0 +1,92 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _AML_DSC_H_
+#define _AML_DSC_H_
+
+#include "sw_demux/swdemux.h"
+#include "dvbdev.h"
+#include <dmxdev.h>
+#include <linux/device.h>
+#include "hw_demux/s2p.h"
+
+#define SW_DSC_MODE 0
+#define HW_DSC_MODE 1
+
+#define DVBCSA_MODE 0
+#define CIPLUS_MODE 1
+#define CBC_MODE 0
+#define ECB_MODE 1
+#define IDSA_MODE 2
+
+#define DSC_SET_EVEN     1
+#define DSC_SET_ODD      2
+#define DSC_SET_AES_EVEN 4
+#define DSC_SET_AES_ODD  8
+#define DSC_FROM_KL      16
+#define DSC_SET_SM4_EVEN 32
+#define DSC_SET_SM4_ODD  64
+
+#define DSC_KEY_SIZE_MAX 16
+
+struct DescChannel {
+	SWDMX_DescChannel *chan;
+	SWDMX_DescAlgo   *algo;
+
+	void *dsc;
+
+	int  pid;
+	u8   even[DSC_KEY_SIZE_MAX];
+	u8   odd[DSC_KEY_SIZE_MAX];
+	u8   even_iv[DSC_KEY_SIZE_MAX];
+	u8   odd_iv[DSC_KEY_SIZE_MAX];
+	int  set;
+	int  id;
+
+	int  work_mode;
+	int  mode;
+
+	int  state;
+};
+
+struct aml_dsc {
+	struct dvb_device   *dev;
+
+	int mode;
+	int work_mode;
+	enum aml_ts_source_t   source;
+	enum aml_ts_source_t   dst;
+
+	SWDMX_Descrambler* swdsc;
+	int  id;
+
+	int channel_num;
+	struct DescChannel *channels;
+
+	struct mutex mutex;
+	spinlock_t slock;
+};
+
+int dsc_init(struct aml_dsc *dsc, struct dvb_adapter *dvb_adapter);
+void dsc_release(struct aml_dsc *dsc);
+int dsc_set_mode(struct aml_dsc *dsc, int mode);
+int dsc_get_mode(struct aml_dsc *dsc, int *mode);
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/aml_dvb.c b/drivers/stream_input/parser/demux/aml_dvb.c
new file mode 100644
index 0000000..8c4df62
--- /dev/null
+++ b/drivers/stream_input/parser/demux/aml_dvb.c
@@ -0,0 +1,666 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/of.h>
+
+#include "aml_dvb.h"
+#include "aml_dmx_ext.h"
+#include "hw_demux/hwdemux.h"
+
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+#define pr_inf(fmt, args...)   printk("DVB: " fmt, ## args)
+
+#define CARD_NAME "amlogic-dvb"
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+extern ssize_t stb_show_tuner_setting(struct class *class,
+				   struct class_attribute *attr, char *buf);
+extern ssize_t stb_store_tuner_setting(struct class *class,
+				    struct class_attribute *attr,
+				    const char *buf, size_t count);
+
+static struct aml_dvb aml_dvb_device;
+typedef struct _ChainPath
+{
+	int ts_id;
+	int dmx_id;
+	int asyncfifo_id;
+}ChainPath;
+
+#define MAX_DMXCHAINPATH_NUM 3
+static ChainPath DmxChainPath[MAX_DMXCHAINPATH_NUM];
+
+#define DSC_MODE_FUNC_DECL(i)\
+static ssize_t dsc##i##_store_mode(struct class *class,\
+				struct class_attribute *attr, const char *buf,size_t size) {\
+	if (!strncmp("sw", buf, 2)) {\
+		dsc_set_mode(&aml_dvb_device.dsc[i], SW_DSC_MODE);\
+	} else if (!strncmp("hw", buf, 2)) {\
+		dsc_set_mode(&aml_dvb_device.dsc[i], HW_DSC_MODE);\
+	}\
+	return 0;\
+}\
+static ssize_t dsc##i##_show_mode(struct class *class,\
+			       struct class_attribute *attr, char *buf) {\
+	int mode = 0;\
+	char *str ;\
+	ssize_t ret = 0;\
+	dsc_get_mode(&aml_dvb_device.dsc[i],&mode);\
+	if (mode == SW_DSC_MODE) {\
+		str = "sw";\
+	} else if (mode == HW_DSC_MODE) {\
+		str = "hw";\
+	}else {\
+		str = "none";\
+	}\
+	ret = sprintf(buf,"%s\n",str);\
+	return ret;\
+}
+
+#define DSC_PATH_FUNC_DECL(i)  \
+static ssize_t dsc##i##_store_path(struct class *class,\
+				struct class_attribute *attr, const char *buf,\
+				size_t size) {\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	int path = 0;\
+	int link = 0;\
+	int ret = 0;\
+	unsigned long flags;\
+	if (size < 13)\
+		goto ERROR;\
+	if (!strncmp("path=",buf,5)) {\
+		path = buf[5]-0x30;\
+	} else if (!strncmp("link=",buf+7,6)){\
+		link = buf[12]-0x30;\
+	} else {\
+		goto ERROR;\
+	}\
+	if (path > CHAIN_PATH_COUNT)\
+		goto ERROR;\
+	spin_lock_irqsave(&dvb->slock, flags);\
+	ret = hwdmx_set_dsc(aml_dvb_device.hwdmx[path],i,link);\
+	spin_unlock_irqrestore(&dvb->slock, flags);\
+	if (ret == 0)\
+		return 0;\
+ERROR:\
+	pr_error("error, such as path=0,link=1");\
+	return 0;\
+}\
+static ssize_t dsc##i##_show_path(struct class *class,\
+			       struct class_attribute *attr, char *buf) {\
+	int n = 0;\
+	int dsc_id = -1;\
+	int ret = -1;\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	unsigned long flags;\
+	spin_lock_irqsave(&dvb->slock, flags);\
+	for (n=0; n<CHAIN_PATH_COUNT; n++) {\
+		if (aml_dvb_device.hwdmx[n]) {\
+			hwdmx_get_dsc(aml_dvb_device.hwdmx[n],&dsc_id);\
+			if (dsc_id == i)\
+				break;\
+		}\
+	}\
+	spin_unlock_irqrestore(&dvb->slock, flags);\
+	ret = sprintf(buf,"%s%d\n","path=",dsc_id);\
+	return ret;\
+}
+
+#define CHAIN_PATH_FUNC_DECL(i)\
+ssize_t chain_path##i##_store_source(struct class *class,\
+			struct class_attribute *attr, const char *buf,\
+			size_t size)\
+{\
+	dmx_source_t src = -1;\
+	struct aml_dvb *dvb = aml_get_dvb_device();\
+	if (!dvb->hwdmx[i]) {\
+		return 0;\
+	}\
+	if (!strncmp("ts0", buf, 3))\
+		src = DMX_SOURCE_FRONT0;\
+	else if (!strncmp("ts1", buf, 3))\
+		src = DMX_SOURCE_FRONT1;\
+	else if (!strncmp("ts2", buf, 3))\
+		src = DMX_SOURCE_FRONT2;\
+	else if (!strncmp("ts3", buf, 3))\
+		src = DMX_SOURCE_FRONT3;\
+	else if (!strncmp("hiu", buf, 3))\
+		src = DMX_SOURCE_DVR0;\
+	else if (!strncmp("dmx0", buf, 4))\
+		src = DMX_SOURCE_FRONT0 + 100;\
+	else if (!strncmp("dmx1", buf, 4))\
+		src = DMX_SOURCE_FRONT1 + 100;\
+	else if (!strncmp("dmx2", buf, 4))\
+		src = DMX_SOURCE_FRONT2 + 100;\
+	if (src != -1) {\
+		hwdmx_set_source(dvb->hwdmx[i], src);\
+		if (src == DMX_SOURCE_DVR0) {\
+			dmx_set_work_mode(&dvb->dmx[0], 0);\
+		} else {\
+			dmx_set_work_mode(&dvb->dmx[0], 1);\
+		}\
+	}\
+	return size;\
+}\
+ssize_t chain_path##i##_show_source(struct class *class,\
+			       struct class_attribute *attr, char *buf)\
+{\
+	struct aml_dvb *dvb = aml_get_dvb_device();\
+	ssize_t ret = 0;\
+	char *src;\
+	dmx_source_t dmx_src=0;\
+	if (!dvb->hwdmx[i]) {\
+		return 0;\
+	}\
+	if (hwdmx_get_source(dvb->hwdmx[i], &dmx_src) != 0)\
+		return 0;\
+	switch (dmx_src) {\
+	case DMX_SOURCE_FRONT0:\
+		src = "ts0";\
+		break;\
+	case DMX_SOURCE_FRONT1:\
+		src = "ts1";\
+		break;\
+	case DMX_SOURCE_FRONT2:\
+		src = "ts2";\
+		break;\
+	case DMX_SOURCE_FRONT3:\
+		src = "ts3";\
+		break;\
+	case DMX_SOURCE_DVR0:\
+		src = "hiu";\
+		break;\
+	case DMX_SOURCE_FRONT0_OFFSET:\
+		src = "dmx0";\
+		break;\
+	case DMX_SOURCE_FRONT1_OFFSET:\
+		src = "dmx1";\
+		break;\
+	case DMX_SOURCE_FRONT2_OFFSET:\
+		src = "dmx2";\
+		break;\
+	default:\
+		src = "disable";\
+		break;\
+	}\
+	ret = sprintf(buf, "%s\n", src);\
+	return ret;\
+}
+
+#define WORK_MODE_FUNC_DECL(i)\
+ssize_t chain_path##i##_store_work_mode(struct class *class,\
+			struct class_attribute *attr, const char *buf,\
+			size_t size)\
+{\
+	int mode = -1;\
+	struct aml_dvb *dvb = aml_get_dvb_device();\
+	if (!dvb->dmx[i].init) {\
+		return 0;\
+	}\
+	if (!strncmp("sw", buf, 2))\
+		mode = 0;\
+	else if (!strncmp("hw", buf, 2))\
+		mode = 1;\
+	if (mode != -1)\
+		dmx_set_work_mode(&dvb->dmx[i], mode);\
+	return size;\
+}\
+ssize_t chain_path##i##_show_work_mode(struct class *class,\
+				   struct class_attribute *attr, char *buf)\
+{\
+	struct aml_dvb *dvb = aml_get_dvb_device();\
+	ssize_t ret = 0;\
+	char *src;\
+	int work_mode=-1;\
+	if (!dvb->dmx[i].init) {\
+		return 0;\
+	}\
+	if (dmx_get_work_mode(&dvb->dmx[i], &work_mode) != 0)\
+		return 0;\
+	switch (work_mode) {\
+	case 0:\
+		src = "sw";\
+		break;\
+	case 1:\
+		src = "hw";\
+		break;\
+	default:\
+		src = "disable";\
+		break;\
+	}\
+	ret = sprintf(buf, "%s\n", src);\
+	return ret;\
+}
+
+#define PATH_BUFF_STATUS_FUNC_DECL(i)\
+ssize_t path##i##_set_buf_warning_level(struct class *class,\
+			struct class_attribute *attr, const char *buf,\
+			size_t size)\
+{\
+	unsigned long warning_level = 0;\
+	struct aml_dvb *dvb = aml_get_dvb_device();\
+	int dmx_id = DmxChainPath[i].dmx_id;\
+	if (dmx_id == -1)\
+		return 0;\
+	if (!dvb->dmx[dmx_id].init) {\
+		return 0;\
+	}\
+	if (kstrtoul(buf,10,&warning_level) == 0) {\
+		if (warning_level >0 && warning_level <= 100) {\
+			dmx_set_buf_warning_level(&dvb->dmx[dmx_id], (int)warning_level);\
+		}\
+	}\
+	return size;\
+}\
+ssize_t path##i##_show_buf_warning_status(struct class *class,\
+				   struct class_attribute *attr, char *buf)\
+{\
+	struct aml_dvb *dvb = aml_get_dvb_device();\
+	ssize_t ret = 0;\
+	char *src;\
+	int status=-1;\
+	int dmx_id = DmxChainPath[i].dmx_id;\
+	if (dmx_id == -1)\
+		return 0;\
+	if (!dvb->dmx[dmx_id].init) {\
+		return 0;\
+	}\
+	if (dmx_get_buf_warning_status(&dvb->dmx[dmx_id], &status) != 0)\
+		return 0;\
+	switch (status) {\
+	case 0:\
+		src = "0";\
+		break;\
+	case 1:\
+		src = "1";\
+		break;\
+	default:\
+		src = "disable";\
+		break;\
+	}\
+	ret = sprintf(buf, "%s\n", src);\
+	return ret;\
+}
+
+DSC_PATH_FUNC_DECL(0)
+DSC_PATH_FUNC_DECL(1)
+
+DSC_MODE_FUNC_DECL(0)
+DSC_MODE_FUNC_DECL(1)
+
+CHAIN_PATH_FUNC_DECL(0)
+CHAIN_PATH_FUNC_DECL(1)
+
+WORK_MODE_FUNC_DECL(0)
+WORK_MODE_FUNC_DECL(1)
+
+PATH_BUFF_STATUS_FUNC_DECL(0)
+PATH_BUFF_STATUS_FUNC_DECL(1)
+
+static struct class_attribute aml_dvb_class_attrs[] = {
+	__ATTR(path0_source, 0664, chain_path0_show_source,
+	       chain_path0_store_source),
+	__ATTR(path1_source, 0664, chain_path1_show_source,
+	       chain_path1_store_source),
+	__ATTR(dsc0_mode, 0664, dsc0_show_mode,dsc0_store_mode),
+	__ATTR(dsc1_mode, 0664, dsc1_show_mode,dsc1_store_mode),
+	__ATTR(dsc0_path, 0664, dsc0_show_path,dsc0_store_path),
+	__ATTR(dsc1_path, 0664, dsc1_show_path,dsc1_store_path),
+	__ATTR(path0_work_mode, 0664, chain_path0_show_work_mode,\
+			chain_path0_store_work_mode),
+	__ATTR(path1_work_mode, 0664, chain_path1_show_work_mode,\
+			chain_path1_store_work_mode),
+	__ATTR(path0_buf_status, 0664, path0_show_buf_warning_status,\
+			path0_set_buf_warning_level),
+	__ATTR(path1_buf_status, 0664, path1_show_buf_warning_status,\
+			path1_set_buf_warning_level),\
+	__ATTR(tuner_setting, 0664, stb_show_tuner_setting, stb_store_tuner_setting),
+	__ATTR_NULL
+};
+
+static struct class aml_dvb_class = {
+	.name = "stb",
+	.class_attrs = aml_dvb_class_attrs,
+};
+
+static void dmx_chain_path_init(void) {
+	int i = 0;
+	for (i = 0; i < MAX_DMXCHAINPATH_NUM; i++) {
+		DmxChainPath[i].ts_id = -1;
+		DmxChainPath[i].dmx_id = -1;
+		DmxChainPath[i].asyncfifo_id = -1;
+	}
+}
+static int dmx_chain_path_parse(struct platform_device *pdev) {
+	int i = 0;
+	u32 ts_id = 0;
+	u32 dmx_id = 0;
+	u32 asyncfifo_id = 0;
+	int count = 0;
+	char buf[32];
+	int ret = 0;
+	u32 path_num = 0;
+
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "path_num");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &path_num);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, path_num);
+	}
+	if (path_num > MAX_DMXCHAINPATH_NUM) {
+		return 0;
+	}
+	for (i = 0; i < path_num; i++) {
+		memset(buf, 0, 32);
+		snprintf(buf, sizeof(buf), "path%d_ts",i);
+		ret = of_property_read_u32(pdev->dev.of_node, buf, &ts_id);
+		if (!ret) {
+			pr_inf("%s: 0x%x\n", buf, ts_id);
+		} else {
+			continue;
+		}
+		memset(buf, 0, 32);
+		snprintf(buf, sizeof(buf), "path%d_dmx",i);
+		ret = of_property_read_u32(pdev->dev.of_node, buf, &dmx_id);
+		if (!ret) {
+			pr_inf("%s: 0x%x\n", buf, dmx_id);
+		} else {
+			continue;
+		}
+
+		memset(buf, 0, 32);
+		snprintf(buf, sizeof(buf), "path%d_asyncfifo",i);
+		ret = of_property_read_u32(pdev->dev.of_node, buf, &asyncfifo_id);
+		if (!ret) {
+			pr_inf("%s: 0x%x\n", buf, asyncfifo_id);
+		} else {
+			continue;
+		}
+		DmxChainPath[count].ts_id = ts_id;
+		DmxChainPath[count].dmx_id = dmx_id;
+		DmxChainPath[count].asyncfifo_id = asyncfifo_id;
+		count++;
+	}
+
+	if (count == 0) {
+		/*pengcc test for local inject*/
+//		DmxChainPath[count].ts_id = DMX_SOURCE_DVR0;
+		DmxChainPath[count].ts_id = DMX_SOURCE_FRONT2;
+		DmxChainPath[count].dmx_id = 0;
+		DmxChainPath[count].asyncfifo_id = 0;
+		count++;
+	}
+
+	return count;
+}
+int dmx_get_dev_num(struct platform_device *pdev){
+	char buf[32];
+	u32 dmxdev = 0;
+	int ret = 0;
+
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "dmxdev_num");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &dmxdev);
+	if (!ret)
+		pr_inf("%s: 0x%x\n", buf, dmxdev);
+
+	return dmxdev;
+}
+struct aml_dvb *aml_get_dvb_device(void)
+{
+	return &aml_dvb_device;
+}
+EXPORT_SYMBOL(aml_get_dvb_device);
+
+struct dvb_adapter *aml_get_dvb_adapter(void)
+{
+	return &aml_dvb_device.dvb_adapter;
+}
+EXPORT_SYMBOL(aml_get_dvb_adapter);
+
+static int aml_dvb_remove(struct platform_device *pdev)
+{
+	struct aml_dvb *advb;
+	int i;
+	printk("aml_dvb_remove.....");
+
+	advb = &aml_dvb_device;
+
+	for (i = 0; i < CHAIN_PATH_COUNT; i++) {
+		if (advb->hwdmx[i])
+			hwdmx_destory(advb->hwdmx[i]);
+		if (advb->tsp[i])
+			swdmx_ts_parser_free(advb->tsp[i]);
+		if (advb->swdsc[i])
+			swdmx_descrambler_free(advb->swdsc[i]);
+		if (advb->swdmx[i])
+			swdmx_demux_free(advb->swdmx[i]);
+	}
+
+	for (i = 0; i < DMX_DEV_COUNT; i++) {
+		if (advb->dmx[i].init) {
+			dmx_destroy(&advb->dmx[i]);
+			advb->dmx[i].id = -1;
+		}
+		dmx_ext_exit(i);
+	}
+
+	for (i = 0; i<DSC_DEV_COUNT; i++) {
+		dsc_release(&advb->dsc[i]);
+		advb->dsc[i].id = -1;
+	}
+
+	hwdmx_remove();
+
+	mutex_destroy(&advb->mutex);
+	dvb_unregister_adapter(&advb->dvb_adapter);
+	class_unregister(&aml_dvb_class);
+
+	return 0;
+}
+
+static int hwdmx_cb(char *buf, int count,void *udata) {
+	SWDMX_TsParser *tsp = (SWDMX_TsParser *)udata;
+	int len = 0;
+	struct aml_dvb *advb;
+
+	advb = &aml_dvb_device;
+
+	if (mutex_lock_interruptible(&advb->mutex))
+		return 0;
+	len = swdmx_ts_parser_run(tsp, buf, count);
+	mutex_unlock(&advb->mutex);
+//	if (len != count)
+//		pr_inf("count is %d,len:%d remain %d\n",count,len,count-len);
+
+	return len;
+}
+
+static int aml_dvb_probe(struct platform_device *pdev)
+{
+	struct aml_dvb *advb;
+	int i, ret = 0;
+	int dmxChainPathNum = 0;
+	int dmxDevNum = 0;
+
+	pr_inf("probe amlogic dvb driver\n");
+	advb = &aml_dvb_device;
+	memset(advb, 0, sizeof(aml_dvb_device));
+
+	advb->dev = &pdev->dev;
+	advb->pdev = pdev;
+
+	ret = dvb_register_adapter(&advb->dvb_adapter, CARD_NAME, THIS_MODULE,
+				 advb->dev, adapter_nr);
+	if (ret < 0) {
+		return ret;
+	}
+
+	mutex_init(&advb->mutex);
+	spin_lock_init(&advb->slock);
+
+	hwdmx_probe(pdev);
+
+	dmx_chain_path_init();
+	dmxChainPathNum = dmx_chain_path_parse(pdev);
+	if (dmxChainPathNum == 0) {
+		pr_error("invalid chain path\n");
+		return -1;
+	}
+
+	dmxDevNum = dmx_get_dev_num(pdev);
+	if (dmxDevNum == 0)
+		dmxDevNum = dmxChainPathNum;
+
+	//create chain path
+	for (i = 0; i < dmxChainPathNum; i++) {
+		advb->hwdmx[i] = hwdmx_create(DmxChainPath[i].ts_id, DmxChainPath[i].dmx_id,DmxChainPath[i].asyncfifo_id);
+		if (advb->hwdmx[i] == NULL) {
+			goto INIT_ERR;
+		}
+		advb->swdsc[i] = swdmx_descrambler_new();
+		if (!advb->swdsc[i]) {
+			goto INIT_ERR;
+		}
+		advb->swdmx[i] = swdmx_demux_new();
+		if (!advb->swdmx[i]) {
+			goto INIT_ERR;
+		}
+		advb->tsp[i] = swdmx_ts_parser_new();
+		if (!advb->tsp[i]) {
+			goto INIT_ERR;
+		}
+		hwdmx_set_cb(advb->hwdmx[i], hwdmx_cb, advb->tsp[i]);
+	}
+
+	//create dmx dev
+	for (i = 0; i < dmxDevNum; i++) {
+		advb->dmx[i].id = i;
+		advb->dmx[i].pmutex = &advb->mutex;
+		advb->dmx[i].pslock = &advb->slock;
+		if (dmxChainPathNum == dmxDevNum) {
+			advb->dmx[i].hwdmx = advb->hwdmx[i];
+			advb->dmx[i].swdmx = advb->swdmx[i];
+			advb->dmx[i].tsp   = advb->tsp[i];
+		} else {
+			advb->dmx[i].hwdmx = advb->hwdmx[0];
+			advb->dmx[i].swdmx = advb->swdmx[0];
+			advb->dmx[i].tsp   = advb->tsp[0];
+		}
+		ret = dmx_init(&advb->dmx[i],&advb->dvb_adapter);
+		if (ret) {
+			goto INIT_ERR;
+		}
+		dmx_ext_init(i);
+	}
+
+	for (i = 0; i<DSC_DEV_COUNT; i++) {
+		advb->dsc[i].mutex = advb->mutex;
+		advb->dsc[i].slock = advb->slock;
+		advb->dsc[i].id = i;
+		if (dmxChainPathNum == DSC_DEV_COUNT) {
+			advb->dsc[i].swdsc = advb->swdsc[i];
+		} else {
+			advb->dsc[i].swdsc = advb->swdsc[0];
+		}
+		ret = dsc_init(&advb->dsc[i], &advb->dvb_adapter);
+		if (ret) {
+			goto INIT_ERR;
+		}
+	}
+
+	for (i = 0; i < dmxChainPathNum; i++) {
+		swdmx_ts_parser_add_ts_packet_cb(advb->tsp[i],swdmx_descrambler_ts_packet_cb,
+				advb->swdsc[i]);
+		swdmx_descrambler_add_ts_packet_cb(advb->swdsc[i],
+				swdmx_demux_ts_packet_cb,advb->swdmx[i]);
+	}
+
+	if (class_register(&aml_dvb_class) < 0)
+		pr_error("register class error\n");
+
+	return 0;
+
+INIT_ERR:
+	aml_dvb_remove(pdev);
+
+	return -1;
+}
+#ifdef CONFIG_OF
+static const struct of_device_id aml_dvb_dt_match[] = {
+	{
+	 .compatible = "amlogic, dvb-swdmx",
+	 },
+	{},
+};
+#endif /*CONFIG_OF */
+
+
+struct platform_driver aml_dvb_driver = {
+	.probe = aml_dvb_probe,
+	.remove = aml_dvb_remove,
+	.suspend = NULL,
+	.resume = NULL,
+	.driver = {
+		   .name = "amlogic-dvb",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_OF
+	   .of_match_table = aml_dvb_dt_match,
+#endif
+		}
+};
+
+static int __init aml_dvb_init(void)
+{
+	pr_inf("aml dvb init\n");
+	return platform_driver_register(&aml_dvb_driver);
+}
+static void __exit aml_dvb_exit(void)
+{
+	pr_inf("aml dvb exit\n");
+	platform_driver_unregister(&aml_dvb_driver);
+}
+
+module_init(aml_dvb_init);
+module_exit(aml_dvb_exit);
+
+MODULE_DESCRIPTION("driver for the AMLogic DVB card");
+MODULE_AUTHOR("AMLOGIC");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/stream_input/parser/demux/aml_dvb.h b/drivers/stream_input/parser/demux/aml_dvb.h
new file mode 100644
index 0000000..eda7928
--- /dev/null
+++ b/drivers/stream_input/parser/demux/aml_dvb.h
@@ -0,0 +1,67 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _AML_DVB_H_
+#define _AML_DVB_H_
+
+#include "aml_dmx.h"
+#include "aml_dsc.h"
+#include "hw_demux/hwdemux.h"
+#include "hw_demux/demod_gt.h"
+
+#define CHAIN_PATH_COUNT  5
+#define DMX_DEV_COUNT     5
+#define DSC_DEV_COUNT     2
+#define FE_DEV_COUNT 	  2
+
+struct aml_tuner {
+	struct tuner_config cfg;
+	unsigned int i2c_adapter_id;
+	struct i2c_adapter *i2c_adp;
+};
+
+struct aml_dvb {
+	struct dvb_device    dvb_dev;
+	struct dvb_adapter   dvb_adapter;
+
+	struct device       *dev;
+	struct platform_device *pdev;
+
+	HWDMX_Demux *hwdmx[CHAIN_PATH_COUNT];
+	SWDMX_TsParser *tsp[CHAIN_PATH_COUNT];
+	SWDMX_Descrambler *swdsc[CHAIN_PATH_COUNT];
+	SWDMX_Demux     *swdmx[CHAIN_PATH_COUNT];
+
+	struct aml_dmx 	dmx[DMX_DEV_COUNT];
+	struct aml_dsc	dsc[DSC_DEV_COUNT];
+
+	struct mutex mutex;
+	spinlock_t slock;
+
+	int ts_out_invert;
+
+	unsigned int tuner_num;
+	unsigned int tuner_cur;
+	struct aml_tuner *tuners;
+	bool tuner_attached;
+};
+
+struct aml_dvb *aml_get_dvb_device(void);
+
+#endif
diff --git a/drivers/stream_input/parser/demux/hw_demux/asyncfifo.c b/drivers/stream_input/parser/demux/hw_demux/asyncfifo.c
new file mode 100644
index 0000000..569d63c
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/asyncfifo.c
@@ -0,0 +1,736 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <linux/dma-mapping.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/vmalloc.h>
+#include <linux/of.h>
+#include <linux/spinlock.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+
+#include "c_stb_define.h"
+#include "c_stb_regs_define.h"
+#include "dvb_reg.h"
+
+#include "../aml_dvb.h"
+#include "hwdemux.h"
+#include "hwdemux_internal.h"
+#include "asyncfifo.h"
+
+struct aml_asyncfifo {
+	int	id;
+	int	init;
+	enum aml_dmx_id_t	source;
+	unsigned long	pages;
+	unsigned long   pages_map;
+	int	buf_len;
+	int	buf_write;
+	int buf_read;
+	int flush_size;
+	struct aml_dvb *dvb;
+	HWDMX_Demux *pdmx;
+	int secure_enable;
+	unsigned long secure_mem;
+	HWDMX_Cb cb;
+	void *udata;
+
+	void *cache;
+	int cache_len;
+	int remain_len;
+	int flush_time_ms;
+	spinlock_t  slock;
+	unsigned int wakeup;
+	wait_queue_head_t wait_queue;
+	struct task_struct *asyncfifo_task;
+	struct timer_list asyncfifo_timer;
+};
+
+#define ASYNCFIFO_COUNT 3
+#define ASYNCFIFO_BUFFER_SIZE_DEFAULT (512*1024)
+
+#define ASYNCFIFO_CACHE_LEN 		  (188)
+
+#define READ_PERI_REG			READ_CBUS_REG
+#define WRITE_PERI_REG			WRITE_CBUS_REG
+
+#define READ_ASYNC_FIFO_REG(i, r) \
+	((i) ? ((i-1)?READ_PERI_REG(ASYNC_FIFO1_##r):\
+	READ_PERI_REG(ASYNC_FIFO2_##r)) : READ_PERI_REG(ASYNC_FIFO_##r))
+
+#define WRITE_ASYNC_FIFO_REG(i, r, d)\
+	do {\
+		if (i == 2) {\
+			WRITE_PERI_REG(ASYNC_FIFO1_##r, d);\
+		} else if (i == 0) {\
+			WRITE_PERI_REG(ASYNC_FIFO_##r, d);\
+		} else {\
+			WRITE_PERI_REG(ASYNC_FIFO2_##r, d);\
+		} \
+	} while (0)
+
+#ifndef MIN
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
+#endif
+
+
+#define CLEAR_ASYNC_FIFO_REG_MASK(i, reg, mask) \
+	WRITE_ASYNC_FIFO_REG(i, reg, \
+	(READ_ASYNC_FIFO_REG(i, reg)&(~(mask))))
+
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+#define pr_inf(fmt, args...)   printk("DVB: " fmt, ## args)
+#define pr_dbg(fmt, args...)   printk(KERN_DEBUG fmt, ## args)
+
+#define asyncfifo_get_dev(afifo) ((afifo)->dvb->dev)
+#define ASYNCFIFO_TIMER    		50
+
+static int async_fifo_total_count = 2;
+static struct aml_asyncfifo asyncfifo[ASYNCFIFO_COUNT];
+static int asyncfifo_buf_len = ASYNCFIFO_BUFFER_SIZE_DEFAULT;
+
+static int asyncfifo_flush_time = ASYNCFIFO_TIMER;
+module_param(asyncfifo_flush_time, int, 0644);
+MODULE_PARM_DESC(asyncfifo_flush_time,
+		"asyncfifo flush time ms");
+
+static int _asyncfifo_reset_all(void);
+
+int asyncfifo_probe(struct platform_device *pdev) {
+
+	char buf[32];
+	u32 value = 0;
+	int ret = 0;
+
+	memset(&asyncfifo, 0,sizeof(asyncfifo))	;
+
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "asyncfifo_count");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		async_fifo_total_count = value;
+	}
+
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "asyncfifo_buf_len");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		asyncfifo_buf_len = value;
+	}
+	_asyncfifo_reset_all();
+	return 0;
+}
+
+int asyncfifo_remove(void) {
+	return 0;
+}
+static inline int _dmx_get_order(unsigned long size)
+{
+	int order;
+
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+
+	return order;
+}
+
+static void dvr_process_channel(struct aml_asyncfifo *afifo)
+{
+	int cnt;
+	int used_len;
+	int w_size = 0;
+	u8 *remain_addr;
+	int buf_read = 0;
+	int buf_write = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&afifo->slock,flags);
+	buf_read = afifo->buf_read;
+	buf_write = afifo->buf_write;
+	spin_unlock_irqrestore(&afifo->slock,flags);
+
+	pr_dbg("%s enter\n",__FUNCTION__);
+
+	if (buf_read > buf_write) {
+		cnt = afifo->buf_len - buf_read;
+		if (afifo->remain_len != 0) {
+			cnt = MIN((afifo->cache_len-afifo->remain_len),cnt);
+		}
+
+		if (!afifo->secure_enable) {
+			dma_sync_single_for_cpu(asyncfifo_get_dev(afifo),
+				afifo->pages_map+buf_read,
+				cnt,
+				DMA_FROM_DEVICE);
+			if (afifo->init && afifo->pdmx && afifo->cb) {
+				if (afifo->remain_len == 0) {
+					w_size = afifo->cb((u8 *)afifo->pages+buf_read,cnt,afifo->udata);
+					afifo->remain_len = cnt-w_size;
+					if (afifo->remain_len) {
+						remain_addr = (u8 *)afifo->pages+buf_read+cnt-afifo->remain_len;
+						memcpy(afifo->cache,(u8 *)remain_addr,afifo->remain_len);
+					}
+				} else {
+					memcpy(afifo->cache+afifo->remain_len,(u8 *)afifo->pages+buf_read,cnt);
+					used_len = cnt+afifo->remain_len;
+					w_size	= afifo->cb(afifo->cache, used_len, afifo->udata);
+					afifo->remain_len = used_len - w_size;
+					if (afifo->remain_len) {
+						printk("cache:total:%d,w_size:%d,remain:%d\n",\
+							used_len,w_size,afifo->remain_len);
+					}
+				}
+			}
+		}
+		spin_lock_irqsave(&afifo->slock,flags);
+		afifo->buf_read = (buf_read+cnt)%afifo->buf_len;
+		spin_unlock_irqrestore(&afifo->slock,flags);
+	}
+	else if (buf_write > buf_read) {
+		cnt = buf_write - buf_read;
+
+		if (afifo->remain_len != 0) {
+			cnt = MIN((afifo->cache_len-afifo->remain_len),cnt);
+		}
+
+		if (!afifo->secure_enable) {
+			dma_sync_single_for_cpu(asyncfifo_get_dev(afifo),
+				afifo->pages_map+buf_read,
+				cnt,
+				DMA_FROM_DEVICE);
+			if (afifo->init && afifo->pdmx && afifo->cb) {
+				if (afifo->remain_len == 0) {
+					w_size = afifo->cb((u8 *)afifo->pages+buf_read,cnt,afifo->udata);
+					afifo->remain_len = cnt - w_size;
+					if (afifo->remain_len) {
+						remain_addr = (u8 *)afifo->pages+buf_read+cnt-afifo->remain_len;
+						memcpy(afifo->cache,(u8 *)remain_addr,afifo->remain_len);
+					}
+				} else {
+					memcpy(afifo->cache+afifo->remain_len,(u8 *)afifo->pages+buf_read,cnt);
+					used_len = cnt+afifo->remain_len;
+					w_size = afifo->cb(afifo->cache, used_len, afifo->udata);
+					afifo->remain_len = used_len - w_size;
+					if (afifo->remain_len) {
+						printk("cache:total:%d,w_size:%d,remain:%d\n",\
+							used_len,w_size,afifo->remain_len);
+					}
+				}
+			}
+		}
+		spin_lock_irqsave(&afifo->slock,flags);
+		afifo->buf_read = (buf_read+cnt);
+		spin_unlock_irqrestore(&afifo->slock,flags);
+	}
+	//pr_dbg_irq_dvr("write data to dvr\n");
+}
+static int check_wakeup(struct aml_asyncfifo *afifo){
+	if (afifo->wakeup) {
+		afifo->wakeup = 0;
+		return 1;
+	}
+	return 0;
+}
+static int dvr_task_asyncfifo_func(void *data)
+{
+	int timeout = 0;
+	struct aml_asyncfifo *afifo = (struct aml_asyncfifo *)data;
+	HWDMX_Demux *pdmx;
+	struct aml_dvb *dvb = afifo->dvb;
+
+	pr_dbg("%s enter,line:%d\n",__FUNCTION__,__LINE__);
+	while (!kthread_should_stop()) {
+		timeout = wait_event_interruptible_timeout(afifo->wait_queue, check_wakeup(afifo), 3*HZ);
+		if (timeout <= 0)
+			continue;
+		if (dvb && afifo->source >= AM_DMX_0 &&
+				afifo->source < AM_DMX_MAX) {
+			pdmx = afifo->pdmx;
+			if (pdmx->init && afifo->init && afifo->cb) {
+				int buf_read = 0;
+				int buf_write = 0;
+				unsigned long flags;
+
+loop:
+				dvr_process_channel(afifo);
+				spin_lock_irqsave(&afifo->slock,flags);
+				buf_read = afifo->buf_read;
+				buf_write = afifo->buf_write;
+				spin_unlock_irqrestore(&afifo->slock,flags);
+				if (buf_read != buf_write)
+					goto loop;
+			}
+		}
+	}
+	return 0;
+}
+static void timer_asyncfifo_func(unsigned long arg)
+{
+	struct aml_asyncfifo *afifo = (struct aml_asyncfifo *)arg;
+	HWDMX_Demux *pdmx;
+	struct aml_dvb *dvb = afifo->dvb;
+	u32 start_addr;
+	int reg_val;
+	int buf_write = 0;
+	int buf_read = 0;
+	unsigned long flags;
+
+	if (dvb && afifo->source >= AM_DMX_0 && afifo->source < AM_DMX_MAX) {
+		pdmx = afifo->pdmx;
+		if (pdmx->init && afifo->init && afifo->cb) {
+			reg_val = READ_ASYNC_FIFO_REG(afifo->id, REG0);
+			start_addr = virt_to_phys((void *)afifo->pages);
+
+			spin_lock_irqsave(&afifo->slock,flags);
+			afifo->buf_write = reg_val - start_addr;
+			buf_write = afifo->buf_write;
+			buf_read = afifo->buf_read;
+			spin_unlock_irqrestore(&afifo->slock,flags);
+
+			if (buf_write != buf_read) {
+				afifo->wakeup = 1;
+				wake_up_interruptible(&afifo->wait_queue);
+			}
+		}
+	}
+	mod_timer(&afifo->asyncfifo_timer,
+		  jiffies + msecs_to_jiffies(asyncfifo_flush_time));
+}
+
+/*Allocate ASYNC FIFO Buffer*/
+static unsigned long _asyncfifo_alloc_buffer(int len)
+{
+	unsigned long pages = __get_free_pages(GFP_KERNEL, get_order(len));
+
+	if (!pages) {
+		pr_error("cannot allocate async fifo buffer\n");
+		return 0;
+	}
+	return pages;
+}
+static void _asyncfifo_free_buffer(unsigned long buf, int len)
+{
+	free_pages(buf, get_order(len));
+}
+
+static int _asyncfifo_set_buffer(struct aml_asyncfifo *afifo,
+					int len, unsigned long buf)
+{
+	if (afifo->pages)
+		return -1;
+
+	afifo->buf_write = 0;
+	afifo->buf_read   = 0;
+	afifo->buf_len = len;
+	pr_error("++++async fifo %d buf size %d, flush size %d\n",
+			afifo->id, afifo->buf_len, afifo->flush_size);
+
+	if ((afifo->flush_size <= 0)
+			|| (afifo->flush_size > (afifo->buf_len>>1))) {
+		afifo->flush_size = afifo->buf_len>>1;
+	} else if (afifo->flush_size < 128) {
+		afifo->flush_size = 128;
+	} else {
+		int fsize;
+
+		for (fsize = 128; fsize < (afifo->buf_len>>1); fsize <<= 1) {
+			if (fsize >= afifo->flush_size)
+				break;
+		}
+
+		afifo->flush_size = fsize;
+	}
+
+	afifo->pages = buf;
+	if (!afifo->pages)
+		return -1;
+
+	afifo->pages_map = dma_map_single(asyncfifo_get_dev(afifo),
+			(void *)afifo->pages, afifo->buf_len, DMA_FROM_DEVICE);
+
+	return 0;
+}
+static void _asyncfifo_put_buffer(struct aml_asyncfifo *afifo, int freemem)
+{
+	if (afifo->pages) {
+		dma_unmap_single(asyncfifo_get_dev(afifo),
+			afifo->pages_map, afifo->buf_len, DMA_FROM_DEVICE);
+		if (freemem)
+			_asyncfifo_free_buffer(afifo->pages, afifo->buf_len);
+		afifo->pages_map = 0;
+		afifo->pages = 0;
+	}
+}
+
+static int _async_fifo_init(struct aml_asyncfifo *afifo, int initirq,
+			int buf_len, unsigned long buf)
+{
+	int ret = 0;
+
+	if (afifo->init)
+		return -1;
+
+	afifo->source  = AM_DMX_MAX;
+	afifo->pages = 0;
+	afifo->buf_write = 0;
+	afifo->buf_read = 0;
+	afifo->buf_len = 0;
+	afifo->wakeup = 0;
+	spin_lock_init(&afifo->slock);
+
+	init_waitqueue_head(&afifo->wait_queue);
+
+	afifo->asyncfifo_task = kthread_run(dvr_task_asyncfifo_func,(void *)afifo, "asyncfifo%d", afifo->id);
+	if (!afifo->asyncfifo_task) {
+		pr_error("create asyncfifo task fail\n");
+	}
+	afifo->flush_time_ms = asyncfifo_flush_time;
+	init_timer(&afifo->asyncfifo_timer);
+	afifo->asyncfifo_timer.function = timer_asyncfifo_func;
+	afifo->asyncfifo_timer.expires =
+		jiffies + msecs_to_jiffies(afifo->flush_time_ms);
+	afifo->asyncfifo_timer.data = (unsigned long)afifo;
+	add_timer(&afifo->asyncfifo_timer);
+
+	/*alloc buffer*/
+	ret = _asyncfifo_set_buffer(afifo, buf_len, buf);
+
+	afifo->init = 1;
+
+	return ret;
+}
+static int _async_fifo_deinit(struct aml_asyncfifo *afifo, int freeirq, int freemem)
+{
+	if (!afifo->init)
+		return 0;
+
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG1, 1 << ASYNC_FIFO_FLUSH_EN);
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG2, 1 << ASYNC_FIFO_FILL_EN);
+
+	if (freemem)
+		_asyncfifo_put_buffer(afifo,1);
+	else
+		_asyncfifo_put_buffer(afifo,0);
+
+	kfree(afifo->cache);
+
+	afifo->source  = AM_DMX_MAX;
+	afifo->buf_write = 0;
+	afifo->buf_read = 0;
+	afifo->buf_len = 0;
+	afifo->cache_len = 0;
+	afifo->remain_len = 0;
+
+	del_timer(&afifo->asyncfifo_timer);
+
+	if (afifo->asyncfifo_task) {
+		kthread_stop(afifo->asyncfifo_task);
+		afifo->asyncfifo_task = NULL;
+	}
+
+	afifo->init = 0;
+
+	return 0;
+}
+static inline int dmx_get_order(unsigned long size)
+{
+	int order;
+
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+
+	return order;
+}
+
+static void async_fifo_set_regs(struct aml_asyncfifo *afifo, int source_val)
+{
+	u32 start_addr = virt_to_phys((void *)afifo->pages);
+	u32 size = afifo->buf_len;
+	u32 flush_size = afifo->flush_size;
+	int factor = dmx_get_order(size / flush_size);
+
+	if (afifo->secure_enable) {
+		start_addr = afifo->secure_mem;
+	}
+
+	pr_error("ASYNC FIFO id=%d, link to DMX%d, start_addr %x, buf_size %d,"
+		"source value 0x%x, factor %d\n",
+		afifo->id, afifo->source, start_addr, size, source_val, factor);
+	/* Destination address */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG0, start_addr);
+
+	/* Setup flush parameters */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+			(0 << ASYNC_FIFO_TO_HIU) |
+			(0 << ASYNC_FIFO_FLUSH) |
+			/* don't flush the path */
+			(1 << ASYNC_FIFO_RESET) |
+			/* reset the path */
+			(1 << ASYNC_FIFO_WRAP_EN) |
+			/* wrap enable */
+			(0 << ASYNC_FIFO_FLUSH_EN) |
+			/* disable the flush path */
+			/*(0x3 << ASYNC_FIFO_FLUSH_CNT_LSB);
+			 * flush 3 x 32  32-bit words
+			 */
+			/*(0x7fff << ASYNC_FIFO_FLUSH_CNT_LSB);
+			 * flush 4MBytes of data
+			 */
+			(((size >> 7) & 0x7fff) << ASYNC_FIFO_FLUSH_CNT_LSB));
+			/* number of 128-byte blocks to flush */
+
+	/* clear the reset signal */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+		     READ_ASYNC_FIFO_REG(afifo->id,
+					REG1) & ~(1 << ASYNC_FIFO_RESET));
+	/* Enable flush */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+		     READ_ASYNC_FIFO_REG(afifo->id,
+				REG1) | (1 << ASYNC_FIFO_FLUSH_EN));
+
+	/*Setup Fill parameters */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+			     (1 << ASYNC_FIFO_ENDIAN_LSB) |
+			     (0 << ASYNC_FIFO_FILL_EN) |
+			     /* disable fill path to reset fill path */
+			     /*(96 << ASYNC_FIFO_FILL_CNT_LSB);
+			      *3 x 32  32-bit words
+			      */
+			     (0 << ASYNC_FIFO_FILL_CNT_LSB));
+				/* forever FILL; */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+			READ_ASYNC_FIFO_REG(afifo->id, REG2) |
+				(1 << ASYNC_FIFO_FILL_EN));/*Enable fill path*/
+
+	/* generate flush interrupt */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG3,
+			(READ_ASYNC_FIFO_REG(afifo->id, REG3) & 0xffff0000) |
+				((((size >> (factor + 7)) - 1) & 0x7fff) <<
+					ASYNC_FLUSH_SIZE_IRQ_LSB));
+
+	/* Connect the STB DEMUX to ASYNC_FIFO */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+			READ_ASYNC_FIFO_REG(afifo->id, REG2) |
+			(source_val << ASYNC_FIFO_SOURCE_LSB));
+}
+
+static void reset_async_fifos(struct aml_asyncfifo *afifo) {
+
+	pr_dbg("Disable ASYNC FIFO id=%d\n", afifo->id);
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG1,
+				  1 << ASYNC_FIFO_FLUSH_EN);
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG2,
+				  1 << ASYNC_FIFO_FILL_EN);
+	if (READ_ASYNC_FIFO_REG(afifo->id, REG2) &
+			(1 << ASYNC_FIFO_FILL_EN) ||
+		READ_ASYNC_FIFO_REG(afifo->id, REG1) &
+			(1 << ASYNC_FIFO_FLUSH_EN)) {
+		pr_error("Set reg failed\n");
+	} else
+		pr_dbg("Set reg ok\n");
+	afifo->buf_write = 0;
+	afifo->buf_read = 0;
+
+	if (afifo->pdmx->dmx_id == AM_DMX_0)
+		async_fifo_set_regs(afifo,0x3);
+	else if (afifo->pdmx->dmx_id == AM_DMX_1)
+		async_fifo_set_regs(afifo,0x2);
+	else
+		async_fifo_set_regs(afifo,0x0);
+}
+
+int asyncfifo_init(int id,HWDMX_Demux *pdmx) {
+	int ret;
+	int len;
+	unsigned long buf;
+
+	pr_inf("%s enter\n",__FUNCTION__);
+
+	if (id >= async_fifo_total_count)
+		return -1;
+
+	asyncfifo[id].id = id;
+	asyncfifo[id].init = 0;
+	asyncfifo[id].flush_size = 256 * 1024;
+	asyncfifo[id].secure_enable = 0;
+	asyncfifo[id].secure_mem = 0;
+	asyncfifo[id].dvb = aml_get_dvb_device();
+	asyncfifo[id].pdmx = pdmx;
+	asyncfifo[id].source = -1;
+	asyncfifo[id].cache_len = ASYNCFIFO_CACHE_LEN;
+	asyncfifo[id].cache = kmalloc(asyncfifo[id].cache_len,GFP_KERNEL);
+	if (!asyncfifo[id].cache)
+		return -1;
+
+	asyncfifo[id].remain_len = 0;
+
+	len = asyncfifo_buf_len;
+	buf = _asyncfifo_alloc_buffer(len);
+	if (!buf) {
+		kfree(asyncfifo[id].cache);
+		return -1;
+	}
+
+	ret = _async_fifo_init(&asyncfifo[id], 1, len, buf);
+	if (ret < 0) {
+		kfree(asyncfifo[id].cache);
+		_asyncfifo_free_buffer(buf, len);
+	}
+
+	pr_inf("%s exit\n",__FUNCTION__);
+
+	return ret;
+}
+int asyncfifo_deinit(int id) {
+	int ret;
+
+	if (id >= async_fifo_total_count)
+		return -1;
+
+	ret = _async_fifo_deinit(&asyncfifo[id], 1, 1);
+
+	return ret;
+}
+int asyncfifo_reset(int id) {
+	unsigned long	buf;
+	int buf_len;
+	int source;
+	int ret = 0;
+	HWDMX_Demux *pdmx;
+
+	if (id >= async_fifo_total_count)
+		return -1;
+	if (!asyncfifo[id].init)
+		return -1;
+
+	source = asyncfifo[id].source;
+
+	if (!asyncfifo[id].secure_enable) {
+		buf = asyncfifo[id].pages;
+		buf_len = asyncfifo[id].buf_len;
+		pdmx = asyncfifo[id].pdmx;
+
+		ret = _async_fifo_deinit(&asyncfifo[id], 1, 0);
+		if (ret != 0)
+			return ret;
+		ret = _async_fifo_init(&asyncfifo[id], 0, buf_len, buf);
+	}
+
+	if (source >= AM_DMX_0 && source < AM_DMX_MAX) {
+		reset_async_fifos(&asyncfifo[id]);
+	}
+
+	return ret;
+}
+static int _asyncfifo_reset_all(void) {
+	int i = 0;
+	WRITE_MPEG_REG(RESET6_REGISTER, (1<<11)|(1<<12));
+
+	for (i = 0; i < async_fifo_total_count; i++) {
+		asyncfifo_reset(i);
+	}
+	return 0;
+}
+
+int asyncfifo_set_source(int id, enum aml_dmx_id_t source) {
+	if (id >= async_fifo_total_count)
+		return -1;
+
+	pr_inf("%s enter\n",__FUNCTION__);
+
+	if (asyncfifo[id].source != source) {
+		asyncfifo[id].source = source;
+		reset_async_fifos(&asyncfifo[id]);
+	}
+	return 0;
+}
+
+int asyncfifo_set_cb(int id, HWDMX_Cb cb, void *udata)
+{
+	if (id >= async_fifo_total_count)
+		return -1;
+
+	asyncfifo[id].cb = cb;
+	asyncfifo[id].udata = udata;
+	return 0;
+}
+
+int asyncfifo_set_security_buf(int id, unsigned long pstart, int size){
+	unsigned long	buf;
+	int buf_len;
+	int source = AM_DMX_MAX;
+	int ret;
+
+	if (id >= async_fifo_total_count)
+		return -1;
+	if (!asyncfifo[id].init)
+		return -1;
+
+	if (!asyncfifo[id].secure_enable) {
+		buf = asyncfifo[id].pages;
+		buf_len = asyncfifo[id].buf_len;
+		source = asyncfifo[id].source;
+
+		ret = _async_fifo_deinit(&asyncfifo[id], 1, 1);
+		if (ret != 0)
+			return ret;
+
+		_asyncfifo_free_buffer(buf, buf_len);
+
+		asyncfifo[id].source = source;
+		asyncfifo[id].init = 1;
+	} else {
+		source = asyncfifo[id].source;
+	}
+	asyncfifo[id].secure_enable = 1;
+	asyncfifo[id].secure_mem = pstart;
+	asyncfifo[id].buf_len = size;
+
+	if (source >= AM_DMX_0 && source < AM_DMX_MAX) {
+		reset_async_fifos(&asyncfifo[id]);
+	}
+	return 0;
+}
diff --git a/drivers/stream_input/parser/demux/hw_demux/asyncfifo.h b/drivers/stream_input/parser/demux/hw_demux/asyncfifo.h
new file mode 100644
index 0000000..71ff255
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/asyncfifo.h
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _ASYNCFIFO_H_
+#define _ASYNCFIFO_H_
+
+int asyncfifo_probe(struct platform_device *pdev);
+int asyncfifo_remove(void);
+
+int asyncfifo_init(int id,HWDMX_Demux *pdmx);
+int asyncfifo_deinit(int id);
+
+int asyncfifo_set_source(int id, enum aml_dmx_id_t source);
+int asyncfifo_set_cb(int id, HWDMX_Cb cb, void *udata);
+int asyncfifo_reset_all(void);
+int asyncfifo_set_security_buf(int id, unsigned long pstart, int size);
+
+
+#endif
diff --git a/drivers/stream_input/parser/demux/hw_demux/c_stb_define.h b/drivers/stream_input/parser/demux/hw_demux/c_stb_define.h
new file mode 100644
index 0000000..98e44e4
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/c_stb_define.h
@@ -0,0 +1,1174 @@
+/* ----------------------------------------------------------------------*/
+/* This file is automatically generated from the script:*/
+/**/
+/* ./create_stb_define_for_C_code.pl*/
+/**/
+/* and was applied to the file*/
+/**/
+/* ./stb_define.h*/
+/**/
+/* DO NOT EDIT!!!!!*/
+/* ----------------------------------------------------------------------*/
+/**/
+#ifdef C_STB_DEFINE_H
+#else
+#define C_STB_DEFINE_H
+
+/*=================================================*/
+/*  STB Registers Start*/
+/*=================================================*/
+/* -----------------------------------------------*/
+/*#define STB_CBUS_BASE           0x1600*/
+/* -----------------------------------------------*/
+/* There are two instantiations under one CBUS slave.
+ * Each CBUS slave can support*/
+/* 256 registers.
+ * Each demux is allocated 128 registers so set the offset in*/
+/* the middle*/
+/* Copy this define but don't add a base address*/
+/*#define DEMUX_1_OFFSET         0x00*/
+/*#define DEMUX_2_OFFSET         0x50*/
+/*#define DEMUX_3_OFFSET         0xa0*/
+/*======================================================*/
+/*  STB TOP Registers                   (8'hf0 - 8'hf7)*/
+/*======================================================*/
+/* bit 30:28 -- ciplus_o_sel*/
+/* bit 27:26 -- ciplus_i_sel*/
+/* bit 25 -- use FAIL fro TS2*/
+/* bit 24 -- use FAIL fro TS1*/
+/* bit 23 -- use FAIL fro TS0*/
+/* bit 22 -- invert fec_error for S2P1*/
+/* bit 21 -- invert fec_data for S2P1*/
+/* bit 20 -- invert fec_sync for S2P1*/
+/* bit 19 -- invert fec_valid for S2P1*/
+/* bit 18 -- invert fec_clk for S2P1*/
+/* bit 17:16 -- fec_s_sel for S2P1
+ * 00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved*/
+/* Bit 15 -- enable_des_pl_clk*/
+/* Bit 14:13 -- reserved*/
+/* Bit 12:10 -- ts_out_select,
+ * 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File*/
+/* bit 9:8 -- des_i_sel 00 -- select demux0 as des input,
+*  01 -- select_demux1, 10 -- select_demux2, 11 - reserved*/
+/* bit 7 -- enable_des_pl*/
+/* bit 6 -- invert fec_error for S2P0*/
+/* bit 5 -- invert fec_data for S2P0*/
+/* bit 4 -- invert fec_sync for S2P0*/
+/* bit 3 -- invert fec_valid for S2P0*/
+/* bit 2 -- invert fec_clk for S2P0*/
+/* bit 1:0 -- fec_s_sel for S2P0
+ * 00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved*/
+/*#define STB_TOP_CONFIG          (STB_CBUS_BASE + 0xf0) // 0x16f0*/
+/*----------- bit define -----------*/
+#define INVERT_S2P1_FEC_ERROR       22
+#define INVERT_S2P1_FEC_DATA        21
+#define INVERT_S2P1_FEC_SYNC        20
+#define INVERT_S2P1_FEC_VALID       19
+#define INVERT_S2P1_FEC_CLK         18
+#define S2P1_FEC_SERIAL_SEL         16
+#define ENABLE_DES_PL_CLK           15
+#define TS_OUTPUT_SOURCE            10
+#define DES_INPUT_SEL               8
+#define ENABLE_DES_PL               7
+#define INVERT_S2P0_FEC_ERROR       6
+#define INVERT_S2P0_FEC_DATA        5
+#define INVERT_S2P0_FEC_SYNC        4
+#define INVERT_S2P0_FEC_VALID       3
+#define INVERT_S2P0_FEC_CLK         2
+#define S2P0_FEC_SERIAL_SEL         0
+
+//define STB_S2P2_CONFIG
+#define S2P2_DISABLE                11
+#define S2P2_CLK_DIV                7
+#define INVERT_S2P2_FEC_ERROR       6
+#define INVERT_S2P2_FEC_DATA        5
+#define INVERT_S2P2_FEC_SYNC        4
+#define INVERT_S2P2_FEC_VALID       3
+#define INVERT_S2P2_FEC_CLK         2
+#define S2P2_FEC_SERIAL_SEL         0
+
+
+/* 31:28 - s2p1_clk_div*/
+/* 27:24 - s2p0_clk_div*/
+/* 23    - s2p1_disable*/
+/* 22    - s2p0_disable*/
+/* 21    - Reserved*/
+/* 20 -- TS_OUT_error_INVERT*/
+/* 19 -- TS_OUT_data_INVERT*/
+/* 18 -- TS_OUT_sync_INVERT*/
+/* 17 -- TS_OUT_valid_INVERT*/
+/* 16 -- TS_OUT_clk_INVERT*/
+/* 15:8 -- TS_package_length_sub_1 (default : 187)*/
+/*  7:0 -- fec_sync_byte (default : 0x47)*/
+/*#define TS_TOP_CONFIG           (STB_CBUS_BASE + 0xf1) // 0x16f1*/
+/*----------- bit define -----------*/
+#define TS_OUT_CLK_INVERT						16
+#define TS_PACKAGE_LENGTH_SUB_1     8
+#define FEC_DEFAULT_SYNC_BYTE       0
+
+/* Bit 25:24 -- transport_scrambling_control_odd_2 // should be 3*/
+/* Bit 23:16 -- file_m2ts_skip_bytes*/
+/* Bit 15:8 -- des_out_dly*/
+/* Bit 7:6 -- transport_scrambling_control_odd // should be 3*/
+/* Bit 5 -- ts_hiu_enable*/
+/* Bit 4:0 -- fec_clk_div*/
+/*#define TS_FILE_CONFIG          (STB_CBUS_BASE + 0xf2) // 0x16f2*/
+/*----------- bit define -----------*/
+#define TRANSPORT_SCRAMBLING_CONTROL_ODD_2 24
+#define FILE_M2TS_SKIP_BYTES        16
+#define DES_OUT_DLY                 8
+#define TRANSPORT_SCRAMBLING_CONTROL_ODD 6
+#define TS_HIU_ENABLE               5
+#define FEC_FILE_CLK_DIV            0
+
+/* Bit 19:14 -- des_2 ts pl state   -- Read Only*/
+/* Bit 13:8 -- des ts pl state   -- Read Only*/
+/* Bit 3:0 PID index to 8 PID to get key-set*/
+/* auto increse after TS_PL_PID_DATA read/write*/
+/*#define TS_PL_PID_INDEX         (STB_CBUS_BASE + 0xf3) // 0x16f3*/
+/*----------- bit define -----------*/
+#define DES_TS_PL_STATE             8
+#define DES_2_TS_PL_STATE           14
+
+/* Bit 13 -- PID match disble*/
+/* Bit 12:0 -- PID*/
+/*#define TS_PL_PID_DATA          (STB_CBUS_BASE + 0xf4) // 0x16f4*/
+/*----------- bit define -----------*/
+#define PID_MATCH_DISABLE_HIGH       29
+#define PID_MATCH_HIGH               16
+#define PID_MATCH_DISABLE_LOW        13
+#define PID_MATCH_LOW                0
+
+/*#define COMM_DESC_KEY0
+ * (STB_CBUS_BASE + 0xf5) // 0x16f5
+ Common descrambler key (key bits[63:32])*/
+/*#define COMM_DESC_KEY1
+ * (STB_CBUS_BASE + 0xf6) // 0x16f6
+ Common descrambler key (key bits[31:0])*/
+/*#define COMM_DESC_KEY_RW
+ * (STB_CBUS_BASE + 0xf7) // 0x16f7 // bits[3:0]
+ * point to the address to write the key
+ * {COMM_DESC_KEY3,...,COMM_DESC_KEY0}*/
+/* Writing this register writes the key to RAM*/
+
+/* bit 15:8 - des_out_dly_2*/
+/* bit   7 - reserved*/
+/* Bit   6-- enable_des_pl_clk_2*/
+/* bit   5 - enable_des_pl_2*/
+/* bit 4:2 -- use_des_2  bit[2] -- demux0, bit[3] -- demux1, bit[4] -- demux2*/
+/* bit 1:0 -- des_i_sel_2 00 -- select_fec_0, 01 -- select_fec_1,
+ *                        10 -- select_fec_2, 11 - reserved*/
+/*#define COMM_DESC_2_CTL     (STB_CBUS_BASE + 0xff) *//*0x16ff*/
+
+/*=======================================================*/
+/*  Multiple STB Registers                  (8'h00 - 8'h45)*/
+/*=======================================================*/
+/* STB registers are 8'h0x*/
+/* Bit 15:0 -- version number : 0x0002  (v0.01)*/
+/*#define STB_VERSION
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x00)  // 0x1600 // read only*/
+/*#define STB_VERSION_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x00)  // 0x1650 // read only*/
+/*#define STB_VERSION_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x00)  // 0x16a0 // read only*/
+
+/*#define STB_TEST_REG
+ *     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x01)  // 0x1601*/
+/*#define STB_TEST_REG_2
+ *     (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x01)  // 0x1651*/
+/*#define STB_TEST_REG_3
+ *    (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x01)  // 0x16a1*/
+
+/* Bit 15 -- fec_core_select 1 - select descramble output*/
+/* Bit 14:12 -  fec_select
+ * 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File*/
+/* Bit 11 -- FEC_CLK*/
+/* Bit 10 -- SOP*/
+/* Bit 9 -- D_VALID*/
+/* Bit 8 -- D_FAIL*/
+/* Bit 7:0 -- D_DATA 7:0*/
+/*#define FEC_INPUT_CONTROL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x02)  // 0x1602*/
+/*#define FEC_INPUT_CONTROL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x02)  // 0x1652*/
+/*#define FEC_INPUT_CONTROL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x02)  // 0x16a2*/
+/*----------- bit define -----------*/
+#define FEC_CORE_SEL               15
+#define FEC_SEL                    12
+#define FEC_INPUT_FEC_CLK          11
+#define FEC_INPUT_SOP              10
+#define FEC_INPUT_D_VALID           9
+#define FEC_INPUT_D_FAIL            8
+
+/*#define FEC_INPUT_DATA
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x03)  // 0x1603 // read only*/
+/*#define FEC_INPUT_DATA_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x03)  // 0x1653 // read only*/
+/*#define FEC_INPUT_DATA_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x03)  // 0x16a3 // read only*/
+
+/* bit 31 -- enable_free_clk_fec_data_valid*/
+/* bit 30 -- enable_free_clk_stb_reg*/
+/* bit 29 -- always_use_pes_package_length*/
+/* bit 28 -- disable_pre_incomplete_section_fix*/
+/* bit 27 -- pointer_field_multi_pre_en*/
+/* bit 26 -- ignore_pre_incomplete_section*/
+/* bit 25 -- video2_enable*/
+/* bit 24:22 -- video2_type*/
+/* bit 21 -- do_not_trust_pes_package_length*/
+/* bit 20 (bit 4) -- Bypass use recoder path*/
+/* bit 19 (bit 3) -- clear_PID_continuity_counter_valid*/
+/* bit 18 (bit 2) -- Disable Splicing*/
+/* bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES*/
+/* bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES*/
+/* Bit 15 - do not trust section length*/
+/* Bit 14 - om cmd push even zero*/
+/* Bit 13 - reserved*/
+/* Bit 12 - SUB, OTHER PES interrupt at beginning of PES*/
+/* Bit 11 - discard_av_package -- for ts_recorder use only*/
+/* Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter*/
+/* Bit 9 - ts_recorder_enable*/
+/* Bit 8 - (table_id == 0xff) means section_end*/
+/* Bit 7 - do not send uncomplete section*/
+/* Bit 6 - do not discard duplicate package*/
+/* Bit 5 - search SOP when trasport_error_indicator*/
+/* Bit 4 - stb demux enable*/
+/* Bit 3 - do not reset state machine on SOP*/
+/* Bit 2 - search SOP when error happened
+ * ( when ignore_fail_n_sop, will have this case)*/
+/* Bit 1 - do not use SOP input ( check FEC sync byte instead )*/
+/* Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)*/
+/*#define DEMUX_CONTROL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x04)  // 0x1604*/
+/*#define DEMUX_CONTROL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x04)  // 0x1654*/
+/*#define DEMUX_CONTROL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x04)  // 0x16a4*/
+/*----------- bit define -----------*/
+#define ENABLE_FREE_CLK_FEC_DATA_VALID          31
+#define ENABLE_FREE_CLK_STB_REG                 30
+#define BYPASS_USE_RECODER_PATH                 20
+#define CLEAR_PID_CONTINUITY_COUNTER_VALID      19
+#define DISABLE_SPLICING                        18
+#define INSERT_AUDIO_PES_STRONG_SYNC            17
+#define INSERT_VIDEO_PES_STRONG_SYNC            16
+#define SECTION_LENGTH_UNTRUSTY                 15
+#define OM_CMD_PUSH_EVEN_ZERO                   14
+#define OTHER_INT_AT_PES_BEGINING               12
+#define DISCARD_AV_PACKAGE                      11
+#define TS_RECORDER_SELECT                      10
+#define TS_RECORDER_ENABLE                      9
+#define SECTION_END_WITH_TABLE_ID               8
+#define SEND_COMPLETE_SECTION_ONLY              7
+#define KEEP_DUPLICATE_PACKAGE                  6
+#define SEACH_SOP_ON_TRANSPORT_ERROR            5
+#define STB_DEMUX_ENABLE                        4
+#define NO_RESET_ON_SOP                         3
+#define SEARCH_SOP_ON_ERROR                     2
+#define NOT_USE_OF_SOP_INPUT                    1
+#define IGNORE_NONSOP_FEC_ERROR                 0
+
+/* bit 15:8 demux package length - 1 ( default : 187 )*/
+/* bit 7:0 default is 0x47*/
+/*#define FEC_SYNC_BYTE
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x05)  // 0x1605*/
+/*#define FEC_SYNC_BYTE_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x05)  // 0x1655*/
+/*#define FEC_SYNC_BYTE_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x05)  // 0x16a5*/
+
+/****************************************
+ * FM Memory Usage :
+ * 0-15 (32 PID filter target) ---- 15:13-PID type 12:0-PID target or force data
+ * (force data : 1 will mask corespoding bit,
+ * 0 will disable this PID filter channel)
+ * advanced setting --	bit 7:0
+ *                      bit 7 -- PID bit 12:11 compare result force
+ *                      bit 6 -- PID bit 10:9 compare result force
+ *                      bit 5 -- PID bit 8:7 compare result force
+ *                      bit 4 -- PID bit 6:5 compare result force
+ *                      bit 3 -- PID bit 4:3 compare result force
+ *                      bit 2 -- PID bit 2 compare result force
+ *                      bit 1 -- PID bit 1 compare result force
+ *                      bit 0 -- PID bit 0 compare result force
+ * 16-255(15x32 Section filter target)
+ * For first byte : Table_ID
+ * ---- 15-Mask High 4-bits
+ *   14-Mask Low 4-bits
+ *   13-disable_PID_check
+ *   12:8-PIDindex
+ *   7:0-section target (always EQ)
+ * For rest of bytes :
+ * ---- 15-Mask 14-EQ/NE 13-disable_PID_check
+ * ----12:8-PIDindex 7:0-section target (or force data)
+ * advanced setting -- bit 7:0 force compare result
+ **************************************************/
+/*----------- bit define -----------*/
+#define PID_TYPE                                13
+#define PID_TARGET                              0
+
+#define SECTION_FIRSTBYTE_MASKHIGH              15
+#define SECTION_FIRSTBYTE_MASKLOW               14
+#define SECTION_FIRSTBYTE_DISABLE_PID_CHECK     13
+#define SECTION_FIRSTBYTE_PID_INDEX             8
+#define SECTION_TARGET                          0
+
+#define SECTION_RESTBYTE_MASK                   15
+#define SECTION_RESTBYTE_MASK_EQ                14
+#define SECTION_RESTBYTE_DISABLE_PID_CHECK      13
+#define SECTION_RESTBYTE_PID_INDEX              8
+
+/* bit 31:16 -- filter memory write data hi[31:16]*/
+/* bit 15:0 -- filter memory write data low [15:0]*/
+/*#define FM_WR_DATA
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x06)  // 0x1606*/
+/*#define FM_WR_DATA_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x06)  // 0x1656*/
+/*#define FM_WR_DATA_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x06)  // 0x16a6*/
+/*----------- bit define -----------*/
+#define FM_WR_DATA_HI                           16
+
+/* bit 31:24 -- advanced setting hi*/
+/* bit 23:16 -- advanced setting low*/
+/* bit 15 -- filter memory write data request*/
+/* bit 7:0 -- filter memory write addr*/
+/*#define FM_WR_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x07)  // 0x1607*/
+/*#define FM_WR_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x07)  // 0x1657*/
+/*#define FM_WR_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x07)  // 0x16a7*/
+/*----------- bit define -----------*/
+#define FM_ADVANCED_SETTING_HI                  24
+#define FM_ADVANCED_SETTING_LO                  16
+#define FM_WR_DATA_REQUEST                      15
+
+/* bit 13:8 demux state  -- read only*/
+/* bit 7:4 -- maxnum section filter compare address*/
+/* bit 3:0 -- maxnum PID filter compare address*/
+/*#define MAX_FM_COMP_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x08)  // 0x1608*/
+/*#define MAX_FM_COMP_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x08)  // 0x1658*/
+/*#define MAX_FM_COMP_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x08)  // 0x16a8*/
+/*----------- bit define -----------*/
+#define DEMUX_STATE                             8
+#define MAX_FM_SECTION_FILTER_COMP_ADDR         4
+
+/* bit 15 - transport_error_indicator*/
+/* bit 14 - payload_unit_start_indicator*/
+/* bit 13 - transport_priority*/
+/* bit 12:0 - PID*/
+/*#define TS_HEAD_0
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x09)  // 0x1609*/
+/*#define TS_HEAD_0_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x09)  // 0x1659*/
+/*#define TS_HEAD_0_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x09)  // 0x16a9*/
+/*----------- bit define -----------*/
+#define TRANSPORT_ERROR_INDICATOR               15
+#define PAYLOAD_UNIT_START_INDICATOR            14
+#define TRANSPORT_PRIORITY                      13
+
+/* bit 7:6 transport_scrambling_control*/
+/* bit 5:4 adaptation_field_control*/
+/* bit 3:0 continuity_counter*/
+/*#define TS_HEAD_1
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0a)  // 0x160a*/
+/*#define TS_HEAD_1_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0a)  // 0x165a*/
+/*#define TS_HEAD_1_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0a)  // 0x16aa*/
+/*----------- bit define -----------*/
+#define TRANSPORT_SCRAMBLING_CONTROL            6
+#define ADAPTATION_FIELD_CONTROL                4
+
+/* bit 15:12 -- om_cmd_count (read only)*/
+/* bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)*/
+/* bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)*/
+/* bit   5:3 -- type_stb_om_w_rd (read only)*/
+/* bit     2 -- unit_start_stb_om_w_rd (read only)*/
+/* bit     1 -- om_cmd_overflow (read only)*/
+/* bit     0 -- om_cmd_pending (read)*/
+/* bit     0 -- om_cmd_read_finished (write)*/
+/*#define OM_CMD_STATUS
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0b)  // 0x160b*/
+/*#define OM_CMD_STATUS_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0b)  // 0x165b*/
+/*#define OM_CMD_STATUS_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0b)  // 0x16ab*/
+/*----------- bit define -----------*/
+#define OM_CMD_COUNT                            12
+#define OM_OVERFLOW_COUNT                       9
+#define OM_OVERWRITE_COUNT                      6
+#define TYPE_STB_OM_W_RD                        3
+#define UNIT_START_STB_OM_W_RD                  2
+#define OM_CMD_OVERFLOW                         1
+
+/* bit 15:9 -- count_stb_om_w_rd  (read only)*/
+/* bit 8:0 -- start_stb_om_wa_rd (read only)*/
+/*#define OM_CMD_DATA
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0c)  // 0x160c*/
+/*#define OM_CMD_DATA_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0c)  // 0x165c*/
+/*#define OM_CMD_DATA_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0c)  // 0x16ac*/
+/*----------- bit define -----------*/
+#define COUNT_STB_OM_W_RD                       9
+
+/* bit 11:0 -- offset for section data*/
+/*#define OM_CMD_DATA2
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0d)  // 0x160d*/
+/*#define OM_CMD_DATA2_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0d)  // 0x165d*/
+/*#define OM_CMD_DATA2_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0d)  // 0x16ad*/
+
+/* bit 31:16 -- base address for section buffer group 0
+ * (*0x400 to get real address)*/
+/* bit 15:0 -- base address for section buffer group 1
+ * (*0x400 to get real address)*/
+/*#define SEC_BUFF_01_START
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0e)  // 0x160e*/
+/*#define SEC_BUFF_01_START_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0e)  // 0x165e*/
+/*#define SEC_BUFF_01_START_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0e)  // 0x16ae*/
+/*----------- bit define -----------*/
+#define SEC_BUFF_0_BASE_ADDR                    16
+
+/* bit 31:16 -- base address for section buffer group 2
+ * (*0x400 to get real address)*/
+/* bit 15:0 -- base address for section buffer group 3
+ * (*0x400 to get real address)*/
+/*#define SEC_BUFF_23_START
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0f)  // 0x160f*/
+/*#define SEC_BUFF_23_START_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0f)  // 0x165f*/
+/*#define SEC_BUFF_23_START_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0f)  // 0x16af*/
+/*----------- bit define -----------*/
+#define SEC_BUFF_2_BASE_ADDR                    16
+
+/* bit 15:12 -- section buffer size for group 3*/
+/* bit 11:8 -- section buffer size for group 2*/
+/* bit 7:4 -- section buffer size for group 1*/
+/* bit 3:0 -- section buffer size for group 0
+ * (bit used,  for example, 10 means 1K)*/
+/*#define SEC_BUFF_SIZE
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x10)  // 0x1610*/
+/*#define SEC_BUFF_SIZE_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x10)  // 0x1660*/
+/*#define SEC_BUFF_SIZE_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x10)  // 0x16b0*/
+/*----------- bit define -----------*/
+#define SEC_BUFF_3_SIZE                        12
+#define SEC_BUFF_2_SIZE                         8
+#define SEC_BUFF_1_SIZE                         4
+
+/* section buffer busy status for buff 31:0 ( Read Only )*/
+/*#define SEC_BUFF_BUSY
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x11)  // 0x1611*/
+/*#define SEC_BUFF_BUSY_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x11)  // 0x1661*/
+/*#define SEC_BUFF_BUSY_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x11)  // 0x16b1*/
+
+/* section buffer write status for buff 31:0 -- Read*/
+/* clear buffer status ( buff READY and BUSY ) -- write*/
+/*#define SEC_BUFF_READY
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x12)  // 0x1612*/
+/*#define SEC_BUFF_READY_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x12)  // 0x1662*/
+/*#define SEC_BUFF_READY_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x12)  // 0x16b2*/
+
+/* bit 15 -- section_reset_busy (Read Only)*/
+/* bit 14 -- output_section_buffer_valid*/
+/* bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only*/
+/* bit 4:0 -- SEC_BUFFER_INDEX   RW*/
+/*#define SEC_BUFF_NUMBER
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x13)  // 0x1613*/
+/*#define SEC_BUFF_NUMBER_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x13)  // 0x1663*/
+/*#define SEC_BUFF_NUMBER_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x13)  // 0x16b3*/
+/*----------- bit define -----------*/
+#define SECTION_RESET_BUSY                      15
+#define OUTPUT_SECTION_BUFFER_VALID             14
+#define INDEXED_SEC_BUFF_NUMBER                 8
+
+/* bit 9:5 -- BYPASS PID number*/
+/* bit 4:0 -- PCR PID number*/
+/*#define ASSIGN_PID_NUMBER
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x14)  // 0x1614*/
+/*#define ASSIGN_PID_NUMBER_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x14)  // 0x1664*/
+/*#define ASSIGN_PID_NUMBER_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x14)  // 0x16b4*/
+/*----------- bit define -----------*/
+#define BYPASS_PID_NUMBER                       5
+
+/* bit 15:0 -- stream_id filter bit enable*/
+/* bit 7:0 -- stream_id filter target*/
+/*#define VIDEO_STREAM_ID
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x15)  // 0x1615*/
+/*#define VIDEO_STREAM_ID_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x15)  // 0x1665*/
+/*#define VIDEO_STREAM_ID_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x15)  // 0x16b5*/
+
+/*#define AUDIO_STREAM_ID
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x16)  // 0x1616*/
+/*#define AUDIO_STREAM_ID_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x16)  // 0x1666*/
+/*#define AUDIO_STREAM_ID_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x16)  // 0x16b6*/
+
+/*#define SUB_STREAM_ID
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x17)  // 0x1617*/
+/*#define SUB_STREAM_ID_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x17)  // 0x1667*/
+/*#define SUB_STREAM_ID_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x17)  // 0x16b7*/
+
+/*#define OTHER_STREAM_ID
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x18)  // 0x1618*/
+/*#define OTHER_STREAM_ID_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x18)  // 0x1668*/
+/*#define OTHER_STREAM_ID_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x18)  // 0x16b8*/
+
+/* bit 12 -- PCR_EN*/
+/* bit 11:0 -- PCR90K_DIV*/
+/*#define PCR90K_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x19)  // 0x1619*/
+/*#define PCR90K_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x19)  // 0x1669*/
+/*#define PCR90K_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x19)  // 0x16b9*/
+/*----------- bit define -----------*/
+#define PCR_EN                     12
+
+/* bit 15:0 -- PCR[31:0] R/W*/
+/*#define PCR_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1a)  // 0x161a*/
+/*#define PCR_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1a)  // 0x166a*/
+/*#define PCR_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1a)  // 0x16ba*/
+
+/* bit 15:0 -- VPTS[31:0] R/W*/
+/*#define VIDEO_PTS_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1b)  // 0x161b*/
+/*#define VIDEO_PTS_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1b)  // 0x166b*/
+/*#define VIDEO_PTS_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1b)  // 0x16bb*/
+
+/* bit 15:0 -- VDTS[31:0] R/W*/
+/*#define VIDEO_DTS_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1c)  // 0x161c*/
+/*#define VIDEO_DTS_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1c)  // 0x166c*/
+/*#define VIDEO_DTS_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1c)  // 0x16bc*/
+
+/* bit 15:0 -- APTS[31:0] R/W*/
+/*#define AUDIO_PTS_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1d)  // 0x161d*/
+/*#define AUDIO_PTS_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1d)  // 0x166d*/
+/*#define AUDIO_PTS_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1d)  // 0x16bd*/
+
+/* bit 15:0 -- SPTS[31:0] R/W*/
+/*#define SUB_PTS_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1e)  // 0x161e*/
+/*#define SUB_PTS_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1e)  // 0x166e*/
+/*#define SUB_PTS_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1e)  // 0x16be*/
+
+/* read -- status, write 1 clear status*/
+/* bit 15 -- SUB_PTS[32]*/
+/* bit 14 -- AUDIO_PTS[32]*/
+/* bit 13 -- VIDEO_DTS[32]*/
+/* bit 12 -- VIDEO_PTS[32]*/
+/* bit 3 -- sub_pts_ready*/
+/* bit 2 -- audio_pts_ready*/
+/* bit 1 -- video_dts_ready*/
+/* bit 0 -- video_pts_ready*/
+/*#define STB_PTS_DTS_STATUS
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1f)  // 0x161f*/
+/*#define STB_PTS_DTS_STATUS_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1f)  // 0x166f*/
+/*#define STB_PTS_DTS_STATUS_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1f)  // 0x16bf*/
+/*----------- bit define -----------*/
+#define SUB_PTS_BIT32              15
+#define AUDIO_PTS_BIT32            14
+#define VIDEO_DTS_BIT32            13
+#define VIDEO_PTS_BIT32            12
+#define SUB_PTS_READY              3
+#define AUDIO_PTS_READY            2
+#define VIDEO_DTS_READY            1
+#define VIDEO_PTS_READY            0
+
+/* bit 3:0 --*/
+/*  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0]*/
+/*  1 -- stream_id[7:0], pes_header_bytes_left[7:0]*/
+/*  2 -- pes_package_bytes_left[15:0]*/
+/*  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]*/
+/*#define STB_DEBUG_INDEX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x20)  // 0x1620*/
+/*#define STB_DEBUG_INDEX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x20)  // 0x1670*/
+/*#define STB_DEBUG_INDEX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x20)  // 0x16c0*/
+
+/* read only*/
+/*#define STB_DEBUG_DATA_OUT
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x21)  // 0x1621*/
+/*#define STB_DEBUG_DATA_OUT_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x21)  // 0x1671*/
+/*#define STB_DEBUG_DATA_OUT_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x21)  // 0x16c1*/
+
+/* bit[31] -- no_match_record_en*/
+/* bit[30:16] - reserved*/
+/* default : 0x807f*/
+/* bit 15:9  -- MAX OM DMA COUNT  (default: 0x40)*/
+/* bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)*/
+/*#define STB_OM_CTL \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x22) // 0x1622*/
+/*#define STB_OM_CTL_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x22) // 0x1672*/
+/*#define STB_OM_CTL_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x22) // 0x16c2*/
+/*----------- bit define -----------*/
+#define MAX_OM_DMA_COUNT           9
+#define LAST_OM_ADDR               0
+
+/* 15:0  WRITE 1 CLEAR to clear interrupt source*/
+/*12 -- INPUT_TIME_OUT*/
+/*11 -- PCR_ready*/
+/*10 -- audio_splicing_point*/
+/* 9 -- video_splicing_point*/
+/* 8 -- other_PES_int*/
+/* 7 -- sub_PES_int*/
+/* 6 -- discontinuity*/
+/* 5 -- duplicated_pack_found*/
+/* 4 -- New PDTS ready*/
+/* 3 -- om_cmd_buffer ready for access*/
+/* 2 -- section buffer ready*/
+/* 1 -- transport_error_indicator*/
+/* 0 -- TS ERROR PIN*/
+/*#define STB_INT_STATUS
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x23)  // 0x1623*/
+/*#define STB_INT_STATUS_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x23)  // 0x1673*/
+/*#define STB_INT_STATUS_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x23)  // 0x16c3*/
+/*----------- bit define -----------*/
+#define INPUT_TIME_OUT             12
+#define PCR_READY                  11
+#define AUDIO_SPLICING_POINT       10
+#define VIDEO_SPLICING_POINT       9
+#define OTHER_PES_READY            8
+#define SUB_PES_READY              7
+#define DIS_CONTINUITY_PACKET      6
+#define DUPLICATED_PACKET          5
+#define NEW_PDTS_READY             4
+#define OM_CMD_READ_PENDING        3
+#define SECTION_BUFFER_READY       2
+#define TS_ERROR_PACKAGE           1
+#define TS_ERROR_PIN               0
+
+/* When Bit 31 - 1 write will indicate all type use sepertate endian
+ * (Write Only)*/
+/* When Bit 31 - 0 write will indicate all type else use Bit 8:6*/
+/* Bit 23:21 - demux om write endian control for OTHER_PES_PACKET*/
+/* Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET*/
+/* Bit 17:15 - demux om write endian control for SUB_PACKET*/
+/* Bit 14:12 - demux om write endian control for AUDIO_PACKET*/
+/* Bit 11:9  - demux om write endian control for VIDEO_PACKET*/
+/* Bit 8:6 - demux om write endian control for else*/
+/* Bit 5:3 - demux om write endian control for bypass*/
+/* Bit 2:0 - demux om write endian control for section*/
+/*#define DEMUX_ENDIAN
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x24)  // 0x1624*/
+/*#define DEMUX_ENDIAN_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x24)  // 0x1674*/
+/*#define DEMUX_ENDIAN_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x24)  // 0x16c4*/
+/*----------- bit define -----------*/
+#define SEPERATE_ENDIAN            31
+#define OTHER_PES_ENDIAN           21
+#define SCR_ENDIAN                 18
+#define SUB_ENDIAN                 15
+#define AUDIO_ENDIAN               12
+#define VIDEO_ENDIAN               9
+#define OTHER_ENDIAN               6
+#define BYPASS_ENDIAN              3
+#define SECTION_ENDIAN             0
+
+/* Bit 15:8 -- last_burst_threshold*/
+/* Bit 7 -- use hi_bsf interface*/
+/* Bit 6:2 - fec_clk_div*/
+/* Bit 1 ts_source_sel */
+/* Bit 0 - Hiu TS generate enable */
+/*#define TS_HIU_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x25)  // 0x1625*/
+/*#define TS_HIU_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x25)  // 0x1675*/
+/*#define TS_HIU_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x25)  // 0x16c5*/
+/*----------- bit define -----------*/
+#define LAST_BURST_THRESHOLD       8
+#define USE_HI_BSF_INTERFACE       7
+
+/* bit 15:0 -- base address for section buffer start
+ * (*0x10000 to get real base)*/
+/*#define SEC_BUFF_BASE
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x26)  // 0x1626*/
+/*#define SEC_BUFF_BASE_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x26)  // 0x1676*/
+/*#define SEC_BUFF_BASE_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x26)  // 0x16c6*/
+
+/* bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN*/
+/* bit 10 -- mask bit for SUB_AHB_DMA_EN*/
+/* bit 9 -- mask bit for BYPASS_AHB_DMA_EN*/
+/* bit 8 -- mask bit for SECTION_AHB_DMA_EN*/
+/* bit 7 -- mask bit for recoder stream*/
+/* bit 6:0 -- mask bit for each type*/
+/*#define DEMUX_MEM_REQ_EN
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x27)  // 0x1627*/
+/*#define DEMUX_MEM_REQ_EN_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x27)  // 0x1677*/
+/*#define DEMUX_MEM_REQ_EN_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x27)  // 0x16c7*/
+/*----------- bit define -----------*/
+#define VIDEO2_DMA_EN_BIT          12
+#define OTHER_PES_AHB_DMA_EN       11
+#define SUB_AHB_DMA_EN             10
+#define BYPASS_AHB_DMA_EN          9
+#define SECTION_AHB_DMA_EN         8
+#define RECORDER_STREAM            7
+#define OTHER_PES_PACKET           6
+#define SCR_ONLY_PACKET            5  /*will never be used*/
+#define BYPASS_PACKET              4
+#define SECTION_PACKET             3
+#define SUB_PACKET                 2
+#define AUDIO_PACKET               1
+#define VIDEO_PACKET               0
+
+/* bit 31:0 -- vb_wr_ptr for video PDTS*/
+/*#define VIDEO_PDTS_WR_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x28)  // 0x1628*/
+/*#define VIDEO_PDTS_WR_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x28)  // 0x1678*/
+/*#define VIDEO_PDTS_WR_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x28)  // 0x16c8*/
+
+/* bit 31:0 -- ab_wr_ptr for audio PDTS*/
+/*#define AUDIO_PDTS_WR_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x29)  // 0x1629*/
+/*#define AUDIO_PDTS_WR_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x29)  // 0x1679*/
+/*#define AUDIO_PDTS_WR_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x29)  // 0x16c9*/
+
+/* bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)*/
+/*#define SUB_WR_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2a)  // 0x162a*/
+/*#define SUB_WR_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2a)  // 0x167a*/
+/*#define SUB_WR_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2a)  // 0x16ca*/
+
+/* bit 19:0 -- SB_START (sb_start << 12 == byte address);*/
+/*#define SB_START
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2b)  // 0x162b*/
+/*#define SB_START_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2b)  // 0x167b*/
+/*#define SB_START_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2b)  // 0x16cb*/
+
+/* bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun)*/
+/*#define SB_LAST_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2c)  // 0x162c*/
+/*#define SB_LAST_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2c)  // 0x167c*/
+/*#define SB_LAST_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2c)  // 0x16cc*/
+
+/* bit 31:0 -- sb_wr_ptr for sub PES*/
+/*#define SB_PES_WRITE_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2d)  // 0x162d*/
+/*#define SB_PES_WRITE_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2d)  // 0x167d*/
+/*#define SB_PES_WRITE_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2d)  // 0x16cd*/
+
+/* bit 31:16 -- ob_wr_ptr for other PES*/
+/* bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)*/
+/*#define OTHER_WR_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2e)  // 0x162e*/
+/*#define OTHER_WR_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2e)  // 0x167e*/
+/*#define OTHER_WR_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2e)  // 0x16ce*/
+
+/* bit 19:0 -- OB_START (ob_start << 12 == byte address);*/
+/*#define OB_START
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2f)  // 0x162f*/
+/*#define OB_START_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2f)  // 0x167f*/
+/*#define OB_START_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2f)  // 0x16cf*/
+
+/* bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun)*/
+/*#define OB_LAST_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x30)  // 0x1630*/
+/*#define OB_LAST_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x30)  // 0x1680*/
+/*#define OB_LAST_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x30)  // 0x16d0*/
+
+/* bit 31:0 -- ob_wr_ptr for sub PES*/
+/*#define OB_PES_WRITE_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x31)  // 0x1631*/
+/*#define OB_PES_WRITE_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x31)  // 0x1681*/
+/*#define OB_PES_WRITE_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x31)  // 0x16d1*/
+
+/* 15:0  DEMUX interrupt MASK*/
+/* 11 -- PCR_READY*/
+/* 10 -- audio_splicing_point*/
+/* 9 -- video_splicing_point*/
+/* 8 -- other_PES_int*/
+/* 7 -- sub_PES_int*/
+/* 6 -- discontinuity*/
+/* 5 -- duplicated_pack_found*/
+/* 4 -- New PDTS ready*/
+/* 3 -- om_cmd_buffer ready for access*/
+/* 2 -- section buffer ready*/
+/* 1 -- transport_error_indicator*/
+/* 0 -- TS ERROR PIN*/
+/*#define STB_INT_MASK
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x32)  // 0x1632*/
+/*#define STB_INT_MASK_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x32)  // 0x1682*/
+/*#define STB_INT_MASK_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x32)  // 0x16d2*/
+
+/* 31:16 VIDEO PID filter data*/
+/*15 -- splicing VIDEO PID change enable*/
+/*14:10 -- VIDEO PID FILTER ADDRESS*/
+/* 9 -- PES splicing active (Read Only)*/
+/* 8 -- splicing active (Read Only)*/
+/* 7:0  splicing countdown (Read Only)*/
+/*#define VIDEO_SPLICING_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x33)  // 0x1633*/
+/*#define VIDEO_SPLICING_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x33)  // 0x1683*/
+/*#define VIDEO_SPLICING_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x33)  // 0x16d3*/
+/*----------- bit define -----------*/
+#define VIDEO_PID_FILTER_DATA      16
+#define VIDEO_SPLICING_PID_CHANGE_ENABLE       15
+#define VIDEO_PID_FILTER_ADDRESS   10
+#define VIDEO_PES_SPLICING_ACTIVE  9
+#define VIDEO_SPLICING_ACTIVE      8
+
+
+/* 31:16 AUDIO PID filter data*/
+/*15 -- splicing AUDIO PID change enable*/
+/*14:10 -- AUDIO PID FILTER ADDRESS*/
+/* 9 -- PES splicing active (Read Only)*/
+/* 8 -- splicing active (Read Only)*/
+/* 7:0  splicing countdown (Read Only)*/
+/*#define AUDIO_SPLICING_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x34)  // 0x1634*/
+/*#define AUDIO_SPLICING_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x34)  // 0x1684*/
+/*#define AUDIO_SPLICING_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x34)  // 0x16d4*/
+/*----------- bit define -----------*/
+#define AUDIO_PID_FILTER_DATA      16
+#define AUDIO_SPLICING_PID_CHANGE_ENABLE       15
+#define AUDIO_PID_FILTER_ADDRESS   10
+#define AUDIO_PES_SPLICING_ACTIVE  9
+#define AUDIO_SPLICING_ACTIVE      8
+
+/* 23:16 M2TS_SKIP_BYTES*/
+/* 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)*/
+/* 7:0  PACKAGE BYTE COUNT (Read Only)*/
+/*#define TS_PACKAGE_BYTE_COUNT
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x35)  // 0x1635*/
+/*#define TS_PACKAGE_BYTE_COUNT_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x35)  // 0x1685*/
+/*#define TS_PACKAGE_BYTE_COUNT_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x35)  // 0x16d5*/
+/*----------- bit define -----------*/
+#define M2TS_SKIP_BYTES            16
+#define LAST_TS_PACKAGE_BYTE_COUNT 8
+
+/* 15:0 2 bytes strong sync add to PES*/
+/*#define PES_STRONG_SYNC
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x36)  // 0x1636*/
+/*#define PES_STRONG_SYNC_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x36)  // 0x1686*/
+/*#define PES_STRONG_SYNC_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x36)  // 0x16d6*/
+
+/* bit 15 -- stb_om_ren*/
+/* bit 14:11 -- reserved*/
+/* bit  10:0 -- OM_DATA_RD_ADDR*/
+/*#define OM_DATA_RD_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x37)  // 0x1637*/
+/*#define OM_DATA_RD_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x37)  // 0x1687*/
+/*#define OM_DATA_RD_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x37)  // 0x16d7*/
+/*----------- bit define -----------*/
+#define STB_OM_REN                 15
+
+/* bit 15:0 -- OM_DATA_RD*/
+/*#define OM_DATA_RD
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x38)  // 0x1638*/
+/*#define OM_DATA_RD_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x38)  // 0x1688*/
+/*#define OM_DATA_RD_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x38)  // 0x16d8*/
+
+/* AUTO STOP SETTING for 32 channels*/
+/* 4-bits per channel*/
+/* when write*/
+/* bit 3 -- set section active*/
+/* bit 2:0 -- auto stop after count (0 means never stop)*/
+/* when read*/
+/* bit 3 -- current active status (1 - active, 0 - stopped )*/
+/* bit 2:0 -- count down to auto stop*/
+/* section 31:24*/
+/*#define SECTION_AUTO_STOP_3
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x39)  // 0x1639*/
+/*#define SECTION_AUTO_STOP_3_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x39)  // 0x1689*/
+/*#define SECTION_AUTO_STOP_3_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x39)  // 0x16d9*/
+/* section 23:16*/
+/*#define SECTION_AUTO_STOP_2
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3a)  // 0x163a*/
+/*#define SECTION_AUTO_STOP_2_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3a)  // 0x168a*/
+/*#define SECTION_AUTO_STOP_2_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3a)  // 0x16da*/
+/* section 15:8*/
+/*#define SECTION_AUTO_STOP_1
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3b)  // 0x163b*/
+/*#define SECTION_AUTO_STOP_1_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3b)  // 0x168b*/
+/*#define SECTION_AUTO_STOP_1_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3b)  // 0x16db*/
+/* section 7:0*/
+/*#define SECTION_AUTO_STOP_0
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3c)  // 0x163c*/
+/*#define SECTION_AUTO_STOP_0_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3c)  // 0x168c*/
+/*#define SECTION_AUTO_STOP_0_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3c)  // 0x16dc*/
+
+/* bit 31:0 reset channel status - each bit reset each channel*/
+/* read -- 32 channel status*/
+/*#define DEMUX_CHANNEL_RESET
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3d)  // 0x163d*/
+/*#define DEMUX_CHANNEL_RESET_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3d)  // 0x168d*/
+/*#define DEMUX_CHANNEL_RESET_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3d)  // 0x16dd*/
+
+/*#define DEMUX_SCRAMBLING_STATE
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3e)  // 0x163e*/
+/*#define DEMUX_SCRAMBLING_STATE_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3e)  // 0x168e*/
+/*#define DEMUX_SCRAMBLING_STATE_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3e)  // 0x16de*/
+
+/*#define DEMUX_CHANNEL_ACTIVITY
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3f)  // 0x163f*/
+/*#define DEMUX_CHANNEL_ACTIVITY_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3f)  // 0x168f*/
+/*#define DEMUX_CHANNEL_ACTIVITY_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3f)  // 0x16df*/
+
+/* bit 4 -- video_stamp_use_dts*/
+/* bit 3 -- audio_stamp_sync_1_en*/
+/* bit 2 -- audio_stamp_insert_en*/
+/* bit 1 -- video_stamp_sync_1_en*/
+/* bit 0 -- video_stamp_insert_en*/
+/*#define DEMUX_STAMP_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x40)  // 0x1640*/
+/*#define DEMUX_STAMP_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x40)  // 0x1690*/
+/*#define DEMUX_STAMP_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x40)  // 0x16e0*/
+
+/*#define DEMUX_VIDEO_STAMP_SYNC_0
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x41)  // 0x1641*/
+/*#define DEMUX_VIDEO_STAMP_SYNC_0_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x41)  // 0x1691*/
+/*#define DEMUX_VIDEO_STAMP_SYNC_0_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x41)  // 0x16e1*/
+
+/*#define DEMUX_VIDEO_STAMP_SYNC_1
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x42)  // 0x1642*/
+/*#define DEMUX_VIDEO_STAMP_SYNC_1_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x42)  // 0x1692*/
+/*#define DEMUX_VIDEO_STAMP_SYNC_1_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x42)  // 0x16e2*/
+
+/*#define DEMUX_AUDIO_STAMP_SYNC_0
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x43)  // 0x1643*/
+/*#define DEMUX_AUDIO_STAMP_SYNC_0_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x43)  // 0x1693*/
+/*#define DEMUX_AUDIO_STAMP_SYNC_0_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x43)  // 0x16e3*/
+
+/*#define DEMUX_AUDIO_STAMP_SYNC_1
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x44)  // 0x1644*/
+/*#define DEMUX_AUDIO_STAMP_SYNC_1_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x44)  // 0x1694*/
+/*#define DEMUX_AUDIO_STAMP_SYNC_1_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x44)  // 0x16e4*/
+
+/* Write : Bit[4:0] secter filter number for reset*/
+/* Read  : select according to output_section_buffer_valid :*/
+/*         per bit per section buffer valid status*/
+/*         or section_buffer_ignore*/
+/*#define DEMUX_SECTION_RESET
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x45)  // 0x1645*/
+/*#define DEMUX_SECTION_RESET_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x45)  // 0x1695*/
+/*#define DEMUX_SECTION_RESET_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x45)  // 0x16e5*/
+
+
+/* bit[31:0] - channel_reset_timeout_disable*/
+/*#define DEMUX_INPUT_TIMEOUT_C   \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x46) // 0x1646*/
+/*#define DEMUX_INPUT_TIMEOUT_C_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x46) // 0x1696*/
+/*#define DEMUX_INPUT_TIMEOUT_C_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x46) // 0x16e6*/
+/* bit[31] - no_match_reset_timeout_disable*/
+/* bit[30:0] input_time_out_int_cnt (0 -- means disable) Wr-setting, Rd-count*/
+/*#define DEMUX_INPUT_TIMEOUT     \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x47) // 0x1647*/
+/*#define DEMUX_INPUT_TIMEOUT_2   \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x47) // 0x1697*/
+/*#define DEMUX_INPUT_TIMEOUT_3   \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x47) // 0x16e7*/
+
+/* bit[31:0] - channel_packet_count_disable*/
+/*#define DEMUX_PACKET_COUNT_C    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x48) // 0x1648*/
+/*#define DEMUX_PACKET_COUNT_C_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x48) // 0x1698*/
+/*#define DEMUX_PACKET_COUNT_C_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x48)*/         /* 0x16e8*/
+/* bit[31] - no_match_packet_count_disable*/
+/* bit[30:0] input_packet_count*/
+/*#define DEMUX_PACKET_COUNT      \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x49) // 0x1649*/
+/*#define DEMUX_PACKET_COUNT_2    \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x49) // 0x1699*/
+/*#define DEMUX_PACKET_COUNT_3    \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x49) // 0x16e9*/
+
+/* bit[31:0] channel_record_enable*/
+/*#define DEMUX_CHAN_RECORD_EN    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4a) // 0x164a*/
+/*#define DEMUX_CHAN_RECORD_EN_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4a) // 0x169a*/
+/*#define DEMUX_CHAN_RECORD_EN_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4a) // 0x16ea*/
+
+/* bit[31:0] channel_process_enable*/
+/*#define DEMUX_CHAN_PROCESS_EN   \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4b) // 0x164b*/
+/*#define DEMUX_CHAN_PROCESS_EN_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4b)  */      /* 0x169b*/
+/*#define DEMUX_CHAN_PROCESS_EN_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4b) // 0x16eb*/
+
+/* bit[31:24] small_sec_size ((n+1) * 256 Bytes)*/
+/* bit[23:16] small_sec_rd_ptr */
+/* bit[15:8]  small_sec_wr_ptr */
+/* bit[7:2]   reserved*/
+/* bit[1] small_sec_wr_ptr_wr_enable*/
+/* bit[0] small_section_enable*/
+/*#define DEMUX_SMALL_SEC_CTL     \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4c)*/         /* 0x164c*/
+/*#define DEMUX_SMALL_SEC_CTL_2   \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4c)  // 0x169c*/
+/*#define DEMUX_SMALL_SEC_CTL_3   \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4c)   // 0x16ec*/
+/* bit[31:0] small_sec_start_addr*/
+/*#define DEMUX_SMALL_SEC_ADDR    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4d)  // 0x164d*/
+/*#define DEMUX_SMALL_SEC_ADDR_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4d)  // 0x169d*/
+/*#define DEMUX_SMALL_SEC_ADDR_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4d)  // 0x16ed*/
+
+
+/*======================================================*/
+/*  STB Registers End*/
+/*====================================================*/
+/* ----------------------------*/
+/* ASYNC FIFO (4)*/
+/* ----------------------------*/
+/*#define ASYNC_FIFO_REG0                            0x2310*/
+/*#define ASYNC_FIFO_REG1                            0x2311*/
+#define ASYNC_FIFO_FLUSH_STATUS     31
+#define ASYNC_FIFO_ERR              30
+#define ASYNC_FIFO_FIFO_EMPTY       29
+#define ASYNC_FIFO_TO_HIU           24
+#define ASYNC_FIFO_FLUSH            23
+#define ASYNC_FIFO_RESET            22
+#define ASYNC_FIFO_WRAP_EN          21
+#define ASYNC_FIFO_FLUSH_EN         20
+#define ASYNC_FIFO_RESIDUAL_MSB     19
+#define ASYNC_FIFO_RESIDUAL_LSB     15
+#define ASYNC_FIFO_FLUSH_CNT_MSB    14
+#define ASYNC_FIFO_FLUSH_CNT_LSB    0
+/*#define ASYNC_FIFO_REG2                            0x2312*/
+#define ASYNC_FIFO_FIFO_FULL        26
+#define ASYNC_FIFO_FILL_STATUS      25
+#define ASYNC_FIFO_SOURCE_MSB       24
+#define ASYNC_FIFO_SOURCE_LSB       23
+#define ASYNC_FIFO_ENDIAN_MSB       22
+#define ASYNC_FIFO_ENDIAN_LSB       21
+#define ASYNC_FIFO_FILL_EN          20
+#define ASYNC_FIFO_FILL_CNT_MSB     19
+#define ASYNC_FIFO_FILL_CNT_LSB     0
+/*#define ASYNC_FIFO_REG3                            0x2313*/
+#define ASYNC_FLUSH_SIZE_IRQ_MSB    15
+#define ASYNC_FLUSH_SIZE_IRQ_LSB    0
+/* ----------------------------*/
+/* ASYNC FIFO (4)*/
+/* ----------------------------*/
+/*#define ASYNC_FIFO2_REG0                           0x2314*/
+/*#define ASYNC_FIFO2_REG1                           0x2315*/
+/*#define ASYNC_FIFO2_REG2                           0x2316*/
+/*#define ASYNC_FIFO2_REG3                           0x2317*/
+
+#define RESET_DEMUXSTB      (1 << 1)
+#endif /* C_STB_DEFINE_H*/
diff --git a/drivers/stream_input/parser/demux/hw_demux/c_stb_regs_define.h b/drivers/stream_input/parser/demux/hw_demux/c_stb_regs_define.h
new file mode 100644
index 0000000..fac8601
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/c_stb_regs_define.h
@@ -0,0 +1,789 @@
+/*
+ * This file is automaticly generated by genregs.awk. Please do not edit it
+ * Base files are ..
+ *   ..
+ *   ..
+ * Tue Oct 22 15:28:48 CST 2013
+ **/
+
+#ifndef __MACH_MESON8_REG_ADDR_H_
+#define __MACH_MESON8_REG_ADDR_H_
+#include <linux/amlogic/iomap.h>
+#define CBUS_REG_ADDR(_r) aml_read_cbus(_r)
+
+
+#define STB_CBUS_BASE		aml_stb_get_base(ID_STB_CBUS_BASE)
+#define SMARTCARD_REG_BASE	aml_stb_get_base(ID_SMARTCARD_REG_BASE)
+#define ASYNC_FIFO_REG_BASE	aml_stb_get_base(ID_ASYNC_FIFO_REG_BASE)
+#define ASYNC_FIFO1_REG_BASE	aml_stb_get_base(ID_ASYNC_FIFO1_REG_BASE)
+#define ASYNC_FIFO2_REG_BASE	aml_stb_get_base(ID_ASYNC_FIFO2_REG_BASE)
+#define RESET_BASE		aml_stb_get_base(ID_RESET_BASE)
+#define PARSER_SUB_START_PTR_BASE \
+	aml_stb_get_base(ID_PARSER_SUB_START_PTR_BASE)
+
+#define HHI_CSI_PHY_CNTL_BASE 0x1000
+
+#define DEMUX_1_OFFSET         0x00
+#define DEMUX_2_OFFSET         0x50
+#define DEMUX_3_OFFSET         0xa0
+
+
+#define STB_S2P2_CONFIG  (STB_CBUS_BASE + 0xef)
+#define P_STB_S2P2_CONFIG                CBUS_REG_ADDR(STB_S2P2_CONFIG)
+
+#define STB_RECORDER2_CNTL	(STB_CBUS_BASE + 0xee)
+#define P_STB_RECORDER2_CNTL             CBUS_REG_ADDR(STB_RECORDER2_CNTL)
+
+#define STB_TOP_CONFIG  (STB_CBUS_BASE + 0xf0)
+#define P_STB_TOP_CONFIG                CBUS_REG_ADDR(STB_TOP_CONFIG)
+#define TS_TOP_CONFIG	(STB_CBUS_BASE + 0xf1)
+#define P_TS_TOP_CONFIG                 CBUS_REG_ADDR(TS_TOP_CONFIG)
+#define TS_FILE_CONFIG	(STB_CBUS_BASE + 0xf2)
+#define P_TS_FILE_CONFIG        CBUS_REG_ADDR(TS_FILE_CONFIG)
+#define TS_PL_PID_INDEX (STB_CBUS_BASE + 0xf3)
+#define P_TS_PL_PID_INDEX               CBUS_REG_ADDR(TS_PL_PID_INDEX)
+#define TS_PL_PID_DATA  (STB_CBUS_BASE + 0xf4)
+#define P_TS_PL_PID_DATA                CBUS_REG_ADDR(TS_PL_PID_DATA)
+#define COMM_DESC_KEY0  (STB_CBUS_BASE + 0xf5)
+#define P_COMM_DESC_KEY0                CBUS_REG_ADDR(COMM_DESC_KEY0)
+#define COMM_DESC_KEY1  (STB_CBUS_BASE + 0xf6)
+#define P_COMM_DESC_KEY1                CBUS_REG_ADDR(COMM_DESC_KEY1)
+#define COMM_DESC_KEY_RW (STB_CBUS_BASE + 0xf7)
+#define P_COMM_DESC_KEY_RW              CBUS_REG_ADDR(COMM_DESC_KEY_RW)
+#define CIPLUS_KEY0		(STB_CBUS_BASE + 0xf8)
+#define P_CIPLUS_KEY0           CBUS_REG_ADDR(CIPLUS_KEY0)
+#define CIPLUS_KEY1		(STB_CBUS_BASE + 0xf9)
+#define P_CIPLUS_KEY1           CBUS_REG_ADDR(CIPLUS_KEY1)
+#define CIPLUS_KEY2		(STB_CBUS_BASE + 0xfa)
+#define P_CIPLUS_KEY2           CBUS_REG_ADDR(CIPLUS_KEY2)
+#define CIPLUS_KEY3		(STB_CBUS_BASE + 0xfb)
+#define P_CIPLUS_KEY3           CBUS_REG_ADDR(CIPLUS_KEY3)
+#define CIPLUS_KEY_WR    (STB_CBUS_BASE + 0xfc)
+#define P_CIPLUS_KEY_WR                 CBUS_REG_ADDR(CIPLUS_KEY_WR)
+#define CIPLUS_CONFIG    (STB_CBUS_BASE + 0xfd)
+#define P_CIPLUS_CONFIG                 CBUS_REG_ADDR(CIPLUS_CONFIG)
+#define CIPLUS_ENDIAN    (STB_CBUS_BASE + 0xfe)
+#define P_CIPLUS_ENDIAN                 CBUS_REG_ADDR(CIPLUS_ENDIAN)
+
+#define SMARTCARD_REG0 (SMARTCARD_REG_BASE + 0x0)
+#define P_SMARTCARD_REG0                CBUS_REG_ADDR(SMARTCARD_REG0)
+#define SMARTCARD_REG1 (SMARTCARD_REG_BASE + 0x1)
+#define P_SMARTCARD_REG1                CBUS_REG_ADDR(SMARTCARD_REG1)
+#define SMARTCARD_REG2 (SMARTCARD_REG_BASE + 0x2)
+#define P_SMARTCARD_REG2                CBUS_REG_ADDR(SMARTCARD_REG2)
+#define SMARTCARD_STATUS (SMARTCARD_REG_BASE + 0x3)
+#define P_SMARTCARD_STATUS              CBUS_REG_ADDR(SMARTCARD_STATUS)
+#define SMARTCARD_INTR (SMARTCARD_REG_BASE + 0x4)
+#define P_SMARTCARD_INTR                CBUS_REG_ADDR(SMARTCARD_INTR)
+#define SMARTCARD_REG5 (SMARTCARD_REG_BASE + 0x5)
+#define P_SMARTCARD_REG5                CBUS_REG_ADDR(SMARTCARD_REG5)
+#define SMARTCARD_REG6 (SMARTCARD_REG_BASE + 0x6)
+#define P_SMARTCARD_REG6                CBUS_REG_ADDR(SMARTCARD_REG6)
+#define SMARTCARD_FIFO (SMARTCARD_REG_BASE + 0x7)
+#define P_SMARTCARD_FIFO                CBUS_REG_ADDR(SMARTCARD_FIFO)
+#define SMARTCARD_REG8 (SMARTCARD_REG_BASE + 0x8)
+#define P_SMARTCARD_REG8                CBUS_REG_ADDR(SMARTCARD_REG8)
+
+#define ASYNC_FIFO_REG0 (ASYNC_FIFO_REG_BASE + 0x0)
+#define P_ASYNC_FIFO_REG0               CBUS_REG_ADDR(ASYNC_FIFO_REG0)
+#define ASYNC_FIFO_REG1 (ASYNC_FIFO_REG_BASE + 0x1)
+#define P_ASYNC_FIFO_REG1               CBUS_REG_ADDR(ASYNC_FIFO_REG1)
+#define ASYNC_FIFO_REG2 (ASYNC_FIFO_REG_BASE + 0x2)
+#define P_ASYNC_FIFO_REG2               CBUS_REG_ADDR(ASYNC_FIFO_REG2)
+#define ASYNC_FIFO_REG3 (ASYNC_FIFO_REG_BASE + 0x3)
+#define P_ASYNC_FIFO_REG3               CBUS_REG_ADDR(ASYNC_FIFO_REG3)
+#define ASYNC_FIFO_REG4 (ASYNC_FIFO_REG_BASE + 0x4)
+#define P_ASYNC_FIFO_REG4               CBUS_REG_ADDR(ASYNC_FIFO_REG4)
+#define ASYNC_FIFO_REG5 (ASYNC_FIFO_REG_BASE + 0x5)
+#define P_ASYNC_FIFO_REG5               CBUS_REG_ADDR(ASYNC_FIFO_REG5)
+
+#define ASYNC_FIFO1_REG0 (ASYNC_FIFO1_REG_BASE + 0x0)
+#define P_ASYNC_FIFO1_REG0              CBUS_REG_ADDR(ASYNC_FIFO1_REG0)
+#define ASYNC_FIFO1_REG1 (ASYNC_FIFO1_REG_BASE + 0x1)
+#define P_ASYNC_FIFO1_REG1              CBUS_REG_ADDR(ASYNC_FIFO1_REG1)
+#define ASYNC_FIFO1_REG2 (ASYNC_FIFO1_REG_BASE + 0x2)
+#define P_ASYNC_FIFO1_REG2              CBUS_REG_ADDR(ASYNC_FIFO1_REG2)
+#define ASYNC_FIFO1_REG3 (ASYNC_FIFO1_REG_BASE + 0x3)
+#define P_ASYNC_FIFO1_REG3              CBUS_REG_ADDR(ASYNC_FIFO1_REG3)
+#define ASYNC_FIFO1_REG4 (ASYNC_FIFO1_REG_BASE + 0x4)
+#define P_ASYNC_FIFO1_REG4              CBUS_REG_ADDR(ASYNC_FIFO1_REG4)
+#define ASYNC_FIFO1_REG5 (ASYNC_FIFO1_REG_BASE + 0x5)
+#define P_ASYNC_FIFO1_REG5              CBUS_REG_ADDR(ASYNC_FIFO1_REG5)
+
+
+#define ASYNC_FIFO2_REG0 (ASYNC_FIFO2_REG_BASE + 0x0)
+#define P_ASYNC_FIFO2_REG0              CBUS_REG_ADDR(ASYNC_FIFO2_REG0)
+#define ASYNC_FIFO2_REG1 (ASYNC_FIFO2_REG_BASE + 0x1)
+#define P_ASYNC_FIFO2_REG1              CBUS_REG_ADDR(ASYNC_FIFO2_REG1)
+#define ASYNC_FIFO2_REG2 (ASYNC_FIFO2_REG_BASE + 0x2)
+#define P_ASYNC_FIFO2_REG2              CBUS_REG_ADDR(ASYNC_FIFO2_REG2)
+#define ASYNC_FIFO2_REG3 (ASYNC_FIFO2_REG_BASE + 0x3)
+#define P_ASYNC_FIFO2_REG3              CBUS_REG_ADDR(ASYNC_FIFO2_REG3)
+#define ASYNC_FIFO2_REG4 (ASYNC_FIFO2_REG_BASE + 0x4)
+#define P_ASYNC_FIFO2_REG4              CBUS_REG_ADDR(ASYNC_FIFO2_REG4)
+#define ASYNC_FIFO2_REG5 (ASYNC_FIFO2_REG_BASE + 0x5)
+#define P_ASYNC_FIFO2_REG5              CBUS_REG_ADDR(ASYNC_FIFO2_REG5)
+
+
+#define RESET0_REGISTER (RESET_BASE + 0x1)
+#define P_RESET0_REGISTER               CBUS_REG_ADDR(RESET0_REGISTER)
+#define RESET1_REGISTER (RESET_BASE + 0x2)
+#define P_RESET1_REGISTER               CBUS_REG_ADDR(RESET1_REGISTER)
+#define RESET2_REGISTER (RESET_BASE + 0x3)
+#define P_RESET2_REGISTER               CBUS_REG_ADDR(RESET2_REGISTER)
+#define RESET3_REGISTER (RESET_BASE + 0x4)
+#define P_RESET3_REGISTER               CBUS_REG_ADDR(RESET3_REGISTER)
+#define RESET4_REGISTER (RESET_BASE + 0x5)
+#define P_RESET4_REGISTER               CBUS_REG_ADDR(RESET4_REGISTER)
+#define RESET5_REGISTER (RESET_BASE + 0x6)
+#define P_RESET5_REGISTER               CBUS_REG_ADDR(RESET5_REGISTER)
+#define RESET6_REGISTER (RESET_BASE + 0x7)
+#define P_RESET6_REGISTER               CBUS_REG_ADDR(RESET6_REGISTER)
+#define RESET7_REGISTER (RESET_BASE + 0x8)
+#define P_RESET7_REGISTER               CBUS_REG_ADDR(RESET7_REGISTER)
+#define RESET0_MASK (RESET_BASE + 0x10)
+#define P_RESET0_MASK           CBUS_REG_ADDR(RESET0_MASK)
+#define RESET1_MASK (RESET_BASE + 0x11)
+#define P_RESET1_MASK           CBUS_REG_ADDR(RESET1_MASK)
+#define RESET2_MASK (RESET_BASE + 0x12)
+#define P_RESET2_MASK           CBUS_REG_ADDR(RESET2_MASK)
+#define RESET3_MASK (RESET_BASE + 0x13)
+#define P_RESET3_MASK           CBUS_REG_ADDR(RESET3_MASK)
+#define RESET4_MASK (RESET_BASE + 0x14)
+#define P_RESET4_MASK           CBUS_REG_ADDR(RESET4_MASK)
+#define RESET5_MASK (RESET_BASE + 0x15)
+#define P_RESET5_MASK           CBUS_REG_ADDR(RESET5_MASK)
+#define RESET6_MASK (RESET_BASE + 0x16)
+#define P_RESET6_MASK           CBUS_REG_ADDR(RESET6_MASK)
+#define CRT_MASK    (RESET_BASE + 0x17)
+#define P_CRT_MASK              CBUS_REG_ADDR(CRT_MASK)
+#define RESET7_MASK (RESET_BASE + 0x18)
+#define P_RESET7_MASK           CBUS_REG_ADDR(RESET7_MASK)
+/*add from M8M2*/
+#define P_RESET0_LEVEL          CBUS_REG_ADDR(RESET0_LEVEL)
+#define RESET1_LEVEL (RESET_BASE + 0x21)
+#define P_RESET1_LEVEL          CBUS_REG_ADDR(RESET1_LEVEL)
+#define RESET2_LEVEL (RESET_BASE + 0x22)
+#define P_RESET2_LEVEL          CBUS_REG_ADDR(RESET2_LEVEL)
+#define RESET3_LEVEL (RESET_BASE + 0x23)
+#define P_RESET3_LEVEL          CBUS_REG_ADDR(RESET3_LEVEL)
+#define RESET4_LEVEL (RESET_BASE + 0x24)
+#define P_RESET4_LEVEL          CBUS_REG_ADDR(RESET4_LEVEL)
+#define RESET5_LEVEL (RESET_BASE + 0x25)
+#define P_RESET5_LEVEL          CBUS_REG_ADDR(RESET5_LEVEL)
+#define RESET6_LEVEL (RESET_BASE + 0x26)
+#define P_RESET6_LEVEL          CBUS_REG_ADDR(RESET6_LEVEL)
+#define RESET7_LEVEL (RESET_BASE + 0x27)
+#define P_RESET7_LEVEL          CBUS_REG_ADDR(RESET7_LEVEL)
+
+/*no set*/
+#ifdef	MESON_M8_CPU
+#define HHI_CSI_PHY_CNTL0 (HHI_CSI_PHY_CNTL_BASE + 0xd3)
+#define P_HHI_CSI_PHY_CNTL0             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL0)
+#define HHI_CSI_PHY_CNTL1 (HHI_CSI_PHY_CNTL_BASE + 0xd4)
+#define P_HHI_CSI_PHY_CNTL1             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL1)
+#define HHI_CSI_PHY_CNTL2 (HHI_CSI_PHY_CNTL_BASE + 0xd5)
+#define P_HHI_CSI_PHY_CNTL2             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL2)
+#define HHI_CSI_PHY_CNTL3 (HHI_CSI_PHY_CNTL_BASE + 0xd6)
+#define P_HHI_CSI_PHY_CNTL3             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL3)
+#define HHI_CSI_PHY_CNTL4 (HHI_CSI_PHY_CNTL_BASE + 0xd7)
+#define P_HHI_CSI_PHY_CNTL4             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL4)
+#endif
+
+#define PARSER_SUB_START_PTR (PARSER_SUB_START_PTR_BASE + 0x8a)
+#define P_PARSER_SUB_START_PTR          CBUS_REG_ADDR(PARSER_SUB_START_PTR)
+#define PARSER_SUB_END_PTR (PARSER_SUB_START_PTR_BASE + 0x8b)
+#define P_PARSER_SUB_END_PTR            CBUS_REG_ADDR(PARSER_SUB_END_PTR)
+#define PARSER_SUB_WP (PARSER_SUB_START_PTR_BASE + 0x8c)
+#define P_PARSER_SUB_WP                 CBUS_REG_ADDR(PARSER_SUB_WP)
+#define PARSER_SUB_RP (PARSER_SUB_START_PTR_BASE + 0x8d)
+#define P_PARSER_SUB_RP                 CBUS_REG_ADDR(PARSER_SUB_RP)
+#define PARSER_SUB_HOLE (PARSER_SUB_START_PTR_BASE + 0x8e)
+#define P_PARSER_SUB_HOLE	CBUS_REG_ADDR(PARSER_SUB_HOLE)
+
+/*no set*/
+#define AO_RTI_GEN_PWR_SLEEP0 ((0x00 << 10) | (0x3a << 2))
+#define P_AO_RTI_GEN_PWR_SLEEP0                 \
+	AOBUS_REG_ADDR(AO_RTI_GEN_PWR_SLEEP0)
+#define AO_RTI_GEN_PWR_ISO0 ((0x00 << 10) | (0x3b << 2))
+#define P_AO_RTI_GEN_PWR_ISO0           AOBUS_REG_ADDR(AO_RTI_GEN_PWR_ISO0)
+
+/**/
+#define STB_VERSION   (STB_CBUS_BASE + 0x00)
+#define P_STB_VERSION           CBUS_REG_ADDR(STB_VERSION)
+#define STB_VERSION_2 (STB_CBUS_BASE + 0x50)
+#define P_STB_VERSION_2                 CBUS_REG_ADDR(STB_VERSION_2)
+#define STB_VERSION_3 (STB_CBUS_BASE + 0xa0)
+#define P_STB_VERSION_3                 CBUS_REG_ADDR(STB_VERSION_3)
+#define STB_TEST_REG   (STB_CBUS_BASE + 0x01)
+#define P_STB_TEST_REG          CBUS_REG_ADDR(STB_TEST_REG)
+#define STB_TEST_REG_2 (STB_CBUS_BASE + 0x51)
+#define P_STB_TEST_REG_2                CBUS_REG_ADDR(STB_TEST_REG_2)
+#define STB_TEST_REG_3 (STB_CBUS_BASE + 0xa1)
+#define P_STB_TEST_REG_3                CBUS_REG_ADDR(STB_TEST_REG_3)
+
+#define FEC_INPUT_CONTROL   (STB_CBUS_BASE + 0x2)
+#define P_FEC_INPUT_CONTROL             CBUS_REG_ADDR(FEC_INPUT_CONTROL)
+#define FEC_INPUT_CONTROL_2 (STB_CBUS_BASE + 0x52)
+#define P_FEC_INPUT_CONTROL_2           CBUS_REG_ADDR(FEC_INPUT_CONTROL_2)
+#define FEC_INPUT_CONTROL_3 (STB_CBUS_BASE + 0xa2)
+#define P_FEC_INPUT_CONTROL_3           CBUS_REG_ADDR(FEC_INPUT_CONTROL_3)
+/*no used*/
+#define FEC_INPUT_DATA (STB_CBUS_BASE + 0x03)
+#define P_FEC_INPUT_DATA                CBUS_REG_ADDR(FEC_INPUT_DATA)
+#define FEC_INPUT_DATA_2 (STB_CBUS_BASE + 0x53)
+#define P_FEC_INPUT_DATA_2              CBUS_REG_ADDR(FEC_INPUT_DATA_2)
+#define FEC_INPUT_DATA_3 (STB_CBUS_BASE + 0xa3)
+#define P_FEC_INPUT_DATA_3              CBUS_REG_ADDR(FEC_INPUT_DATA_3)
+/*no used end*/
+#define DEMUX_CONTROL (STB_CBUS_BASE + 0x04)
+#define P_DEMUX_CONTROL                 CBUS_REG_ADDR(DEMUX_CONTROL)
+#define DEMUX_CONTROL_2 (STB_CBUS_BASE + 0x54)
+#define P_DEMUX_CONTROL_2               CBUS_REG_ADDR(DEMUX_CONTROL_2)
+#define DEMUX_CONTROL_3 (STB_CBUS_BASE + 0xa4)
+#define P_DEMUX_CONTROL_3               CBUS_REG_ADDR(DEMUX_CONTROL_3)
+/*no used*/
+#define FEC_SYNC_BYTE (STB_CBUS_BASE + 0x05)
+#define P_FEC_SYNC_BYTE                 CBUS_REG_ADDR(FEC_SYNC_BYTE)
+#define FEC_SYNC_BYTE_2 (STB_CBUS_BASE + 0x55)
+#define P_FEC_SYNC_BYTE_2               CBUS_REG_ADDR(FEC_SYNC_BYTE_2)
+#define FEC_SYNC_BYTE_3 (STB_CBUS_BASE + 0xa5)
+#define P_FEC_SYNC_BYTE_3               CBUS_REG_ADDR(FEC_SYNC_BYTE_3)
+/*no used end*/
+
+#define FM_WR_DATA (STB_CBUS_BASE + 0x06)
+#define P_FM_WR_DATA            CBUS_REG_ADDR(FM_WR_DATA)
+#define FM_WR_DATA_2 (STB_CBUS_BASE + 0x56)
+#define P_FM_WR_DATA_2          CBUS_REG_ADDR(FM_WR_DATA_2)
+#define FM_WR_DATA_3 (STB_CBUS_BASE + 0xa6)
+#define P_FM_WR_DATA_3          CBUS_REG_ADDR(FM_WR_DATA_3)
+#define FM_WR_ADDR (STB_CBUS_BASE + 0x07)
+#define P_FM_WR_ADDR            CBUS_REG_ADDR(FM_WR_ADDR)
+#define FM_WR_ADDR_2 (STB_CBUS_BASE + 0x57)
+#define P_FM_WR_ADDR_2          CBUS_REG_ADDR(FM_WR_ADDR_2)
+#define FM_WR_ADDR_3 (STB_CBUS_BASE + 0xa7)
+#define P_FM_WR_ADDR_3          CBUS_REG_ADDR(FM_WR_ADDR_3)
+#define MAX_FM_COMP_ADDR (STB_CBUS_BASE + 0x08)
+#define P_MAX_FM_COMP_ADDR              CBUS_REG_ADDR(MAX_FM_COMP_ADDR)
+#define MAX_FM_COMP_ADDR_2 (STB_CBUS_BASE + 0x58)
+#define P_MAX_FM_COMP_ADDR_2            CBUS_REG_ADDR(MAX_FM_COMP_ADDR_2)
+#define MAX_FM_COMP_ADDR_3 (STB_CBUS_BASE + 0xa8)
+#define P_MAX_FM_COMP_ADDR_3            CBUS_REG_ADDR(MAX_FM_COMP_ADDR_3)
+
+#define TS_HEAD_0 (STB_CBUS_BASE + 0x09)
+#define P_TS_HEAD_0             CBUS_REG_ADDR(TS_HEAD_0)
+#define TS_HEAD_0_2 (STB_CBUS_BASE + 0x59)
+#define P_TS_HEAD_0_2           CBUS_REG_ADDR(TS_HEAD_0_2)
+#define TS_HEAD_0_3 (STB_CBUS_BASE + 0xa9)
+#define P_TS_HEAD_0_3           CBUS_REG_ADDR(TS_HEAD_0_3)
+#define TS_HEAD_1 (STB_CBUS_BASE + 0x0a)
+#define P_TS_HEAD_1             CBUS_REG_ADDR(TS_HEAD_1)
+#define TS_HEAD_1_2 (STB_CBUS_BASE + 0x5a)
+#define P_TS_HEAD_1_2           CBUS_REG_ADDR(TS_HEAD_1_2)
+#define TS_HEAD_1_3 (STB_CBUS_BASE + 0xaa)
+#define P_TS_HEAD_1_3           CBUS_REG_ADDR(TS_HEAD_1_3)
+
+#define OM_CMD_STATUS (STB_CBUS_BASE + 0x0b)
+#define P_OM_CMD_STATUS                 CBUS_REG_ADDR(OM_CMD_STATUS)
+#define OM_CMD_STATUS_2 (STB_CBUS_BASE + 0x5b)
+#define P_OM_CMD_STATUS_2               CBUS_REG_ADDR(OM_CMD_STATUS_2)
+#define OM_CMD_STATUS_3 (STB_CBUS_BASE + 0xab)
+#define P_OM_CMD_STATUS_3               CBUS_REG_ADDR(OM_CMD_STATUS_3)
+
+#define OM_CMD_DATA (STB_CBUS_BASE + 0x0c)
+#define P_OM_CMD_DATA           CBUS_REG_ADDR(OM_CMD_DATA)
+#define OM_CMD_DATA_2 (STB_CBUS_BASE + 0x5c)
+#define P_OM_CMD_DATA_2                 CBUS_REG_ADDR(OM_CMD_DATA_2)
+#define OM_CMD_DATA_3 (STB_CBUS_BASE + 0xac)
+#define P_OM_CMD_DATA_3                 CBUS_REG_ADDR(OM_CMD_DATA_3)
+#define OM_CMD_DATA2 (STB_CBUS_BASE + 0x0d)
+#define P_OM_CMD_DATA2          CBUS_REG_ADDR(OM_CMD_DATA2)
+#define OM_CMD_DATA2_2 (STB_CBUS_BASE + 0x5d)
+#define P_OM_CMD_DATA2_2                CBUS_REG_ADDR(OM_CMD_DATA2_2)
+#define OM_CMD_DATA2_3 (STB_CBUS_BASE + 0xad)
+#define P_OM_CMD_DATA2_3                CBUS_REG_ADDR(OM_CMD_DATA2_3)
+
+#define SEC_BUFF_01_START (STB_CBUS_BASE + 0x0e)
+#define P_SEC_BUFF_01_START             CBUS_REG_ADDR(SEC_BUFF_01_START)
+#define SEC_BUFF_01_START_2 (STB_CBUS_BASE + 0x5e)
+#define P_SEC_BUFF_01_START_2           CBUS_REG_ADDR(SEC_BUFF_01_START_2)
+#define SEC_BUFF_01_START_3 (STB_CBUS_BASE + 0xae)
+#define P_SEC_BUFF_01_START_3           CBUS_REG_ADDR(SEC_BUFF_01_START_3)
+#define SEC_BUFF_23_START (STB_CBUS_BASE + 0x0f)
+#define P_SEC_BUFF_23_START             CBUS_REG_ADDR(SEC_BUFF_23_START)
+#define SEC_BUFF_23_START_2 (STB_CBUS_BASE + 0x5f)
+#define P_SEC_BUFF_23_START_2           CBUS_REG_ADDR(SEC_BUFF_23_START_2)
+#define SEC_BUFF_23_START_3 (STB_CBUS_BASE + 0xaf)
+#define P_SEC_BUFF_23_START_3           CBUS_REG_ADDR(SEC_BUFF_23_START_3)
+#define SEC_BUFF_SIZE (STB_CBUS_BASE + 0x10)
+#define P_SEC_BUFF_SIZE                 CBUS_REG_ADDR(SEC_BUFF_SIZE)
+#define SEC_BUFF_SIZE_2 (STB_CBUS_BASE + 0x60)
+#define P_SEC_BUFF_SIZE_2               CBUS_REG_ADDR(SEC_BUFF_SIZE_2)
+#define SEC_BUFF_SIZE_3 (STB_CBUS_BASE + 0xb0)
+#define P_SEC_BUFF_SIZE_3               CBUS_REG_ADDR(SEC_BUFF_SIZE_3)
+#define SEC_BUFF_BUSY (STB_CBUS_BASE + 0x11)
+#define P_SEC_BUFF_BUSY                 CBUS_REG_ADDR(SEC_BUFF_BUSY)
+#define SEC_BUFF_BUSY_2 (STB_CBUS_BASE + 0x61)
+#define P_SEC_BUFF_BUSY_2               CBUS_REG_ADDR(SEC_BUFF_BUSY_2)
+#define SEC_BUFF_BUSY_3 (STB_CBUS_BASE + 0xb1)
+#define P_SEC_BUFF_BUSY_3               CBUS_REG_ADDR(SEC_BUFF_BUSY_3)
+#define SEC_BUFF_READY (STB_CBUS_BASE + 0x12)
+#define P_SEC_BUFF_READY                CBUS_REG_ADDR(SEC_BUFF_READY)
+#define SEC_BUFF_READY_2 (STB_CBUS_BASE + 0x62)
+#define P_SEC_BUFF_READY_2              CBUS_REG_ADDR(SEC_BUFF_READY_2)
+#define SEC_BUFF_READY_3 (STB_CBUS_BASE + 0xb2)
+#define P_SEC_BUFF_READY_3              CBUS_REG_ADDR(SEC_BUFF_READY_3)
+#define SEC_BUFF_NUMBER (STB_CBUS_BASE + 0x13)
+#define P_SEC_BUFF_NUMBER               CBUS_REG_ADDR(SEC_BUFF_NUMBER)
+#define SEC_BUFF_NUMBER_2 (STB_CBUS_BASE + 0x63)
+#define P_SEC_BUFF_NUMBER_2             CBUS_REG_ADDR(SEC_BUFF_NUMBER_2)
+#define SEC_BUFF_NUMBER_3 (STB_CBUS_BASE + 0xb3)
+#define P_SEC_BUFF_NUMBER_3             CBUS_REG_ADDR(SEC_BUFF_NUMBER_3)
+
+
+/**no used*/
+#define ASSIGN_PID_NUMBER (STB_CBUS_BASE + 0x14)
+#define P_ASSIGN_PID_NUMBER             CBUS_REG_ADDR(ASSIGN_PID_NUMBER)
+#define ASSIGN_PID_NUMBER_2 (STB_CBUS_BASE + 0x64)
+#define P_ASSIGN_PID_NUMBER_2           CBUS_REG_ADDR(ASSIGN_PID_NUMBER_2)
+#define ASSIGN_PID_NUMBER_3 (STB_CBUS_BASE + 0xb4)
+#define P_ASSIGN_PID_NUMBER_3           CBUS_REG_ADDR(ASSIGN_PID_NUMBER_3)
+#define VIDEO_STREAM_ID (STB_CBUS_BASE + 0x15)
+#define P_VIDEO_STREAM_ID               CBUS_REG_ADDR(VIDEO_STREAM_ID)
+#define VIDEO_STREAM_ID_2 (STB_CBUS_BASE + 0x65)
+#define P_VIDEO_STREAM_ID_2             CBUS_REG_ADDR(VIDEO_STREAM_ID_2)
+#define VIDEO_STREAM_ID_3 (STB_CBUS_BASE + 0xb5)
+#define P_VIDEO_STREAM_ID_3             CBUS_REG_ADDR(VIDEO_STREAM_ID_3)
+#define AUDIO_STREAM_ID (STB_CBUS_BASE + 0x16)
+#define P_AUDIO_STREAM_ID               CBUS_REG_ADDR(AUDIO_STREAM_ID)
+#define AUDIO_STREAM_ID_2 (STB_CBUS_BASE + 0x66)
+#define P_AUDIO_STREAM_ID_2             CBUS_REG_ADDR(AUDIO_STREAM_ID_2)
+#define AUDIO_STREAM_ID_3 (STB_CBUS_BASE + 0xb6)
+#define P_AUDIO_STREAM_ID_3             CBUS_REG_ADDR(AUDIO_STREAM_ID_3)
+#define SUB_STREAM_ID (STB_CBUS_BASE + 0x17)
+#define P_SUB_STREAM_ID                 CBUS_REG_ADDR(SUB_STREAM_ID)
+#define SUB_STREAM_ID_2 (STB_CBUS_BASE + 0x67)
+#define P_SUB_STREAM_ID_2               CBUS_REG_ADDR(SUB_STREAM_ID_2)
+#define SUB_STREAM_ID_3 (STB_CBUS_BASE + 0xb7)
+#define P_SUB_STREAM_ID_3               CBUS_REG_ADDR(SUB_STREAM_ID_3)
+#define OTHER_STREAM_ID (STB_CBUS_BASE + 0x18)
+#define P_OTHER_STREAM_ID               CBUS_REG_ADDR(OTHER_STREAM_ID)
+#define OTHER_STREAM_ID_2 (STB_CBUS_BASE + 0x68)
+#define P_OTHER_STREAM_ID_2             CBUS_REG_ADDR(OTHER_STREAM_ID_2)
+#define OTHER_STREAM_ID_3 (STB_CBUS_BASE + 0xb8)
+#define P_OTHER_STREAM_ID_3             CBUS_REG_ADDR(OTHER_STREAM_ID_3)
+#define PCR90K_CTL (STB_CBUS_BASE + 0x19)
+#define P_PCR90K_CTL            CBUS_REG_ADDR(PCR90K_CTL)
+#define PCR90K_CTL_2 (STB_CBUS_BASE + 0x69)
+#define P_PCR90K_CTL_2          CBUS_REG_ADDR(PCR90K_CTL_2)
+#define PCR90K_CTL_3 (STB_CBUS_BASE + 0xb9)
+#define P_PCR90K_CTL_3          CBUS_REG_ADDR(PCR90K_CTL_3)
+/*no used end*/
+#define PCR_DEMUX (STB_CBUS_BASE + 0x1a)
+#define P_PCR_DEMUX             CBUS_REG_ADDR(PCR_DEMUX)
+#define PCR_DEMUX_2 (STB_CBUS_BASE + 0x6a)
+#define P_PCR_DEMUX_2           CBUS_REG_ADDR(PCR_DEMUX_2)
+#define PCR_DEMUX_3 (STB_CBUS_BASE + 0xba)
+#define P_PCR_DEMUX_3           CBUS_REG_ADDR(PCR_DEMUX_3)
+
+#define VIDEO_PTS_DEMUX (STB_CBUS_BASE + 0x1b)
+#define P_VIDEO_PTS_DEMUX               CBUS_REG_ADDR(VIDEO_PTS_DEMUX)
+#define VIDEO_PTS_DEMUX_2 (STB_CBUS_BASE + 0x6b)
+#define P_VIDEO_PTS_DEMUX_2             CBUS_REG_ADDR(VIDEO_PTS_DEMUX_2)
+#define VIDEO_PTS_DEMUX_3 (STB_CBUS_BASE + 0xbb)
+#define P_VIDEO_PTS_DEMUX_3             CBUS_REG_ADDR(VIDEO_PTS_DEMUX_3)
+/*no used*/
+#define VIDEO_DTS_DEMUX (STB_CBUS_BASE + 0x1c)
+#define P_VIDEO_DTS_DEMUX               CBUS_REG_ADDR(VIDEO_DTS_DEMUX)
+#define VIDEO_DTS_DEMUX_2 (STB_CBUS_BASE + 0x6c)
+#define P_VIDEO_DTS_DEMUX_2             CBUS_REG_ADDR(VIDEO_DTS_DEMUX_2)
+#define VIDEO_DTS_DEMUX_3 (STB_CBUS_BASE + 0xbc)
+#define P_VIDEO_DTS_DEMUX_3             CBUS_REG_ADDR(VIDEO_DTS_DEMUX_3)
+/*no used end*/
+#define AUDIO_PTS_DEMUX (STB_CBUS_BASE + 0x1d)
+#define P_AUDIO_PTS_DEMUX               CBUS_REG_ADDR(AUDIO_PTS_DEMUX)
+#define AUDIO_PTS_DEMUX_2 (STB_CBUS_BASE + 0x6d)
+#define P_AUDIO_PTS_DEMUX_2             CBUS_REG_ADDR(AUDIO_PTS_DEMUX_2)
+#define AUDIO_PTS_DEMUX_3 (STB_CBUS_BASE + 0xbd)
+#define P_AUDIO_PTS_DEMUX_3             CBUS_REG_ADDR(AUDIO_PTS_DEMUX_3)
+/*no used */
+#define SUB_PTS_DEMUX (STB_CBUS_BASE + 0x1e)
+#define P_SUB_PTS_DEMUX                 CBUS_REG_ADDR(SUB_PTS_DEMUX)
+#define SUB_PTS_DEMUX_2 (STB_CBUS_BASE + 0x6e)
+#define P_SUB_PTS_DEMUX_2               CBUS_REG_ADDR(SUB_PTS_DEMUX_2)
+#define SUB_PTS_DEMUX_3 (STB_CBUS_BASE + 0xbe)
+#define P_SUB_PTS_DEMUX_3               CBUS_REG_ADDR(SUB_PTS_DEMUX_3)
+/*no used end*/
+#define STB_PTS_DTS_STATUS (STB_CBUS_BASE + 0x1f)
+#define P_STB_PTS_DTS_STATUS            CBUS_REG_ADDR(STB_PTS_DTS_STATUS)
+#define STB_PTS_DTS_STATUS_2 (STB_CBUS_BASE + 0x6f)
+#define P_STB_PTS_DTS_STATUS_2          CBUS_REG_ADDR(STB_PTS_DTS_STATUS_2)
+#define STB_PTS_DTS_STATUS_3 (STB_CBUS_BASE + 0xbf)
+#define P_STB_PTS_DTS_STATUS_3          CBUS_REG_ADDR(STB_PTS_DTS_STATUS_3)
+
+/*no use*/
+#define STB_DEBUG_INDEX (STB_CBUS_BASE + 0x20)
+#define P_STB_DEBUG_INDEX               CBUS_REG_ADDR(STB_DEBUG_INDEX)
+#define STB_DEBUG_INDEX_2 (STB_CBUS_BASE + 0x70)
+#define P_STB_DEBUG_INDEX_2             CBUS_REG_ADDR(STB_DEBUG_INDEX_2)
+#define STB_DEBUG_INDEX_3 (STB_CBUS_BASE + 0xc0)
+#define P_STB_DEBUG_INDEX_3             CBUS_REG_ADDR(STB_DEBUG_INDEX_3)
+#define STB_DEBUG_DATAUT_O (STB_CBUS_BASE + 0x21)
+#define P_STB_DEBUG_DATAUT_O            CBUS_REG_ADDR(STB_DEBUG_DATAUT_O)
+#define STB_DEBUG_DATAUT_O_2 (STB_CBUS_BASE + 0x71)
+#define P_STB_DEBUG_DATAUT_O_2          CBUS_REG_ADDR(STB_DEBUG_DATAUT_O_2)
+#define STB_DEBUG_DATAUT_O_3 (STB_CBUS_BASE + 0xc1)
+#define P_STB_DEBUG_DATAUT_O_3          CBUS_REG_ADDR(STB_DEBUG_DATAUT_O_3)
+/*no use end*/
+
+#define STBM_CTL_O (STB_CBUS_BASE + 0x22)
+#define P_STBM_CTL_O            CBUS_REG_ADDR(STBM_CTL_O)
+#define STBM_CTL_O_2 (STB_CBUS_BASE + 0x72)
+#define P_STBM_CTL_O_2          CBUS_REG_ADDR(STBM_CTL_O_2)
+#define STBM_CTL_O_3 (STB_CBUS_BASE + 0xc2)
+#define P_STBM_CTL_O_3          CBUS_REG_ADDR(STBM_CTL_O_3)
+#define STB_INT_STATUS (STB_CBUS_BASE + 0x23)
+#define P_STB_INT_STATUS                CBUS_REG_ADDR(STB_INT_STATUS)
+#define STB_INT_STATUS_2 (STB_CBUS_BASE + 0x73)
+#define P_STB_INT_STATUS_2              CBUS_REG_ADDR(STB_INT_STATUS_2)
+#define STB_INT_STATUS_3 (STB_CBUS_BASE + 0xc3)
+#define P_STB_INT_STATUS_3              CBUS_REG_ADDR(STB_INT_STATUS_3)
+#define DEMUX_ENDIAN (STB_CBUS_BASE + 0x24)
+#define P_DEMUX_ENDIAN          CBUS_REG_ADDR(DEMUX_ENDIAN)
+#define DEMUX_ENDIAN_2 (STB_CBUS_BASE + 0x74)
+#define P_DEMUX_ENDIAN_2                CBUS_REG_ADDR(DEMUX_ENDIAN_2)
+#define DEMUX_ENDIAN_3 (STB_CBUS_BASE + 0xc4)
+#define P_DEMUX_ENDIAN_3                CBUS_REG_ADDR(DEMUX_ENDIAN_3)
+#define TS_HIU_CTL (STB_CBUS_BASE + 0x25)
+#define P_TS_HIU_CTL            CBUS_REG_ADDR(TS_HIU_CTL)
+#define TS_HIU_CTL_2 (STB_CBUS_BASE + 0x75)
+#define P_TS_HIU_CTL_2          CBUS_REG_ADDR(TS_HIU_CTL_2)
+#define TS_HIU_CTL_3 (STB_CBUS_BASE + 0xc5)
+#define P_TS_HIU_CTL_3          CBUS_REG_ADDR(TS_HIU_CTL_3)
+
+#define SEC_BUFF_BASE (STB_CBUS_BASE + 0x26)
+#define P_SEC_BUFF_BASE                 CBUS_REG_ADDR(SEC_BUFF_BASE)
+#define SEC_BUFF_BASE_2 (STB_CBUS_BASE + 0x76)
+#define P_SEC_BUFF_BASE_2               CBUS_REG_ADDR(SEC_BUFF_BASE_2)
+#define SEC_BUFF_BASE_3 (STB_CBUS_BASE + 0xc6)
+#define P_SEC_BUFF_BASE_3               CBUS_REG_ADDR(SEC_BUFF_BASE_3)
+#define DEMUX_MEM_REQ_EN (STB_CBUS_BASE + 0x27)
+#define P_DEMUX_MEM_REQ_EN              CBUS_REG_ADDR(DEMUX_MEM_REQ_EN)
+#define DEMUX_MEM_REQ_EN_2 (STB_CBUS_BASE + 0x77)
+#define P_DEMUX_MEM_REQ_EN_2            CBUS_REG_ADDR(DEMUX_MEM_REQ_EN_2)
+#define DEMUX_MEM_REQ_EN_3 (STB_CBUS_BASE + 0xc7)
+#define P_DEMUX_MEM_REQ_EN_3            CBUS_REG_ADDR(DEMUX_MEM_REQ_EN_3)
+
+
+/*no use*/
+#define VIDEO_PDTS_WR_PTR (STB_CBUS_BASE + 0x28)
+#define P_VIDEO_PDTS_WR_PTR             CBUS_REG_ADDR(VIDEO_PDTS_WR_PTR)
+#define VIDEO_PDTS_WR_PTR_2 (STB_CBUS_BASE + 0x78)
+#define P_VIDEO_PDTS_WR_PTR_2           CBUS_REG_ADDR(VIDEO_PDTS_WR_PTR_2)
+#define VIDEO_PDTS_WR_PTR_3 (STB_CBUS_BASE + 0xc8)
+#define P_VIDEO_PDTS_WR_PTR_3           CBUS_REG_ADDR(VIDEO_PDTS_WR_PTR_3)
+#define AUDIO_PDTS_WR_PTR (STB_CBUS_BASE + 0x29)
+#define P_AUDIO_PDTS_WR_PTR             CBUS_REG_ADDR(AUDIO_PDTS_WR_PTR)
+#define AUDIO_PDTS_WR_PTR_2 (STB_CBUS_BASE + 0x79)
+#define P_AUDIO_PDTS_WR_PTR_2           CBUS_REG_ADDR(AUDIO_PDTS_WR_PTR_2)
+#define AUDIO_PDTS_WR_PTR_3 (STB_CBUS_BASE + 0xc9)
+#define P_AUDIO_PDTS_WR_PTR_3           CBUS_REG_ADDR(AUDIO_PDTS_WR_PTR_3)
+#define SUB_WR_PTR (STB_CBUS_BASE + 0x2a)
+#define P_SUB_WR_PTR            CBUS_REG_ADDR(SUB_WR_PTR)
+#define SUB_WR_PTR_2 (STB_CBUS_BASE + 0x7a)
+#define P_SUB_WR_PTR_2          CBUS_REG_ADDR(SUB_WR_PTR_2)
+#define SUB_WR_PTR_3 (STB_CBUS_BASE + 0xca)
+#define P_SUB_WR_PTR_3          CBUS_REG_ADDR(SUB_WR_PTR_3)
+/*no use*/
+
+#define SB_START (STB_CBUS_BASE + 0x2b)
+#define P_SB_START              CBUS_REG_ADDR(SB_START)
+#define SB_START_2 (STB_CBUS_BASE + 0x7b)
+#define P_SB_START_2            CBUS_REG_ADDR(SB_START_2)
+#define SB_START_3 (STB_CBUS_BASE + 0xcb)
+#define P_SB_START_3            CBUS_REG_ADDR(SB_START_3)
+#define SB_LAST_ADDR (STB_CBUS_BASE + 0x2c)
+#define P_SB_LAST_ADDR          CBUS_REG_ADDR(SB_LAST_ADDR)
+#define SB_LAST_ADDR_2 (STB_CBUS_BASE + 0x7c)
+#define P_SB_LAST_ADDR_2                CBUS_REG_ADDR(SB_LAST_ADDR_2)
+#define SB_LAST_ADDR_3 (STB_CBUS_BASE + 0xcc)
+#define P_SB_LAST_ADDR_3                CBUS_REG_ADDR(SB_LAST_ADDR_3)
+#define SB_PES_WR_PTR (STB_CBUS_BASE + 0x2d)
+#define P_SB_PES_WR_PTR                 CBUS_REG_ADDR(SB_PES_WR_PTR)
+#define SB_PES_WR_PTR_2 (STB_CBUS_BASE + 0x7d)
+#define P_SB_PES_WR_PTR_2               CBUS_REG_ADDR(SB_PES_WR_PTR_2)
+#define SB_PES_WR_PTR_3 (STB_CBUS_BASE + 0xcd)
+#define P_SB_PES_WR_PTR_3               CBUS_REG_ADDR(SB_PES_WR_PTR_3)
+#define OTHER_WR_PTR (STB_CBUS_BASE + 0x2e)
+#define P_OTHER_WR_PTR          CBUS_REG_ADDR(OTHER_WR_PTR)
+#define OTHER_WR_PTR_2 (STB_CBUS_BASE + 0x7e)
+#define P_OTHER_WR_PTR_2                CBUS_REG_ADDR(OTHER_WR_PTR_2)
+#define OTHER_WR_PTR_3 (STB_CBUS_BASE + 0xce)
+#define P_OTHER_WR_PTR_3                CBUS_REG_ADDR(OTHER_WR_PTR_3)
+
+#define OB_START (STB_CBUS_BASE + 0x2f)
+#define P_OB_START              CBUS_REG_ADDR(OB_START)
+#define OB_START_2 (STB_CBUS_BASE + 0x7f)
+#define P_OB_START_2            CBUS_REG_ADDR(OB_START_2)
+#define OB_START_3 (STB_CBUS_BASE + 0xcf)
+#define P_OB_START_3            CBUS_REG_ADDR(OB_START_3)
+#define OB_LAST_ADDR (STB_CBUS_BASE + 0x30)
+#define P_OB_LAST_ADDR          CBUS_REG_ADDR(OB_LAST_ADDR)
+#define OB_LAST_ADDR_2 (STB_CBUS_BASE + 0x80)
+#define P_OB_LAST_ADDR_2                CBUS_REG_ADDR(OB_LAST_ADDR_2)
+#define OB_LAST_ADDR_3 (STB_CBUS_BASE + 0xd0)
+#define P_OB_LAST_ADDR_3                CBUS_REG_ADDR(OB_LAST_ADDR_3)
+#define OB_PES_WR_PTR (STB_CBUS_BASE + 0x31)
+#define P_OB_PES_WR_PTR                 CBUS_REG_ADDR(OB_PES_WR_PTR)
+#define OB_PES_WR_PTR_2 (STB_CBUS_BASE + 0x81)
+#define P_OB_PES_WR_PTR_2               CBUS_REG_ADDR(OB_PES_WR_PTR_2)
+#define OB_PES_WR_PTR_3 (STB_CBUS_BASE + 0xd1)
+#define P_OB_PES_WR_PTR_3               CBUS_REG_ADDR(OB_PES_WR_PTR_3)
+#define STB_INT_MASK (STB_CBUS_BASE + 0x32)
+#define P_STB_INT_MASK          CBUS_REG_ADDR(STB_INT_MASK)
+#define STB_INT_MASK_2 (STB_CBUS_BASE + 0x82)
+#define P_STB_INT_MASK_2                CBUS_REG_ADDR(STB_INT_MASK_2)
+#define STB_INT_MASK_3 (STB_CBUS_BASE + 0xd2)
+#define P_STB_INT_MASK_3                CBUS_REG_ADDR(STB_INT_MASK_3)
+/*no used */
+#define VIDEO_SPLICING_CTL (STB_CBUS_BASE + 0x33)
+#define P_VIDEO_SPLICING_CTL            CBUS_REG_ADDR(VIDEO_SPLICING_CTL)
+#define VIDEO_SPLICING_CTL_2 (STB_CBUS_BASE + 0x83)
+#define P_VIDEO_SPLICING_CTL_2          CBUS_REG_ADDR(VIDEO_SPLICING_CTL_2)
+#define VIDEO_SPLICING_CTL_3 (STB_CBUS_BASE + 0xd3)
+#define P_VIDEO_SPLICING_CTL_3          CBUS_REG_ADDR(VIDEO_SPLICING_CTL_3)
+#define AUDIO_SPLICING_CTL (STB_CBUS_BASE + 0x34)
+#define P_AUDIO_SPLICING_CTL            CBUS_REG_ADDR(AUDIO_SPLICING_CTL)
+#define AUDIO_SPLICING_CTL_2 (STB_CBUS_BASE + 0x84)
+#define P_AUDIO_SPLICING_CTL_2          CBUS_REG_ADDR(AUDIO_SPLICING_CTL_2)
+#define AUDIO_SPLICING_CTL_3 (STB_CBUS_BASE + 0xd4)
+#define P_AUDIO_SPLICING_CTL_3          CBUS_REG_ADDR(AUDIO_SPLICING_CTL_3)
+#define TS_PACKAGE_BYTE_COUNT (STB_CBUS_BASE + 0x35)
+#define P_TS_PACKAGE_BYTE_COUNT                 \
+	CBUS_REG_ADDR(TS_PACKAGE_BYTE_COUNT)
+#define TS_PACKAGE_BYTE_COUNT_2 (STB_CBUS_BASE + 0x85)
+#define P_TS_PACKAGE_BYTE_COUNT_2               \
+	CBUS_REG_ADDR(TS_PACKAGE_BYTE_COUNT_2)
+#define TS_PACKAGE_BYTE_COUNT_3 (STB_CBUS_BASE + 0xd5)
+#define P_TS_PACKAGE_BYTE_COUNT_3               \
+	CBUS_REG_ADDR(TS_PACKAGE_BYTE_COUNT_3)
+/*no used end*/
+
+#define PES_STRONG_SYNC (STB_CBUS_BASE + 0x36)
+#define P_PES_STRONG_SYNC               CBUS_REG_ADDR(PES_STRONG_SYNC)
+#define PES_STRONG_SYNC_2 (STB_CBUS_BASE + 0x86)
+#define P_PES_STRONG_SYNC_2             CBUS_REG_ADDR(PES_STRONG_SYNC_2)
+#define PES_STRONG_SYNC_3 (STB_CBUS_BASE + 0xd6)
+#define P_PES_STRONG_SYNC_3             CBUS_REG_ADDR(PES_STRONG_SYNC_3)
+
+#define OM_DATA_RD_ADDR (STB_CBUS_BASE + 0x37)
+#define P_OM_DATA_RD_ADDR               CBUS_REG_ADDR(OM_DATA_RD_ADDR)
+#define OM_DATA_RD_ADDR_2 (STB_CBUS_BASE + 0x87)
+#define P_OM_DATA_RD_ADDR_2             CBUS_REG_ADDR(OM_DATA_RD_ADDR_2)
+#define OM_DATA_RD_ADDR_3 (STB_CBUS_BASE + 0xd7)
+#define P_OM_DATA_RD_ADDR_3             CBUS_REG_ADDR(OM_DATA_RD_ADDR_3)
+#define OM_DATA_RD (STB_CBUS_BASE + 0x38)
+#define P_OM_DATA_RD            CBUS_REG_ADDR(OM_DATA_RD)
+#define OM_DATA_RD_2 (STB_CBUS_BASE + 0x88)
+#define P_OM_DATA_RD_2          CBUS_REG_ADDR(OM_DATA_RD_2)
+#define OM_DATA_RD_3 (STB_CBUS_BASE + 0xd8)
+#define P_OM_DATA_RD_3          CBUS_REG_ADDR(OM_DATA_RD_3)
+
+/*no used*/
+
+#define SECTION_AUTO_STOP_3 (STB_CBUS_BASE + 0x39)
+#define P_SECTION_AUTO_STOP_3           CBUS_REG_ADDR(SECTION_AUTO_STOP_3)
+#define SECTION_AUTO_STOP_3_2 (STB_CBUS_BASE + 0x89)
+#define P_SECTION_AUTO_STOP_3_2                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_3_2)
+#define SECTION_AUTO_STOP_3_3 (STB_CBUS_BASE + 0xd9)
+#define P_SECTION_AUTO_STOP_3_3                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_3_3)
+#define SECTION_AUTO_STOP_2 (STB_CBUS_BASE + 0x3a)
+#define P_SECTION_AUTO_STOP_2           \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_2)
+#define SECTION_AUTO_STOP_2_2 (STB_CBUS_BASE + 0x8a)
+#define P_SECTION_AUTO_STOP_2_2                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_2_2)
+#define SECTION_AUTO_STOP_2_3 (STB_CBUS_BASE + 0xda)
+#define P_SECTION_AUTO_STOP_2_3                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_2_3)
+#define SECTION_AUTO_STOP_1 (STB_CBUS_BASE + 0x3b)
+#define P_SECTION_AUTO_STOP_1           CBUS_REG_ADDR(SECTION_AUTO_STOP_1)
+#define SECTION_AUTO_STOP_1_2 (STB_CBUS_BASE + 0x8b)
+#define P_SECTION_AUTO_STOP_1_2                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_1_2)
+#define SECTION_AUTO_STOP_1_3 (STB_CBUS_BASE + 0xdb)
+#define P_SECTION_AUTO_STOP_1_3                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_1_3)
+#define SECTION_AUTO_STOP_0 (STB_CBUS_BASE + 0x3c)
+#define P_SECTION_AUTO_STOP_0           \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_0)
+#define SECTION_AUTO_STOP_0_2 (STB_CBUS_BASE + 0x8c)
+#define P_SECTION_AUTO_STOP_0_2                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_0_2)
+#define SECTION_AUTO_STOP_0_3 (STB_CBUS_BASE + 0xdc)
+#define P_SECTION_AUTO_STOP_0_3                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_0_3)
+
+#define DEMUX_CHANNEL_RESET (STB_CBUS_BASE + 0x3d)
+#define P_DEMUX_CHANNEL_RESET           \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_RESET)
+#define DEMUX_CHANNEL_RESET_2 (STB_CBUS_BASE + 0x8d)
+#define P_DEMUX_CHANNEL_RESET_2                 \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_RESET_2)
+#define DEMUX_CHANNEL_RESET_3 (STB_CBUS_BASE + 0xdd)
+#define P_DEMUX_CHANNEL_RESET_3                 \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_RESET_3)
+/*no use end*/
+#define DEMUX_SCRAMBLING_STATE (STB_CBUS_BASE + 0x3e)
+#define DEMUX_SCRAMBLING_STATE_2 (STB_CBUS_BASE + 0x8e)
+#define P_DEMUX_SCRAMBLING_STATE_2              \
+	CBUS_REG_ADDR(DEMUX_SCRAMBLING_STATE_2)
+#define DEMUX_SCRAMBLING_STATE_3 (STB_CBUS_BASE + 0xde)
+#define P_DEMUX_SCRAMBLING_STATE_3              \
+	CBUS_REG_ADDR(DEMUX_SCRAMBLING_STATE_3)
+#define DEMUX_CHANNEL_ACTIVITY (STB_CBUS_BASE + 0x3f)
+#define P_DEMUX_CHANNEL_ACTIVITY                \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_ACTIVITY)
+#define DEMUX_CHANNEL_ACTIVITY_2 (STB_CBUS_BASE + 0x8f)
+#define P_DEMUX_CHANNEL_ACTIVITY_2              \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_ACTIVITY_2)
+#define DEMUX_CHANNEL_ACTIVITY_3 (STB_CBUS_BASE + 0xdf)
+#define P_DEMUX_CHANNEL_ACTIVITY_3              \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_ACTIVITY_3)
+
+/*no use*/
+
+#define DEMUX_STAMP_CTL (STB_CBUS_BASE + 0x40)
+#define P_DEMUX_STAMP_CTL               CBUS_REG_ADDR(DEMUX_STAMP_CTL)
+#define DEMUX_STAMP_CTL_2 (STB_CBUS_BASE + 0x90)
+#define P_DEMUX_STAMP_CTL_2             \
+	CBUS_REG_ADDR(DEMUX_STAMP_CTL_2)
+#define DEMUX_STAMP_CTL_3 (STB_CBUS_BASE + 0xe0)
+#define P_DEMUX_STAMP_CTL_3             \
+	CBUS_REG_ADDR(DEMUX_STAMP_CTL_3)
+#define DEMUX_VIDEO_STAMP_SYNC_0 (STB_CBUS_BASE + 0x41)
+#define P_DEMUX_VIDEO_STAMP_SYNC_0              \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_0)
+#define DEMUX_VIDEO_STAMP_SYNC_0_2 (STB_CBUS_BASE + 0x91)
+#define P_DEMUX_VIDEO_STAMP_SYNC_0_2            \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_0_2)
+#define DEMUX_VIDEO_STAMP_SYNC_0_3 (STB_CBUS_BASE + 0xe1)
+#define P_DEMUX_VIDEO_STAMP_SYNC_0_3            \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_0_3)
+#define DEMUX_VIDEO_STAMP_SYNC_1 (STB_CBUS_BASE + 0x42)
+#define P_DEMUX_VIDEO_STAMP_SYNC_1              \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_1)
+#define DEMUX_VIDEO_STAMP_SYNC_1_2 (STB_CBUS_BASE + 0x92)
+#define P_DEMUX_VIDEO_STAMP_SYNC_1_2            \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_1_2)
+#define DEMUX_VIDEO_STAMP_SYNC_1_3 (STB_CBUS_BASE + 0xe2)
+#define P_DEMUX_VIDEO_STAMP_SYNC_1_3            \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_1_3)
+#define DEMUX_AUDIO_STAMP_SYNC_0 (STB_CBUS_BASE + 0x43)
+#define P_DEMUX_AUDIO_STAMP_SYNC_0              \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_0)
+#define DEMUX_AUDIO_STAMP_SYNC_0_2 (STB_CBUS_BASE + 0x93)
+#define P_DEMUX_AUDIO_STAMP_SYNC_0_2            \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_0_2)
+#define DEMUX_AUDIO_STAMP_SYNC_0_3 (STB_CBUS_BASE + 0xe3)
+#define P_DEMUX_AUDIO_STAMP_SYNC_0_3            \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_0_3)
+#define DEMUX_AUDIO_STAMP_SYNC_1 (STB_CBUS_BASE + 0x44)
+#define P_DEMUX_AUDIO_STAMP_SYNC_1              \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_1)
+#define DEMUX_AUDIO_STAMP_SYNC_1_2 (STB_CBUS_BASE + 0x94)
+#define P_DEMUX_AUDIO_STAMP_SYNC_1_2            \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_1_2)
+#define DEMUX_AUDIO_STAMP_SYNC_1_3 (STB_CBUS_BASE + 0xe4)
+#define P_DEMUX_AUDIO_STAMP_SYNC_1_3            \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_1_3)
+#define DEMUX_SECTION_RESET (STB_CBUS_BASE + 0x45)
+#define P_DEMUX_SECTION_RESET           CBUS_REG_ADDR(DEMUX_SECTION_RESET)
+#define DEMUX_SECTION_RESET_2 (STB_CBUS_BASE + 0x95)
+#define P_DEMUX_SECTION_RESET_2                 \
+	CBUS_REG_ADDR(DEMUX_SECTION_RESET_2)
+#define DEMUX_SECTION_RESET_3 (STB_CBUS_BASE + 0xe5)
+#define P_DEMUX_SECTION_RESET_3                 \
+	CBUS_REG_ADDR(DEMUX_SECTION_RESET_3)
+/*no use end*/
+
+/*from c_stb_define.h*/
+#define COMM_DESC_2_CTL     (STB_CBUS_BASE + 0xff) /*0x16ff*/
+
+#define STB_OM_CTL \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x22) /* 0x1622*/
+#define STB_OM_CTL_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x22) /* 0x1672*/
+#define STB_OM_CTL_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x22) /* 0x16c2*/
+
+#define DEMUX_INPUT_TIMEOUT_C   \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x46)         /* 0x1646*/
+#define DEMUX_INPUT_TIMEOUT_C_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x46)         /* 0x1696*/
+#define DEMUX_INPUT_TIMEOUT_C_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x46)         /* 0x16e6*/
+/* bit[31] - no_match_reset_timeout_disable*/
+/* bit[30:0] input_time_out_int_cnt (0 -- means disable) Wr-setting, Rd-count*/
+#define DEMUX_INPUT_TIMEOUT     \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x47)         /* 0x1647*/
+#define DEMUX_INPUT_TIMEOUT_2   \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x47)         /* 0x1697*/
+#define DEMUX_INPUT_TIMEOUT_3   \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x47)         /* 0x16e7*/
+
+/* bit[31:0] - channel_packet_count_disable*/
+#define DEMUX_PACKET_COUNT_C    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x48)         /* 0x1648*/
+#define DEMUX_PACKET_COUNT_C_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x48)         /* 0x1698*/
+#define DEMUX_PACKET_COUNT_C_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x48)         /* 0x16e8*/
+/* bit[31] - no_match_packet_count_disable*/
+/* bit[30:0] input_packet_count*/
+#define DEMUX_PACKET_COUNT      \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x49)         /* 0x1649*/
+#define DEMUX_PACKET_COUNT_2    \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x49)         /* 0x1699*/
+#define DEMUX_PACKET_COUNT_3    \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x49)         /* 0x16e9*/
+
+/* bit[31:0] channel_record_enable*/
+#define DEMUX_CHAN_RECORD_EN    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4a)         /* 0x164a*/
+#define DEMUX_CHAN_RECORD_EN_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4a)         /* 0x169a*/
+#define DEMUX_CHAN_RECORD_EN_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4a)         /* 0x16ea*/
+
+/* bit[31:0] channel_process_enable*/
+#define DEMUX_CHAN_PROCESS_EN   \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4b)         /* 0x164b*/
+#define DEMUX_CHAN_PROCESS_EN_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4b)         /* 0x169b*/
+#define DEMUX_CHAN_PROCESS_EN_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4b)         /* 0x16eb*/
+
+/* bit[31:24] small_sec_size ((n+1) * 256 Bytes)*/
+/* bit[23:16] small_sec_rd_ptr */
+/* bit[15:8]  small_sec_wr_ptr */
+/* bit[7:2]   reserved*/
+/* bit[1] small_sec_wr_ptr_wr_enable*/
+/* bit[0] small_section_enable*/
+#define DEMUX_SMALL_SEC_CTL     \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4c)         /* 0x164c*/
+#define DEMUX_SMALL_SEC_CTL_2   \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4c)         /* 0x169c*/
+#define DEMUX_SMALL_SEC_CTL_3   \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4c)         /* 0x16ec*/
+/* bit[31:0] small_sec_start_addr*/
+#define DEMUX_SMALL_SEC_ADDR    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4d)         /* 0x164d*/
+#define DEMUX_SMALL_SEC_ADDR_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4d)         /* 0x169d*/
+#define DEMUX_SMALL_SEC_ADDR_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4d)         /* 0x16ed*/
+
+#endif
diff --git a/drivers/stream_input/parser/demux/hw_demux/demod_gt.h b/drivers/stream_input/parser/demux/hw_demux/demod_gt.h
new file mode 100644
index 0000000..729257b
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/demod_gt.h
@@ -0,0 +1,65 @@
+#ifndef __AML_DEMOD_GT_H__
+#define __AML_DEMOD_GT_H__
+
+#include  "dvb_frontend.h"
+
+struct amlfe_exp_config {
+	/*config by aml_fe ?*/
+	/* */
+	int set_mode;
+};
+
+struct amlfe_demod_config {
+	int	dev_id;
+	u32 ts;
+	struct i2c_adapter *i2c_adap;
+	int i2c_addr;
+	int	reset_gpio;
+	int	reset_value;
+};
+
+/* For configure different tuners */
+/* It can add fields as extensions */
+struct tuner_config {
+	u8 id;
+	u8 i2c_addr;
+	u8 xtal; /* 0: 16MHz, 1: 24MHz, 3: 27MHz */
+	u8 xtal_cap;
+	u8 xtal_mode;
+};
+
+static inline struct dvb_frontend* aml_dtvdm_attach (const struct amlfe_exp_config *config) {
+	return NULL;
+}
+
+static inline struct dvb_frontend* si2151_attach (struct dvb_frontend *fe,struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* mxl661_attach (struct dvb_frontend *fe,struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* si2159_attach (struct dvb_frontend *fe,struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+    return NULL;
+}
+
+static inline struct dvb_frontend* r842_attach (struct dvb_frontend *fe, struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+    return NULL;
+}
+
+static inline struct dvb_frontend* r840_attach (struct dvb_frontend *fe, struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+    return NULL;
+}
+
+static inline struct dvb_frontend* atbm8881_attach (const struct amlfe_demod_config *config)
+{
+	return NULL;
+}
+
+#endif	/*__AML_DEMOD_GT_H__*/
diff --git a/drivers/stream_input/parser/demux/hw_demux/dvb_reg.h b/drivers/stream_input/parser/demux/hw_demux/dvb_reg.h
new file mode 100644
index 0000000..dbfa6ba
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/dvb_reg.h
@@ -0,0 +1,58 @@
+/*
+ * drivers/amlogic/dvb_tv/dvb_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _DVB_REG_H_
+#define _DVB_REG_H_
+
+#include <linux/amlogic/iomap.h>
+
+#include <linux/amlogic/cpu_version.h>
+
+#define ID_STB_CBUS_BASE		0
+#define ID_SMARTCARD_REG_BASE		1
+#define ID_ASYNC_FIFO_REG_BASE		2
+#define ID_ASYNC_FIFO1_REG_BASE		3
+#define ID_ASYNC_FIFO2_REG_BASE	4
+#define ID_RESET_BASE			5
+#define ID_PARSER_SUB_START_PTR_BASE	6
+
+long aml_stb_get_base(int id);
+#include "c_stb_define.h"
+#include "c_stb_regs_define.h"
+
+#define WRITE_MPEG_REG(_r, _v)   aml_write_cbus(_r, _v)
+#define READ_MPEG_REG(_r)        aml_read_cbus(_r)
+
+#define WRITE_CBUS_REG(_r, _v)   aml_write_cbus(_r, _v)
+#define READ_CBUS_REG(_r)        aml_read_cbus(_r)
+
+#define WRITE_VCBUS_REG(_r, _v)  aml_write_vcbus(_r, _v)
+#define READ_VCBUS_REG(_r)       aml_read_vcbus(_r)
+
+#define BASE_IRQ 32
+#define AM_IRQ(reg)             (reg + BASE_IRQ)
+#define INT_DEMUX               AM_IRQ(23)
+#define INT_DEMUX_1             AM_IRQ(5)
+#define INT_DEMUX_2             AM_IRQ(21) //AM_IRQ(53)
+#define INT_ASYNC_FIFO_FILL     AM_IRQ(18)
+#define INT_ASYNC_FIFO_FLUSH    AM_IRQ(19)
+#define INT_ASYNC_FIFO2_FILL    AM_IRQ(24)
+#define INT_ASYNC_FIFO2_FLUSH   AM_IRQ(25)
+
+#define INT_ASYNC_FIFO3_FLUSH   AM_IRQ(17)
+#endif
+
diff --git a/drivers/stream_input/parser/demux/hw_demux/frontend.c b/drivers/stream_input/parser/demux/hw_demux/frontend.c
new file mode 100644
index 0000000..2e40179
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/frontend.c
@@ -0,0 +1,519 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+//#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/string.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/reset.h>
+#include <linux/amlogic/media/utils/amstream.h>
+//#include <linux/clk.h>
+#include "c_stb_define.h"
+#include "c_stb_regs_define.h"
+#include "../aml_dvb.h"
+#include "dvb_reg.h"
+
+#include "../../../tv_frontend/aml_fe.h"
+#include "demod_gt.h"
+#include "../../../../common/media_clock/switch/amports_gate.h"
+
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+#define pr_inf(fmt, args...)   printk("DVB: " fmt, ## args)
+
+typedef enum __demod_type
+{
+	DEMOD_INVALID,
+	DEMOD_INTERNAL,
+	DEMOD_ATBM8881,
+	DEMOD_MAX_NUM
+}demod_type;
+
+typedef enum __tuner_type
+{
+	TUNER_INVALID,
+	TUNER_SI2151,
+	TUNER_MXL661,
+	TUNER_SI2159,
+	TUNER_R842,
+	TUNER_R840,
+	TUNER_MAX_NUM
+}tuner_type;
+
+static struct dvb_frontend *frontend[FE_DEV_COUNT] = {NULL, NULL};
+static demod_type s_demod_type[FE_DEV_COUNT] = {DEMOD_INVALID, DEMOD_INVALID};
+static tuner_type s_tuner_type[FE_DEV_COUNT] = {TUNER_INVALID, TUNER_INVALID};
+
+static int dvb_attach_tuner(struct dvb_frontend *fe, struct aml_tuner *tuner, tuner_type *type)
+{
+	struct tuner_config *cfg = &tuner->cfg;
+	struct i2c_adapter *i2c_adap = tuner->i2c_adp;
+
+	switch (cfg->id) {
+	case AM_TUNER_R840:
+		if (!dvb_attach(r840_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach r840_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("r840_attach  attach sucess\n");
+			*type = TUNER_R840;
+		}
+		break;
+	case AM_TUNER_R842:
+		if (!dvb_attach(r842_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach r842_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("r842_attach  attach sucess\n");
+			*type = TUNER_R842;
+		}
+		break;
+	case AM_TUNER_SI2151:
+		if (!dvb_attach(si2151_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("si2151 attach sucess\n");
+			*type = TUNER_SI2151;
+		}
+		break;
+	case AM_TUNER_SI2159:
+		if (!dvb_attach(si2159_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach si2159_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("si2159_attach  attach sucess\n");
+			*type = TUNER_SI2159;
+		}
+		break;
+	case AM_TUNER_MXL661:
+		if (!dvb_attach(mxl661_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach mxl661_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("mxl661_attach  attach sucess\n");
+			*type = TUNER_MXL661;
+		}
+		break;
+	default:
+		pr_error("can't support tuner type: %d\n", cfg->id);
+		break;
+	}
+
+	return 0;
+}
+
+ssize_t stb_show_tuner_setting(struct class *class,
+				   struct class_attribute *attr, char *buf)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+
+	if (dvb->tuner_cur >= 0)
+		pr_inf("dvb current attatch tuner %d, id: %d\n",
+				dvb->tuner_cur, dvb->tuners[dvb->tuner_cur].cfg.id);
+	else
+		pr_inf("dvb has no attatch tuner.\n");
+
+	return 0;
+}
+
+ssize_t stb_store_tuner_setting(struct class *class,
+				    struct class_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int n = 0, i = 0, val = 0;
+	unsigned long tmp = 0;
+	char *buf_orig = NULL, *ps = NULL, *token = NULL;
+	char *parm[4] = { NULL };
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	int tuner_id = 0;
+	struct aml_tuner *tuner = NULL;
+
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	ps = buf_orig;
+
+	while (1) {
+		token = strsep(&ps, "\n ");
+		if (token == NULL)
+			break;
+		if (*token == '\0')
+			continue;
+		parm[n++] = token;
+	}
+
+	if (parm[0] && kstrtoul(parm[0], 10, &tmp) == 0) {
+		val = tmp;
+
+		for (i = 0; i < dvb->tuner_num; ++i) {
+			if (dvb->tuners[i].cfg.id == val) {
+				tuner_id = dvb->tuners[i].cfg.id;
+				break;
+			}
+		}
+
+		if (tuner_id == 0 || dvb->tuner_cur == i) {
+			pr_error("%s: set nonsupport or the same tuner %d.\n",
+					__func__, val);
+			goto EXIT;
+		}
+
+		dvb->tuner_cur = i;
+
+		for (i = 0; i < FE_DEV_COUNT; i++) {
+			tuner = &dvb->tuners[dvb->tuner_cur];
+
+			if (frontend[i] == NULL)
+				continue;
+
+			if (dvb_attach_tuner(frontend[i], tuner, &s_tuner_type[i]) < 0) {
+				pr_error("attach tuner %d failed\n", dvb->tuner_cur);
+				goto EXIT;
+			}
+		}
+
+		pr_error("%s: attach tuner %d done.\n", __func__, dvb->tuners[dvb->tuner_cur].cfg.id);
+	}
+
+EXIT:
+
+	return count;
+}
+
+
+int frontend_probe(struct platform_device *pdev)
+{
+	struct amlfe_exp_config config;
+	char buf[32];
+	const char *str = NULL;
+	struct device_node *node_tuner = NULL;
+	struct device_node *node_i2c = NULL;
+	u32 i2c_addr = 0xFFFFFFFF;
+	struct tuner_config *cfg = NULL;
+	u32 value = 0;
+	int i = 0;
+	int ret =0;
+	int j = 0;
+	struct aml_dvb *advb = aml_get_dvb_device();
+
+	for (i=0; i<FE_DEV_COUNT; i++) {
+		memset(buf, 0, 32);
+		snprintf(buf, sizeof(buf), "fe%d_mode", i);
+		ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+		if (ret) {
+			continue;
+		}
+		if (!strcmp(str,"internal"))
+		{
+			config.set_mode = 0;
+			frontend[i] = dvb_attach(aml_dtvdm_attach,&config);
+			if (frontend[i] == NULL) {
+				pr_error("dvb attach demod error\n");
+				goto error_fe;
+			} else {
+				pr_inf("dtvdemod attatch sucess\n");
+				s_demod_type[i] = DEMOD_INTERNAL;
+			}
+
+			memset(&cfg, 0, sizeof(struct tuner_config));
+			memset(buf, 0, 32);
+			snprintf(buf, sizeof(buf), "fe%d_tuner",i);
+			node_tuner = of_parse_phandle(pdev->dev.of_node, buf, 0);
+			if (!node_tuner){
+				pr_err("can't find tuner.\n");
+				goto error_fe;
+			}
+			ret = of_property_read_u32(node_tuner, "tuner_num", &value);
+			if (ret) {
+				pr_err("can't find tuner_num.\n");
+				goto error_fe;
+			} else
+				advb->tuner_num = value;
+
+			advb->tuners = kzalloc(sizeof(struct aml_tuner) * advb->tuner_num, GFP_KERNEL);
+			if (!advb->tuners) {
+				pr_err("can't kzalloc for tuners.\n");
+				goto error_fe;
+			}
+
+			ret = of_property_read_u32(node_tuner, "tuner_cur", &value);
+			if (ret) {
+				pr_err("can't find tuner_cur, use default 0.\n");
+				advb->tuner_cur = -1;
+			} else
+				advb->tuner_cur = value;
+
+			for (j = 0; j < advb->tuner_num; ++j) {
+				snprintf(buf, sizeof(buf), "tuner_name_%d", j);
+				ret = of_property_read_string(node_tuner, buf, &str);
+				if (ret) {
+					//pr_error("tuner%d type error\n",i);
+					ret = 0;
+					continue;
+				} else {
+					if (!strncmp(str, "mxl661_tuner", 12))
+						advb->tuners[j].cfg.id = AM_TUNER_MXL661;
+					else if (!strncmp(str, "si2151_tuner", 12))
+						advb->tuners[j].cfg.id = AM_TUNER_SI2151;
+					else if (!strncmp(str, "si2159_tuner", 12))
+						advb->tuners[j].cfg.id = AM_TUNER_SI2159;
+					else if (!strncmp(str, "r840_tuner", 10))
+						advb->tuners[j].cfg.id = AM_TUNER_R840;
+					else if (!strncmp(str, "r842_tuner", 10))
+						advb->tuners[j].cfg.id = AM_TUNER_R842;
+					else {
+						pr_err("nonsupport tuner: %s.\n", str);
+						advb->tuners[j].cfg.id = AM_TUNER_NONE;
+					}
+				}
+
+				snprintf(buf, sizeof(buf), "tuner_i2c_adap_%d", j);
+				node_i2c = of_parse_phandle(node_tuner, buf, 0);
+				if (!node_i2c) {
+					pr_error("tuner_i2c_adap_id error\n");
+				} else {
+					advb->tuners[j].i2c_adp = of_find_i2c_adapter_by_node(node_i2c);
+					of_node_put(node_i2c);
+					if (advb->tuners[j].i2c_adp == NULL) {
+						pr_error("i2c_get_adapter error\n");
+						of_node_put(node_tuner);
+						goto error_fe;
+					}
+				}
+
+				snprintf(buf, sizeof(buf), "tuner_i2c_addr_%d", j);
+				ret = of_property_read_u32(node_tuner, buf, &i2c_addr);
+				if (ret) {
+					pr_error("i2c_addr error\n");
+				}
+				else
+					advb->tuners[j].cfg.i2c_addr = i2c_addr;
+
+				snprintf(buf, sizeof(buf), "tuner_xtal_%d", j);
+				ret = of_property_read_u32(node_tuner, buf, &value);
+				if (ret)
+					pr_err("tuner_xtal error.\n");
+				else
+					advb->tuners[j].cfg.xtal = value;
+
+				snprintf(buf, sizeof(buf), "tuner_xtal_mode_%d", j);
+				ret = of_property_read_u32(node_tuner, buf, &value);
+				if (ret)
+					pr_err("tuner_xtal_mode error.\n");
+				else
+					advb->tuners[j].cfg.xtal_mode = value;
+
+				snprintf(buf, sizeof(buf), "tuner_xtal_cap_%d", j);
+				ret = of_property_read_u32(node_tuner, buf, &value);
+				if (ret)
+					pr_err("tuner_xtal_cap error.\n");
+				else
+					advb->tuners[j].cfg.xtal_cap = value;
+			}
+
+			of_node_put(node_tuner);
+
+			/* define general-purpose callback pointer */
+			frontend[i]->callback = NULL;
+
+			if (advb->tuner_cur >= 0) {
+				if (dvb_attach_tuner(frontend[i], &advb->tuners[advb->tuner_cur], &s_tuner_type[i]) < 0) {
+					pr_error("attach tuner failed\n");
+					goto error_fe;
+				}
+			}
+
+			ret = dvb_register_frontend(&advb->dvb_adapter, frontend[i]);
+			if (ret) {
+				pr_error("register dvb frontend failed\n");
+				goto error_fe;
+			}
+		} else if(!strcmp(str,"external")) {
+			const char *name = NULL;
+			struct amlfe_demod_config config;
+
+			config.dev_id = i;
+			memset(buf, 0, 32);
+			snprintf(buf, sizeof(buf), "fe%d_demod",i);
+			ret = of_property_read_string(pdev->dev.of_node, buf, &name);
+			if (ret) {
+				ret = 0;
+				continue;
+			}
+
+			memset(buf, 0, 32);
+			snprintf(buf, sizeof(buf), "fe%d_i2c_adap_id",i);
+			node_i2c = of_parse_phandle(pdev->dev.of_node,buf,0);
+			if (!node_i2c) {
+				pr_error("demod%d_i2c_adap_id error\n", i);
+			} else {
+				config.i2c_adap = of_find_i2c_adapter_by_node(node_i2c);
+				of_node_put(node_i2c);
+				if (config.i2c_adap == NULL) {
+					pr_error("i2c_get_adapter error\n");
+					goto error_fe;
+				}
+			}
+
+			memset(buf, 0, 32);
+			snprintf(buf, sizeof(buf), "fe%d_demod_i2c_addr",i);
+			ret = of_property_read_u32(pdev->dev.of_node, buf,&config.i2c_addr);
+			if (ret) {
+				pr_error("i2c_addr error\n");
+				goto error_fe;
+			}
+
+			memset(buf, 0, 32);
+			snprintf(buf, sizeof(buf), "fe%d_ts",i);
+			ret = of_property_read_u32(pdev->dev.of_node, buf,&config.ts);
+			if (ret) {
+				pr_error("ts error\n");
+				goto error_fe;
+			}
+
+			memset(buf, 0, 32);
+			snprintf(buf, sizeof(buf), "fe%d_reset_gpio",i);
+			ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+			if (!ret) {
+				config.reset_gpio =
+				     of_get_named_gpio_flags(pdev->dev.of_node,
+				     buf, 0, NULL);
+				pr_inf("%s: %d\n", buf, config.reset_gpio);
+			} else {
+				config.reset_gpio = -1;
+				pr_error("cannot find resource \"%s\"\n", buf);
+				goto error_fe;
+			}
+
+			memset(buf, 0, 32);
+			snprintf(buf, sizeof(buf), "fe%d_reset_value",i);
+			ret = of_property_read_u32(pdev->dev.of_node, buf,&config.reset_value);
+			if (ret) {
+				pr_error("reset_value error\n");
+				goto error_fe;
+			}
+
+			if (!strcmp(name,"Atbm8881")) {
+				frontend[i] = dvb_attach(atbm8881_attach,&config);
+				if (frontend[i] == NULL) {
+					pr_error("dvb attach demod error\n");
+					goto error_fe;
+				} else {
+					pr_inf("dtvdemod attatch sucess\n");
+					s_demod_type[i] = DEMOD_ATBM8881;
+				}
+			}
+			if (frontend[i]) {
+				ret = dvb_register_frontend(&advb->dvb_adapter, frontend[i]);
+				if (ret) {
+					pr_error("register dvb frontend failed\n");
+					goto error_fe;
+				}
+			}
+		}
+	}
+	if (advb->tuners)
+		kfree(advb->tuners);
+	return 0;
+error_fe:
+	for (i=0; i<FE_DEV_COUNT; i++) {
+		if (s_demod_type[i] == DEMOD_INTERNAL) {
+			dvb_detach(aml_dtvdm_attach);
+			frontend[i] = NULL;
+			s_demod_type[i] = DEMOD_INVALID;
+		}else if (s_demod_type[i] == DEMOD_ATBM8881) {
+			dvb_detach(atbm8881_attach);
+			frontend[i] = NULL;
+			s_demod_type[i] = DEMOD_INVALID;
+		}
+		if (s_tuner_type[i] == TUNER_SI2151) {
+			dvb_detach(si2151_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}else if (s_tuner_type[i] == TUNER_MXL661) {
+			dvb_detach(mxl661_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}else if (s_tuner_type[i] == TUNER_SI2159) {
+			dvb_detach(si2159_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}else if (s_tuner_type[i] == TUNER_R842) {
+			dvb_detach(r842_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}else if (s_tuner_type[i] == TUNER_R840) {
+			dvb_detach(r840_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}
+	}
+
+	if (advb->tuners)
+		kfree(advb->tuners);
+
+	return 0;
+}
+
+int frontend_remove(void)
+{
+	int i;
+
+	for (i=0; i<FE_DEV_COUNT; i++) {
+		if (s_demod_type[i] == DEMOD_INTERNAL) {
+			dvb_detach(aml_dtvdm_attach);
+		}else if (s_demod_type[i] == DEMOD_ATBM8881) {
+			dvb_detach(atbm8881_attach);
+		}
+		if (s_tuner_type[i] == TUNER_SI2151) {
+			dvb_detach(si2151_attach);
+		}else if (s_tuner_type[i] == TUNER_MXL661) {
+			dvb_detach(mxl661_attach);
+		}else if (s_tuner_type[i] == TUNER_SI2159) {
+			dvb_detach(si2159_attach);
+		}else if (s_tuner_type[i] == TUNER_R842) {
+			dvb_detach(r842_attach);
+		}else if (s_tuner_type[i] == TUNER_R840) {
+			dvb_detach(r840_attach);
+		}
+
+		if (frontend[i] && \
+			( (s_tuner_type[i] == TUNER_SI2151) || (s_tuner_type[i] == TUNER_MXL661) || (s_tuner_type[i] == TUNER_SI2159) || (s_tuner_type[i] == TUNER_R842) || (s_tuner_type[i] == TUNER_R840)) \
+			)
+		{
+			dvb_unregister_frontend(frontend[i]);
+			dvb_frontend_detach(frontend[i]);
+		}
+		frontend[i] = NULL;
+		s_demod_type[i] = DEMOD_INVALID;
+		s_tuner_type[i] = TUNER_INVALID;
+
+	}
+	return 0;
+}
+
diff --git a/drivers/stream_input/parser/demux/hw_demux/frontend.h b/drivers/stream_input/parser/demux/hw_demux/frontend.h
new file mode 100644
index 0000000..c14f0d8
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/frontend.h
@@ -0,0 +1,26 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _FRONTEND_H_
+#define _FRONTEND_H_
+
+int frontend_probe(struct platform_device *pdev);
+int frontend_remove(void);
+
+#endif
diff --git a/drivers/stream_input/parser/demux/hw_demux/hwdemux.c b/drivers/stream_input/parser/demux/hw_demux/hwdemux.c
new file mode 100644
index 0000000..1577cb3
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/hwdemux.c
@@ -0,0 +1,1252 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/crc32.h>
+#include <linux/clk.h>
+
+#include <asm/uaccess.h>
+#include <asm/div64.h>
+
+//#include "c_stb_define.h"
+//#include "c_stb_regs_define.h"
+#include "dvb_reg.h"
+
+#include "../aml_dvb.h"
+#include "hwdemux.h"
+#include "hwdemux_internal.h"
+
+#include "s2p.h"
+#include "frontend.h"
+#include "asyncfifo.h"
+
+#define DEMUX_COUNT				  3
+#define USE_AHB_MODE
+
+#define CIPLUS_OUT_SEL    28
+#define CIPLUS_IN_SEL     26
+
+#define DMX_TYPE_TS  0
+#define DMX_TYPE_SEC 1
+#define DMX_TYPE_PES 2
+
+#define pr_dbg_flag(_f, _args...)\
+	do {\
+		if (debug_dmx &(_f))\
+			printk(_args);\
+	} while (0)
+#define pr_dbg_irq_flag(_f, _args...)\
+	do {\
+		if (debug_irq&(_f))\
+			printk(_args);\
+	} while (0)
+#define pr_dbg(args...)	pr_dbg_flag(0x1, args)
+
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+#define pr_inf(fmt, args...)   printk("DVB: " fmt, ## args)
+
+#define IS_SRC_DMX(_src) ((_src) >= AM_TS_SRC_DMX0 && (_src) <= AM_TS_SRC_DMX2)
+
+static int npids = CHANNEL_COUNT;
+#define MOD_PARAM_DECLARE_CHANPIDS(_dmx) \
+MODULE_PARM_DESC(debug_dmx##_dmx##_chanpids, "\n\t\t pids of dmx channels"); \
+static short debug_dmx##_dmx##_chanpids[CHANNEL_COUNT] = \
+					{[0 ... (CHANNEL_COUNT - 1)] = -1}; \
+module_param_array(debug_dmx##_dmx##_chanpids, short, &npids, 0444)
+
+MOD_PARAM_DECLARE_CHANPIDS(0);
+MOD_PARAM_DECLARE_CHANPIDS(1);
+MOD_PARAM_DECLARE_CHANPIDS(2);
+
+#define set_debug_dmx_chanpids(_dmx, _idx, _pid)\
+	do { \
+		if ((_dmx) == 0) \
+			debug_dmx0_chanpids[(_idx)] = (_pid); \
+		else if ((_dmx) == 1) \
+			debug_dmx1_chanpids[(_idx)] = (_pid); \
+		else if ((_dmx) == 2) \
+			debug_dmx2_chanpids[(_idx)] = (_pid); \
+	} while (0)
+
+static u32 old_stb_top_config;
+static u32 old_fec_input_control;
+static int have_old_stb_top_config = 1;
+static int have_old_fec_input_control = 1;
+static int dmx_count = 0;
+
+MODULE_PARM_DESC(disable_dsc, "\n\t\t Disable discrambler");
+static int disable_dsc;
+module_param(disable_dsc, int, 0644);
+
+static void
+_hwdmx_write_reg(int r, u32 v)
+{
+	u32 oldv, mask;
+
+	if (disable_dsc) {
+		if (r == STB_TOP_CONFIG) {
+			if (have_old_stb_top_config) {
+				oldv = old_stb_top_config;
+				have_old_stb_top_config = 0;
+			} else {
+				oldv = READ_MPEG_REG(STB_TOP_CONFIG);
+			}
+
+			mask = (1<<7)|(1<<15)|(3<<26)|(7<<28);
+			v	 &= ~mask;
+			v	 |= (oldv & mask);
+		} else if (r == FEC_INPUT_CONTROL) {
+			if (have_old_fec_input_control) {
+				oldv = old_fec_input_control;
+				have_old_fec_input_control = 0;
+			} else {
+				oldv = READ_MPEG_REG(FEC_INPUT_CONTROL);
+			}
+
+			mask = (1<<15);
+			v	&= ~mask;
+			v	|= (oldv & mask);
+		} else if ((r == RESET1_REGISTER) || (r == RESET3_REGISTER)) {
+			if (!have_old_stb_top_config) {
+				have_old_stb_top_config = 1;
+				old_stb_top_config =
+					READ_MPEG_REG(STB_TOP_CONFIG);
+			}
+			if (!have_old_fec_input_control) {
+				have_old_fec_input_control = 1;
+				old_fec_input_control =
+					READ_MPEG_REG(FEC_INPUT_CONTROL);
+			}
+		} else if ((r == TS_PL_PID_INDEX) || (r == TS_PL_PID_DATA)
+					|| (r == COMM_DESC_KEY0)
+					|| (r == COMM_DESC_KEY1)
+					|| (r == COMM_DESC_KEY_RW)
+					|| (r == CIPLUS_KEY0)
+					|| (r == CIPLUS_KEY1)
+					|| (r == CIPLUS_KEY2)
+					|| (r == CIPLUS_KEY3)
+					|| (r == CIPLUS_KEY_WR)
+					|| (r == CIPLUS_CONFIG)
+					|| (r == CIPLUS_ENDIAN)) {
+			return;
+		}
+	}
+
+	WRITE_MPEG_REG(r, v);
+}
+
+#undef WRITE_MPEG_REG
+#define WRITE_MPEG_REG(r, v) _hwdmx_write_reg(r, v)
+
+#define DMX_READ_REG(i, r)\
+			((i)?((i == 1)?READ_MPEG_REG(r##_2) :\
+			READ_MPEG_REG(r##_3)) : READ_MPEG_REG(r))
+
+#define DMX_WRITE_REG(i, r, d)\
+			do {\
+				if (i == 1) {\
+					WRITE_MPEG_REG(r##_2, d);\
+				} else if (i == 2) {\
+					WRITE_MPEG_REG(r##_3, d);\
+				} \
+				else {\
+					WRITE_MPEG_REG(r, d);\
+				} \
+			} while (0)
+
+#define DEMUX_INT_MASK\
+							((0<<(AUDIO_SPLICING_POINT))	|\
+							(0<<(VIDEO_SPLICING_POINT)) 	|\
+							(1<<(OTHER_PES_READY))			|\
+							(1<<(PCR_READY))				|\
+							(1<<(SUB_PES_READY))			|\
+							(1<<(SECTION_BUFFER_READY)) 	|\
+							(0<<(OM_CMD_READ_PENDING))		|\
+							(1<<(TS_ERROR_PIN)) 			|\
+							(1<<(NEW_PDTS_READY))			|\
+							(0<<(DUPLICATED_PACKET))		|\
+							(0<<(DIS_CONTINUITY_PACKET)))
+
+static struct clk *aml_dvb_demux_clk;
+static struct clk *aml_dvb_afifo_clk;
+static struct clk *aml_dvb_ahbarb0_clk;
+static struct clk *aml_dvb_uparsertop_clk;
+
+static int demux_skipbyte = 0;
+static int tsfile_clkdiv = 4;
+
+static HWDMX_Demux Demux[DEMUX_COUNT];
+static spinlock_t	slock;
+
+static int cbus_base = 0x1800;
+static int asyncfifo0_reg_base = 0x2800;
+static int asyncfifo1_reg_base = 0x9800;
+static int asyncfifo2_reg_base = 0x2400;
+static int reset_base = 0x0400;
+static int parser_sub_ptr_base = 0x3800;
+
+MODULE_PARM_DESC(debug_dmx, "\n\t\t Enable demux debug information");
+static int debug_dmx;
+module_param(debug_dmx, int, 0644);
+
+
+MODULE_PARM_DESC(use_of_sop, "\n\t\t Enable use of sop input");
+static int use_of_sop;
+module_param(use_of_sop, int, 0644);
+
+long aml_stb_get_base(int id)
+{
+	switch (id) {
+	case ID_STB_CBUS_BASE:
+		return cbus_base;
+	case ID_ASYNC_FIFO_REG_BASE:
+		return asyncfifo0_reg_base;
+	case ID_ASYNC_FIFO1_REG_BASE:
+		return asyncfifo1_reg_base;
+	case ID_ASYNC_FIFO2_REG_BASE:
+		return asyncfifo2_reg_base;
+	case ID_RESET_BASE:
+		return reset_base;
+	case ID_PARSER_SUB_START_PTR_BASE:
+		return parser_sub_ptr_base;
+	default:
+		return 0;
+	}
+	return 0;
+}
+
+static int _hwdmx_init_clk(struct platform_device *pdev){
+
+	aml_dvb_demux_clk =
+		devm_clk_get(&pdev->dev, "demux");
+	if (IS_ERR_OR_NULL(aml_dvb_demux_clk)) {
+		dev_err(&pdev->dev, "get demux clk fail\n");
+		return -1;
+	}
+	clk_prepare_enable(aml_dvb_demux_clk);
+
+	aml_dvb_afifo_clk =
+		devm_clk_get(&pdev->dev, "asyncfifo");
+	if (!IS_ERR_OR_NULL(aml_dvb_afifo_clk)) {
+		clk_prepare_enable(aml_dvb_afifo_clk);
+	}
+
+	aml_dvb_ahbarb0_clk =
+		devm_clk_get(&pdev->dev, "ahbarb0");
+	if (IS_ERR_OR_NULL(aml_dvb_ahbarb0_clk)) {
+		dev_err(&pdev->dev, "get ahbarb0 clk fail\n");
+		return -1;
+	}
+	clk_prepare_enable(aml_dvb_ahbarb0_clk);
+
+	aml_dvb_uparsertop_clk =
+		devm_clk_get(&pdev->dev, "uparsertop");
+	if (IS_ERR_OR_NULL(aml_dvb_uparsertop_clk)) {
+		dev_err(&pdev->dev, "get uparsertop clk fail\n");
+		return -1;
+	}
+	clk_prepare_enable(aml_dvb_uparsertop_clk);
+	return 0;
+}
+static int _hwdmx_release_clk(void) {
+
+	clk_disable_unprepare(aml_dvb_uparsertop_clk);
+	clk_disable_unprepare(aml_dvb_ahbarb0_clk);
+
+	if (!IS_ERR_OR_NULL(aml_dvb_afifo_clk))
+		clk_disable_unprepare(aml_dvb_afifo_clk);
+
+	clk_disable_unprepare(aml_dvb_demux_clk);
+	return 0;
+}
+static int _hwdmx_set_misc(HWDMX_Demux *pdmx, int hi_bsf, int en_dsc)
+{
+	if (!pdmx->init)
+		return 0;
+
+	if (hi_bsf >= 0) {
+		DMX_WRITE_REG(pdmx->id, TS_HIU_CTL,
+					hi_bsf ?
+					(DMX_READ_REG(pdmx->id, TS_HIU_CTL) |
+					(1 << USE_HI_BSF_INTERFACE))
+					:
+					(DMX_READ_REG(pdmx->id, TS_HIU_CTL) &
+					(~(1 << USE_HI_BSF_INTERFACE))));
+	}
+
+	if (en_dsc >= 0) {
+		DMX_WRITE_REG(pdmx->id, FEC_INPUT_CONTROL,
+				en_dsc ?
+				(DMX_READ_REG(pdmx->id, FEC_INPUT_CONTROL) |
+				(1 << FEC_CORE_SEL))
+				:
+				(DMX_READ_REG(pdmx->id, FEC_INPUT_CONTROL) &
+				(~(1 << FEC_CORE_SEL))));
+	}
+
+	return 0;
+}
+static int _hwdmx_enable(HWDMX_Demux *pdmx)
+{
+	int fec_sel = 0, hi_bsf=0, fec_ctrl = 0, record = 0;
+	int fec_core_sel = 0;
+	int set_stb = 0, fec_s = 0;
+	int s2p_id;
+	u32 invert0 = 0, invert1 = 0, invert2 = 0, fec_s0 = 0, fec_s1 = 0, fec_s2 = 0;
+	u32 use_sop = 0;
+
+	record = 1;
+	if (use_of_sop == 1) {
+		use_sop = 1;
+		pr_inf("dmx use of sop input\r\n");
+	}
+	switch (pdmx->dmx_source) {
+	case AM_TS_SRC_TS0:
+		fec_sel = 0;
+		fec_ctrl = pdmx->ts[0].control;
+		record = record ? 1 : 0;
+		break;
+	case AM_TS_SRC_TS1:
+		fec_sel = 1;
+		fec_ctrl = pdmx->ts[1].control;
+		record = record ? 1 : 0;
+		break;
+	case AM_TS_SRC_TS2:
+		fec_sel = 2;
+		fec_ctrl = pdmx->ts[2].control;
+		record = record ? 1 : 0;
+		break;
+	case AM_TS_SRC_S_TS0:
+	case AM_TS_SRC_S_TS1:
+	case AM_TS_SRC_S_TS2:
+		s2p_id = 0;
+		fec_ctrl = 0;
+		if (pdmx->dmx_source == AM_TS_SRC_S_TS0) {
+			s2p_id = pdmx->ts[0].s2p_id;
+			fec_ctrl = pdmx->ts[0].control;
+		} else if (pdmx->dmx_source == AM_TS_SRC_S_TS1) {
+			s2p_id = pdmx->ts[1].s2p_id;
+			fec_ctrl = pdmx->ts[1].control;
+		} else if (pdmx->dmx_source == AM_TS_SRC_S_TS2) {
+			s2p_id = pdmx->ts[2].s2p_id;
+			fec_ctrl = pdmx->ts[2].control;
+		}
+		//fec_sel = (s2p_id == 1) ? 5 : 6;
+		fec_sel = 6 - s2p_id;
+		record = record ? 1 : 0;
+		set_stb = 1;
+		fec_s = pdmx->dmx_source - AM_TS_SRC_S_TS0;
+		break;
+	case AM_TS_SRC_HIU:
+		fec_sel = 7;
+		fec_ctrl = 0;
+		/*
+			support record in HIU mode
+		record = 0;
+		*/
+		break;
+	default:
+		fec_sel = 0;
+		fec_ctrl = 0;
+		record = 0;
+		break;
+	}
+
+	if (pdmx->channel[0].used || pdmx->channel[1].used)
+		hi_bsf = 1;
+	else
+		hi_bsf = 0;
+
+	pr_dbg("[dmx-%d]src: %d, rec: %d, hi_bsf: %d, dsc: %d\n",
+		   pdmx->id, pdmx->dmx_source, record, hi_bsf, fec_core_sel);
+
+	if (pdmx->chan_count) {
+		if (set_stb) {
+			u32 v = READ_MPEG_REG(STB_TOP_CONFIG);
+			int i;
+
+			for (i = 0; i < pdmx->ts_in_total_count; i++) {
+				if (pdmx->ts[i].s2p_id == 0)
+					fec_s0 = i;
+				else if (pdmx->ts[i].s2p_id == 1)
+					fec_s1 = i;
+				else if (pdmx->ts[i].s2p_id == 2)
+					fec_s2 = i;
+			}
+
+			invert0 = pdmx->s2p[0].invert;
+			invert1 = pdmx->s2p[1].invert;
+
+			v &= ~((0x3 << S2P0_FEC_SERIAL_SEL) |
+				   (0x1f << INVERT_S2P0_FEC_CLK) |
+				   (0x3 << S2P1_FEC_SERIAL_SEL) |
+				   (0x1f << INVERT_S2P1_FEC_CLK));
+
+			v |= (fec_s0 << S2P0_FEC_SERIAL_SEL) |
+				(invert0 << INVERT_S2P0_FEC_CLK) |
+				(fec_s1 << S2P1_FEC_SERIAL_SEL) |
+				(invert1 << INVERT_S2P1_FEC_CLK);
+			WRITE_MPEG_REG(STB_TOP_CONFIG, v);
+
+			if (pdmx->s2p_total_count >= 3) {
+				invert2 = pdmx->s2p[2].invert;
+
+			//add s2p2 config
+			v = READ_MPEG_REG(STB_S2P2_CONFIG);
+			v &= ~((0x3 << S2P2_FEC_SERIAL_SEL) |
+				   (0x1f << INVERT_S2P2_FEC_CLK));
+				v |= (fec_s2 << S2P2_FEC_SERIAL_SEL) |
+				   (invert2 << INVERT_S2P2_FEC_CLK);
+				WRITE_MPEG_REG(STB_S2P2_CONFIG, v);
+			}
+		}
+
+		/*Initialize the registers */
+		DMX_WRITE_REG(pdmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+		DMX_WRITE_REG(pdmx->id, DEMUX_MEM_REQ_EN,
+#ifdef USE_AHB_MODE
+				  (1 << SECTION_AHB_DMA_EN) |
+				  (0 << SUB_AHB_DMA_EN) |
+				  (1 << OTHER_PES_AHB_DMA_EN) |
+#endif
+				  (1 << SECTION_PACKET) |
+				  (1 << VIDEO_PACKET) |
+				  (1 << AUDIO_PACKET) |
+				  (1 << SUB_PACKET) |
+				  (1 << SCR_ONLY_PACKET) |
+				(1 << OTHER_PES_PACKET));
+		DMX_WRITE_REG(pdmx->id, PES_STRONG_SYNC, 0x1234);
+		DMX_WRITE_REG(pdmx->id, DEMUX_ENDIAN,
+				  (1<<SEPERATE_ENDIAN) |
+				  (0<<OTHER_PES_ENDIAN) |
+				  (7<<SCR_ENDIAN) |
+				  (7<<SUB_ENDIAN) |
+				  (7<<AUDIO_ENDIAN) |
+				  (7<<VIDEO_ENDIAN) |
+				  (7 << OTHER_ENDIAN) |
+				  (7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
+		DMX_WRITE_REG(pdmx->id, TS_HIU_CTL,
+				  (0 << LAST_BURST_THRESHOLD) |
+				  (hi_bsf << USE_HI_BSF_INTERFACE));
+
+		DMX_WRITE_REG(pdmx->id, FEC_INPUT_CONTROL,
+				  (fec_core_sel << FEC_CORE_SEL) |
+				  (fec_sel << FEC_SEL) | (fec_ctrl << 0));
+		DMX_WRITE_REG(pdmx->id, STB_OM_CTL,
+				  (0x40 << MAX_OM_DMA_COUNT) |
+				  (0x7f << LAST_OM_ADDR));
+		DMX_WRITE_REG(pdmx->id, DEMUX_CONTROL,
+				  (0 << BYPASS_USE_RECODER_PATH) |
+				  (0 << INSERT_AUDIO_PES_STRONG_SYNC) |
+				  (0 << INSERT_VIDEO_PES_STRONG_SYNC) |
+				  (0 << OTHER_INT_AT_PES_BEGINING) |
+				  (0 << DISCARD_AV_PACKAGE) |
+				  ((!!pdmx->dump_ts_select) << TS_RECORDER_SELECT) |
+				  (record << TS_RECORDER_ENABLE) |
+				  (1 << KEEP_DUPLICATE_PACKAGE) |
+				  (1 << SECTION_END_WITH_TABLE_ID) |
+				  (1 << ENABLE_FREE_CLK_FEC_DATA_VALID) |
+				  (1 << ENABLE_FREE_CLK_STB_REG) |
+				  (1 << STB_DEMUX_ENABLE) |
+				  (use_sop << NOT_USE_OF_SOP_INPUT));
+	} else {
+		DMX_WRITE_REG(pdmx->id, STB_INT_MASK, 0);
+		DMX_WRITE_REG(pdmx->id, FEC_INPUT_CONTROL, 0);
+		DMX_WRITE_REG(pdmx->id, DEMUX_CONTROL, 0);
+	}
+
+	return 0;
+}
+/*Get the channel's target*/
+static u32 _hwdmx_get_chan_target(HWDMX_Demux *pdmx, int cid)
+{
+	u32 type;
+
+	if (!pdmx->channel[cid].used)
+		return 0xFFFF;
+
+	if (pdmx->channel[cid].type == DMX_TYPE_SEC) {
+		type = SECTION_PACKET;
+	} else {
+		switch (pdmx->channel[cid].pes_type) {
+		case DMX_PES_AUDIO:
+			type = AUDIO_PACKET;
+			break;
+		case DMX_PES_VIDEO:
+			type = VIDEO_PACKET;
+			break;
+		case DMX_PES_SUBTITLE:
+		case DMX_PES_TELETEXT:
+			type = SUB_PACKET;
+			break;
+		case DMX_PES_PCR:
+			type = SCR_ONLY_PACKET;
+			break;
+		default:
+			type = OTHER_PES_PACKET;
+			break;
+		}
+	}
+
+	pr_dbg("chan target: %x %x\n", type, pdmx->channel[cid].pid);
+	return (type << PID_TYPE) | pdmx->channel[cid].pid;
+}
+/*Get the advance value of the channel*/
+static inline u32 _hwdmx_get_chan_advance(HWDMX_Demux *pdmx, int cid)
+{
+	return 0;
+}
+
+
+/*Set the channel registers*/
+static int _hwdmx_set_chan_regs(HWDMX_Demux *pdmx, int cid)
+{
+	u32 data, addr, advance, max;
+
+	pr_dbg("set channel (id:%d PID:0x%x) registers\n", cid,
+	       pdmx->channel[cid].pid);
+
+	while (DMX_READ_REG(pdmx->id, FM_WR_ADDR) & 0x8000)
+		udelay(1);
+
+	if (cid & 1) {
+		data =
+		    (_hwdmx_get_chan_target(pdmx, cid - 1) << 16) |
+		    _hwdmx_get_chan_target(pdmx, cid);
+		advance =
+		    (_hwdmx_get_chan_advance(pdmx, cid) << 8) |
+		    _hwdmx_get_chan_advance(pdmx, cid - 1);
+	} else {
+		data =
+		    (_hwdmx_get_chan_target(pdmx, cid) << 16) |
+		    _hwdmx_get_chan_target(pdmx, cid + 1);
+		advance =
+		    (_hwdmx_get_chan_advance(pdmx, cid + 1) << 8) |
+		    _hwdmx_get_chan_advance(pdmx, cid);
+	}
+	addr = cid >> 1;
+	DMX_WRITE_REG(pdmx->id, FM_WR_DATA, data);
+	DMX_WRITE_REG(pdmx->id, FM_WR_ADDR, (advance << 16) | 0x8000 | addr);
+
+	pr_dbg("write fm %x:%x\n", (advance << 16) | 0x8000 | addr, data);
+
+	for (max = CHANNEL_COUNT - 1; max > 0; max--) {
+		if (pdmx->channel[max].used)
+			break;
+	}
+
+	data = DMX_READ_REG(pdmx->id, MAX_FM_COMP_ADDR) & 0xF0;
+	DMX_WRITE_REG(pdmx->id, MAX_FM_COMP_ADDR, data | (max >> 1));
+
+	pr_dbg("write fm comp %x\n", data | (max >> 1));
+
+	if (DMX_READ_REG(pdmx->id, OM_CMD_STATUS) & 0x8e00) {
+		pr_error("error send cmd %x\n",
+			 DMX_READ_REG(pdmx->id, OM_CMD_STATUS));
+	}
+
+	return 0;
+}
+/*Free a channel*/
+void _hwdmx_free_chan(HWDMX_Demux *pdmx, int cid)
+{
+	pr_dbg("free channel(id:%d PID:0x%x)\n", cid, pdmx->channel[cid].pid);
+
+	_hwdmx_set_chan_regs(pdmx, cid);
+	set_debug_dmx_chanpids(pdmx->id, cid, -1);
+	_hwdmx_enable(pdmx);
+}
+int _hwdmx_set_chan_pid(HWDMX_Demux *pdmx, int cid, int pid)
+{
+	_hwdmx_set_chan_regs(pdmx, cid);
+	set_debug_dmx_chanpids(pdmx->id, cid, pid);
+	_hwdmx_enable(pdmx);
+	return 0;
+}
+static void _hwdmx_init_chan(HWDMX_Demux *pdmx) {
+
+	memset(pdmx->channel,0,sizeof(pdmx->channel));
+}
+static int _hwdmx_enable_ts(HWDMX_Demux *pdmx)
+{
+	int out_src=0, des_in=0, en_des=0, fec_clk=0, hiu=0, dec_clk_en=0;
+//	int src=0, tso_src=0, i=0;
+	int src=0, i=0;
+	u32 fec_s0=0, fec_s1=0,fec_s2=0;
+	u32 invert0=0, invert1=0, invert2=0;
+//	u32 data = 0;
+
+	switch (pdmx->dmx_source) {
+	case AM_TS_SRC_TS0:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_TS1:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_TS2:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_TS3:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_S_TS0:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_S_TS1:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_S_TS2:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_HIU:
+		fec_clk = tsfile_clkdiv;
+		hiu = 1;
+		break;
+	default:
+		fec_clk = 0;
+		hiu = 0;
+		break;
+	}
+#if 0
+	switch (dvb->dsc[0].source) {
+	case AM_TS_SRC_DMX0:
+		des_in = 0;
+		en_des = 1;
+		dec_clk_en = 1;
+		break;
+	case AM_TS_SRC_DMX1:
+		des_in = 1;
+		en_des = 1;
+		dec_clk_en = 1;
+		break;
+	case AM_TS_SRC_DMX2:
+		des_in = 2;
+		en_des = 1;
+		dec_clk_en = 1;
+		break;
+	default:
+		des_in = 0;
+		en_des = 0;
+		dec_clk_en = 0;
+		break;
+	}
+
+	switch (dvb->tso_source) {
+	case AM_TS_SRC_DMX0:
+		tso_src = dvb->dmx[0].source;
+		break;
+	case AM_TS_SRC_DMX1:
+		tso_src = dvb->dmx[1].source;
+		break;
+	case AM_TS_SRC_DMX2:
+		tso_src = dvb->dmx[2].source;
+		break;
+	default:
+		tso_src = dvb->tso_source;
+		break;
+	}
+
+	switch (tso_src) {
+	case AM_TS_SRC_TS0:
+		out_src = 0;
+		break;
+	case AM_TS_SRC_TS1:
+		out_src = 1;
+		break;
+	case AM_TS_SRC_TS2:
+		out_src = 2;
+		break;
+	case AM_TS_SRC_TS3:
+		out_src = 3;
+		break;
+	case AM_TS_SRC_S_TS0:
+		out_src = 6;
+		break;
+	case AM_TS_SRC_S_TS1:
+		out_src = 5;
+		break;
+	case AM_TS_SRC_S_TS2:
+		out_src = 4;
+		break;
+	case AM_TS_SRC_HIU:
+		out_src = 7;
+		break;
+	default:
+		out_src = 0;
+		break;
+	}
+#endif
+	pr_dbg("[stb]src: %d, dsc1in: %d, tso: %d\n", src, des_in, out_src);
+
+	fec_s0 = 0;
+	fec_s1 = 0;
+	fec_s2 = 0;
+	invert0 = 0;
+	invert1 = 0;
+	invert2 = 0;
+
+	for (i = 0; i < pdmx->ts_in_total_count; i++) {
+		if (pdmx->ts[i].s2p_id == 0)
+			fec_s0 = i;
+		else if (pdmx->ts[i].s2p_id == 1)
+			fec_s1 = i;
+		else if (pdmx->ts[i].s2p_id == 2)
+			fec_s2 = i;
+	}
+
+	invert0 = pdmx->s2p[0].invert;
+	invert1 = pdmx->s2p[1].invert;
+
+	WRITE_MPEG_REG(STB_TOP_CONFIG,
+			   (invert1 << INVERT_S2P1_FEC_CLK) |
+			   (fec_s1 << S2P1_FEC_SERIAL_SEL) |
+			   (out_src << TS_OUTPUT_SOURCE) |
+			   (des_in << DES_INPUT_SEL) |
+			   (en_des << ENABLE_DES_PL) |
+			   (dec_clk_en << ENABLE_DES_PL_CLK) |
+			   (invert0 << INVERT_S2P0_FEC_CLK) |
+			   (fec_s0 << S2P0_FEC_SERIAL_SEL));
+
+	if (pdmx->s2p_total_count >= 3) {
+		invert2 = pdmx->s2p[2].invert;
+
+		WRITE_MPEG_REG(STB_S2P2_CONFIG,
+			   (invert2 << INVERT_S2P2_FEC_CLK) |
+			   (fec_s2 << S2P2_FEC_SERIAL_SEL));
+	}
+
+#if 0
+	/* invert ts out clk,add ci model need add this*/
+	if (dvb->ts_out_invert) {
+		/*printk("ts out invert ---\r\n");*/
+		data = READ_MPEG_REG(TS_TOP_CONFIG);
+		data |= 1 << TS_OUT_CLK_INVERT;
+		WRITE_MPEG_REG(TS_TOP_CONFIG, data);
+	}
+	/* invert ts out clk  end */
+#endif
+	WRITE_MPEG_REG(TS_FILE_CONFIG,
+			   (demux_skipbyte << 16) |
+			   (6 << DES_OUT_DLY) |
+			   (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
+			   (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD_2) |
+			   (hiu << TS_HIU_ENABLE) | (fec_clk << FEC_FILE_CLK_DIV));
+	return 0;
+}
+static int _hwdmx_init(HWDMX_Demux *pdmx)
+{
+//	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+	int id, times;
+	u32 version, data;
+
+	if (pdmx->init)
+		return 0;
+
+	pr_inf("demux init\n");
+
+	WRITE_MPEG_REG(RESET1_REGISTER, RESET_DEMUXSTB);
+
+	id = pdmx->id;
+	times = 0;
+	while (times++ < 1000000) {
+		if (!(DMX_READ_REG(id, OM_CMD_STATUS) & 0x01))
+			break;
+	}
+
+	WRITE_MPEG_REG(STB_TOP_CONFIG, 0);
+	WRITE_MPEG_REG(STB_S2P2_CONFIG, 0);
+
+	DMX_WRITE_REG(id, DEMUX_CONTROL, 0x0000);
+	version = DMX_READ_REG(id, STB_VERSION);
+	DMX_WRITE_REG(id, STB_TEST_REG, version);
+	pr_dbg("STB %d hardware version : %d\n", id, version);
+	DMX_WRITE_REG(id, STB_TEST_REG, 0x5550);
+	data = DMX_READ_REG(id, STB_TEST_REG);
+	if (data != 0x5550)
+		pr_error("STB %d register access failed\n", id);
+	DMX_WRITE_REG(id, STB_TEST_REG, 0xaaa0);
+	data = DMX_READ_REG(id, STB_TEST_REG);
+	if (data != 0xaaa0)
+		pr_error("STB %d register access failed\n", id);
+	DMX_WRITE_REG(id, MAX_FM_COMP_ADDR, 0x0000);
+	DMX_WRITE_REG(id, STB_INT_MASK, 0);
+	DMX_WRITE_REG(id, STB_INT_STATUS, 0xffff);
+	DMX_WRITE_REG(id, FEC_INPUT_CONTROL, 0);
+
+	pdmx->dump_ts_select = 0;
+
+	//get ts
+	pdmx->ts_in_total_count = getts(&pdmx->ts);
+	pdmx->s2p_total_count = gets2p(&pdmx->s2p);
+
+	pdmx->init = 1;
+
+	return 0;
+}
+static void _hwdmx_get_base_addr(struct platform_device *pdev){
+	char buf[32];
+	u32 value;
+	int ret = 0;
+
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "cbus_base");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		cbus_base = value;
+	}
+
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "asyncfifo0_reg_base");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		asyncfifo0_reg_base = value;
+	}
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "asyncfifo1_reg_base");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		asyncfifo1_reg_base = value;
+	}
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "asyncfifo2_reg_base");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		asyncfifo2_reg_base = value;
+	}
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "reset_base");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		reset_base = value;
+	}
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "parser_sub_ptr_base");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		parser_sub_ptr_base = value;
+	}
+}
+
+int hwdmx_set_source(HWDMX_Demux *pdmx, dmx_source_t src)
+{
+	unsigned long flags;
+	int hw_src;
+	int ret;
+
+	ret = 0;
+
+	spin_lock_irqsave(&slock, flags);
+
+	if (pdmx->init == 0) {
+		spin_unlock_irqrestore(&slock, flags);
+		return -1;
+	}
+
+	hw_src = pdmx->dmx_source;
+
+	switch (src) {
+	case DMX_SOURCE_FRONT0:
+		hw_src =
+			(pdmx->ts[0].mode ==
+			 AM_TS_SERIAL) ? (pdmx->ts[0].s2p_id + AM_TS_SRC_S_TS0) : AM_TS_SRC_TS0;
+		break;
+	case DMX_SOURCE_FRONT1:
+		hw_src =
+			(pdmx->ts[1].mode ==
+			 AM_TS_SERIAL) ? (pdmx->ts[1].s2p_id + AM_TS_SRC_S_TS0) : AM_TS_SRC_TS1;
+		break;
+	case DMX_SOURCE_FRONT2:
+		hw_src =
+			(pdmx->ts[2].mode ==
+			 AM_TS_SERIAL) ? (pdmx->ts[2].s2p_id + AM_TS_SRC_S_TS0) : AM_TS_SRC_TS2;
+		break;
+	case DMX_SOURCE_FRONT3:
+		hw_src =
+			(pdmx->ts[3].mode ==
+			 AM_TS_SERIAL) ? (pdmx->ts[3].s2p_id + AM_TS_SRC_S_TS0) : AM_TS_SRC_TS3;
+		break;
+	case DMX_SOURCE_DVR0:
+		hw_src = AM_TS_SRC_HIU;
+		break;
+	case DMX_SOURCE_FRONT0_OFFSET:
+		hw_src = AM_TS_SRC_DMX0;
+		break;
+	case DMX_SOURCE_FRONT1_OFFSET:
+		hw_src = AM_TS_SRC_DMX1;
+		break;
+	case DMX_SOURCE_FRONT2_OFFSET:
+		hw_src = AM_TS_SRC_DMX2;
+		break;
+	default:
+		pr_error("illegal demux source %d\n", src);
+		ret = -EINVAL;
+		break;
+	}
+
+	if (pdmx->dmx_source != hw_src) {
+		int old_source = pdmx->dmx_source;
+
+		pdmx->dmx_source = hw_src;
+
+		if (IS_SRC_DMX(old_source)) {
+			_hwdmx_set_misc(pdmx, 0, -1);
+		} else {
+			/*which dmx for av-play is unknown,
+			 *can't avoid reset-all
+			 */
+//			dmx_reset_hw_ex(dvb, 0);
+		}
+
+		if (IS_SRC_DMX(pdmx->dmx_source)) {
+			_hwdmx_set_misc(pdmx, 1, -1);
+			/*dmx_reset_dmx_id_hw_ex_unlock
+			 *	 (dvb, (dvb->stb_source-AM_TS_SRC_DMX0), 0);
+			 */
+		} else {
+			/*which dmx for av-play is unknown,
+			 *can't avoid reset-all
+			 */
+//			dmx_reset_hw_ex(dvb, 0);
+		}
+	}
+
+	_hwdmx_enable_ts(pdmx);
+
+	spin_unlock_irqrestore(&slock, flags);
+
+	return ret;
+}
+int hwdmx_get_source(HWDMX_Demux *pdmx, dmx_source_t *src) {
+	unsigned long flags;
+
+	spin_lock_irqsave(&slock, flags);
+	if (pdmx->init == 0) {
+		spin_unlock_irqrestore(&slock, flags);
+		return -1;
+	}
+	switch (pdmx->dmx_source) {
+	case AM_TS_SRC_S_TS0:
+	case AM_TS_SRC_TS0:
+		*src = DMX_SOURCE_FRONT0;
+		break;
+	case AM_TS_SRC_TS1:
+	case AM_TS_SRC_S_TS1:
+		*src = DMX_SOURCE_FRONT1;
+		break;
+	case AM_TS_SRC_TS2:
+	case AM_TS_SRC_S_TS2:
+		*src = DMX_SOURCE_FRONT2;
+		break;
+	case AM_TS_SRC_HIU:
+		*src = DMX_SOURCE_DVR0;
+		break;
+	case AM_TS_SRC_DMX0:
+		*src = DMX_SOURCE_FRONT0_OFFSET;
+		break;
+	case AM_TS_SRC_DMX1:
+		*src = DMX_SOURCE_FRONT1_OFFSET;
+		break;
+	case AM_TS_SRC_DMX2:
+		*src = DMX_SOURCE_FRONT2_OFFSET;
+		break;
+	default:
+		spin_unlock_irqrestore(&slock, flags);
+		return -1;
+	}
+
+	spin_unlock_irqrestore(&slock, flags);
+	return 0;
+}
+int hwdmx_probe(struct platform_device *pdev){
+	char buf[32];
+//	const char *str;
+	u32 value;
+	int i = 0;
+	int ret = 0;
+	struct resource *res;
+	struct aml_dvb *advb = aml_get_dvb_device();
+
+	_hwdmx_get_base_addr(pdev);
+
+	if (_hwdmx_init_clk(pdev) != 0) {
+		pr_error("hwdmx_probe init clk fail\n");
+		return -1;
+	}
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "ts_out_invert");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		advb->ts_out_invert = value;
+	}
+	for (i = 0; i < DEMUX_COUNT; i++) {
+		Demux[i].dmx_irq = -1;
+		snprintf(buf, sizeof(buf), "demux%d_irq", i);
+		res = platform_get_resource_byname(pdev, IORESOURCE_IRQ, buf);
+		if (res)
+			Demux[i].dmx_irq = res->start;
+
+		pr_error("%s irq num:%d \r\n", buf, Demux[i].dmx_irq);
+	}
+	frontend_probe(pdev);
+	s2p_probe(pdev);
+	asyncfifo_probe(pdev);
+	slock = advb->slock;
+
+	return 0;
+}
+
+int hwdmx_remove(void) {
+	int i = 0;
+	_hwdmx_release_clk();
+	frontend_remove();
+	s2p_remove();
+
+	for (i = 0; i < dmx_count; i++) {
+		asyncfifo_deinit(Demux[i].asyncfifo_id);
+	}
+	return 0;
+}
+HWDMX_Demux *hwdmx_create(int ts_id, int dmx_id, int asyncfifo_id){
+	if (dmx_count >= DEMUX_COUNT)
+		return NULL;
+
+	Demux[dmx_count].ts_id = ts_id;
+	Demux[dmx_count].asyncfifo_id = asyncfifo_id;
+	Demux[dmx_count].dmx_id = dmx_id;
+	Demux[dmx_count].cb = NULL;
+	Demux[dmx_count].id = dmx_id;
+	Demux[dmx_count].dsc_id = -1;
+
+	_hwdmx_init_chan(&Demux[dmx_count]);
+
+	_hwdmx_init(&Demux[dmx_count]);
+	hwdmx_set_source(&Demux[dmx_count],ts_id);
+
+	asyncfifo_init(asyncfifo_id,&Demux[dmx_count]);
+	asyncfifo_set_source(asyncfifo_id, dmx_id);
+	dmx_count++;
+
+	return &Demux[dmx_count-1];
+}
+
+int hwdmx_set_dsc(HWDMX_Demux *pdmx,int dsc_id, int link) {
+
+	int des_in = 0, en_des = 0, dec_clk_en = 0, des_out = 0;
+	int dmx_source;
+	int fec_core_sel = 1;
+	u32 data;
+	int ciplus_src = 0;
+	int ciplus_out = 0;
+
+	if (!pdmx || (dsc_id !=0 && dsc_id != 1))
+		return -1;
+
+	dmx_source = pdmx->dmx_id;
+
+	switch (dmx_source) {
+		case AM_DMX_0:
+			des_in = 0;
+			en_des = 1;
+			dec_clk_en = 1;
+			des_out = 1;
+
+			ciplus_src = 0;
+			ciplus_out = 1;
+			break;
+		case AM_DMX_1:
+			des_in = 1;
+			en_des = 1;
+			dec_clk_en = 1;
+			des_out = 2;
+
+			ciplus_src = 1;
+			ciplus_out = 2;
+
+			break;
+		case AM_DMX_2:
+			des_in = 2;
+			en_des = 1;
+			dec_clk_en = 1;
+			des_out = 4;
+
+			ciplus_src = 2;
+			ciplus_out = 4;
+
+			break;
+		default:
+			des_in = 0;
+			en_des = 0;
+			dec_clk_en = 0;
+			des_out = 0;
+
+			ciplus_src = 0;
+			ciplus_out = 0;
+
+			break;
+	}
+	if (link == 0) {
+		des_in = 0;
+		en_des = 0;
+		dec_clk_en = 0;
+		fec_core_sel = 0;
+	}
+	if (dsc_id == 0) {
+		data = READ_MPEG_REG(STB_TOP_CONFIG);
+		data &= ~((3 << DES_INPUT_SEL) |
+					(1 << ENABLE_DES_PL) |
+					(1 << ENABLE_DES_PL_CLK));
+
+		WRITE_MPEG_REG(STB_TOP_CONFIG, data |
+			       (des_in << DES_INPUT_SEL) |
+			       (en_des << ENABLE_DES_PL) |
+			       (dec_clk_en << ENABLE_DES_PL_CLK));
+
+		//for ciplus configure, i can't confirm.
+		data = READ_MPEG_REG(STB_TOP_CONFIG);
+		/* Set ciplus input source ,
+		 * output set 0 means no output. ---> need confirm.
+		 * if output set 0 still affects dsc output, we need to disable
+		 * ciplus module.
+		 */
+		data &= ~(3<<CIPLUS_IN_SEL);
+		WRITE_MPEG_REG(STB_TOP_CONFIG, data |
+				(ciplus_src << CIPLUS_IN_SEL));
+
+		data &= ~(7<<CIPLUS_OUT_SEL);
+		WRITE_MPEG_REG(STB_TOP_CONFIG, data |
+				(ciplus_out << CIPLUS_OUT_SEL));
+
+	} else {
+		WRITE_MPEG_REG(COMM_DESC_2_CTL,
+				(6 << 8) |/*des_out_dly_2*/
+				((!!en_des) << 6) |/* des_pl_clk_2*/
+				((!!en_des) << 5) |/* des_pl_2*/
+				(des_out << 2) |/*use_des_2*/
+				(des_in)/*des_i_sel_2*/
+				);
+	}
+
+	data = 0;
+
+	data = DMX_READ_REG(pdmx->id, FEC_INPUT_CONTROL);
+
+	data &= ~(0x1 << FEC_CORE_SEL);
+
+	DMX_WRITE_REG(pdmx->id, FEC_INPUT_CONTROL, data |
+		(fec_core_sel << FEC_CORE_SEL));
+
+	if (link == 0)
+		pdmx->dsc_id = -1;
+	else
+		pdmx->dsc_id = dsc_id;
+
+	return 0;
+}
+int hwdmx_get_dsc(HWDMX_Demux *pdmx,int *dsc_id) {
+	if (!pdmx || !dsc_id)
+		return -1;
+	*dsc_id = pdmx->dsc_id;
+	return 0;
+}
+void hwdmx_destory(HWDMX_Demux *pdmx){
+	return ;
+}
+
+int hwdmx_set_cb(HWDMX_Demux *pdmx, HWDMX_Cb cb,void *udata) {
+	if (pdmx == NULL)
+		return -1;
+
+	pdmx->cb = cb;
+	pdmx->udata = udata;
+	asyncfifo_set_cb(pdmx->asyncfifo_id, cb, udata);
+	return 0;
+}
+HWDMX_Chan *hwdmx_alloc_chan(HWDMX_Demux *pdmx) {
+	int i = 0;
+
+	for (i = 0; i < CHANNEL_COUNT; i++) {
+		if (!pdmx->channel[i].used) {
+			break;
+		}
+	}
+
+	if (i == CHANNEL_COUNT) {
+		return NULL;
+	} else {
+		pdmx->channel[i].pdmx = pdmx;
+		pdmx->channel[i].used = 1;
+		pdmx->channel[i].cid = i;
+		pdmx->chan_count++;
+	}
+	return &pdmx->channel[i];
+}
+int hwdmx_free_chan(HWDMX_Chan *chan) {
+
+	if (chan && chan->used) {
+		chan->pdmx->chan_count--;
+		chan->pid = 0x1fff;
+		_hwdmx_free_chan(chan->pdmx, chan->cid);
+		chan->used = 0;
+	}
+	return 0;
+}
+int hwdmx_set_pid(HWDMX_Chan *chan,int type, int pes_type, int pid) {
+	if (chan && chan->used) {
+		chan->pid = pid;
+		chan->type = type;
+		chan->pes_type = pes_type;
+		_hwdmx_set_chan_pid(chan->pdmx, chan->cid, pid);
+	}
+	return 0;
+}
+
diff --git a/drivers/stream_input/parser/demux/hw_demux/hwdemux.h b/drivers/stream_input/parser/demux/hw_demux/hwdemux.h
new file mode 100644
index 0000000..da2e6c7
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/hwdemux.h
@@ -0,0 +1,54 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _AML_HWDMX_H_
+#define _AML_HWDMX_H_
+#include <linux/dvb/dmx.h>
+
+enum aml_dmx_id_t {
+	AM_DMX_0 = 0,
+	AM_DMX_1,
+	AM_DMX_2,
+	AM_DMX_MAX,
+};
+
+typedef struct HWDMX_Demux_s HWDMX_Demux;
+typedef struct HWDMX_Chan_s HWDMX_Chan;
+typedef int (*HWDMX_Cb)(char *buf, int count, void *udata);
+
+int hwdmx_probe(struct platform_device *pdev);
+int hwdmx_remove(void);
+
+HWDMX_Demux *hwdmx_create(int ts_id, int dmx_id, int asyncfifo_id);
+void hwdmx_destory(HWDMX_Demux *pdmx);
+int hwdmx_set_cb(HWDMX_Demux *pdmx, HWDMX_Cb cb, void *udata);
+int hwdmx_inject(HWDMX_Demux *pdmx, const char *buf, int count);
+void hwdmx_inject_destroy(HWDMX_Demux *pdmx);
+
+HWDMX_Chan *hwdmx_alloc_chan(HWDMX_Demux *pdmx);
+int hwdmx_free_chan(HWDMX_Chan *chan);
+int hwdmx_set_pid(HWDMX_Chan *chan,int type, int pes_type, int pid);
+int hwdmx_set_dsc(HWDMX_Demux *pdmx,int dsc_id, int link);
+int hwdmx_get_dsc(HWDMX_Demux *pdmx,int *dsc_id);
+
+int hwdmx_set_source(HWDMX_Demux *pdmx, dmx_source_t src);
+int hwdmx_get_source(HWDMX_Demux *pdmx, dmx_source_t *src);
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/hw_demux/hwdemux_inject.c b/drivers/stream_input/parser/demux/hw_demux/hwdemux_inject.c
new file mode 100644
index 0000000..0f201a9
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/hwdemux_inject.c
@@ -0,0 +1,240 @@
+/*
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/amlogic/media/utils/vdec_reg.h>
+#include "../../../../frame_provider/decoder/utils/vdec.h"
+
+#include "../aml_dvb.h"
+#include "hwdemux.h"
+#include "hwdemux_internal.h"
+
+#define FETCHBUF_SIZE   (64*1024)
+
+#define RESET_PARSER        (1<<8)
+#define PARSER_INTSTAT_FETCH_CMD    (1<<7)
+#define PARSER_INT_HOST_EN_BIT      8
+
+#define FETCH_ENDIAN                27
+#define FETCH_ENDIAN_MASK           (0x7<<27)
+
+#define PS_CFG_PFIFO_EMPTY_CNT_BIT      16
+#define PS_CFG_MAX_ES_WR_CYCLE_BIT      12
+#define PS_CFG_MAX_FETCH_CYCLE_BIT      0
+
+#define pr_dbg_flag(_f, _args...)\
+	do {\
+		if (1&(_f))\
+			printk(_args);\
+	} while (0)
+
+#define pr_dbg(args...)	pr_dbg_flag(0x1, args)
+
+static DECLARE_WAIT_QUEUE_HEAD(wq);
+static u32 fetch_done = 0;
+static void *fetchbuf = NULL;
+
+static const char tsdemux_fetch_id[] = "tsdemux-fetch-id";
+
+static int stbuf_fetch_init(void)
+{
+	if (NULL != fetchbuf)
+		return 0;
+	pr_dbg("%s line:%d\n",__FUNCTION__,__LINE__);
+
+	fetchbuf = (void *)__get_free_pages(GFP_KERNEL,
+					 get_order(FETCHBUF_SIZE));
+	if (!fetchbuf) {
+		pr_info("%s: Can not allocate fetch working buffer\n",
+			 __func__);
+		return -ENOMEM;
+	}
+	return 0;
+}
+static void stbuf_fetch_release(void)
+{
+	if (0 && fetchbuf) {
+		/* always don't free.for safe alloc/free*/
+		free_pages((unsigned long)fetchbuf, get_order(FETCHBUF_SIZE));
+		fetchbuf = 0;
+	}
+}
+static irqreturn_t parser_isr(int irq, void *dev_id)
+{
+	u32 int_status = READ_PARSER_REG(PARSER_INT_STATUS);
+
+	WRITE_PARSER_REG(PARSER_INT_STATUS, int_status);
+
+	if (int_status & PARSER_INTSTAT_FETCH_CMD) {
+		fetch_done = 1;
+
+		wake_up_interruptible(&wq);
+	}
+
+	return IRQ_HANDLED;
+}
+static void _paser_reset(void) {
+	WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER);
+
+	WRITE_PARSER_REG(PARSER_CONFIG,
+				   (10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
+				   (1 << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
+				   (16 << PS_CFG_MAX_FETCH_CYCLE_BIT));
+
+	WRITE_PARSER_REG(PARSER_INT_STATUS, 0xffff);
+	WRITE_PARSER_REG(PARSER_INT_ENABLE,
+			PARSER_INTSTAT_FETCH_CMD << PARSER_INT_HOST_EN_BIT);
+}
+static void _hwdmx_inject_init(HWDMX_Demux *pdmx) {
+
+	s32 r;
+	pr_info("%s line:%d\n",__FUNCTION__,__LINE__);
+
+	if (pdmx->inject_init)
+		return ;
+
+	stbuf_fetch_init();
+
+	r = vdec_request_irq(PARSER_IRQ, parser_isr,
+			"tsdemux-fetch", (void *)tsdemux_fetch_id);
+	if (r)
+		goto err;
+
+	_paser_reset();
+	pr_info("%s line:%d\n",__FUNCTION__,__LINE__);
+
+	pdmx->inject_init = 1;
+	return;
+err:
+	pr_info("_hwdmx_inject_init, err\n");
+	return ;
+}
+struct device *hwdemux_get_dma_device(void)
+{
+	return aml_get_dvb_device()->dev;
+}
+static int _hwdmx_inject_write(HWDMX_Demux *pdmx, const char *buf, int count) {
+
+	size_t r = count;
+	const char __user *p = buf;
+	u32 len;
+	int ret;
+	int isphybuf = 0;
+	dma_addr_t dma_addr = 0;
+
+	if (r > 0) {
+	 if (isphybuf)
+		 len = count;
+	 else {
+		 len = min_t(size_t, r, FETCHBUF_SIZE);
+		 if (copy_from_user(fetchbuf, p, len))
+			 return -EFAULT;
+
+		 dma_addr =
+			 dma_map_single(hwdemux_get_dma_device(),
+					 fetchbuf,
+					 FETCHBUF_SIZE, DMA_TO_DEVICE);
+		 if (dma_mapping_error(hwdemux_get_dma_device(),
+					 dma_addr))
+			 return -EFAULT;
+	 }
+
+	 fetch_done = 0;
+
+	 wmb(); 	 /* Ensure fetchbuf  contents visible */
+
+	 if (isphybuf) {
+		 u32 buf_32 = (unsigned long)buf & 0xffffffff;
+		 WRITE_PARSER_REG(PARSER_FETCH_ADDR, buf_32);
+	 } else {
+		 WRITE_PARSER_REG(PARSER_FETCH_ADDR, dma_addr);
+		 dma_unmap_single(hwdemux_get_dma_device(), dma_addr,
+				 FETCHBUF_SIZE, DMA_TO_DEVICE);
+	 }
+
+	 WRITE_PARSER_REG(PARSER_FETCH_CMD, (7 << FETCH_ENDIAN) | len);
+
+	 ret =
+		 wait_event_interruptible_timeout(wq, fetch_done != 0,
+				 HZ / 2);
+	 if (ret == 0) {
+		 WRITE_PARSER_REG(PARSER_FETCH_CMD, 0);
+		 pr_info("write timeout, retry\n");
+		 ret = -EAGAIN;
+		 goto ERROR_RESET;
+	 } else if (ret < 0) {
+		 ret = -ERESTARTSYS;
+		 goto ERROR_RESET;
+	 }
+	 p += len;
+	 r -= len;
+  }
+  return count - r;
+ERROR_RESET:
+	_paser_reset();
+	return ret;
+}
+
+void hwdmx_inject_destroy(HWDMX_Demux *pdmx) {
+ if (!(pdmx && pdmx->init)) {
+	 return ;
+ }
+ stbuf_fetch_release();
+
+ WRITE_PARSER_REG(PARSER_INT_ENABLE, 0);
+ vdec_free_irq(PARSER_IRQ, (void *)tsdemux_fetch_id);
+}
+
+int hwdmx_inject(HWDMX_Demux *pdmx, const char *buf, int count) {
+ int ret = 0;
+
+ if (!(pdmx && pdmx->dmx_source == AM_TS_SRC_HIU)) {
+	 return -1;
+ }
+
+ if (!(pdmx && pdmx->init)) {
+	 return -1;
+ }
+ if (!pdmx->inject_init) {
+	 _hwdmx_inject_init(pdmx);
+ }
+ ret = _hwdmx_inject_write(pdmx, buf, count);
+ if (ret < 0) {
+	ret = 0;
+ }
+ return ret;
+}
+
diff --git a/drivers/stream_input/parser/demux/hw_demux/hwdemux_internal.h b/drivers/stream_input/parser/demux/hw_demux/hwdemux_internal.h
new file mode 100644
index 0000000..46bd468
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/hwdemux_internal.h
@@ -0,0 +1,64 @@
+/*
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _HWDMX_INTERNAL_H_
+#define _HWDMX_INTERNAL_H_
+
+#include "hwdemux.h"
+
+#define CHANNEL_COUNT     31
+
+struct HWDMX_Chan_s {
+	int                  type;
+	int 				pes_type;
+	int                  pid;
+	int                  used;
+	int					 cid;
+	HWDMX_Demux 		 *pdmx;
+};
+
+struct HWDMX_Demux_s
+{
+	int ts_id;
+	int dmx_id;
+	int asyncfifo_id;
+	int	ts_out_invert;
+	int dmx_irq;
+	int dmx_source;
+	int dsc_id;
+
+	int id;
+
+	int ts_in_total_count;
+	struct aml_ts_input *ts;
+
+	int s2p_total_count;
+	struct aml_s2p *s2p;
+
+	int chan_count;
+	struct HWDMX_Chan_s   channel[CHANNEL_COUNT+1];
+
+	HWDMX_Cb cb;
+	void *udata;
+
+	int dump_ts_select;
+
+	int inject_init;
+	int init;
+};
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/hw_demux/s2p.c b/drivers/stream_input/parser/demux/hw_demux/s2p.c
new file mode 100644
index 0000000..f4e33f1
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/s2p.c
@@ -0,0 +1,188 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <linux/dma-mapping.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/vmalloc.h>
+#include <linux/of.h>
+
+#include "s2p.h"
+
+#define TS_INPUT_COUNT 		5
+#define S2P_COUNT			5
+
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+#define pr_inf(fmt, args...)   printk("DVB: " fmt, ## args)
+
+static int ts_in_total_count = 0;
+static int s2p_total_count = 0;
+static struct aml_ts_input ts[TS_INPUT_COUNT];
+static struct aml_s2p s2p[S2P_COUNT];
+
+int s2p_probe(struct platform_device *pdev) {
+
+#ifdef CONFIG_OF
+	int i = 0;
+	int ret = 0;
+	char buf[32];
+	u32 value;
+
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "ts_in_count");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		if (value > TS_INPUT_COUNT) {
+			ts_in_total_count = TS_INPUT_COUNT;
+			pr_inf("ts_in %d bigger than array num %d \n", value, ts_in_total_count);
+		} else {
+			ts_in_total_count = value;
+		}
+	} else {
+		ts_in_total_count = 3;
+	}
+
+	memset(buf, 0, 32);
+	snprintf(buf, sizeof(buf), "s2p_count");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_inf("%s: 0x%x\n", buf, value);
+		if (value > S2P_COUNT) {
+			s2p_total_count = S2P_COUNT;
+			pr_inf("s2p_count %d bigger than array num %d \n", value, s2p_total_count);
+		} else {
+			s2p_total_count = value;
+		}
+	} else {
+		s2p_total_count = 2;
+	}
+
+	if (pdev->dev.of_node) {
+		int s2p_id = 0;
+		char buf[32];
+		const char *str;
+		u32 value;
+
+		for (i = 0; i < ts_in_total_count; i++) {
+
+			ts[i].mode = AM_TS_DISABLE;
+			ts[i].s2p_id = -1;
+			ts[i].pinctrl = NULL;
+			memset(buf, 0, 32);
+			snprintf(buf, sizeof(buf), "ts%d", i);
+			ret =
+				of_property_read_string(pdev->dev.of_node, buf,
+							&str);
+			if (!ret) {
+				if (!strcmp(str, "serial")) {
+					pr_inf("%s: serial\n", buf);
+
+					if (s2p_id >= S2P_COUNT)
+						pr_error("no free s2p\n");
+					else {
+						snprintf(buf, sizeof(buf),
+							 "s_ts%d", i);
+						ts[i].mode = AM_TS_SERIAL;
+						ts[i].pinctrl =
+							devm_pinctrl_get_select
+							(&pdev->dev, buf);
+						ts[i].s2p_id = s2p_id;
+
+						s2p_id++;
+					}
+				} else if (!strcmp(str, "parallel")) {
+					pr_inf("%s: parallel\n", buf);
+					memset(buf, 0, 32);
+					snprintf(buf, sizeof(buf), "p_ts%d", i);
+					ts[i].mode = AM_TS_PARALLEL;
+					ts[i].pinctrl =
+						devm_pinctrl_get_select(&pdev->dev,
+									buf);
+				} else {
+					ts[i].mode = AM_TS_DISABLE;
+					ts[i].pinctrl = NULL;
+				}
+			}
+			memset(buf, 0, 32);
+			snprintf(buf, sizeof(buf), "ts%d_control", i);
+			ret =
+				of_property_read_u32(pdev->dev.of_node, buf,
+						 &value);
+			if (!ret) {
+				pr_inf("%s: 0x%x\n", buf, value);
+				ts[i].control = value;
+			} else {
+				pr_inf("read error:%s: 0x%x\n", buf, value);
+			}
+
+			if (ts[i].s2p_id != -1) {
+				memset(buf, 0, 32);
+				snprintf(buf, sizeof(buf), "ts%d_invert", i);
+				ret =
+					of_property_read_u32(pdev->dev.of_node, buf,
+							 &value);
+				if (!ret) {
+					pr_inf("%s: 0x%x\n", buf, value);
+					s2p[ts[i].s2p_id].invert =
+						value;
+				}
+			}
+		}
+	}
+#endif
+	return 0;
+}
+
+int s2p_remove(void) {
+	return 0;
+}
+
+int getts(struct aml_ts_input **ts_p)
+{
+	*ts_p = ts;
+	return ts_in_total_count;
+}
+
+int gets2p(struct aml_s2p **s2p_p)
+{
+	*s2p_p = s2p;
+	return s2p_total_count;
+}
+
+
+
diff --git a/drivers/stream_input/parser/demux/hw_demux/s2p.h b/drivers/stream_input/parser/demux/hw_demux/s2p.h
new file mode 100644
index 0000000..a5e8e8e
--- /dev/null
+++ b/drivers/stream_input/parser/demux/hw_demux/s2p.h
@@ -0,0 +1,63 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _S2P_H_
+#define _S2P_H_
+
+enum aml_ts_source_t {
+	AM_TS_SRC_TS0,
+	AM_TS_SRC_TS1,
+	AM_TS_SRC_TS2,
+	AM_TS_SRC_TS3,
+
+	AM_TS_SRC_S_TS0,
+	AM_TS_SRC_S_TS1,
+	AM_TS_SRC_S_TS2,
+
+	AM_TS_SRC_HIU,
+	AM_TS_SRC_DMX0,
+	AM_TS_SRC_DMX1,
+	AM_TS_SRC_DMX2
+};
+
+enum{
+	AM_TS_DISABLE,
+	AM_TS_PARALLEL,
+	AM_TS_SERIAL
+};
+
+struct aml_ts_input {
+	int                  mode;
+	struct pinctrl      *pinctrl;
+	int                  control;
+	int                  s2p_id;
+};
+
+struct aml_s2p {
+	int    invert;
+};
+
+int s2p_probe(struct platform_device *pdev);
+int s2p_remove(void);
+
+int getts(struct aml_ts_input **ts_p);
+int gets2p(struct aml_s2p **s2p_p);
+
+
+#endif
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/Kconfig b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/Kconfig
new file mode 100644
index 0000000..3f97a34
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/Kconfig
@@ -0,0 +1,13 @@
+#
+# Amlogic sw demux configuration
+#
+
+menu "Meson SW DEMUX dvbcsa2 Support"
+
+config AMLOGIC_SWDEMUX_DVBCSA
+	bool "sw demux dvbcsa"
+	default y
+	help
+		Amlogic support sw demux dvbcsa config.
+		Support for sw demux dvbcsa
+endmenu
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/Makefile b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/Makefile
new file mode 100644
index 0000000..dade405
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/Makefile
@@ -0,0 +1,15 @@
+#
+# AMLOGIC sw demux driver
+#
+
+obj-$(AMLOGIC_SWDEMUX_DVBCSA) += dvbcsa_bs_algo.o \
+				dvbcsa_algo.o \
+				dvbcsa_block.o \
+				dvbcsa_bs_block.o \
+				dvbcsa_bs_key.o \
+				dvbcsa_bs_stream.o \
+				dvbcsa_bs_transpose.o \
+				dvbcsa_key.o \
+				dvbcsa_stream.o
+
+ccflags-y += -I$(srctree)/drivers/amlogic/swdemux/dvbcsa2/dvbcsa
\ No newline at end of file
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/Makefile.bak b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/Makefile.bak
new file mode 100755
index 0000000..6603c63
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/Makefile.bak
@@ -0,0 +1,13 @@
+#
+# AMLOGIC sw demux driver
+#
+
+obj-$(AMLOGIC_SWDEMUX_DVBCSA) += dvbcsa_bs_algo.o \
+				dvbcsa_algo.o \
+				dvbcsa_block.o \
+				dvbcsa_bs_block.o \
+				dvbcsa_bs_key.o \
+				dvbcsa_bs_stream.o \
+				dvbcsa_bs_transpose.o \
+				dvbcsa_key.o \
+				dvbcsa_stream.o 
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/config.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/config.h
new file mode 100644
index 0000000..619cc45
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/config.h
@@ -0,0 +1,126 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Using AltiVec bitslice. */
+/* #undef DVBCSA_USE_ALTIVEC */
+
+/* Using MMX bitslice. */
+/* #undef DVBCSA_USE_MMX */
+
+/* Using SSE2 bitslice. */
+/* #undef DVBCSA_USE_SSE */
+
+/* Using 32 bits integer bitslice. */
+/* #undef DVBCSA_USE_UINT32 */
+
+/* Using 64 bits integer bitslice. */
+#define DVBCSA_USE_UINT64 1
+
+/* Define to 1 if you have the <assert.h> header file. */
+#ifdef __KERNEL__
+//#define HAVE_ASSERT_H 0
+#else
+#define HAVE_ASSERT_H 1
+#endif
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#ifdef __KERNEL__
+#define HAVE_INTTYPES_H 0
+#else
+#define HAVE_INTTYPES_H 1
+#endif
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* _mm_malloc is available */
+#ifdef __KERNEL__
+//#define HAVE_MM_MALLOC 0
+#else
+#define HAVE_MM_MALLOC 1
+#endif
+
+/* posix_memalign is available */
+#ifdef __KERNEL__
+#else
+#define HAVE_POSIX_MEMALIGN 1
+#endif
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#ifdef __KERNEL__
+#define HAVE_STDINT_H 0
+#else
+#define HAVE_STDINT_H 1
+#endif
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#ifdef __KERNEL__
+#define HAVE_STDLIB_H 0
+#else
+#define HAVE_STDLIB_H 1
+#endif
+
+/* Define to 1 if you have the <strings.h> header file. */
+#ifdef __KERNEL__
+#define HAVE_STRINGS_H 0
+#else
+#define HAVE_STRINGS_H 1
+#endif
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "libdvbcsa"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libdvbcsa"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "libdvbcsa 1.1.0"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "libdvbcsa"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.1.0"
+
+/* The size of `long', as computed by sizeof. */
+#define SIZEOF_LONG 8
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "1.1.0"
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa/dvbcsa.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa/dvbcsa.h
new file mode 100644
index 0000000..e051f4f
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa/dvbcsa.h
@@ -0,0 +1,112 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Parallel bitslice implementation based on FFdecsa,
+     Copyright (C) 2003-2004 fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#ifndef LIBDVBCSA_H_
+#define LIBDVBCSA_H_
+
+/* csa control word */
+typedef unsigned char		dvbcsa_cw_t[8];
+
+/***********************************************************************
+	Single packet CSA implemetation API
+ */
+
+/* single packet implementation key context */
+typedef struct dvbcsa_key_s	dvbcsa_key_t;
+
+/** allocate a new csa key context */
+struct dvbcsa_key_s * dvbcsa_key_alloc(void);
+
+/** free a csa key context */
+
+void dvbcsa_key_free(struct dvbcsa_key_s *key);
+
+/** setup a csa key context to use the given control word */
+
+void dvbcsa_key_set (const dvbcsa_cw_t cw, struct dvbcsa_key_s *key);
+
+/** decrypt a packet payload */
+
+void dvbcsa_decrypt (const struct dvbcsa_key_s *key,
+		     unsigned char *data, unsigned int len);
+
+/** encrypt a packet payload */
+
+void dvbcsa_encrypt (const struct dvbcsa_key_s *key,
+		     unsigned char *data, unsigned int len);
+
+
+
+/***********************************************************************
+	Parallel bitslice CSA implemetation API
+ */
+
+/** packets batch structure, describe each data packet payload to process */
+struct dvbcsa_bs_batch_s
+{
+  unsigned char		*data;	/* pointer to payload */
+  unsigned int		len;	/* payload bytes lenght */
+};
+
+/** parallel bitslice implementation key context */
+typedef struct dvbcsa_bs_key_s	dvbcsa_bs_key_t;
+
+/** allocate a new csa bitslice key context */
+
+struct dvbcsa_bs_key_s * dvbcsa_bs_key_alloc(void);
+
+/** free a csa bitslice key context */
+
+void dvbcsa_bs_key_free(struct dvbcsa_bs_key_s *key);
+
+/** setup a csa bitslice key context to use the given control word */
+
+void dvbcsa_bs_key_set(const dvbcsa_cw_t cw, struct dvbcsa_bs_key_s *key);
+
+/** get maximum number of packet per batch */
+
+unsigned int dvbcsa_bs_batch_size(void);
+
+/** decrypt a packet batch. batch is an array of struct
+    dvbcsa_bs_batch_s with an extra NULL data termination
+    entry. maxlen is the maximum data bytes lenght to process, must be
+    a multiple of 8, should be 184 for TS packets. */
+
+void dvbcsa_bs_decrypt(const struct dvbcsa_bs_key_s *key,
+		       const struct dvbcsa_bs_batch_s *pcks,
+		       unsigned int maxlen);
+
+/** encrypt a packet batch. batch is an array of struct
+    dvbcsa_bs_batch_s with an extra NULL data termination
+    entry. maxlen is the maximum data bytes lenght to process, must be
+    a multiple of 8, should be 184 for TS packets. */
+
+void dvbcsa_bs_encrypt(const struct dvbcsa_bs_key_s *key,
+		       const struct dvbcsa_bs_batch_s *pcks,
+		       unsigned int maxlen);
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_algo.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_algo.c
new file mode 100644
index 0000000..7a13f7a
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_algo.c
@@ -0,0 +1,93 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_pv.h"
+#ifdef __KERNEL__
+#include <linux/slab.h>
+#endif
+
+void dvbcsa_decrypt (const struct dvbcsa_key_s *key, uint8_t *data, unsigned int len)
+{
+  unsigned int	alen = len & (unsigned)~0x7;
+  int		i;
+
+  if (len < 8)
+    return;
+
+#ifndef DVBCSA_DISABLE_STREAM
+  dvbcsa_stream_xor(key->cws, data, data + 8, len - 8);
+#endif
+
+#ifndef DVBCSA_DISABLE_BLOCK
+  dvbcsa_block_decrypt(key->sch, data, data);
+
+  for (i = 8; i < alen; i += 8)
+    {
+      dvbcsa_xor_64(data + i - 8, data + i);
+      dvbcsa_block_decrypt(key->sch, data + i, data + i);
+    }
+#endif
+}
+
+void dvbcsa_encrypt (const struct dvbcsa_key_s *key, uint8_t *data, unsigned int len)
+{
+  unsigned int	alen = len & (unsigned)~0x7;
+  int		i;
+
+  if (len < 8)
+    return;
+
+#ifndef DVBCSA_DISABLE_BLOCK
+  dvbcsa_block_encrypt(key->sch, data + alen - 8, data + alen - 8);
+
+  for (i = alen - 16; i >= 0; i -= 8)
+    {
+      dvbcsa_xor_64(data + i, data + i + 8);
+      dvbcsa_block_encrypt(key->sch, data + i, data + i);
+    }
+#endif
+
+#ifndef DVBCSA_DISABLE_STREAM
+  dvbcsa_stream_xor(key->cws, data, data + 8, len - 8);
+#endif
+}
+
+struct dvbcsa_key_s * dvbcsa_key_alloc(void)
+{
+#ifdef __KERNEL__
+  return kmalloc(sizeof (struct dvbcsa_key_s),GFP_KERNEL);
+#else
+  return malloc(sizeof (struct dvbcsa_key_s));
+#endif
+}
+
+void dvbcsa_key_free(struct dvbcsa_key_s *key)
+{
+#ifdef __KERNEL__
+  kfree(key);
+#else
+  free(key);
+#endif
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_block.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_block.c
new file mode 100644
index 0000000..a036242
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_block.c
@@ -0,0 +1,138 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_pv.h"
+
+void dvbcsa_key_set (const dvbcsa_cw_t cw, struct dvbcsa_key_s *key)
+{
+  uint64_t a = dvbcsa_load_le64(cw);
+  dvbcsa_store_le64(key->cw,  a);
+  dvbcsa_store_le64(key->cws, ((a & 0xf0f0f0f0f0f0f0f0ULL) >> 4) |
+		              ((a & 0x0f0f0f0f0f0f0f0fULL) << 4));
+
+  dvbcsa_key_schedule_block(cw, key->sch);
+}
+
+static const uint8_t		csa_block_perm[256] =
+  {
+    0x00, 0x02, 0x80, 0x82, 0x20, 0x22, 0xa0, 0xa2, 0x10, 0x12, 0x90, 0x92, 0x30, 0x32, 0xb0, 0xb2,
+    0x04, 0x06, 0x84, 0x86, 0x24, 0x26, 0xa4, 0xa6, 0x14, 0x16, 0x94, 0x96, 0x34, 0x36, 0xb4, 0xb6,
+    0x40, 0x42, 0xc0, 0xc2, 0x60, 0x62, 0xe0, 0xe2, 0x50, 0x52, 0xd0, 0xd2, 0x70, 0x72, 0xf0, 0xf2,
+    0x44, 0x46, 0xc4, 0xc6, 0x64, 0x66, 0xe4, 0xe6, 0x54, 0x56, 0xd4, 0xd6, 0x74, 0x76, 0xf4, 0xf6,
+    0x01, 0x03, 0x81, 0x83, 0x21, 0x23, 0xa1, 0xa3, 0x11, 0x13, 0x91, 0x93, 0x31, 0x33, 0xb1, 0xb3,
+    0x05, 0x07, 0x85, 0x87, 0x25, 0x27, 0xa5, 0xa7, 0x15, 0x17, 0x95, 0x97, 0x35, 0x37, 0xb5, 0xb7,
+    0x41, 0x43, 0xc1, 0xc3, 0x61, 0x63, 0xe1, 0xe3, 0x51, 0x53, 0xd1, 0xd3, 0x71, 0x73, 0xf1, 0xf3,
+    0x45, 0x47, 0xc5, 0xc7, 0x65, 0x67, 0xe5, 0xe7, 0x55, 0x57, 0xd5, 0xd7, 0x75, 0x77, 0xf5, 0xf7,
+    0x08, 0x0a, 0x88, 0x8a, 0x28, 0x2a, 0xa8, 0xaa, 0x18, 0x1a, 0x98, 0x9a, 0x38, 0x3a, 0xb8, 0xba,
+    0x0c, 0x0e, 0x8c, 0x8e, 0x2c, 0x2e, 0xac, 0xae, 0x1c, 0x1e, 0x9c, 0x9e, 0x3c, 0x3e, 0xbc, 0xbe,
+    0x48, 0x4a, 0xc8, 0xca, 0x68, 0x6a, 0xe8, 0xea, 0x58, 0x5a, 0xd8, 0xda, 0x78, 0x7a, 0xf8, 0xfa,
+    0x4c, 0x4e, 0xcc, 0xce, 0x6c, 0x6e, 0xec, 0xee, 0x5c, 0x5e, 0xdc, 0xde, 0x7c, 0x7e, 0xfc, 0xfe,
+    0x09, 0x0b, 0x89, 0x8b, 0x29, 0x2b, 0xa9, 0xab, 0x19, 0x1b, 0x99, 0x9b, 0x39, 0x3b, 0xb9, 0xbb,
+    0x0d, 0x0f, 0x8d, 0x8f, 0x2d, 0x2f, 0xad, 0xaf, 0x1d, 0x1f, 0x9d, 0x9f, 0x3d, 0x3f, 0xbd, 0xbf,
+    0x49, 0x4b, 0xc9, 0xcb, 0x69, 0x6b, 0xe9, 0xeb, 0x59, 0x5b, 0xd9, 0xdb, 0x79, 0x7b, 0xf9, 0xfb,
+    0x4d, 0x4f, 0xcd, 0xcf, 0x6d, 0x6f, 0xed, 0xef, 0x5d, 0x5f, 0xdd, 0xdf, 0x7d, 0x7f, 0xfd, 0xff,
+};
+
+const uint8_t		dvbcsa_block_sbox[256] =
+  {
+    0x3a, 0xea, 0x68, 0xfe, 0x33, 0xe9, 0x88, 0x1a, 0x83, 0xcf, 0xe1, 0x7f, 0xba, 0xe2, 0x38, 0x12,
+    0xe8, 0x27, 0x61, 0x95, 0x0c, 0x36, 0xe5, 0x70, 0xa2, 0x06, 0x82, 0x7c, 0x17, 0xa3, 0x26, 0x49,
+    0xbe, 0x7a, 0x6d, 0x47, 0xc1, 0x51, 0x8f, 0xf3, 0xcc, 0x5b, 0x67, 0xbd, 0xcd, 0x18, 0x08, 0xc9,
+    0xff, 0x69, 0xef, 0x03, 0x4e, 0x48, 0x4a, 0x84, 0x3f, 0xb4, 0x10, 0x04, 0xdc, 0xf5, 0x5c, 0xc6,
+    0x16, 0xab, 0xac, 0x4c, 0xf1, 0x6a, 0x2f, 0x3c, 0x3b, 0xd4, 0xd5, 0x94, 0xd0, 0xc4, 0x63, 0x62,
+    0x71, 0xa1, 0xf9, 0x4f, 0x2e, 0xaa, 0xc5, 0x56, 0xe3, 0x39, 0x93, 0xce, 0x65, 0x64, 0xe4, 0x58,
+    0x6c, 0x19, 0x42, 0x79, 0xdd, 0xee, 0x96, 0xf6, 0x8a, 0xec, 0x1e, 0x85, 0x53, 0x45, 0xde, 0xbb,
+    0x7e, 0x0a, 0x9a, 0x13, 0x2a, 0x9d, 0xc2, 0x5e, 0x5a, 0x1f, 0x32, 0x35, 0x9c, 0xa8, 0x73, 0x30,
+    0x29, 0x3d, 0xe7, 0x92, 0x87, 0x1b, 0x2b, 0x4b, 0xa5, 0x57, 0x97, 0x40, 0x15, 0xe6, 0xbc, 0x0e,
+    0xeb, 0xc3, 0x34, 0x2d, 0xb8, 0x44, 0x25, 0xa4, 0x1c, 0xc7, 0x23, 0xed, 0x90, 0x6e, 0x50, 0x00,
+    0x99, 0x9e, 0x4d, 0xd9, 0xda, 0x8d, 0x6f, 0x5f, 0x3e, 0xd7, 0x21, 0x74, 0x86, 0xdf, 0x6b, 0x05,
+    0x8e, 0x5d, 0x37, 0x11, 0xd2, 0x28, 0x75, 0xd6, 0xa7, 0x77, 0x24, 0xbf, 0xf0, 0xb0, 0x02, 0xb7,
+    0xf8, 0xfc, 0x81, 0x09, 0xb1, 0x01, 0x76, 0x91, 0x7d, 0x0f, 0xc8, 0xa0, 0xf2, 0xcb, 0x78, 0x60,
+    0xd1, 0xf7, 0xe0, 0xb5, 0x98, 0x22, 0xb3, 0x20, 0x1d, 0xa6, 0xdb, 0x7b, 0x59, 0x9f, 0xae, 0x31,
+    0xfb, 0xd3, 0xb6, 0xca, 0x43, 0x72, 0x07, 0xf4, 0xd8, 0x41, 0x14, 0x55, 0x0d, 0x54, 0x8b, 0xb9,
+    0xad, 0x46, 0x0b, 0xaf, 0x80, 0x52, 0x2c, 0xfa, 0x8c, 0x89, 0x66, 0xfd, 0xb2, 0xa9, 0x9b, 0xc0,
+  };
+
+void dvbcsa_block_decrypt (const dvbcsa_keys_t key, const dvbcsa_block_t in, dvbcsa_block_t out)
+{
+  unsigned int	i = DVBCSA_KEYSBUFF_SIZE;
+  dvbcsa_block_t	W;
+
+  memcpy(W, in, sizeof(W));
+
+  while (i--)
+    {
+      register uint8_t	L;
+      uint8_t		S;
+
+      S = dvbcsa_block_sbox[key[i] ^ W[6]];
+
+      L    = W[7] ^ S;
+
+      W[7] = W[6];
+      W[6] = W[5] ^ csa_block_perm[S];
+      W[5] = W[4];
+      W[4] = W[3] ^ L;
+      W[3] = W[2] ^ L;
+      W[2] = W[1] ^ L;
+      W[1] = W[0];
+
+      W[0] = L;
+    }
+
+  memcpy(out, W, sizeof(W));
+}
+
+void dvbcsa_block_encrypt (const dvbcsa_keys_t key, const dvbcsa_block_t in, dvbcsa_block_t out)
+{
+  unsigned int	i = 0;
+  dvbcsa_block_t	W;
+
+  memcpy(W, in, sizeof(W));
+
+  while (i < DVBCSA_KEYSBUFF_SIZE)
+    {
+      register uint8_t	L;
+      uint8_t		S;
+
+      S = dvbcsa_block_sbox[key[i] ^ W[7]];
+
+      L    = W[1];
+
+      W[1] = W[2] ^ W[0];
+      W[2] = W[3] ^ W[0];
+      W[3] = W[4] ^ W[0];
+      W[4] = W[5];
+      W[5] = W[6] ^ csa_block_perm[S];
+      W[6] = W[7];
+      W[7] = W[0] ^ S;
+
+      W[0] = L;
+
+      i++;
+    }
+
+  memcpy(out, W, sizeof(W));
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs.h
new file mode 100644
index 0000000..75cabc9
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs.h
@@ -0,0 +1,86 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#ifndef DVBCSA_BS_H_
+#define DVBCSA_BS_H_
+
+#include "dvbcsa_pv.h"
+
+#if defined(DVBCSA_USE_UINT64)
+# include "dvbcsa_bs_uint64.h"
+
+#elif defined(DVBCSA_USE_UINT32)
+# include "dvbcsa_bs_uint32.h"
+
+#elif defined(DVBCSA_USE_MMX)
+# include "dvbcsa_bs_mmx.h"
+
+#elif defined(DVBCSA_USE_SSE)
+# include "dvbcsa_bs_sse.h"
+
+#elif defined(DVBCSA_USE_ALTIVEC)
+# include "dvbcsa_bs_altivec.h"
+
+#else
+# error No dvbcsa word size defined
+#endif
+
+struct dvbcsa_bs_key_s
+{
+  dvbcsa_bs_word_t	block[DVBCSA_KEYSBUFF_SIZE];
+  dvbcsa_bs_word_t	stream[DVBCSA_CWBITS_SIZE];
+}
+#ifdef __GNUC__
+  __attribute__ ((aligned(sizeof(dvbcsa_bs_word_t))))
+#endif
+;
+
+void dvbcsa_bs_stream_cipher_batch(const struct dvbcsa_bs_key_s *key,
+				   const struct dvbcsa_bs_batch_s *pcks,
+				   unsigned int maxlen);
+
+void dvbcsa_bs_block_decrypt_batch(const struct dvbcsa_bs_key_s *key,
+				   const struct dvbcsa_bs_batch_s *pcks,
+				   unsigned int maxlen);
+
+void dvbcsa_bs_block_encrypt_batch(const struct dvbcsa_bs_key_s *key,
+				   const struct dvbcsa_bs_batch_s *pcks,
+				   unsigned int maxlen);
+
+void dvbcsa_bs_block_transpose_in(dvbcsa_bs_word_t *out, const struct dvbcsa_bs_batch_s *pcks,
+				  unsigned int offset);
+
+void dvbcsa_bs_block_transpose_out(dvbcsa_bs_word_t *in, const struct dvbcsa_bs_batch_s *pcks,
+				   unsigned int offset);
+
+void dvbcsa_bs_stream_transpose_out(const struct dvbcsa_bs_batch_s *pcks,
+				      unsigned int index, dvbcsa_bs_word_t *row);
+
+void dvbcsa_bs_stream_transpose_in(const struct dvbcsa_bs_batch_s *pcks,
+				     dvbcsa_bs_word_t *row);
+
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_algo.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_algo.c
new file mode 100644
index 0000000..6257991
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_algo.c
@@ -0,0 +1,152 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#if defined(DVBCSA_DEBUG)
+#include <stdio.h>
+#endif
+
+#ifdef __KERNEL__
+#include <linux/slab.h>
+#endif
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_bs.h"
+
+#ifdef HAVE_MM_MALLOC
+#include <mm_malloc.h>
+#endif
+
+#ifdef HAVE_ASSERT_H
+#include <assert.h>
+#endif
+
+void dvbcsa_bs_decrypt(const struct dvbcsa_bs_key_s *key,
+		       const struct dvbcsa_bs_batch_s *pcks,
+		       unsigned int maxlen)
+{
+#ifdef HAVE_ASSERT_H
+  assert(maxlen % 8 == 0);
+#endif
+
+#ifndef DVBCSA_DISABLE_STREAM
+  dvbcsa_bs_stream_cipher_batch(key, pcks, maxlen);
+#endif
+#ifndef DVBCSA_DISABLE_BLOCK
+  dvbcsa_bs_block_decrypt_batch(key, pcks, maxlen);
+#endif
+
+  BS_EMPTY ();			// restore CPU multimedia state
+}
+
+void dvbcsa_bs_encrypt(const struct dvbcsa_bs_key_s *key,
+		       const struct dvbcsa_bs_batch_s *pcks,
+		       unsigned int maxlen)
+{
+#ifdef HAVE_ASSERT_H
+  assert(maxlen % 8 == 0);
+#endif
+
+#ifndef DVBCSA_DISABLE_BLOCK
+  dvbcsa_bs_block_encrypt_batch(key, pcks, maxlen);
+#endif
+#ifndef DVBCSA_DISABLE_STREAM
+  dvbcsa_bs_stream_cipher_batch(key, pcks, maxlen);
+#endif
+
+  BS_EMPTY ();			// restore CPU multimedia state
+}
+
+struct dvbcsa_bs_key_s * dvbcsa_bs_key_alloc(void)
+{
+  void *p;
+
+#if defined(HAVE_MM_MALLOC)
+  p = _mm_malloc(sizeof (struct dvbcsa_bs_key_s), sizeof(dvbcsa_bs_word_t));
+
+#elif defined(HAVE_POSIX_MEMALIGN)
+  p = posix_memalign(&p, sizeof(dvbcsa_bs_word_t) > sizeof(void *)
+			? sizeof(dvbcsa_bs_word_t) : sizeof(void *),
+			sizeof (struct dvbcsa_bs_key_s)) ? NULL : p;
+
+#else
+#ifdef __KERNEL__
+  p = kmalloc(sizeof (struct dvbcsa_bs_key_s),GFP_KERNEL);
+#else
+  p = malloc(sizeof (struct dvbcsa_bs_key_s));
+#endif
+//#warning Using malloc instead of posix_memalign may raise alignment issues
+#ifdef HAVE_ASSERT_H
+  assert((uintptr_t)p % sizeof(dvbcsa_bs_word_t) == 0);
+#endif
+#endif
+
+  return p;
+}
+
+void dvbcsa_bs_key_free(struct dvbcsa_bs_key_s *key)
+{
+#ifdef HAVE_MM_MALLOC
+  _mm_free(key);
+#else
+#ifdef __KERNEL__
+  kfree(key);
+#else
+  free(key);
+#endif
+#endif
+}
+
+unsigned int dvbcsa_bs_batch_size (void)
+{
+  return BS_BATCH_SIZE;
+}
+
+#if defined(DVBCSA_DEBUG)
+void
+worddump (const char *str, const void *data, size_t len, size_t ws)
+{
+  const uint8_t *p = data;
+  uint32_t i;
+
+  printf ("- %s - %zu bytes\n", str, len);
+  for (i = 0; i < len; i++)
+    {
+      const char *s;
+
+      if ((i + 1) % 32 == 0)
+	s = "\n";
+      else if ((i + 1) % ws == 0)
+	s = " ";
+      else
+	s = "";
+
+      printf("%02x%s", p[i ^ (ws - 1)], s);
+    }
+
+  if (i % 32)
+    putchar ('\n');
+}
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_altivec.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_altivec.h
new file mode 100644
index 0000000..8c1b608
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_altivec.h
@@ -0,0 +1,111 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#ifndef DVBCSA_ALTIVEC_H_
+#define DVBCSA_ALTIVEC_H_
+
+#include <altivec.h>
+
+typedef vector unsigned int dvbcsa_bs_word_t;
+
+#define BS_BATCH_SIZE 128
+#define BS_BATCH_BYTES 16
+
+#define BS_VAL_(a,n,m)	({						\
+		a uint32_t _v[4] __attribute__((aligned(16))) = {	\
+			(uint32_t)((n)>>32), (uint32_t)(n),		\
+			(uint32_t)((m)>>32), (uint32_t)(m) };		\
+		vec_ld(0, _v);						\
+	})
+
+#define BS_VAL(n, m)	BS_VAL_(, n, m)
+#define BS_VAL64(n)	BS_VAL_(static const, 0x##n##ULL, 0x##n##ULL)
+#define BS_VAL32(n)	BS_VAL64(n##n)
+#define BS_VAL16(n)	BS_VAL32(n##n)
+
+static DVBCSA_INLINE dvbcsa_bs_word_t get_bs_val8( uint8_t val, dvbcsa_bs_word_t def_val )
+{
+	if ( (val & 0xf) == val ) {
+		return (dvbcsa_bs_word_t)vec_splat_u8(val);
+	}
+
+	switch (val) {
+	case 0x02:
+		return (dvbcsa_bs_word_t)vec_splat_u8(2);
+	case 0x03:
+		return (dvbcsa_bs_word_t)vec_splat_u8(3);
+	case 0x04:
+		return (dvbcsa_bs_word_t)vec_splat_u8(4);
+	case 0x10: {
+		dvbcsa_bs_word_t x = vec_splat_u8(8);
+		return (dvbcsa_bs_word_t)vec_add(x,x);
+	}
+	case 0x29: {
+		dvbcsa_bs_word_t x = vec_splat_u8(10);
+		return (dvbcsa_bs_word_t)vec_add(vec_splat_u8(0x1),vec_rl(x,x));
+	}
+	case 0x40: {
+		dvbcsa_bs_word_t x = vec_splat_u8(4);
+		return (dvbcsa_bs_word_t)vec_rl(x,x);
+	}
+	case 0x80: {
+		vector unsigned char x = vec_splat_u8(6);
+		return (dvbcsa_bs_word_t)vec_sl(x,x);
+	}
+	case 0xff:
+		return (dvbcsa_bs_word_t)vec_splat_s8(-1);
+	default:
+		return def_val;
+	}
+}
+
+#define BS_VAL8(x) get_bs_val8(0x##x, BS_VAL16(x##x))
+
+#define BS_AND(a, b)	vec_and((a), (b))
+#define BS_OR(a, b)	vec_or((a), (b))
+#define BS_XOR(a, b)	vec_xor((a), (b))
+#define BS_NOT(a)	vec_nor((a), (a))
+
+#define SHVAL_1 BS_VAL8(01)
+#define SHVAL_2 BS_VAL8(02)
+#define SHVAL_3 BS_VAL8(03)
+#define SHVAL_4 BS_VAL8(04)
+#define SHVAL_6 BS_VAL8(06)
+#define SHVAL_28 BS_VAL8(1C)
+#define SHVAL_13 BS_VAL8(0d)
+#define SHVAL_14 BS_VAL8(0e)
+#define SHVAL_7 BS_VAL8(07)
+
+#define BS_SHL(a, n)	({ dvbcsa_bs_word_t x = SHVAL_##n; vec_sll(vec_slo((a), x), x); })
+#define BS_SHR(a, n)	({ dvbcsa_bs_word_t x = SHVAL_##n; vec_srl(vec_sro((a), x), x); })
+#define BS_SHL8(a, n)	({ dvbcsa_bs_word_t x = vec_splat_u8(n*2); x = vec_add(x,x); x = vec_add(x,x); vec_slo((a), x); })
+#define BS_SHR8(a, n)	({ dvbcsa_bs_word_t x = vec_splat_u8(n*2); x = vec_add(x,x); x = vec_add(x,x); vec_sro((a), x); })
+
+#define BS_EXTRACT8(a, n) ((uint8_t*)&(a))[15 - (n)]
+
+#define BS_EMPTY()
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_block.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_block.c
new file mode 100644
index 0000000..5d35df1
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_block.c
@@ -0,0 +1,223 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_bs.h"
+#include <linux/slab.h>
+#include <linux/printk.h>
+
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+
+#define BS_XOREQ(a, b)	do { dvbcsa_bs_word_t *_t = &(a); *_t = BS_XOR(*_t, (b)); } while (0)
+
+DVBCSA_INLINE static inline void
+dvbcsa_bs_block_decrypt_register (const dvbcsa_bs_word_t *block, dvbcsa_bs_word_t *r)
+{
+  int	i, j, g;
+  dvbcsa_bs_word_t sbox_out;
+  dvbcsa_bs_word_t in;
+  dvbcsa_bs_word_t w;
+  dvbcsa_bs_word_t *r6_N;
+
+  r += 8 * 56;
+
+  // loop over kk[55]..kk[0]
+  for (i = 55; i >= 0; i--)
+    {
+      r6_N = r + 8 * 6;
+
+      r -= 8;	/* virtual shift of registers */
+
+      for (g = 0; g < 8; g++)
+	{
+	  union {
+	    dvbcsa_bs_word_t so;
+	    uint8_t si[BS_BATCH_BYTES];
+	  } u;
+
+	  u.so = BS_XOR(block[i], r6_N[g]);
+
+	  for (j = 0; j < BS_BATCH_BYTES; j++)
+	    u.si[j] = dvbcsa_block_sbox[u.si[j]];
+
+	  sbox_out = u.so;
+
+	  // bit permutation
+
+	  in = BS_OR(
+				      BS_OR(
+					    BS_OR (BS_SHL (BS_AND (sbox_out, BS_VAL8(29)), 1),
+						   BS_SHL (BS_AND (sbox_out, BS_VAL8(02)), 6)),
+					    BS_OR (BS_SHL (BS_AND (sbox_out, BS_VAL8(04)), 3),
+						   BS_SHR (BS_AND (sbox_out, BS_VAL8(10)), 2))),
+				      BS_OR(       BS_SHR (BS_AND (sbox_out, BS_VAL8(40)), 6),
+					           BS_SHR (BS_AND (sbox_out, BS_VAL8(80)), 4)));
+
+	  w = BS_XOR(r[8 * 8 + g], sbox_out);
+
+	  r[8 * 0 + g] = w;
+	  BS_XOREQ(r[8 * 2 + g], w);
+	  BS_XOREQ(r[8 * 3 + g], w);
+	  BS_XOREQ(r[8 * 4 + g], w);
+	  BS_XOREQ(r[8 * 6 + g], in);
+	}
+    }
+}
+
+DVBCSA_INLINE static inline void
+dvbcsa_bs_block_decrypt_block(const struct dvbcsa_bs_key_s *key,
+			      const struct dvbcsa_bs_batch_s *pcks,
+			      unsigned int offset)
+{
+  unsigned int size=8*(8+56);
+  dvbcsa_bs_word_t	*r;
+
+  r = kmalloc(size*sizeof(dvbcsa_bs_word_t), GFP_KERNEL);
+  if (r == NULL) {
+	  pr_error("dvbcsa_bs_block_decrypt_block fail\n");
+      return ;
+  }
+
+  dvbcsa_bs_block_transpose_in(r + 8 * 56, pcks, offset);
+  dvbcsa_bs_block_decrypt_register(key->block, r);
+  dvbcsa_bs_block_transpose_out(r, pcks, offset);
+  kfree(r);
+}
+
+void dvbcsa_bs_block_decrypt_batch(const struct dvbcsa_bs_key_s *key,
+				   const struct dvbcsa_bs_batch_s *pcks,
+				   unsigned int maxlen)
+{
+  unsigned int	i;
+  unsigned int	g;
+
+  /* decrypt first block */
+  dvbcsa_bs_block_decrypt_block(key, pcks, 0);
+
+  for (i = 8; i < maxlen; i += 8)
+    {
+
+      /* chained cipher XOR */
+      for (g = 0; pcks[g].data; g++)
+	if (i < (pcks[g].len & (unsigned)~0x7))
+	  dvbcsa_xor_64(pcks[g].data + i - 8, pcks[g].data + i);
+
+      /* decrypt other blocks */
+      dvbcsa_bs_block_decrypt_block(key, pcks, i);
+    }
+}
+
+DVBCSA_INLINE static inline void
+dvbcsa_bs_block_encrypt_register (const dvbcsa_bs_word_t *block, dvbcsa_bs_word_t *r)
+{
+  int	i, j, g;
+  dvbcsa_bs_word_t sbox_out;
+  dvbcsa_bs_word_t in;
+  dvbcsa_bs_word_t w;
+  dvbcsa_bs_word_t *r7_N;
+
+  // loop over kk[55]..kk[0]
+  for (i = 0; i < 56; i++)
+    {
+      r7_N = r + 8 * 7;
+
+      r += 8;	/* virtual shift of registers */
+
+      for (g = 0; g < 8; g++)
+	{
+	  union {
+	    dvbcsa_bs_word_t so;
+	    uint8_t si[BS_BATCH_BYTES];
+	  } u;
+
+	  u.so = BS_XOR(block[i], r7_N[g]);
+
+	  for (j = 0; j < BS_BATCH_BYTES; j++)
+	    u.si[j] = dvbcsa_block_sbox[u.si[j]];
+
+	  sbox_out = u.so;
+
+	  // bit permutation
+
+	  in = BS_OR(
+				      BS_OR(
+					    BS_OR (BS_SHL (BS_AND (sbox_out, BS_VAL8(29)), 1),
+						   BS_SHL (BS_AND (sbox_out, BS_VAL8(02)), 6)),
+					    BS_OR (BS_SHL (BS_AND (sbox_out, BS_VAL8(04)), 3),
+						   BS_SHR (BS_AND (sbox_out, BS_VAL8(10)), 2))),
+				      BS_OR(       BS_SHR (BS_AND (sbox_out, BS_VAL8(40)), 6),
+					           BS_SHR (BS_AND (sbox_out, BS_VAL8(80)), 4)));
+
+	  w = r[-8 * 1 + g];
+
+	  r[8 * 7 + g] = BS_XOR(w, sbox_out);
+	  BS_XOREQ(r[8 * 1 + g], w);
+	  BS_XOREQ(r[8 * 2 + g], w);
+	  BS_XOREQ(r[8 * 3 + g], w);
+	  BS_XOREQ(r[8 * 5 + g], in);
+	}
+    }
+}
+
+DVBCSA_INLINE static inline void
+dvbcsa_bs_block_encrypt_block(const struct dvbcsa_bs_key_s *key,
+			      const struct dvbcsa_bs_batch_s *pcks,
+			      unsigned int offset)
+{
+  unsigned int size=8*(8+56);
+  dvbcsa_bs_word_t	*r;
+
+  r = kmalloc(size*sizeof(dvbcsa_bs_word_t), GFP_KERNEL);
+  if (r == NULL) {
+	  pr_error("dvbcsa_bs_block_decrypt_block fail\n");
+      return ;
+  }
+  dvbcsa_bs_block_transpose_in(r, pcks, offset);
+  dvbcsa_bs_block_encrypt_register(key->block, r);
+  dvbcsa_bs_block_transpose_out(r + 8 * 56, pcks, offset);
+  kfree(r);
+}
+
+void dvbcsa_bs_block_encrypt_batch(const struct dvbcsa_bs_key_s *key,
+				   const struct dvbcsa_bs_batch_s *pcks,
+				   unsigned int maxlen)
+{
+  int	i;
+  unsigned int	g;
+
+  dvbcsa_bs_block_encrypt_block(key, pcks, maxlen - 8);
+
+  for (i = maxlen - 16; i >= 0; i -= 8)
+    {
+      /* chained cipher XOR */
+      for (g = 0; pcks[g].data; g++)
+	if (i + 8 < (pcks[g].len & (unsigned)~0x7))
+	  dvbcsa_xor_64(pcks[g].data + i, pcks[g].data + i + 8);
+
+      /* encrypt other blocks */
+      dvbcsa_bs_block_encrypt_block(key, pcks, i);
+    }
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_key.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_key.c
new file mode 100644
index 0000000..178ec62
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_key.c
@@ -0,0 +1,65 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2011 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_bs.h"
+
+void
+dvbcsa_bs_key_set (const dvbcsa_cw_t cw, struct dvbcsa_bs_key_s *key)
+{
+  dvbcsa_keys_t kk;
+  int i;
+
+  /* precalculations for stream */
+
+  uint64_t ck = dvbcsa_load_le64(cw);
+
+  for (i = 0; i < DVBCSA_CWBITS_SIZE; i++)
+    key->stream[i] = (ck >> (i^4)) & 1 ? BS_VAL8(ff) : BS_VAL8(00);
+
+  /* precalculations for block */
+
+  dvbcsa_key_schedule_block(cw, kk);
+
+  for (i = 0; i < DVBCSA_KEYSBUFF_SIZE; i++)
+    {
+#if BS_BATCH_SIZE == 32
+      *(uint32_t*)(key->block + i) = kk[i] * 0x01010101;
+
+#elif BS_BATCH_SIZE == 64
+      *(uint64_t*)(key->block + i) = kk[i] * 0x0101010101010101ULL;
+
+#elif BS_BATCH_SIZE > 64 && BS_BATCH_SIZE % 64 == 0
+      uint64_t v = kk[i] * 0x0101010101010101ULL;
+      int j;
+
+      for (j = 0; j < BS_BATCH_BYTES / 8; j++)
+	*((uint64_t*)(key->block + i) + j) = v;
+#else
+# error
+#endif
+    }
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_mmx.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_mmx.h
new file mode 100644
index 0000000..2235ff8
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_mmx.h
@@ -0,0 +1,56 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#ifndef DVBCSA_MMX_H_
+#define DVBCSA_MMX_H_
+
+# include <mmintrin.h>
+
+typedef __m64 dvbcsa_bs_word_t;
+
+#define BS_BATCH_SIZE 64
+#define BS_BATCH_BYTES 8
+
+#define BS_VAL(n)	((dvbcsa_bs_word_t)(n))
+#define BS_VAL64(n)	BS_VAL(0x##n##ULL)
+#define BS_VAL32(n)	BS_VAL64(n##n)
+#define BS_VAL16(n)	BS_VAL32(n##n)
+#define BS_VAL8(n)	BS_VAL16(n##n)
+
+#define BS_AND(a, b)	_m_pand((a), (b))
+#define BS_OR(a, b)	_m_por((a), (b))
+#define BS_XOR(a, b)	_m_pxor ((a), (b))
+#define BS_NOT(a)	_m_pxor ((a), BS_VAL8(ff))
+
+#define BS_SHL(a, n)	_m_psllqi((a), n)
+#define BS_SHR(a, n)	_m_psrlqi((a), n)
+#define BS_SHL8(a, n)	BS_SHL(a, 8 * (n))
+#define BS_SHR8(a, n)	BS_SHR(a, 8 * (n))
+#define BS_EXTRACT8(a, n) _mm_cvtsi64_si32(_m_psrlqi((a), 8 * (n)))
+
+#define BS_EMPTY()	_m_empty()
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_neon.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_neon.h
new file mode 100644
index 0000000..27389fa
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_neon.h
@@ -0,0 +1,57 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    (c) 2013 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#ifndef DVBCSA_NEON_H_
+#define DVBCSA_NEON_H_
+
+# include <arm_neon.h>
+
+typedef uint32x4_t dvbcsa_bs_word_t __attribute__((aligned(16)));
+
+#define BS_BATCH_SIZE 128
+#define BS_BATCH_BYTES 16
+
+#define BS_VAL(n, m)	vreinterpretq_u32_u64(vcombine_u64(vcreate_u64(m), vcreate_u64(n)))
+#define BS_VAL64(n)	vreinterpretq_u32_u64(vdupq_n_u64(0x##n##ULL))
+#define BS_VAL32(n)	vdupq_n_u32(0x##n##UL)
+#define BS_VAL16(n)	BS_VAL32(n##n)
+#define BS_VAL8(n)	BS_VAL16(n##n)
+
+#define BS_AND(a, b)	vandq_u32((a), (b))
+#define BS_OR(a, b)	vorrq_u32((a), (b))
+#define BS_XOR(a, b)	veorq_u32((a), (b))
+#define BS_NOT(a)	vmvnq_u32(a)
+
+#define BS_SHL(a, n)	vreinterpretq_u32_u64(vshlq_n_u64 (vreinterpretq_u64_u32(a), n))
+#define BS_SHR(a, n)	vreinterpretq_u32_u64(vshrq_n_u64 (vreinterpretq_u64_u32(a), n))
+#define BS_SHL8(a, n)	(n == 1 ? vreinterpretq_u32_u8(vrev16q_u8(vreinterpretq_u8_u32(a))) : ( \
+                         n == 2 ? vreinterpretq_u32_u16(vrev32q_u16(vreinterpretq_u16_u32(a))) : \
+				  vrev64q_u32(a)))
+#define BS_SHR8(a, n)   BS_SHL8(a, n)
+
+#define BS_EXTRACT8(a, n) ((uint8_t*)&(a))[n]
+
+#define BS_EMPTY()
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_sse.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_sse.h
new file mode 100644
index 0000000..f1b0c79
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_sse.h
@@ -0,0 +1,57 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#ifndef DVBCSA_SSE_H_
+#define DVBCSA_SSE_H_
+
+#include <xmmintrin.h>
+#include <emmintrin.h>
+
+typedef __m128i dvbcsa_bs_word_t;
+
+#define BS_BATCH_SIZE 128
+#define BS_BATCH_BYTES 16
+
+#define BS_VAL(n, m)	_mm_set_epi64x(n, m)
+#define BS_VAL64(n)	BS_VAL(0x##n##ULL, 0x##n##ULL)
+#define BS_VAL32(n)	BS_VAL64(n##n)
+#define BS_VAL16(n)	BS_VAL32(n##n)
+#define BS_VAL8(n)	BS_VAL16(n##n)
+
+#define BS_AND(a, b)	_mm_and_si128((a), (b))
+#define BS_OR(a, b)	_mm_or_si128((a), (b))
+#define BS_XOR(a, b)	_mm_xor_si128((a), (b))
+#define BS_NOT(a)	_mm_andnot_si128((a), BS_VAL8(ff))
+
+#define BS_SHL(a, n)	_mm_slli_epi64(a, n)
+#define BS_SHR(a, n)	_mm_srli_epi64(a, n)
+#define BS_SHL8(a, n)	_mm_slli_si128(a, n)
+#define BS_SHR8(a, n)	_mm_srli_si128(a, n)
+
+#define BS_EXTRACT8(a, n) ((uint8_t*)&(a))[n]
+
+#define BS_EMPTY()
+
+#endif
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_stream.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_stream.c
new file mode 100644
index 0000000..ec6c65e
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_stream.c
@@ -0,0 +1,436 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_bs.h"
+
+static void DVBCSA_INLINE inline
+dvbcsa_bs_stream_sbox1(dvbcsa_bs_word_t fa, dvbcsa_bs_word_t fb,
+		       dvbcsa_bs_word_t fc, dvbcsa_bs_word_t fd,
+		       dvbcsa_bs_word_t fe,
+		       dvbcsa_bs_word_t *sa, dvbcsa_bs_word_t *sb)
+{
+  dvbcsa_bs_word_t tmp0, tmp1, tmp2, tmp3;
+
+  tmp0 = BS_XOR (fa, BS_XOR (fb, BS_NOT (BS_OR (BS_XOR (BS_OR (fa, fb), fc), BS_XOR (fc, fd)))));
+  tmp1 = BS_XOR (BS_OR (fa, fb), BS_NOT (BS_AND (fc, BS_OR (fa, BS_XOR (fb, fd)))));
+  tmp2 = BS_XOR (fa, BS_XOR (BS_AND (fb, fd), BS_OR (BS_AND (fa, fd), fc)));
+  tmp3 = BS_XOR (BS_AND (fa, fc), BS_XOR (fa, BS_OR (BS_AND (fa, fb), fd)));
+
+  *sa = BS_XOR (tmp0, BS_AND (fe, tmp1));
+  *sb = BS_XOR (tmp2, BS_AND (fe, tmp3));
+}
+
+static void DVBCSA_INLINE inline
+dvbcsa_bs_stream_sbox2(dvbcsa_bs_word_t fa, dvbcsa_bs_word_t fb,
+		       dvbcsa_bs_word_t fc, dvbcsa_bs_word_t fd,
+		       dvbcsa_bs_word_t fe,
+		       dvbcsa_bs_word_t *sa, dvbcsa_bs_word_t *sb)
+{
+  dvbcsa_bs_word_t tmp0, tmp1, tmp2, tmp3;
+
+  tmp0 = BS_XOR (fa, BS_XOR (BS_AND (fb, BS_OR (fc, fd)), BS_XOR (fc, BS_NOT (fd))));
+  tmp1 = BS_OR (BS_AND (fa, BS_XOR (fb, fd)), BS_AND (BS_OR (fa, fb), fc));
+  tmp2 = BS_XOR (BS_AND (fb, fd), BS_OR (BS_AND (fa, fd), BS_XOR (fb, BS_NOT (fc))));
+  tmp3 = BS_OR (BS_AND (fa, fd), BS_XOR (fa, BS_XOR (fb, BS_AND (fc, fd))));
+
+  *sa = BS_XOR (tmp0, BS_AND (fe, tmp1));
+  *sb = BS_XOR (tmp2, BS_AND (fe, tmp3));
+}
+
+static void DVBCSA_INLINE inline
+dvbcsa_bs_stream_sbox3(dvbcsa_bs_word_t fa, dvbcsa_bs_word_t fb,
+		       dvbcsa_bs_word_t fc, dvbcsa_bs_word_t fd,
+		       dvbcsa_bs_word_t fe,
+		       dvbcsa_bs_word_t *sa, dvbcsa_bs_word_t *sb)
+{
+  dvbcsa_bs_word_t tmp0, tmp1, tmp2;
+
+  tmp0 = BS_XOR (fa, BS_XOR (fb, BS_XOR (BS_AND (fc, BS_OR (fa, fd)), fd)));
+  tmp1 = BS_XOR (BS_AND (fa, fc), BS_OR (BS_XOR (fa, fd), BS_XOR (BS_OR (fb, fc), BS_NOT (fd))));
+  tmp2 = BS_XOR (fa, BS_XOR (BS_AND (BS_XOR (fb, fc), fd), fc));
+
+  *sa = BS_XOR (tmp0, BS_AND (BS_NOT (fe), tmp1));
+  *sb = BS_XOR (tmp2, fe);
+}
+
+static void DVBCSA_INLINE inline
+dvbcsa_bs_stream_sbox4(dvbcsa_bs_word_t fa, dvbcsa_bs_word_t fb,
+		       dvbcsa_bs_word_t fc, dvbcsa_bs_word_t fd,
+		       dvbcsa_bs_word_t fe,
+		       dvbcsa_bs_word_t *sa, dvbcsa_bs_word_t *sb)
+{
+  dvbcsa_bs_word_t tmp0, tmp1, tmp2;
+
+  tmp0 = BS_XOR (fa, BS_OR (BS_AND (fc, BS_XOR (fa, fd)), BS_XOR (fb, BS_OR (fc, BS_NOT (fd)))));
+  tmp1 = BS_XOR (BS_AND (fa, fb), BS_XOR (fb, BS_XOR (BS_AND (BS_OR (fa, fc), fd), fc)));
+  tmp2 = BS_XOR (fa, BS_OR (BS_AND (fb, fc), BS_XOR (BS_OR (BS_AND (fa, BS_XOR (fb, fd)), fc), fd)));
+
+  *sa = BS_XOR (tmp0, BS_AND (fe, BS_XOR (tmp1, tmp0)));
+  *sb = BS_XOR (BS_XOR (*sa, tmp2), fe);
+}
+
+static void DVBCSA_INLINE inline
+dvbcsa_bs_stream_sbox5(dvbcsa_bs_word_t fa, dvbcsa_bs_word_t fb,
+		       dvbcsa_bs_word_t fc, dvbcsa_bs_word_t fd,
+		       dvbcsa_bs_word_t fe,
+		       dvbcsa_bs_word_t *sa, dvbcsa_bs_word_t *sb)
+{
+  dvbcsa_bs_word_t tmp0, tmp1, tmp2, tmp3;
+
+  tmp0 = BS_OR (BS_XOR (BS_AND (fa, BS_OR (fb, fc)), fb), BS_XOR (BS_OR (BS_XOR (fa, fc), fd), BS_VAL8(ff)));
+  tmp1 = BS_XOR (fb, BS_AND (BS_XOR (fc, fd), BS_XOR (fc, BS_OR (fb, BS_XOR (fa, fd)))));
+  tmp2 = BS_XOR (BS_AND (fa, fc), BS_XOR (fb, BS_AND (BS_OR (fb, BS_XOR (fa, fc)), fd)));
+  tmp3 = BS_OR (BS_AND (BS_XOR (fa, fb), BS_XOR (fc, BS_VAL8(ff))), fd);
+
+  *sa = BS_XOR (tmp0, BS_AND (fe, tmp1));
+  *sb = BS_XOR (tmp2, BS_AND (fe, tmp3));
+}
+
+static void DVBCSA_INLINE inline
+dvbcsa_bs_stream_sbox6(dvbcsa_bs_word_t fa, dvbcsa_bs_word_t fb,
+		       dvbcsa_bs_word_t fc, dvbcsa_bs_word_t fd,
+		       dvbcsa_bs_word_t fe,
+		       dvbcsa_bs_word_t *sa, dvbcsa_bs_word_t *sb)
+{
+  dvbcsa_bs_word_t tmp0, tmp1, tmp2, tmp3;
+
+  tmp0 = BS_XOR (BS_AND (BS_AND (fa, fc), fd), BS_XOR (BS_AND (fb, BS_OR (fa, fd)), fc));
+  tmp1 = BS_NOT (BS_AND (BS_XOR (fa, fc), fd));
+  tmp2 = BS_XOR (BS_AND (fa, BS_OR (fb, fc)), BS_XOR (fb, BS_OR (BS_AND (fb, fc), fd)));
+  tmp3 = BS_AND (fc, BS_XOR (BS_AND (fa, BS_XOR (fb, fd)), BS_OR (fb, fd)));
+
+  *sa = BS_XOR (tmp0, BS_AND (fe, tmp1));
+  *sb = BS_XOR (tmp2, BS_AND (fe, tmp3));
+}
+
+static void DVBCSA_INLINE inline
+dvbcsa_bs_stream_sbox7(dvbcsa_bs_word_t fa, dvbcsa_bs_word_t fb,
+		       dvbcsa_bs_word_t fc, dvbcsa_bs_word_t fd,
+		       dvbcsa_bs_word_t fe,
+		       dvbcsa_bs_word_t *sa, dvbcsa_bs_word_t *sb)
+{
+  dvbcsa_bs_word_t tmp0, tmp1, tmp2, tmp3;
+
+  tmp0 = BS_XOR (fb, BS_OR (BS_AND (fc, fd), BS_XOR (fa, BS_XOR (fc, fd))));
+  tmp1 = BS_AND (BS_OR (fb, fd), BS_OR (BS_AND (fa, fc), BS_XOR (fb, BS_XOR (fc, fd))));
+  tmp2 = BS_XOR (BS_OR (fa, fb), BS_XOR (BS_AND (fc, BS_OR (fb, fd)), fd));
+  tmp3 = BS_OR (fd, BS_XOR (BS_AND (fa, fc), BS_VAL8(ff)));
+
+  *sa = BS_XOR (tmp0, BS_AND (fe, tmp1));
+  *sb = BS_XOR (tmp2, BS_AND (fe, tmp3));
+}
+
+void
+dvbcsa_bs_stream_cipher_batch(const struct dvbcsa_bs_key_s *key,
+			      const struct dvbcsa_bs_batch_s *pcks,
+			      unsigned int maxlen)
+{
+  dvbcsa_bs_word_t A[10][4];
+  dvbcsa_bs_word_t B[10][4];
+  dvbcsa_bs_word_t X[4];
+  dvbcsa_bs_word_t Y[4];
+  dvbcsa_bs_word_t Z[4];
+  dvbcsa_bs_word_t D[4];
+  dvbcsa_bs_word_t E[4];
+  dvbcsa_bs_word_t F[4];
+  dvbcsa_bs_word_t p;
+  dvbcsa_bs_word_t q;
+  dvbcsa_bs_word_t r;
+  dvbcsa_bs_word_t in1[4];
+  dvbcsa_bs_word_t in2[4];
+  dvbcsa_bs_word_t extra_B[4];
+  dvbcsa_bs_word_t s1a, s1b, s2a, s2b, s3a, s3b, s4a, s4b, s5a, s5b, s6a, s6b, s7a, s7b;
+  dvbcsa_bs_word_t next_E[4];
+  dvbcsa_bs_word_t tmp0, tmp1, tmp3, tmp4;
+  dvbcsa_bs_word_t sb[64];
+  int h, i, j, k, b;
+  dvbcsa_bs_word_t	B_next[4];
+
+  dvbcsa_bs_stream_transpose_in(pcks, sb);
+
+  for (b = 0; b < 4; b++)
+    {
+      for (i = 0; i < 8; i++)
+	{
+	  A[i][b] = key->stream[b + i * 4];
+	  B[i][b] = key->stream[b + i * 4 + 32];
+	}
+
+      // all other regs = 0
+      A[8][b] = BS_VAL8(00);
+      A[9][b] = BS_VAL8(00);
+      B[8][b] = BS_VAL8(00);
+      B[9][b] = BS_VAL8(00);
+
+      X[b] = BS_VAL8(00);
+      Y[b] = BS_VAL8(00);
+      Z[b] = BS_VAL8(00);
+      D[b] = BS_VAL8(00);
+      E[b] = BS_VAL8(00);
+      F[b] = BS_VAL8(00);
+    }
+
+  p = BS_VAL8(00);
+  q = BS_VAL8(00);
+  r = BS_VAL8(00);
+
+  /* Stream INIT */
+
+  for (i = 0; i < 8; i++)
+    {
+
+      for (b = 0; b < 4; b++)
+	{
+	  in1[b] = sb[8 * i + 4 + b];
+	  in2[b] = sb[8 * i + b];
+	}
+
+      for (j = 0; j < 4; j++)
+	{
+	  dvbcsa_bs_stream_sbox1(A[0][2], A[5][1], A[6][3], A[8][0], A[3][0], &s1a, &s1b);
+	  dvbcsa_bs_stream_sbox2(A[2][2], A[5][3], A[6][0], A[8][1], A[1][1], &s2a, &s2b);
+	  dvbcsa_bs_stream_sbox3(A[1][0], A[4][1], A[4][3], A[5][2], A[0][3], &s3a, &s3b);
+	  dvbcsa_bs_stream_sbox4(A[0][1], A[1][3], A[3][2], A[7][0], A[2][3], &s4a, &s4b);
+	  dvbcsa_bs_stream_sbox5(A[3][3], A[5][0], A[7][1], A[8][2], A[4][2], &s5a, &s5b);
+	  dvbcsa_bs_stream_sbox6(A[3][1], A[4][0], A[6][2], A[8][3], A[2][1], &s6a, &s6b);
+	  dvbcsa_bs_stream_sbox7(A[2][0], A[6][1], A[7][2], A[7][3], A[1][2], &s7a, &s7b);
+
+	  extra_B[3] = BS_XOR (BS_XOR (BS_XOR (B[2][0], B[5][1]), B[6][2]), B[8][3]);
+	  extra_B[2] = BS_XOR (BS_XOR (BS_XOR (B[5][0], B[7][1]), B[2][3]), B[3][2]);
+	  extra_B[1] = BS_XOR (BS_XOR (BS_XOR (B[4][3], B[7][2]), B[3][0]), B[4][1]);
+	  extra_B[0] = BS_XOR (BS_XOR (BS_XOR (B[8][2], B[5][3]), B[2][1]), B[7][0]);
+
+	  for (b = 0; b < 4; b++)
+	    {
+	      dvbcsa_bs_word_t	A_next;
+
+	      A_next = BS_XOR (A[9][b], X[b]);
+	      A_next = BS_XOR (BS_XOR (A_next, D[b]), ((j % 2) ? in2[b] : in1[b]));
+
+	      for (k = 9; k > 0; k--)
+		A[k][b] = A[k - 1][b];
+
+	      A[0][b] = A_next;
+	    }
+
+	  //dvbcsa_bs_word_t	B_next[4];
+
+	  for (b = 0; b < 4; b++)
+	    {
+	      B_next[b] = BS_XOR (BS_XOR (B[6][b], B[9][b]), Y[b]);
+	      B_next[b] = BS_XOR (B_next[b], ((j % 2) ? in1[b] : in2[b]));
+	    }
+
+	  tmp3 = B_next[3];
+	  B_next[3] = BS_XOR (B_next[3], BS_AND (BS_XOR (B_next[3], B_next[2]), p));
+	  B_next[2] = BS_XOR (B_next[2], BS_AND (BS_XOR (B_next[2], B_next[1]), p));
+	  B_next[1] = BS_XOR (B_next[1], BS_AND (BS_XOR (B_next[1], B_next[0]), p));
+	  B_next[0] = BS_XOR (B_next[0], BS_AND (BS_XOR (B_next[0], tmp3), p));
+
+	  for (b = 0; b < 4; b++)
+	    {
+	      for (k = 9; k > 0; k--)
+		B[k][b] = B[k - 1][b];
+
+	      B[0][b] = B_next[b];
+	    }
+
+	  for (b = 0; b < 4; b++)
+	    D[b] = BS_XOR (BS_XOR (E[b], Z[b]), extra_B[b]);
+
+	  for (b = 0; b < 4; b++)
+	    next_E[b] = F[b];
+
+	  tmp0 = BS_XOR (Z[0], E[0]);
+	  tmp1 = BS_AND (Z[0], E[0]);
+	  F[0] = BS_XOR (E[0], BS_AND (q, BS_XOR (Z[0], r)));
+	  tmp3 = BS_AND (tmp0, r);
+	  tmp4 = BS_OR (tmp1, tmp3);
+
+	  tmp0 = BS_XOR (Z[1], E[1]);
+	  tmp1 = BS_AND (Z[1], E[1]);
+	  F[1] = BS_XOR (E[1], BS_AND (q, BS_XOR (Z[1], tmp4)));
+	  tmp3 = BS_AND (tmp0, tmp4);
+	  tmp4 = BS_OR (tmp1, tmp3);
+
+	  tmp0 = BS_XOR (Z[2], E[2]);
+	  tmp1 = BS_AND (Z[2], E[2]);
+	  F[2] = BS_XOR (E[2], BS_AND (q, BS_XOR (Z[2], tmp4)));
+	  tmp3 = BS_AND (tmp0, tmp4);
+	  tmp4 = BS_OR (tmp1, tmp3);
+
+	  tmp0 = BS_XOR (Z[3], E[3]);
+	  tmp1 = BS_AND (Z[3], E[3]);
+	  F[3] = BS_XOR (E[3], BS_AND (q, BS_XOR (Z[3], tmp4)));
+	  tmp3 = BS_AND (tmp0, tmp4);
+	  r = BS_XOR (r, BS_AND (q, BS_XOR (BS_OR (tmp1, tmp3), r)));	// ultimate carry
+
+	  for (b = 0; b < 4; b++)
+	    E[b] = next_E[b];
+
+	  X[0] = s1a;
+	  X[1] = s2a;
+	  X[2] = s3b;
+	  X[3] = s4b;
+	  Y[0] = s3a;
+	  Y[1] = s4a;
+	  Y[2] = s5b;
+	  Y[3] = s6b;
+	  Z[0] = s5a;
+	  Z[1] = s6a;
+	  Z[2] = s1b;
+	  Z[3] = s2b;
+	  p = s7a;
+	  q = s7b;
+
+	}
+
+    }
+
+  /* Stream GEN */
+
+  for (h = 8; h < maxlen; h++)
+    {
+      dvbcsa_bs_word_t cb[8];
+
+      for (j = 0; j < 4; j++)
+	{
+	  dvbcsa_bs_stream_sbox1(A[0][2], A[5][1], A[6][3], A[8][0], A[3][0], &s1a, &s1b);
+	  dvbcsa_bs_stream_sbox2(A[2][2], A[5][3], A[6][0], A[8][1], A[1][1], &s2a, &s2b);
+	  dvbcsa_bs_stream_sbox3(A[1][0], A[4][1], A[4][3], A[5][2], A[0][3], &s3a, &s3b);
+	  dvbcsa_bs_stream_sbox4(A[0][1], A[1][3], A[3][2], A[7][0], A[2][3], &s4a, &s4b);
+	  dvbcsa_bs_stream_sbox5(A[3][3], A[5][0], A[7][1], A[8][2], A[4][2], &s5a, &s5b);
+	  dvbcsa_bs_stream_sbox6(A[3][1], A[4][0], A[6][2], A[8][3], A[2][1], &s6a, &s6b);
+	  dvbcsa_bs_stream_sbox7(A[2][0], A[6][1], A[7][2], A[7][3], A[1][2], &s7a, &s7b);
+
+	  // use 4x4 xor to produce extra nibble for T3
+
+	  extra_B[3] = BS_XOR (BS_XOR (BS_XOR (B[2][0], B[5][1]), B[6][2]), B[8][3]);
+	  extra_B[2] = BS_XOR (BS_XOR (BS_XOR (B[5][0], B[7][1]), B[2][3]), B[3][2]);
+	  extra_B[1] = BS_XOR (BS_XOR (BS_XOR (B[4][3], B[7][2]), B[3][0]), B[4][1]);
+	  extra_B[0] = BS_XOR (BS_XOR (BS_XOR (B[8][2], B[5][3]), B[2][1]), B[7][0]);
+
+	  // T1 = xor all inputs
+	  // in1, in2, D are only used in T1 during initialisation, not generation
+	  for (b = 0; b < 4; b++)
+	    {
+	      dvbcsa_bs_word_t	A_next;
+
+	      A_next = BS_XOR (A[9][b], X[b]);
+
+	      for (k = 9; k > 0; k--)
+		A[k][b] = A[k - 1][b];
+
+	      A[0][b] = A_next;
+	    }
+
+	  // T2 =  xor all inputs
+	  // in1, in2 are only used in T1 during initialisation, not generation
+	  // if p=0, use this, if p=1, rotate the result left
+	  for (b = 0; b < 4; b++)
+	    B_next[b] = BS_XOR (BS_XOR (B[6][b], B[9][b]), Y[b]);
+
+	  // if p=1, rotate left (yes, this is what we're doing)
+	  tmp3 = B_next[3];
+	  B_next[3] = BS_XOR (B_next[3], BS_AND (BS_XOR (B_next[3], B_next[2]), p));
+	  B_next[2] = BS_XOR (B_next[2], BS_AND (BS_XOR (B_next[2], B_next[1]), p));
+	  B_next[1] = BS_XOR (B_next[1], BS_AND (BS_XOR (B_next[1], B_next[0]), p));
+	  B_next[0] = BS_XOR (B_next[0], BS_AND (BS_XOR (B_next[0], tmp3), p));
+
+	  for (b = 0; b < 4; b++)
+	    {
+	      for (k = 9; k > 0; k--)
+		B[k][b] = B[k - 1][b];
+
+	      B[0][b] = B_next[b];
+	    }
+
+	  // T3 = xor all inputs
+	  for (b = 0; b < 4; b++)
+	    D[b] = BS_XOR (BS_XOR (E[b], Z[b]), extra_B[b]);
+
+	  // T4 = sum, carry of Z + E + r
+	  for (b = 0; b < 4; b++)
+	    next_E[b] = F[b];
+
+	  tmp0 = BS_XOR (Z[0], E[0]);
+	  tmp1 = BS_AND (Z[0], E[0]);
+	  F[0] = BS_XOR (E[0], BS_AND (q, BS_XOR (Z[0], r)));
+	  tmp3 = BS_AND (tmp0, r);
+	  tmp4 = BS_OR (tmp1, tmp3);
+
+	  tmp0 = BS_XOR (Z[1], E[1]);
+	  tmp1 = BS_AND (Z[1], E[1]);
+	  F[1] = BS_XOR (E[1], BS_AND (q, BS_XOR (Z[1], tmp4)));
+	  tmp3 = BS_AND (tmp0, tmp4);
+	  tmp4 = BS_OR (tmp1, tmp3);
+
+	  tmp0 = BS_XOR (Z[2], E[2]);
+	  tmp1 = BS_AND (Z[2], E[2]);
+	  F[2] = BS_XOR (E[2], BS_AND (q, BS_XOR (Z[2], tmp4)));
+	  tmp3 = BS_AND (tmp0, tmp4);
+	  tmp4 = BS_OR (tmp1, tmp3);
+
+	  tmp0 = BS_XOR (Z[3], E[3]);
+	  tmp1 = BS_AND (Z[3], E[3]);
+	  F[3] = BS_XOR (E[3], BS_AND (q, BS_XOR (Z[3], tmp4)));
+	  tmp3 = BS_AND (tmp0, tmp4);
+	  r = BS_XOR (r, BS_AND (q, BS_XOR (BS_OR (tmp1, tmp3), r)));	// ultimate carry
+
+	  for (b = 0; b < 4; b++)
+	    E[b] = next_E[b];
+
+	  X[0] = s1a;
+	  X[1] = s2a;
+	  X[2] = s3b;
+	  X[3] = s4b;
+	  Y[0] = s3a;
+	  Y[1] = s4a;
+	  Y[2] = s5b;
+	  Y[3] = s6b;
+	  Z[0] = s5a;
+	  Z[1] = s6a;
+	  Z[2] = s1b;
+	  Z[3] = s2b;
+
+	  p = s7a;
+	  q = s7b;
+
+	  // require 4 loops per output byte
+	  // 2 output bits are a function of the 4 bits of D
+	  // xor 2 by 2
+	  cb[7 - 2 * j] = BS_XOR (D[2], D[3]);
+	  cb[6 - 2 * j] = BS_XOR (D[0], D[1]);
+	}				// EXTERNAL LOOP
+
+      ////////////////////////////////////////////////////////////////////////////////
+
+      dvbcsa_bs_stream_transpose_out(pcks, h, cb);
+
+    }
+
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose.c
new file mode 100644
index 0000000..2b3e304
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose.c
@@ -0,0 +1,112 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_bs.h"
+
+/***********************************************************************
+	Block cipher transpose
+ */
+
+void dvbcsa_bs_block_transpose_in (dvbcsa_bs_word_t *out,
+				   const struct dvbcsa_bs_batch_s *pcks,
+				   unsigned int offset)
+{
+  uint32_t		*ri = (uint32_t *) out;
+  unsigned int		j, i, k;
+
+  for (i = 0; pcks[i].data; i++)
+    if (offset < (pcks[i].len & (unsigned)~0x7))
+      {
+        ri[i                ] = dvbcsa_load_le32(pcks[i].data + offset);
+        ri[i + BS_BATCH_SIZE] = dvbcsa_load_le32(pcks[i].data + offset + 4);
+      }
+
+  for (j = 0; j < 64; j += 32)
+    for (i = 0; i < 16; i += 8)
+      for (k = 0; k < 8; k++)
+	{
+	  dvbcsa_bs_word_t *r = out + j + i + k;
+	  dvbcsa_bs_word_t t, b;
+
+	  t = r[0];
+	  b = r[16];
+	  r[0]  = BS_OR(BS_AND(t, BS_VAL32(0000ffff)), BS_SHL8(BS_AND(b, BS_VAL32(0000ffff)), 2));
+	  r[16] = BS_OR(BS_AND(b, BS_VAL32(ffff0000)), BS_SHR8(BS_AND(t, BS_VAL32(ffff0000)), 2));
+	}
+
+  for (j = 0; j < 64; j += 16)
+    for (k = 0; k < 8; k++)
+      {
+	dvbcsa_bs_word_t *r = out + j + k;
+	dvbcsa_bs_word_t t, b;
+
+	t = r[0];
+	b = r[8];
+	r[0] = BS_OR(BS_AND(t, BS_VAL16(00ff)), BS_SHL8(BS_AND(b, BS_VAL16(00ff)), 1));
+	r[8] = BS_OR(BS_AND(b, BS_VAL16(ff00)), BS_SHR8(BS_AND(t, BS_VAL16(ff00)), 1));
+      }
+}
+
+void dvbcsa_bs_block_transpose_out (dvbcsa_bs_word_t *in,
+				    const struct dvbcsa_bs_batch_s *pcks,
+				    unsigned int offset)
+{
+  uint32_t		*ri = (uint32_t *) in;
+  unsigned int		j, i, k;
+
+  for (j = 0; j < 64; j += 16)
+    for (k = 0; k < 8; k++)
+      {
+	dvbcsa_bs_word_t *r = in + j + k;
+	dvbcsa_bs_word_t t, b;
+
+	t = r[0];
+	b = r[8];
+	r[0] = BS_OR(BS_AND(t, BS_VAL16(00ff)), BS_SHL8(BS_AND(b, BS_VAL16(00ff)), 1));
+	r[8] = BS_OR(BS_AND(b, BS_VAL16(ff00)), BS_SHR8(BS_AND(t, BS_VAL16(ff00)), 1));
+      }
+
+  for (j = 0; j < 64; j += 32)
+    for (i = 0; i < 16; i += 8)
+      for (k = 0; k < 8; k++)
+	{
+	  dvbcsa_bs_word_t *r = in + j + i + k;
+	  dvbcsa_bs_word_t t, b;
+
+	  t = r[0];
+	  b = r[16];
+	  r[0]  = BS_OR(BS_AND(t, BS_VAL32(0000ffff)), BS_SHL8(BS_AND(b, BS_VAL32(0000ffff)), 2));
+	  r[16] = BS_OR(BS_AND(b, BS_VAL32(ffff0000)), BS_SHR8(BS_AND(t, BS_VAL32(ffff0000)), 2));
+	}
+
+  for (i = 0; pcks[i].data; i++)
+    if (offset < (pcks[i].len & (unsigned)~0x7))
+      {
+	dvbcsa_store_le32(pcks[i].data + offset    , ri[i                ]);
+	dvbcsa_store_le32(pcks[i].data + offset + 4, ri[i + BS_BATCH_SIZE]);
+      }
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose128.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose128.c
new file mode 100644
index 0000000..8a75d09
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose128.c
@@ -0,0 +1,209 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_bs.h"
+
+/***********************************************************************
+	Stream cipher transpose
+ */
+
+/* 64 rows of 64 bits transposition (bytes transp. - 8x8 rotate counterclockwise)*/
+
+void dvbcsa_bs_stream_transpose_in(const struct dvbcsa_bs_batch_s *pcks, dvbcsa_bs_word_t *row)
+{
+  int i, j;
+
+  for (i = 0; pcks->data; i++)
+    {
+      uint64_t t, b;
+
+      if (pcks->data)
+	{
+	  if (pcks->len >= 8)
+	    t = dvbcsa_load_le64(pcks->data);
+	  pcks++;
+	}
+
+      if (pcks->data)
+	{
+	  if (pcks->len >= 8)
+	    b = dvbcsa_load_le64(pcks->data);
+	  pcks++;
+	}
+
+      row[i] = BS_VAL(b, t);
+    }
+
+  for (i = 0; i < 32; i++)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      t = row[i];
+      b = row[32 + i];
+      row[i]      = BS_OR(BS_AND(t, BS_VAL64(00000000ffffffff)), BS_SHL8(BS_AND(b, BS_VAL64(00000000ffffffff)), 4));
+      row[32 + i] = BS_OR(BS_AND(b, BS_VAL64(ffffffff00000000)), BS_SHR8(BS_AND(t, BS_VAL64(ffffffff00000000)), 4));
+    }
+
+  for (j = 0; j < 64; j += 32)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 16; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 16 + i];
+	  row[j + i]      = BS_OR(BS_AND(t, BS_VAL32(0000ffff)), BS_SHL8(BS_AND(b, BS_VAL32(0000ffff)), 2));
+	  row[j + 16 + i] = BS_OR(BS_AND(b, BS_VAL32(ffff0000)), BS_SHR8(BS_AND(t, BS_VAL32(ffff0000)), 2));
+	}
+    }
+
+  for (j = 0; j < 64; j += 16)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 8; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 8 + i];
+	  row[j + i]     = BS_OR(BS_AND(t, BS_VAL16(00ff)), BS_SHL8(BS_AND(b, BS_VAL16(00ff)), 1));
+	  row[j + 8 + i] = BS_OR(BS_AND(b, BS_VAL16(ff00)), BS_SHR8(BS_AND(t, BS_VAL16(ff00)), 1));
+	}
+    }
+
+  for (j = 0; j < 64; j += 8)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 4; i++)
+	{
+	  b = row[j + i];
+	  t = row[j + 4 + i];
+	  row[j + i]     = BS_OR(BS_AND(b, BS_VAL8(0f)), BS_SHL(BS_AND(t, BS_VAL8(0f)), 4));
+	  row[j + 4 + i] = BS_OR(BS_AND(t, BS_VAL8(f0)), BS_SHR(BS_AND(b, BS_VAL8(f0)), 4));
+	}
+    }
+
+  for (j = 0; j < 64; j += 4)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 2; i++)
+	{
+	  b = row[j + i];
+	  t = row[j + 2 + i];
+	  row[j + i]     = BS_OR(BS_AND(b, BS_VAL8(33)), BS_SHL(BS_AND(t, BS_VAL8(33)), 2));
+	  row[j + 2 + i] = BS_OR(BS_AND(t, BS_VAL8(cc)), BS_SHR(BS_AND(b, BS_VAL8(cc)), 2));
+	}
+    }
+
+  for (j = 0; j < 64; j += 2)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      b = row[j];
+      t = row[j + 1];
+      row[j]     = BS_OR(BS_AND(b, BS_VAL8(55)), BS_SHL(BS_AND(t, BS_VAL8(55)), 1));
+      row[j + 1] = BS_OR(BS_AND(t, BS_VAL8(aa)), BS_SHR(BS_AND(b, BS_VAL8(aa)), 1));
+    }
+}
+
+/* 8 rows of 64 bits transposition (bytes transp. - 8x8 rotate clockwise)*/
+
+void dvbcsa_bs_stream_transpose_out(const struct dvbcsa_bs_batch_s *pcks,
+				      unsigned int index, dvbcsa_bs_word_t *row)
+{
+  int i, j;
+
+  for (i = 0; i < 4; i++)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      t = row[i];
+      b = row[4 + i];
+      row[i]     = BS_OR(BS_AND(t, BS_VAL64(00000000ffffffff)), BS_SHL8(BS_AND(b, BS_VAL64(00000000ffffffff)), 4));
+      row[4 + i] = BS_OR(BS_AND(b, BS_VAL64(ffffffff00000000)), BS_SHR8(BS_AND(t, BS_VAL64(ffffffff00000000)), 4));
+    }
+
+  for (j = 0; j < 8; j += 4)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 2; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 2 + i];
+	  row[j + i]     = BS_OR(BS_AND(t, BS_VAL32(0000ffff)), BS_SHL8(BS_AND(b, BS_VAL32(0000ffff)), 2));
+	  row[j + 2 + i] = BS_OR(BS_AND(b, BS_VAL32(ffff0000)), BS_SHR8(BS_AND(t, BS_VAL32(ffff0000)), 2));
+	}
+    }
+
+  for (j = 0; j < 8; j += 2)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      t = row[j];
+      b = row[j + 1];
+      row[j]     = BS_OR(BS_AND(t, BS_VAL16(00ff)), BS_SHL8(BS_AND(b, BS_VAL16(00ff)), 1));
+      row[j + 1] = BS_OR(BS_AND(b, BS_VAL16(ff00)), BS_SHR8(BS_AND(t, BS_VAL16(ff00)), 1));
+    }
+
+  for (j = 0; j < 8; j++)
+    {
+      dvbcsa_bs_word_t t;
+
+      t = row[j];
+
+      t = BS_OR(       BS_AND(t, BS_VAL64(f0f0f0f00f0f0f0f)),
+	  BS_OR(BS_SHR(BS_AND(t, BS_VAL64(0f0f0f0f00000000)), 28),
+		BS_SHL(BS_AND(t, BS_VAL64(00000000f0f0f0f0)), 28)));
+
+      t = BS_OR(       BS_AND(t, BS_VAL32(        cccc3333)),
+	  BS_OR(BS_SHR(BS_AND(t, BS_VAL32(        33330000)), 14),
+		BS_SHL(BS_AND(t, BS_VAL32(        0000cccc)), 14)));
+
+      t = BS_OR(       BS_AND(t, BS_VAL16(            aa55)),
+          BS_OR(BS_SHR(BS_AND(t, BS_VAL16(            5500)), 7 ),
+		BS_SHL(BS_AND(t, BS_VAL16(            00aa)), 7 )));
+
+      for (i = 0; i < BS_BATCH_BYTES; i++)
+	{
+	  static const unsigned int p[16] =
+	    {
+	      0 , 8, 1, 9, 2, 10, 3, 11,
+	      4, 12, 5, 13, 6, 14, 7, 15
+	    };
+
+	  unsigned int k = j * BS_BATCH_BYTES + i;
+
+	  if (!pcks[k].data)
+	    return;
+
+	  if (index < pcks[k].len)
+	  pcks[k].data[index] ^= BS_EXTRACT8(t, p[i]);
+	}
+    }
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose32.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose32.c
new file mode 100644
index 0000000..2cfff7a
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose32.c
@@ -0,0 +1,185 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_bs.h"
+
+/***********************************************************************
+	Stream cipher transpose
+ */
+
+/* 64 rows of 32 bits transposition (bytes transp. - 8x8 rotate counterclockwise)*/
+
+void dvbcsa_bs_stream_transpose_in(const struct dvbcsa_bs_batch_s *pcks, dvbcsa_bs_word_t *row)
+{
+  int i, j;
+
+  for (i = 0; pcks[i].data; i++)
+    if (pcks[i].len >= 8)
+      {
+	row[i     ] = BS_VAL(dvbcsa_load_le32(pcks[i].data    ));
+	row[i + 32] = BS_VAL(dvbcsa_load_le32(pcks[i].data + 4));
+      }
+
+  for (j = 0; j < 64; j += 32)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 16; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 16 + i];
+	  row[j + i     ] = BS_OR(BS_AND(t, BS_VAL32(0000ffff)), BS_SHL8(BS_AND(b, BS_VAL32(0000ffff)), 2));
+	  row[j + 16 + i] = BS_OR(BS_AND(b, BS_VAL32(ffff0000)), BS_SHR8(BS_AND(t, BS_VAL32(ffff0000)), 2));
+	}
+    }
+
+  for (j = 0; j < 64; j += 16)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 8; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 8 + i];
+	  row[j + i    ] = BS_OR(BS_AND(t, BS_VAL16(00ff)), BS_SHL8(BS_AND(b, BS_VAL16(00ff)), 1));
+	  row[j + 8 + i] = BS_OR(BS_AND(b, BS_VAL16(ff00)), BS_SHR8(BS_AND(t, BS_VAL16(ff00)), 1));
+	}
+    }
+
+  for (j = 0; j < 64; j += 8)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 4; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 4 + i];
+	  row[j + i    ] = BS_OR(BS_AND(b, BS_VAL8(0f)), BS_SHL(BS_AND(t, BS_VAL8(0f)), 4));
+	  row[j + 4 + i] = BS_OR(BS_AND(t, BS_VAL8(f0)), BS_SHR(BS_AND(b, BS_VAL8(f0)), 4));
+	}
+    }
+
+  for (j = 0; j < 64; j += 4)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 2; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 2 + i];
+	  row[j + i    ] = BS_OR(BS_AND(b, BS_VAL8(33)), BS_SHL(BS_AND(t, BS_VAL8(33)), 2));
+	  row[j + 2 + i] = BS_OR(BS_AND(t, BS_VAL8(cc)), BS_SHR(BS_AND(b, BS_VAL8(cc)), 2));
+	}
+    }
+
+  for (j = 0; j < 64; j += 2)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      t = row[j];
+      b = row[j + 1];
+      row[j    ] = BS_OR(BS_AND(b, BS_VAL8(55)), BS_SHL(BS_AND(t, BS_VAL8(55)), 1));
+      row[j + 1] = BS_OR(BS_AND(t, BS_VAL8(aa)), BS_SHR(BS_AND(b, BS_VAL8(aa)), 1));
+    }
+}
+
+/* 64 rows of 32 bits transposition (bytes transp. - 8x8 rotate clockwise)*/
+
+void dvbcsa_bs_stream_transpose_out(const struct dvbcsa_bs_batch_s *pcks,
+				    unsigned int index, dvbcsa_bs_word_t *row)
+{
+  int i, j;
+
+  for (i = 0; i < 4; i++)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      t = row[i];
+      b = row[4 + i];
+      row[i    ] = BS_OR(BS_AND(t, BS_VAL32(0000ffff)), BS_SHL8(BS_AND(b, BS_VAL32(0000ffff)), 2));
+      row[4 + i] = BS_OR(BS_AND(b, BS_VAL32(ffff0000)), BS_SHR8(BS_AND(t, BS_VAL32(ffff0000)), 2));
+    }
+
+  for (j = 0; j < 8; j += 4)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 2; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 2 + i];
+	  row[j + i    ] = BS_OR(BS_AND(t, BS_VAL16(00ff)), BS_SHL8(BS_AND(b, BS_VAL16(00ff)), 1));
+	  row[j + i + 2] = BS_OR(BS_AND(b, BS_VAL16(ff00)), BS_SHR8(BS_AND(t, BS_VAL16(ff00)), 1));
+	}
+    }
+
+  for (j = 0; j < 8; j += 2)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      t = row[j];
+      b = row[j + 1];
+      row[j + 1] = BS_OR(BS_AND(t, BS_VAL8(0f)), BS_SHL(BS_AND(b, BS_VAL8(0f)), 4)); //(t & 0x0f0f0f0f) | ((b & 0x0f0f0f0f) << 4);
+      row[j    ] = BS_OR(BS_AND(b, BS_VAL8(f0)), BS_SHR(BS_AND(t, BS_VAL8(f0)), 4));//((t & 0xf0f0f0f0) >> 4) | (b & 0xf0f0f0f0);
+    }
+
+  for (j = 0; j < 8; j++)
+    {
+      dvbcsa_bs_word_t t;
+
+      t = row[j];
+
+      t = BS_OR(       BS_AND(t, BS_VAL32(cccc3333)),
+	  BS_OR(BS_SHR(BS_AND(t, BS_VAL32(33330000)), 14),
+		BS_SHL(BS_AND(t, BS_VAL32(0000cccc)), 14)));
+
+      t = BS_OR(       BS_AND(t, BS_VAL16(    aa55)),
+          BS_OR(BS_SHR(BS_AND(t, BS_VAL16(    5500)), 7 ),
+		BS_SHL(BS_AND(t, BS_VAL16(    00aa)), 7 )));
+
+      t = BS_OR(       BS_AND(t, BS_VAL8 (      81)),
+
+	  BS_OR(BS_SHR(BS_AND(t, BS_VAL8 (      10)), 3 ),
+	  BS_OR(BS_SHR(BS_AND(t, BS_VAL8 (      20)), 2 ),
+	  BS_OR(BS_SHR(BS_AND(t, BS_VAL8 (      40)), 1 ),
+
+	  BS_OR(BS_SHL(BS_AND(t, BS_VAL8 (      02)), 1 ),
+	  BS_OR(BS_SHL(BS_AND(t, BS_VAL8 (      04)), 2 ),
+	        BS_SHL(BS_AND(t, BS_VAL8 (      08)), 3 )))))));
+
+      for (i = 0; i < 4; i++)
+	{
+	  unsigned int k = j * 4 + i;
+
+	  if (!pcks[k].data)
+	    return;
+
+	  if (index < pcks[k].len)
+	    pcks[k].data[index] ^= BS_EXTRACT8(t, 3 - i);
+	}
+    }
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose64.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose64.c
new file mode 100644
index 0000000..c75127b
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_transpose64.c
@@ -0,0 +1,186 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_bs.h"
+
+/***********************************************************************
+	Stream cipher transpose
+ */
+
+/* 64 rows of 64 bits transposition (bytes transp. - 8x8 rotate counterclockwise)*/
+
+void dvbcsa_bs_stream_transpose_in(const struct dvbcsa_bs_batch_s *pcks, dvbcsa_bs_word_t *row)
+{
+  int i, j;
+
+  for (i = 0; pcks[i].data; i++)
+    if (pcks[i].len >= 8)
+      row[i] = BS_VAL(dvbcsa_load_le64(pcks[i].data));
+
+  for (i = 0; i < 32; i++)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      t = row[i];
+      b = row[32 + i];
+      row[i]      = BS_OR(BS_AND(t, BS_VAL64(00000000ffffffff)), BS_SHL8(b, 4));
+      row[32 + i] = BS_OR(BS_AND(b, BS_VAL64(ffffffff00000000)), BS_SHR8(t, 4));
+    }
+
+  for (j = 0; j < 64; j += 32)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 16; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 16 + i];
+	  row[j + i]      = BS_OR(BS_AND(t, BS_VAL32(0000ffff)), BS_SHL8(BS_AND(b, BS_VAL32(0000ffff)), 2));
+	  row[j + 16 + i] = BS_OR(BS_AND(b, BS_VAL32(ffff0000)), BS_SHR8(BS_AND(t, BS_VAL32(ffff0000)), 2));
+	}
+    }
+
+  for (j = 0; j < 64; j += 16)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 8; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 8 + i];
+	  row[j + i]     = BS_OR(BS_AND(t, BS_VAL16(00ff)), BS_SHL8(BS_AND(b, BS_VAL16(00ff)), 1));
+	  row[j + 8 + i] = BS_OR(BS_AND(b, BS_VAL16(ff00)), BS_SHR8(BS_AND(t, BS_VAL16(ff00)), 1));
+	}
+    }
+
+  for (j = 0; j < 64; j += 8)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 4; i++)
+	{
+	  b = row[j + i];
+	  t = row[j + 4 + i];
+	  row[j + i]     = BS_OR(BS_AND(b, BS_VAL8(0f)), BS_SHL(BS_AND(t, BS_VAL8(0f)), 4));
+	  row[j + 4 + i] = BS_OR(BS_AND(t, BS_VAL8(f0)), BS_SHR(BS_AND(b, BS_VAL8(f0)), 4));
+	}
+    }
+
+  for (j = 0; j < 64; j += 4)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 2; i++)
+	{
+	  b = row[j + i];
+	  t = row[j + 2 + i];
+	  row[j + i]     = BS_OR(BS_AND(b, BS_VAL8(33)), BS_SHL(BS_AND(t, BS_VAL8(33)), 2));
+	  row[j + 2 + i] = BS_OR(BS_AND(t, BS_VAL8(cc)), BS_SHR(BS_AND(b, BS_VAL8(cc)), 2));
+	}
+    }
+
+  for (j = 0; j < 64; j += 2)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      b = row[j];
+      t = row[j + 1];
+      row[j]     = BS_OR(BS_AND(b, BS_VAL8(55)), BS_SHL(BS_AND(t, BS_VAL8(55)), 1));
+      row[j + 1] = BS_OR(BS_AND(t, BS_VAL8(aa)), BS_SHR(BS_AND(b, BS_VAL8(aa)), 1));
+    }
+}
+
+/* 8 rows of 64 bits transposition (bytes transp. - 8x8 rotate clockwise)*/
+
+void dvbcsa_bs_stream_transpose_out(const struct dvbcsa_bs_batch_s *pcks,
+				      unsigned int index, dvbcsa_bs_word_t *row)
+{
+  int i, j;
+
+  for (i = 0; i < 4; i++)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      t = row[i];
+      b = row[4 + i];
+      row[i]     = BS_OR(BS_AND(t, BS_VAL64(00000000ffffffff)), BS_SHL8(b, 4));
+      row[4 + i] = BS_OR(BS_AND(b, BS_VAL64(ffffffff00000000)), BS_SHR8(t, 4));
+    }
+
+  for (j = 0; j < 8; j += 4)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      for (i = 0; i < 2; i++)
+	{
+	  t = row[j + i];
+	  b = row[j + 2 + i];
+	  row[j + i]     = BS_OR(BS_AND(t, BS_VAL32(0000ffff)), BS_SHL8(BS_AND(b, BS_VAL32(0000ffff)), 2));
+	  row[j + 2 + i] = BS_OR(BS_AND(b, BS_VAL32(ffff0000)), BS_SHR8(BS_AND(t, BS_VAL32(ffff0000)), 2));
+	}
+    }
+
+  for (j = 0; j < 8; j += 2)
+    {
+      dvbcsa_bs_word_t t, b;
+
+      t = row[j];
+      b = row[j + 1];
+      row[j]     = BS_OR(BS_AND(t, BS_VAL16(00ff)), BS_SHL8(BS_AND(b, BS_VAL16(00ff)), 1));
+      row[j + 1] = BS_OR(BS_AND(b, BS_VAL16(ff00)), BS_SHR8(BS_AND(t, BS_VAL16(ff00)), 1));
+    }
+
+  for (j = 0; j < 8; j++)
+    {
+      dvbcsa_bs_word_t t;
+
+      t = row[j];
+
+      t = BS_OR(       BS_AND(t, BS_VAL64(f0f0f0f00f0f0f0f)),
+	  BS_OR(BS_SHR(BS_AND(t, BS_VAL64(0f0f0f0f00000000)), 28),
+		BS_SHL(BS_AND(t, BS_VAL64(00000000f0f0f0f0)), 28)));
+
+      t = BS_OR(       BS_AND(t, BS_VAL32(        cccc3333)),
+	  BS_OR(BS_SHR(BS_AND(t, BS_VAL32(        33330000)), 14),
+		BS_SHL(BS_AND(t, BS_VAL32(        0000cccc)), 14)));
+
+      t = BS_OR(       BS_AND(t, BS_VAL16(            aa55)),
+          BS_OR(BS_SHR(BS_AND(t, BS_VAL16(            5500)), 7 ),
+		BS_SHL(BS_AND(t, BS_VAL16(            00aa)), 7 )));
+
+      for (i = 0; i < BS_BATCH_BYTES; i++)
+	{
+	  unsigned int k = j * BS_BATCH_BYTES + i;
+
+	  if (!pcks[k].data)
+	    return;
+
+	  if (index < pcks[k].len)
+	  pcks[k].data[index] ^= BS_EXTRACT8(t, i);
+	}
+    }
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_uint32.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_uint32.h
new file mode 100644
index 0000000..4aa4efb
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_uint32.h
@@ -0,0 +1,53 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#ifndef DVBCSA_UINT32_H_
+#define DVBCSA_UINT32_H_
+
+typedef uint32_t dvbcsa_bs_word_t;
+
+#define BS_BATCH_SIZE 32
+#define BS_BATCH_BYTES 4
+
+#define BS_VAL(n)	((dvbcsa_bs_word_t)(n))
+#define BS_VAL32(n)	BS_VAL(0x##n)
+#define BS_VAL16(n)	BS_VAL32(n##n)
+#define BS_VAL8(n)	BS_VAL16(n##n)
+
+#define BS_AND(a, b)	((a) & (b))
+#define BS_OR(a, b)	((a) | (b))
+#define BS_XOR(a, b)	((a) ^ (b))
+#define BS_NOT(a)	(~(a))
+
+#define BS_SHL(a, n)	((a) << (n))
+#define BS_SHR(a, n)	((a) >> (n))
+#define BS_SHL8(a, n)	((a) << (8 * (n)))
+#define BS_SHR8(a, n)	((a) >> (8 * (n)))
+#define BS_EXTRACT8(a, n) ((a) >> (8 * (n)))
+
+#define BS_EMPTY()
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_uint64.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_uint64.h
new file mode 100644
index 0000000..a34b4bc
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_bs_uint64.h
@@ -0,0 +1,60 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    Based on FFdecsa, Copyright (C) 2003-2004  fatih89r
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#ifndef DVBCSA_UINT64_H_
+#define DVBCSA_UINT64_H_
+
+typedef uint64_t dvbcsa_bs_word_t;
+
+#define BS_BATCH_SIZE 64
+#define BS_BATCH_BYTES 8
+
+#define BS_VAL(n)	((dvbcsa_bs_word_t)(n))
+
+#if SIZEOF_LONG == 8
+#define BS_VAL64(n)	BS_VAL(0x##n##UL)
+#else
+#define BS_VAL64(n)	BS_VAL(0x##n##ULL)
+#endif
+
+#define BS_VAL32(n)	BS_VAL64(n##n)
+#define BS_VAL16(n)	BS_VAL32(n##n)
+#define BS_VAL8(n)	BS_VAL16(n##n)
+
+#define BS_AND(a, b)	((a) & (b))
+#define BS_OR(a, b)	((a) | (b))
+#define BS_XOR(a, b)	((a) ^ (b))
+#define BS_NOT(a)	(~(a))
+
+#define BS_SHL(a, n)	((a) << (n))
+#define BS_SHR(a, n)	((a) >> (n))
+#define BS_SHL8(a, n)	((a) << (8 * (n)))
+#define BS_SHR8(a, n)	((a) >> (8 * (n)))
+#define BS_EXTRACT8(a, n) ((a) >> (8 * (n)))
+
+#define BS_EMPTY()
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_key.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_key.c
new file mode 100644
index 0000000..a75bd02
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_key.c
@@ -0,0 +1,587 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    (c) 2006-2011 Alexandre Becoulet <alexandre.becoulet@free.fr>
+    (c) 2011 Erik Tews <e_tews at cdc.informatik.tu-darmstadt.de>
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_pv.h"
+
+static const uint64_t kperm[8][256] =
+  {
+    {
+      0x0000000000000000ULL, 0x0000000000080000ULL, 0x0000000008000000ULL, 0x0000000008080000ULL,
+      0x0080000000000000ULL, 0x0080000000080000ULL, 0x0080000008000000ULL, 0x0080000008080000ULL,
+      0x0000400000000000ULL, 0x0000400000080000ULL, 0x0000400008000000ULL, 0x0000400008080000ULL,
+      0x0080400000000000ULL, 0x0080400000080000ULL, 0x0080400008000000ULL, 0x0080400008080000ULL,
+      0x0000000000000002ULL, 0x0000000000080002ULL, 0x0000000008000002ULL, 0x0000000008080002ULL,
+      0x0080000000000002ULL, 0x0080000000080002ULL, 0x0080000008000002ULL, 0x0080000008080002ULL,
+      0x0000400000000002ULL, 0x0000400000080002ULL, 0x0000400008000002ULL, 0x0000400008080002ULL,
+      0x0080400000000002ULL, 0x0080400000080002ULL, 0x0080400008000002ULL, 0x0080400008080002ULL,
+      0x0000000000008000ULL, 0x0000000000088000ULL, 0x0000000008008000ULL, 0x0000000008088000ULL,
+      0x0080000000008000ULL, 0x0080000000088000ULL, 0x0080000008008000ULL, 0x0080000008088000ULL,
+      0x0000400000008000ULL, 0x0000400000088000ULL, 0x0000400008008000ULL, 0x0000400008088000ULL,
+      0x0080400000008000ULL, 0x0080400000088000ULL, 0x0080400008008000ULL, 0x0080400008088000ULL,
+      0x0000000000008002ULL, 0x0000000000088002ULL, 0x0000000008008002ULL, 0x0000000008088002ULL,
+      0x0080000000008002ULL, 0x0080000000088002ULL, 0x0080000008008002ULL, 0x0080000008088002ULL,
+      0x0000400000008002ULL, 0x0000400000088002ULL, 0x0000400008008002ULL, 0x0000400008088002ULL,
+      0x0080400000008002ULL, 0x0080400000088002ULL, 0x0080400008008002ULL, 0x0080400008088002ULL,
+      0x0000001000000000ULL, 0x0000001000080000ULL, 0x0000001008000000ULL, 0x0000001008080000ULL,
+      0x0080001000000000ULL, 0x0080001000080000ULL, 0x0080001008000000ULL, 0x0080001008080000ULL,
+      0x0000401000000000ULL, 0x0000401000080000ULL, 0x0000401008000000ULL, 0x0000401008080000ULL,
+      0x0080401000000000ULL, 0x0080401000080000ULL, 0x0080401008000000ULL, 0x0080401008080000ULL,
+      0x0000001000000002ULL, 0x0000001000080002ULL, 0x0000001008000002ULL, 0x0000001008080002ULL,
+      0x0080001000000002ULL, 0x0080001000080002ULL, 0x0080001008000002ULL, 0x0080001008080002ULL,
+      0x0000401000000002ULL, 0x0000401000080002ULL, 0x0000401008000002ULL, 0x0000401008080002ULL,
+      0x0080401000000002ULL, 0x0080401000080002ULL, 0x0080401008000002ULL, 0x0080401008080002ULL,
+      0x0000001000008000ULL, 0x0000001000088000ULL, 0x0000001008008000ULL, 0x0000001008088000ULL,
+      0x0080001000008000ULL, 0x0080001000088000ULL, 0x0080001008008000ULL, 0x0080001008088000ULL,
+      0x0000401000008000ULL, 0x0000401000088000ULL, 0x0000401008008000ULL, 0x0000401008088000ULL,
+      0x0080401000008000ULL, 0x0080401000088000ULL, 0x0080401008008000ULL, 0x0080401008088000ULL,
+      0x0000001000008002ULL, 0x0000001000088002ULL, 0x0000001008008002ULL, 0x0000001008088002ULL,
+      0x0080001000008002ULL, 0x0080001000088002ULL, 0x0080001008008002ULL, 0x0080001008088002ULL,
+      0x0000401000008002ULL, 0x0000401000088002ULL, 0x0000401008008002ULL, 0x0000401008088002ULL,
+      0x0080401000008002ULL, 0x0080401000088002ULL, 0x0080401008008002ULL, 0x0080401008088002ULL,
+      0x0000000000400000ULL, 0x0000000000480000ULL, 0x0000000008400000ULL, 0x0000000008480000ULL,
+      0x0080000000400000ULL, 0x0080000000480000ULL, 0x0080000008400000ULL, 0x0080000008480000ULL,
+      0x0000400000400000ULL, 0x0000400000480000ULL, 0x0000400008400000ULL, 0x0000400008480000ULL,
+      0x0080400000400000ULL, 0x0080400000480000ULL, 0x0080400008400000ULL, 0x0080400008480000ULL,
+      0x0000000000400002ULL, 0x0000000000480002ULL, 0x0000000008400002ULL, 0x0000000008480002ULL,
+      0x0080000000400002ULL, 0x0080000000480002ULL, 0x0080000008400002ULL, 0x0080000008480002ULL,
+      0x0000400000400002ULL, 0x0000400000480002ULL, 0x0000400008400002ULL, 0x0000400008480002ULL,
+      0x0080400000400002ULL, 0x0080400000480002ULL, 0x0080400008400002ULL, 0x0080400008480002ULL,
+      0x0000000000408000ULL, 0x0000000000488000ULL, 0x0000000008408000ULL, 0x0000000008488000ULL,
+      0x0080000000408000ULL, 0x0080000000488000ULL, 0x0080000008408000ULL, 0x0080000008488000ULL,
+      0x0000400000408000ULL, 0x0000400000488000ULL, 0x0000400008408000ULL, 0x0000400008488000ULL,
+      0x0080400000408000ULL, 0x0080400000488000ULL, 0x0080400008408000ULL, 0x0080400008488000ULL,
+      0x0000000000408002ULL, 0x0000000000488002ULL, 0x0000000008408002ULL, 0x0000000008488002ULL,
+      0x0080000000408002ULL, 0x0080000000488002ULL, 0x0080000008408002ULL, 0x0080000008488002ULL,
+      0x0000400000408002ULL, 0x0000400000488002ULL, 0x0000400008408002ULL, 0x0000400008488002ULL,
+      0x0080400000408002ULL, 0x0080400000488002ULL, 0x0080400008408002ULL, 0x0080400008488002ULL,
+      0x0000001000400000ULL, 0x0000001000480000ULL, 0x0000001008400000ULL, 0x0000001008480000ULL,
+      0x0080001000400000ULL, 0x0080001000480000ULL, 0x0080001008400000ULL, 0x0080001008480000ULL,
+      0x0000401000400000ULL, 0x0000401000480000ULL, 0x0000401008400000ULL, 0x0000401008480000ULL,
+      0x0080401000400000ULL, 0x0080401000480000ULL, 0x0080401008400000ULL, 0x0080401008480000ULL,
+      0x0000001000400002ULL, 0x0000001000480002ULL, 0x0000001008400002ULL, 0x0000001008480002ULL,
+      0x0080001000400002ULL, 0x0080001000480002ULL, 0x0080001008400002ULL, 0x0080001008480002ULL,
+      0x0000401000400002ULL, 0x0000401000480002ULL, 0x0000401008400002ULL, 0x0000401008480002ULL,
+      0x0080401000400002ULL, 0x0080401000480002ULL, 0x0080401008400002ULL, 0x0080401008480002ULL,
+      0x0000001000408000ULL, 0x0000001000488000ULL, 0x0000001008408000ULL, 0x0000001008488000ULL,
+      0x0080001000408000ULL, 0x0080001000488000ULL, 0x0080001008408000ULL, 0x0080001008488000ULL,
+      0x0000401000408000ULL, 0x0000401000488000ULL, 0x0000401008408000ULL, 0x0000401008488000ULL,
+      0x0080401000408000ULL, 0x0080401000488000ULL, 0x0080401008408000ULL, 0x0080401008488000ULL,
+      0x0000001000408002ULL, 0x0000001000488002ULL, 0x0000001008408002ULL, 0x0000001008488002ULL,
+      0x0080001000408002ULL, 0x0080001000488002ULL, 0x0080001008408002ULL, 0x0080001008488002ULL,
+      0x0000401000408002ULL, 0x0000401000488002ULL, 0x0000401008408002ULL, 0x0000401008488002ULL,
+      0x0080401000408002ULL, 0x0080401000488002ULL, 0x0080401008408002ULL, 0x0080401008488002ULL,
+    },
+    {
+      0x0000000000000000ULL, 0x0100000000000000ULL, 0x2000000000000000ULL, 0x2100000000000000ULL,
+      0x0000008000000000ULL, 0x0100008000000000ULL, 0x2000008000000000ULL, 0x2100008000000000ULL,
+      0x0000000000200000ULL, 0x0100000000200000ULL, 0x2000000000200000ULL, 0x2100000000200000ULL,
+      0x0000008000200000ULL, 0x0100008000200000ULL, 0x2000008000200000ULL, 0x2100008000200000ULL,
+      0x0040000000000000ULL, 0x0140000000000000ULL, 0x2040000000000000ULL, 0x2140000000000000ULL,
+      0x0040008000000000ULL, 0x0140008000000000ULL, 0x2040008000000000ULL, 0x2140008000000000ULL,
+      0x0040000000200000ULL, 0x0140000000200000ULL, 0x2040000000200000ULL, 0x2140000000200000ULL,
+      0x0040008000200000ULL, 0x0140008000200000ULL, 0x2040008000200000ULL, 0x2140008000200000ULL,
+      0x0400000000000000ULL, 0x0500000000000000ULL, 0x2400000000000000ULL, 0x2500000000000000ULL,
+      0x0400008000000000ULL, 0x0500008000000000ULL, 0x2400008000000000ULL, 0x2500008000000000ULL,
+      0x0400000000200000ULL, 0x0500000000200000ULL, 0x2400000000200000ULL, 0x2500000000200000ULL,
+      0x0400008000200000ULL, 0x0500008000200000ULL, 0x2400008000200000ULL, 0x2500008000200000ULL,
+      0x0440000000000000ULL, 0x0540000000000000ULL, 0x2440000000000000ULL, 0x2540000000000000ULL,
+      0x0440008000000000ULL, 0x0540008000000000ULL, 0x2440008000000000ULL, 0x2540008000000000ULL,
+      0x0440000000200000ULL, 0x0540000000200000ULL, 0x2440000000200000ULL, 0x2540000000200000ULL,
+      0x0440008000200000ULL, 0x0540008000200000ULL, 0x2440008000200000ULL, 0x2540008000200000ULL,
+      0x0004000000000000ULL, 0x0104000000000000ULL, 0x2004000000000000ULL, 0x2104000000000000ULL,
+      0x0004008000000000ULL, 0x0104008000000000ULL, 0x2004008000000000ULL, 0x2104008000000000ULL,
+      0x0004000000200000ULL, 0x0104000000200000ULL, 0x2004000000200000ULL, 0x2104000000200000ULL,
+      0x0004008000200000ULL, 0x0104008000200000ULL, 0x2004008000200000ULL, 0x2104008000200000ULL,
+      0x0044000000000000ULL, 0x0144000000000000ULL, 0x2044000000000000ULL, 0x2144000000000000ULL,
+      0x0044008000000000ULL, 0x0144008000000000ULL, 0x2044008000000000ULL, 0x2144008000000000ULL,
+      0x0044000000200000ULL, 0x0144000000200000ULL, 0x2044000000200000ULL, 0x2144000000200000ULL,
+      0x0044008000200000ULL, 0x0144008000200000ULL, 0x2044008000200000ULL, 0x2144008000200000ULL,
+      0x0404000000000000ULL, 0x0504000000000000ULL, 0x2404000000000000ULL, 0x2504000000000000ULL,
+      0x0404008000000000ULL, 0x0504008000000000ULL, 0x2404008000000000ULL, 0x2504008000000000ULL,
+      0x0404000000200000ULL, 0x0504000000200000ULL, 0x2404000000200000ULL, 0x2504000000200000ULL,
+      0x0404008000200000ULL, 0x0504008000200000ULL, 0x2404008000200000ULL, 0x2504008000200000ULL,
+      0x0444000000000000ULL, 0x0544000000000000ULL, 0x2444000000000000ULL, 0x2544000000000000ULL,
+      0x0444008000000000ULL, 0x0544008000000000ULL, 0x2444008000000000ULL, 0x2544008000000000ULL,
+      0x0444000000200000ULL, 0x0544000000200000ULL, 0x2444000000200000ULL, 0x2544000000200000ULL,
+      0x0444008000200000ULL, 0x0544008000200000ULL, 0x2444008000200000ULL, 0x2544008000200000ULL,
+      0x0000000010000000ULL, 0x0100000010000000ULL, 0x2000000010000000ULL, 0x2100000010000000ULL,
+      0x0000008010000000ULL, 0x0100008010000000ULL, 0x2000008010000000ULL, 0x2100008010000000ULL,
+      0x0000000010200000ULL, 0x0100000010200000ULL, 0x2000000010200000ULL, 0x2100000010200000ULL,
+      0x0000008010200000ULL, 0x0100008010200000ULL, 0x2000008010200000ULL, 0x2100008010200000ULL,
+      0x0040000010000000ULL, 0x0140000010000000ULL, 0x2040000010000000ULL, 0x2140000010000000ULL,
+      0x0040008010000000ULL, 0x0140008010000000ULL, 0x2040008010000000ULL, 0x2140008010000000ULL,
+      0x0040000010200000ULL, 0x0140000010200000ULL, 0x2040000010200000ULL, 0x2140000010200000ULL,
+      0x0040008010200000ULL, 0x0140008010200000ULL, 0x2040008010200000ULL, 0x2140008010200000ULL,
+      0x0400000010000000ULL, 0x0500000010000000ULL, 0x2400000010000000ULL, 0x2500000010000000ULL,
+      0x0400008010000000ULL, 0x0500008010000000ULL, 0x2400008010000000ULL, 0x2500008010000000ULL,
+      0x0400000010200000ULL, 0x0500000010200000ULL, 0x2400000010200000ULL, 0x2500000010200000ULL,
+      0x0400008010200000ULL, 0x0500008010200000ULL, 0x2400008010200000ULL, 0x2500008010200000ULL,
+      0x0440000010000000ULL, 0x0540000010000000ULL, 0x2440000010000000ULL, 0x2540000010000000ULL,
+      0x0440008010000000ULL, 0x0540008010000000ULL, 0x2440008010000000ULL, 0x2540008010000000ULL,
+      0x0440000010200000ULL, 0x0540000010200000ULL, 0x2440000010200000ULL, 0x2540000010200000ULL,
+      0x0440008010200000ULL, 0x0540008010200000ULL, 0x2440008010200000ULL, 0x2540008010200000ULL,
+      0x0004000010000000ULL, 0x0104000010000000ULL, 0x2004000010000000ULL, 0x2104000010000000ULL,
+      0x0004008010000000ULL, 0x0104008010000000ULL, 0x2004008010000000ULL, 0x2104008010000000ULL,
+      0x0004000010200000ULL, 0x0104000010200000ULL, 0x2004000010200000ULL, 0x2104000010200000ULL,
+      0x0004008010200000ULL, 0x0104008010200000ULL, 0x2004008010200000ULL, 0x2104008010200000ULL,
+      0x0044000010000000ULL, 0x0144000010000000ULL, 0x2044000010000000ULL, 0x2144000010000000ULL,
+      0x0044008010000000ULL, 0x0144008010000000ULL, 0x2044008010000000ULL, 0x2144008010000000ULL,
+      0x0044000010200000ULL, 0x0144000010200000ULL, 0x2044000010200000ULL, 0x2144000010200000ULL,
+      0x0044008010200000ULL, 0x0144008010200000ULL, 0x2044008010200000ULL, 0x2144008010200000ULL,
+      0x0404000010000000ULL, 0x0504000010000000ULL, 0x2404000010000000ULL, 0x2504000010000000ULL,
+      0x0404008010000000ULL, 0x0504008010000000ULL, 0x2404008010000000ULL, 0x2504008010000000ULL,
+      0x0404000010200000ULL, 0x0504000010200000ULL, 0x2404000010200000ULL, 0x2504000010200000ULL,
+      0x0404008010200000ULL, 0x0504008010200000ULL, 0x2404008010200000ULL, 0x2504008010200000ULL,
+      0x0444000010000000ULL, 0x0544000010000000ULL, 0x2444000010000000ULL, 0x2544000010000000ULL,
+      0x0444008010000000ULL, 0x0544008010000000ULL, 0x2444008010000000ULL, 0x2544008010000000ULL,
+      0x0444000010200000ULL, 0x0544000010200000ULL, 0x2444000010200000ULL, 0x2544000010200000ULL,
+      0x0444008010200000ULL, 0x0544008010200000ULL, 0x2444008010200000ULL, 0x2544008010200000ULL,
+    },
+    {
+      0x0000000000000000ULL, 0x0000000000000080ULL, 0x0000000020000000ULL, 0x0000000020000080ULL,
+      0x0008000000000000ULL, 0x0008000000000080ULL, 0x0008000020000000ULL, 0x0008000020000080ULL,
+      0x0000000000000040ULL, 0x00000000000000c0ULL, 0x0000000020000040ULL, 0x00000000200000c0ULL,
+      0x0008000000000040ULL, 0x00080000000000c0ULL, 0x0008000020000040ULL, 0x00080000200000c0ULL,
+      0x0000000200000000ULL, 0x0000000200000080ULL, 0x0000000220000000ULL, 0x0000000220000080ULL,
+      0x0008000200000000ULL, 0x0008000200000080ULL, 0x0008000220000000ULL, 0x0008000220000080ULL,
+      0x0000000200000040ULL, 0x00000002000000c0ULL, 0x0000000220000040ULL, 0x00000002200000c0ULL,
+      0x0008000200000040ULL, 0x00080002000000c0ULL, 0x0008000220000040ULL, 0x00080002200000c0ULL,
+      0x0000000800000000ULL, 0x0000000800000080ULL, 0x0000000820000000ULL, 0x0000000820000080ULL,
+      0x0008000800000000ULL, 0x0008000800000080ULL, 0x0008000820000000ULL, 0x0008000820000080ULL,
+      0x0000000800000040ULL, 0x00000008000000c0ULL, 0x0000000820000040ULL, 0x00000008200000c0ULL,
+      0x0008000800000040ULL, 0x00080008000000c0ULL, 0x0008000820000040ULL, 0x00080008200000c0ULL,
+      0x0000000a00000000ULL, 0x0000000a00000080ULL, 0x0000000a20000000ULL, 0x0000000a20000080ULL,
+      0x0008000a00000000ULL, 0x0008000a00000080ULL, 0x0008000a20000000ULL, 0x0008000a20000080ULL,
+      0x0000000a00000040ULL, 0x0000000a000000c0ULL, 0x0000000a20000040ULL, 0x0000000a200000c0ULL,
+      0x0008000a00000040ULL, 0x0008000a000000c0ULL, 0x0008000a20000040ULL, 0x0008000a200000c0ULL,
+      0x0000000000100000ULL, 0x0000000000100080ULL, 0x0000000020100000ULL, 0x0000000020100080ULL,
+      0x0008000000100000ULL, 0x0008000000100080ULL, 0x0008000020100000ULL, 0x0008000020100080ULL,
+      0x0000000000100040ULL, 0x00000000001000c0ULL, 0x0000000020100040ULL, 0x00000000201000c0ULL,
+      0x0008000000100040ULL, 0x00080000001000c0ULL, 0x0008000020100040ULL, 0x00080000201000c0ULL,
+      0x0000000200100000ULL, 0x0000000200100080ULL, 0x0000000220100000ULL, 0x0000000220100080ULL,
+      0x0008000200100000ULL, 0x0008000200100080ULL, 0x0008000220100000ULL, 0x0008000220100080ULL,
+      0x0000000200100040ULL, 0x00000002001000c0ULL, 0x0000000220100040ULL, 0x00000002201000c0ULL,
+      0x0008000200100040ULL, 0x00080002001000c0ULL, 0x0008000220100040ULL, 0x00080002201000c0ULL,
+      0x0000000800100000ULL, 0x0000000800100080ULL, 0x0000000820100000ULL, 0x0000000820100080ULL,
+      0x0008000800100000ULL, 0x0008000800100080ULL, 0x0008000820100000ULL, 0x0008000820100080ULL,
+      0x0000000800100040ULL, 0x00000008001000c0ULL, 0x0000000820100040ULL, 0x00000008201000c0ULL,
+      0x0008000800100040ULL, 0x00080008001000c0ULL, 0x0008000820100040ULL, 0x00080008201000c0ULL,
+      0x0000000a00100000ULL, 0x0000000a00100080ULL, 0x0000000a20100000ULL, 0x0000000a20100080ULL,
+      0x0008000a00100000ULL, 0x0008000a00100080ULL, 0x0008000a20100000ULL, 0x0008000a20100080ULL,
+      0x0000000a00100040ULL, 0x0000000a001000c0ULL, 0x0000000a20100040ULL, 0x0000000a201000c0ULL,
+      0x0008000a00100040ULL, 0x0008000a001000c0ULL, 0x0008000a20100040ULL, 0x0008000a201000c0ULL,
+      0x0000000000010000ULL, 0x0000000000010080ULL, 0x0000000020010000ULL, 0x0000000020010080ULL,
+      0x0008000000010000ULL, 0x0008000000010080ULL, 0x0008000020010000ULL, 0x0008000020010080ULL,
+      0x0000000000010040ULL, 0x00000000000100c0ULL, 0x0000000020010040ULL, 0x00000000200100c0ULL,
+      0x0008000000010040ULL, 0x00080000000100c0ULL, 0x0008000020010040ULL, 0x00080000200100c0ULL,
+      0x0000000200010000ULL, 0x0000000200010080ULL, 0x0000000220010000ULL, 0x0000000220010080ULL,
+      0x0008000200010000ULL, 0x0008000200010080ULL, 0x0008000220010000ULL, 0x0008000220010080ULL,
+      0x0000000200010040ULL, 0x00000002000100c0ULL, 0x0000000220010040ULL, 0x00000002200100c0ULL,
+      0x0008000200010040ULL, 0x00080002000100c0ULL, 0x0008000220010040ULL, 0x00080002200100c0ULL,
+      0x0000000800010000ULL, 0x0000000800010080ULL, 0x0000000820010000ULL, 0x0000000820010080ULL,
+      0x0008000800010000ULL, 0x0008000800010080ULL, 0x0008000820010000ULL, 0x0008000820010080ULL,
+      0x0000000800010040ULL, 0x00000008000100c0ULL, 0x0000000820010040ULL, 0x00000008200100c0ULL,
+      0x0008000800010040ULL, 0x00080008000100c0ULL, 0x0008000820010040ULL, 0x00080008200100c0ULL,
+      0x0000000a00010000ULL, 0x0000000a00010080ULL, 0x0000000a20010000ULL, 0x0000000a20010080ULL,
+      0x0008000a00010000ULL, 0x0008000a00010080ULL, 0x0008000a20010000ULL, 0x0008000a20010080ULL,
+      0x0000000a00010040ULL, 0x0000000a000100c0ULL, 0x0000000a20010040ULL, 0x0000000a200100c0ULL,
+      0x0008000a00010040ULL, 0x0008000a000100c0ULL, 0x0008000a20010040ULL, 0x0008000a200100c0ULL,
+      0x0000000000110000ULL, 0x0000000000110080ULL, 0x0000000020110000ULL, 0x0000000020110080ULL,
+      0x0008000000110000ULL, 0x0008000000110080ULL, 0x0008000020110000ULL, 0x0008000020110080ULL,
+      0x0000000000110040ULL, 0x00000000001100c0ULL, 0x0000000020110040ULL, 0x00000000201100c0ULL,
+      0x0008000000110040ULL, 0x00080000001100c0ULL, 0x0008000020110040ULL, 0x00080000201100c0ULL,
+      0x0000000200110000ULL, 0x0000000200110080ULL, 0x0000000220110000ULL, 0x0000000220110080ULL,
+      0x0008000200110000ULL, 0x0008000200110080ULL, 0x0008000220110000ULL, 0x0008000220110080ULL,
+      0x0000000200110040ULL, 0x00000002001100c0ULL, 0x0000000220110040ULL, 0x00000002201100c0ULL,
+      0x0008000200110040ULL, 0x00080002001100c0ULL, 0x0008000220110040ULL, 0x00080002201100c0ULL,
+      0x0000000800110000ULL, 0x0000000800110080ULL, 0x0000000820110000ULL, 0x0000000820110080ULL,
+      0x0008000800110000ULL, 0x0008000800110080ULL, 0x0008000820110000ULL, 0x0008000820110080ULL,
+      0x0000000800110040ULL, 0x00000008001100c0ULL, 0x0000000820110040ULL, 0x00000008201100c0ULL,
+      0x0008000800110040ULL, 0x00080008001100c0ULL, 0x0008000820110040ULL, 0x00080008201100c0ULL,
+      0x0000000a00110000ULL, 0x0000000a00110080ULL, 0x0000000a20110000ULL, 0x0000000a20110080ULL,
+      0x0008000a00110000ULL, 0x0008000a00110080ULL, 0x0008000a20110000ULL, 0x0008000a20110080ULL,
+      0x0000000a00110040ULL, 0x0000000a001100c0ULL, 0x0000000a20110040ULL, 0x0000000a201100c0ULL,
+      0x0008000a00110040ULL, 0x0008000a001100c0ULL, 0x0008000a20110040ULL, 0x0008000a201100c0ULL,
+    },
+    {
+      0x0000000000000000ULL, 0x0000800000000000ULL, 0x0000000040000000ULL, 0x0000800040000000ULL,
+      0x0000000100000000ULL, 0x0000800100000000ULL, 0x0000000140000000ULL, 0x0000800140000000ULL,
+      0x8000000000000000ULL, 0x8000800000000000ULL, 0x8000000040000000ULL, 0x8000800040000000ULL,
+      0x8000000100000000ULL, 0x8000800100000000ULL, 0x8000000140000000ULL, 0x8000800140000000ULL,
+      0x0000000000000400ULL, 0x0000800000000400ULL, 0x0000000040000400ULL, 0x0000800040000400ULL,
+      0x0000000100000400ULL, 0x0000800100000400ULL, 0x0000000140000400ULL, 0x0000800140000400ULL,
+      0x8000000000000400ULL, 0x8000800000000400ULL, 0x8000000040000400ULL, 0x8000800040000400ULL,
+      0x8000000100000400ULL, 0x8000800100000400ULL, 0x8000000140000400ULL, 0x8000800140000400ULL,
+      0x0000000000000800ULL, 0x0000800000000800ULL, 0x0000000040000800ULL, 0x0000800040000800ULL,
+      0x0000000100000800ULL, 0x0000800100000800ULL, 0x0000000140000800ULL, 0x0000800140000800ULL,
+      0x8000000000000800ULL, 0x8000800000000800ULL, 0x8000000040000800ULL, 0x8000800040000800ULL,
+      0x8000000100000800ULL, 0x8000800100000800ULL, 0x8000000140000800ULL, 0x8000800140000800ULL,
+      0x0000000000000c00ULL, 0x0000800000000c00ULL, 0x0000000040000c00ULL, 0x0000800040000c00ULL,
+      0x0000000100000c00ULL, 0x0000800100000c00ULL, 0x0000000140000c00ULL, 0x0000800140000c00ULL,
+      0x8000000000000c00ULL, 0x8000800000000c00ULL, 0x8000000040000c00ULL, 0x8000800040000c00ULL,
+      0x8000000100000c00ULL, 0x8000800100000c00ULL, 0x8000000140000c00ULL, 0x8000800140000c00ULL,
+      0x0000000000000010ULL, 0x0000800000000010ULL, 0x0000000040000010ULL, 0x0000800040000010ULL,
+      0x0000000100000010ULL, 0x0000800100000010ULL, 0x0000000140000010ULL, 0x0000800140000010ULL,
+      0x8000000000000010ULL, 0x8000800000000010ULL, 0x8000000040000010ULL, 0x8000800040000010ULL,
+      0x8000000100000010ULL, 0x8000800100000010ULL, 0x8000000140000010ULL, 0x8000800140000010ULL,
+      0x0000000000000410ULL, 0x0000800000000410ULL, 0x0000000040000410ULL, 0x0000800040000410ULL,
+      0x0000000100000410ULL, 0x0000800100000410ULL, 0x0000000140000410ULL, 0x0000800140000410ULL,
+      0x8000000000000410ULL, 0x8000800000000410ULL, 0x8000000040000410ULL, 0x8000800040000410ULL,
+      0x8000000100000410ULL, 0x8000800100000410ULL, 0x8000000140000410ULL, 0x8000800140000410ULL,
+      0x0000000000000810ULL, 0x0000800000000810ULL, 0x0000000040000810ULL, 0x0000800040000810ULL,
+      0x0000000100000810ULL, 0x0000800100000810ULL, 0x0000000140000810ULL, 0x0000800140000810ULL,
+      0x8000000000000810ULL, 0x8000800000000810ULL, 0x8000000040000810ULL, 0x8000800040000810ULL,
+      0x8000000100000810ULL, 0x8000800100000810ULL, 0x8000000140000810ULL, 0x8000800140000810ULL,
+      0x0000000000000c10ULL, 0x0000800000000c10ULL, 0x0000000040000c10ULL, 0x0000800040000c10ULL,
+      0x0000000100000c10ULL, 0x0000800100000c10ULL, 0x0000000140000c10ULL, 0x0000800140000c10ULL,
+      0x8000000000000c10ULL, 0x8000800000000c10ULL, 0x8000000040000c10ULL, 0x8000800040000c10ULL,
+      0x8000000100000c10ULL, 0x8000800100000c10ULL, 0x8000000140000c10ULL, 0x8000800140000c10ULL,
+      0x0000004000000000ULL, 0x0000804000000000ULL, 0x0000004040000000ULL, 0x0000804040000000ULL,
+      0x0000004100000000ULL, 0x0000804100000000ULL, 0x0000004140000000ULL, 0x0000804140000000ULL,
+      0x8000004000000000ULL, 0x8000804000000000ULL, 0x8000004040000000ULL, 0x8000804040000000ULL,
+      0x8000004100000000ULL, 0x8000804100000000ULL, 0x8000004140000000ULL, 0x8000804140000000ULL,
+      0x0000004000000400ULL, 0x0000804000000400ULL, 0x0000004040000400ULL, 0x0000804040000400ULL,
+      0x0000004100000400ULL, 0x0000804100000400ULL, 0x0000004140000400ULL, 0x0000804140000400ULL,
+      0x8000004000000400ULL, 0x8000804000000400ULL, 0x8000004040000400ULL, 0x8000804040000400ULL,
+      0x8000004100000400ULL, 0x8000804100000400ULL, 0x8000004140000400ULL, 0x8000804140000400ULL,
+      0x0000004000000800ULL, 0x0000804000000800ULL, 0x0000004040000800ULL, 0x0000804040000800ULL,
+      0x0000004100000800ULL, 0x0000804100000800ULL, 0x0000004140000800ULL, 0x0000804140000800ULL,
+      0x8000004000000800ULL, 0x8000804000000800ULL, 0x8000004040000800ULL, 0x8000804040000800ULL,
+      0x8000004100000800ULL, 0x8000804100000800ULL, 0x8000004140000800ULL, 0x8000804140000800ULL,
+      0x0000004000000c00ULL, 0x0000804000000c00ULL, 0x0000004040000c00ULL, 0x0000804040000c00ULL,
+      0x0000004100000c00ULL, 0x0000804100000c00ULL, 0x0000004140000c00ULL, 0x0000804140000c00ULL,
+      0x8000004000000c00ULL, 0x8000804000000c00ULL, 0x8000004040000c00ULL, 0x8000804040000c00ULL,
+      0x8000004100000c00ULL, 0x8000804100000c00ULL, 0x8000004140000c00ULL, 0x8000804140000c00ULL,
+      0x0000004000000010ULL, 0x0000804000000010ULL, 0x0000004040000010ULL, 0x0000804040000010ULL,
+      0x0000004100000010ULL, 0x0000804100000010ULL, 0x0000004140000010ULL, 0x0000804140000010ULL,
+      0x8000004000000010ULL, 0x8000804000000010ULL, 0x8000004040000010ULL, 0x8000804040000010ULL,
+      0x8000004100000010ULL, 0x8000804100000010ULL, 0x8000004140000010ULL, 0x8000804140000010ULL,
+      0x0000004000000410ULL, 0x0000804000000410ULL, 0x0000004040000410ULL, 0x0000804040000410ULL,
+      0x0000004100000410ULL, 0x0000804100000410ULL, 0x0000004140000410ULL, 0x0000804140000410ULL,
+      0x8000004000000410ULL, 0x8000804000000410ULL, 0x8000004040000410ULL, 0x8000804040000410ULL,
+      0x8000004100000410ULL, 0x8000804100000410ULL, 0x8000004140000410ULL, 0x8000804140000410ULL,
+      0x0000004000000810ULL, 0x0000804000000810ULL, 0x0000004040000810ULL, 0x0000804040000810ULL,
+      0x0000004100000810ULL, 0x0000804100000810ULL, 0x0000004140000810ULL, 0x0000804140000810ULL,
+      0x8000004000000810ULL, 0x8000804000000810ULL, 0x8000004040000810ULL, 0x8000804040000810ULL,
+      0x8000004100000810ULL, 0x8000804100000810ULL, 0x8000004140000810ULL, 0x8000804140000810ULL,
+      0x0000004000000c10ULL, 0x0000804000000c10ULL, 0x0000004040000c10ULL, 0x0000804040000c10ULL,
+      0x0000004100000c10ULL, 0x0000804100000c10ULL, 0x0000004140000c10ULL, 0x0000804140000c10ULL,
+      0x8000004000000c10ULL, 0x8000804000000c10ULL, 0x8000004040000c10ULL, 0x8000804040000c10ULL,
+      0x8000004100000c10ULL, 0x8000804100000c10ULL, 0x8000004140000c10ULL, 0x8000804140000c10ULL,
+    },
+    {
+      0x0000000000000000ULL, 0x4000000000000000ULL, 0x0000000004000000ULL, 0x4000000004000000ULL,
+      0x0000010000000000ULL, 0x4000010000000000ULL, 0x0000010004000000ULL, 0x4000010004000000ULL,
+      0x0000000000040000ULL, 0x4000000000040000ULL, 0x0000000004040000ULL, 0x4000000004040000ULL,
+      0x0000010000040000ULL, 0x4000010000040000ULL, 0x0000010004040000ULL, 0x4000010004040000ULL,
+      0x0000000000001000ULL, 0x4000000000001000ULL, 0x0000000004001000ULL, 0x4000000004001000ULL,
+      0x0000010000001000ULL, 0x4000010000001000ULL, 0x0000010004001000ULL, 0x4000010004001000ULL,
+      0x0000000000041000ULL, 0x4000000000041000ULL, 0x0000000004041000ULL, 0x4000000004041000ULL,
+      0x0000010000041000ULL, 0x4000010000041000ULL, 0x0000010004041000ULL, 0x4000010004041000ULL,
+      0x0010000000000000ULL, 0x4010000000000000ULL, 0x0010000004000000ULL, 0x4010000004000000ULL,
+      0x0010010000000000ULL, 0x4010010000000000ULL, 0x0010010004000000ULL, 0x4010010004000000ULL,
+      0x0010000000040000ULL, 0x4010000000040000ULL, 0x0010000004040000ULL, 0x4010000004040000ULL,
+      0x0010010000040000ULL, 0x4010010000040000ULL, 0x0010010004040000ULL, 0x4010010004040000ULL,
+      0x0010000000001000ULL, 0x4010000000001000ULL, 0x0010000004001000ULL, 0x4010000004001000ULL,
+      0x0010010000001000ULL, 0x4010010000001000ULL, 0x0010010004001000ULL, 0x4010010004001000ULL,
+      0x0010000000041000ULL, 0x4010000000041000ULL, 0x0010000004041000ULL, 0x4010000004041000ULL,
+      0x0010010000041000ULL, 0x4010010000041000ULL, 0x0010010004041000ULL, 0x4010010004041000ULL,
+      0x0000002000000000ULL, 0x4000002000000000ULL, 0x0000002004000000ULL, 0x4000002004000000ULL,
+      0x0000012000000000ULL, 0x4000012000000000ULL, 0x0000012004000000ULL, 0x4000012004000000ULL,
+      0x0000002000040000ULL, 0x4000002000040000ULL, 0x0000002004040000ULL, 0x4000002004040000ULL,
+      0x0000012000040000ULL, 0x4000012000040000ULL, 0x0000012004040000ULL, 0x4000012004040000ULL,
+      0x0000002000001000ULL, 0x4000002000001000ULL, 0x0000002004001000ULL, 0x4000002004001000ULL,
+      0x0000012000001000ULL, 0x4000012000001000ULL, 0x0000012004001000ULL, 0x4000012004001000ULL,
+      0x0000002000041000ULL, 0x4000002000041000ULL, 0x0000002004041000ULL, 0x4000002004041000ULL,
+      0x0000012000041000ULL, 0x4000012000041000ULL, 0x0000012004041000ULL, 0x4000012004041000ULL,
+      0x0010002000000000ULL, 0x4010002000000000ULL, 0x0010002004000000ULL, 0x4010002004000000ULL,
+      0x0010012000000000ULL, 0x4010012000000000ULL, 0x0010012004000000ULL, 0x4010012004000000ULL,
+      0x0010002000040000ULL, 0x4010002000040000ULL, 0x0010002004040000ULL, 0x4010002004040000ULL,
+      0x0010012000040000ULL, 0x4010012000040000ULL, 0x0010012004040000ULL, 0x4010012004040000ULL,
+      0x0010002000001000ULL, 0x4010002000001000ULL, 0x0010002004001000ULL, 0x4010002004001000ULL,
+      0x0010012000001000ULL, 0x4010012000001000ULL, 0x0010012004001000ULL, 0x4010012004001000ULL,
+      0x0010002000041000ULL, 0x4010002000041000ULL, 0x0010002004041000ULL, 0x4010002004041000ULL,
+      0x0010012000041000ULL, 0x4010012000041000ULL, 0x0010012004041000ULL, 0x4010012004041000ULL,
+      0x0020000000000000ULL, 0x4020000000000000ULL, 0x0020000004000000ULL, 0x4020000004000000ULL,
+      0x0020010000000000ULL, 0x4020010000000000ULL, 0x0020010004000000ULL, 0x4020010004000000ULL,
+      0x0020000000040000ULL, 0x4020000000040000ULL, 0x0020000004040000ULL, 0x4020000004040000ULL,
+      0x0020010000040000ULL, 0x4020010000040000ULL, 0x0020010004040000ULL, 0x4020010004040000ULL,
+      0x0020000000001000ULL, 0x4020000000001000ULL, 0x0020000004001000ULL, 0x4020000004001000ULL,
+      0x0020010000001000ULL, 0x4020010000001000ULL, 0x0020010004001000ULL, 0x4020010004001000ULL,
+      0x0020000000041000ULL, 0x4020000000041000ULL, 0x0020000004041000ULL, 0x4020000004041000ULL,
+      0x0020010000041000ULL, 0x4020010000041000ULL, 0x0020010004041000ULL, 0x4020010004041000ULL,
+      0x0030000000000000ULL, 0x4030000000000000ULL, 0x0030000004000000ULL, 0x4030000004000000ULL,
+      0x0030010000000000ULL, 0x4030010000000000ULL, 0x0030010004000000ULL, 0x4030010004000000ULL,
+      0x0030000000040000ULL, 0x4030000000040000ULL, 0x0030000004040000ULL, 0x4030000004040000ULL,
+      0x0030010000040000ULL, 0x4030010000040000ULL, 0x0030010004040000ULL, 0x4030010004040000ULL,
+      0x0030000000001000ULL, 0x4030000000001000ULL, 0x0030000004001000ULL, 0x4030000004001000ULL,
+      0x0030010000001000ULL, 0x4030010000001000ULL, 0x0030010004001000ULL, 0x4030010004001000ULL,
+      0x0030000000041000ULL, 0x4030000000041000ULL, 0x0030000004041000ULL, 0x4030000004041000ULL,
+      0x0030010000041000ULL, 0x4030010000041000ULL, 0x0030010004041000ULL, 0x4030010004041000ULL,
+      0x0020002000000000ULL, 0x4020002000000000ULL, 0x0020002004000000ULL, 0x4020002004000000ULL,
+      0x0020012000000000ULL, 0x4020012000000000ULL, 0x0020012004000000ULL, 0x4020012004000000ULL,
+      0x0020002000040000ULL, 0x4020002000040000ULL, 0x0020002004040000ULL, 0x4020002004040000ULL,
+      0x0020012000040000ULL, 0x4020012000040000ULL, 0x0020012004040000ULL, 0x4020012004040000ULL,
+      0x0020002000001000ULL, 0x4020002000001000ULL, 0x0020002004001000ULL, 0x4020002004001000ULL,
+      0x0020012000001000ULL, 0x4020012000001000ULL, 0x0020012004001000ULL, 0x4020012004001000ULL,
+      0x0020002000041000ULL, 0x4020002000041000ULL, 0x0020002004041000ULL, 0x4020002004041000ULL,
+      0x0020012000041000ULL, 0x4020012000041000ULL, 0x0020012004041000ULL, 0x4020012004041000ULL,
+      0x0030002000000000ULL, 0x4030002000000000ULL, 0x0030002004000000ULL, 0x4030002004000000ULL,
+      0x0030012000000000ULL, 0x4030012000000000ULL, 0x0030012004000000ULL, 0x4030012004000000ULL,
+      0x0030002000040000ULL, 0x4030002000040000ULL, 0x0030002004040000ULL, 0x4030002004040000ULL,
+      0x0030012000040000ULL, 0x4030012000040000ULL, 0x0030012004040000ULL, 0x4030012004040000ULL,
+      0x0030002000001000ULL, 0x4030002000001000ULL, 0x0030002004001000ULL, 0x4030002004001000ULL,
+      0x0030012000001000ULL, 0x4030012000001000ULL, 0x0030012004001000ULL, 0x4030012004001000ULL,
+      0x0030002000041000ULL, 0x4030002000041000ULL, 0x0030002004041000ULL, 0x4030002004041000ULL,
+      0x0030012000041000ULL, 0x4030012000041000ULL, 0x0030012004041000ULL, 0x4030012004041000ULL,
+    },
+    {
+      0x0000000000000000ULL, 0x0000000000800000ULL, 0x0800000000000000ULL, 0x0800000000800000ULL,
+      0x0000020000000000ULL, 0x0000020000800000ULL, 0x0800020000000000ULL, 0x0800020000800000ULL,
+      0x0000000000020000ULL, 0x0000000000820000ULL, 0x0800000000020000ULL, 0x0800000000820000ULL,
+      0x0000020000020000ULL, 0x0000020000820000ULL, 0x0800020000020000ULL, 0x0800020000820000ULL,
+      0x0000000080000000ULL, 0x0000000080800000ULL, 0x0800000080000000ULL, 0x0800000080800000ULL,
+      0x0000020080000000ULL, 0x0000020080800000ULL, 0x0800020080000000ULL, 0x0800020080800000ULL,
+      0x0000000080020000ULL, 0x0000000080820000ULL, 0x0800000080020000ULL, 0x0800000080820000ULL,
+      0x0000020080020000ULL, 0x0000020080820000ULL, 0x0800020080020000ULL, 0x0800020080820000ULL,
+      0x0000000000000001ULL, 0x0000000000800001ULL, 0x0800000000000001ULL, 0x0800000000800001ULL,
+      0x0000020000000001ULL, 0x0000020000800001ULL, 0x0800020000000001ULL, 0x0800020000800001ULL,
+      0x0000000000020001ULL, 0x0000000000820001ULL, 0x0800000000020001ULL, 0x0800000000820001ULL,
+      0x0000020000020001ULL, 0x0000020000820001ULL, 0x0800020000020001ULL, 0x0800020000820001ULL,
+      0x0000000080000001ULL, 0x0000000080800001ULL, 0x0800000080000001ULL, 0x0800000080800001ULL,
+      0x0000020080000001ULL, 0x0000020080800001ULL, 0x0800020080000001ULL, 0x0800020080800001ULL,
+      0x0000000080020001ULL, 0x0000000080820001ULL, 0x0800000080020001ULL, 0x0800000080820001ULL,
+      0x0000020080020001ULL, 0x0000020080820001ULL, 0x0800020080020001ULL, 0x0800020080820001ULL,
+      0x0000000002000000ULL, 0x0000000002800000ULL, 0x0800000002000000ULL, 0x0800000002800000ULL,
+      0x0000020002000000ULL, 0x0000020002800000ULL, 0x0800020002000000ULL, 0x0800020002800000ULL,
+      0x0000000002020000ULL, 0x0000000002820000ULL, 0x0800000002020000ULL, 0x0800000002820000ULL,
+      0x0000020002020000ULL, 0x0000020002820000ULL, 0x0800020002020000ULL, 0x0800020002820000ULL,
+      0x0000000082000000ULL, 0x0000000082800000ULL, 0x0800000082000000ULL, 0x0800000082800000ULL,
+      0x0000020082000000ULL, 0x0000020082800000ULL, 0x0800020082000000ULL, 0x0800020082800000ULL,
+      0x0000000082020000ULL, 0x0000000082820000ULL, 0x0800000082020000ULL, 0x0800000082820000ULL,
+      0x0000020082020000ULL, 0x0000020082820000ULL, 0x0800020082020000ULL, 0x0800020082820000ULL,
+      0x0000000002000001ULL, 0x0000000002800001ULL, 0x0800000002000001ULL, 0x0800000002800001ULL,
+      0x0000020002000001ULL, 0x0000020002800001ULL, 0x0800020002000001ULL, 0x0800020002800001ULL,
+      0x0000000002020001ULL, 0x0000000002820001ULL, 0x0800000002020001ULL, 0x0800000002820001ULL,
+      0x0000020002020001ULL, 0x0000020002820001ULL, 0x0800020002020001ULL, 0x0800020002820001ULL,
+      0x0000000082000001ULL, 0x0000000082800001ULL, 0x0800000082000001ULL, 0x0800000082800001ULL,
+      0x0000020082000001ULL, 0x0000020082800001ULL, 0x0800020082000001ULL, 0x0800020082800001ULL,
+      0x0000000082020001ULL, 0x0000000082820001ULL, 0x0800000082020001ULL, 0x0800000082820001ULL,
+      0x0000020082020001ULL, 0x0000020082820001ULL, 0x0800020082020001ULL, 0x0800020082820001ULL,
+      0x0000080000000000ULL, 0x0000080000800000ULL, 0x0800080000000000ULL, 0x0800080000800000ULL,
+      0x00000a0000000000ULL, 0x00000a0000800000ULL, 0x08000a0000000000ULL, 0x08000a0000800000ULL,
+      0x0000080000020000ULL, 0x0000080000820000ULL, 0x0800080000020000ULL, 0x0800080000820000ULL,
+      0x00000a0000020000ULL, 0x00000a0000820000ULL, 0x08000a0000020000ULL, 0x08000a0000820000ULL,
+      0x0000080080000000ULL, 0x0000080080800000ULL, 0x0800080080000000ULL, 0x0800080080800000ULL,
+      0x00000a0080000000ULL, 0x00000a0080800000ULL, 0x08000a0080000000ULL, 0x08000a0080800000ULL,
+      0x0000080080020000ULL, 0x0000080080820000ULL, 0x0800080080020000ULL, 0x0800080080820000ULL,
+      0x00000a0080020000ULL, 0x00000a0080820000ULL, 0x08000a0080020000ULL, 0x08000a0080820000ULL,
+      0x0000080000000001ULL, 0x0000080000800001ULL, 0x0800080000000001ULL, 0x0800080000800001ULL,
+      0x00000a0000000001ULL, 0x00000a0000800001ULL, 0x08000a0000000001ULL, 0x08000a0000800001ULL,
+      0x0000080000020001ULL, 0x0000080000820001ULL, 0x0800080000020001ULL, 0x0800080000820001ULL,
+      0x00000a0000020001ULL, 0x00000a0000820001ULL, 0x08000a0000020001ULL, 0x08000a0000820001ULL,
+      0x0000080080000001ULL, 0x0000080080800001ULL, 0x0800080080000001ULL, 0x0800080080800001ULL,
+      0x00000a0080000001ULL, 0x00000a0080800001ULL, 0x08000a0080000001ULL, 0x08000a0080800001ULL,
+      0x0000080080020001ULL, 0x0000080080820001ULL, 0x0800080080020001ULL, 0x0800080080820001ULL,
+      0x00000a0080020001ULL, 0x00000a0080820001ULL, 0x08000a0080020001ULL, 0x08000a0080820001ULL,
+      0x0000080002000000ULL, 0x0000080002800000ULL, 0x0800080002000000ULL, 0x0800080002800000ULL,
+      0x00000a0002000000ULL, 0x00000a0002800000ULL, 0x08000a0002000000ULL, 0x08000a0002800000ULL,
+      0x0000080002020000ULL, 0x0000080002820000ULL, 0x0800080002020000ULL, 0x0800080002820000ULL,
+      0x00000a0002020000ULL, 0x00000a0002820000ULL, 0x08000a0002020000ULL, 0x08000a0002820000ULL,
+      0x0000080082000000ULL, 0x0000080082800000ULL, 0x0800080082000000ULL, 0x0800080082800000ULL,
+      0x00000a0082000000ULL, 0x00000a0082800000ULL, 0x08000a0082000000ULL, 0x08000a0082800000ULL,
+      0x0000080082020000ULL, 0x0000080082820000ULL, 0x0800080082020000ULL, 0x0800080082820000ULL,
+      0x00000a0082020000ULL, 0x00000a0082820000ULL, 0x08000a0082020000ULL, 0x08000a0082820000ULL,
+      0x0000080002000001ULL, 0x0000080002800001ULL, 0x0800080002000001ULL, 0x0800080002800001ULL,
+      0x00000a0002000001ULL, 0x00000a0002800001ULL, 0x08000a0002000001ULL, 0x08000a0002800001ULL,
+      0x0000080002020001ULL, 0x0000080002820001ULL, 0x0800080002020001ULL, 0x0800080002820001ULL,
+      0x00000a0002020001ULL, 0x00000a0002820001ULL, 0x08000a0002020001ULL, 0x08000a0002820001ULL,
+      0x0000080082000001ULL, 0x0000080082800001ULL, 0x0800080082000001ULL, 0x0800080082800001ULL,
+      0x00000a0082000001ULL, 0x00000a0082800001ULL, 0x08000a0082000001ULL, 0x08000a0082800001ULL,
+      0x0000080082020001ULL, 0x0000080082820001ULL, 0x0800080082020001ULL, 0x0800080082820001ULL,
+      0x00000a0082020001ULL, 0x00000a0082820001ULL, 0x08000a0082020001ULL, 0x08000a0082820001ULL,
+    },
+    {
+      0x0000000000000000ULL, 0x0000100000000000ULL, 0x0000000000004000ULL, 0x0000100000004000ULL,
+      0x0000000000000004ULL, 0x0000100000000004ULL, 0x0000000000004004ULL, 0x0000100000004004ULL,
+      0x0000000000002000ULL, 0x0000100000002000ULL, 0x0000000000006000ULL, 0x0000100000006000ULL,
+      0x0000000000002004ULL, 0x0000100000002004ULL, 0x0000000000006004ULL, 0x0000100000006004ULL,
+      0x0000200000000000ULL, 0x0000300000000000ULL, 0x0000200000004000ULL, 0x0000300000004000ULL,
+      0x0000200000000004ULL, 0x0000300000000004ULL, 0x0000200000004004ULL, 0x0000300000004004ULL,
+      0x0000200000002000ULL, 0x0000300000002000ULL, 0x0000200000006000ULL, 0x0000300000006000ULL,
+      0x0000200000002004ULL, 0x0000300000002004ULL, 0x0000200000006004ULL, 0x0000300000006004ULL,
+      0x0001000000000000ULL, 0x0001100000000000ULL, 0x0001000000004000ULL, 0x0001100000004000ULL,
+      0x0001000000000004ULL, 0x0001100000000004ULL, 0x0001000000004004ULL, 0x0001100000004004ULL,
+      0x0001000000002000ULL, 0x0001100000002000ULL, 0x0001000000006000ULL, 0x0001100000006000ULL,
+      0x0001000000002004ULL, 0x0001100000002004ULL, 0x0001000000006004ULL, 0x0001100000006004ULL,
+      0x0001200000000000ULL, 0x0001300000000000ULL, 0x0001200000004000ULL, 0x0001300000004000ULL,
+      0x0001200000000004ULL, 0x0001300000000004ULL, 0x0001200000004004ULL, 0x0001300000004004ULL,
+      0x0001200000002000ULL, 0x0001300000002000ULL, 0x0001200000006000ULL, 0x0001300000006000ULL,
+      0x0001200000002004ULL, 0x0001300000002004ULL, 0x0001200000006004ULL, 0x0001300000006004ULL,
+      0x0000000000000008ULL, 0x0000100000000008ULL, 0x0000000000004008ULL, 0x0000100000004008ULL,
+      0x000000000000000cULL, 0x000010000000000cULL, 0x000000000000400cULL, 0x000010000000400cULL,
+      0x0000000000002008ULL, 0x0000100000002008ULL, 0x0000000000006008ULL, 0x0000100000006008ULL,
+      0x000000000000200cULL, 0x000010000000200cULL, 0x000000000000600cULL, 0x000010000000600cULL,
+      0x0000200000000008ULL, 0x0000300000000008ULL, 0x0000200000004008ULL, 0x0000300000004008ULL,
+      0x000020000000000cULL, 0x000030000000000cULL, 0x000020000000400cULL, 0x000030000000400cULL,
+      0x0000200000002008ULL, 0x0000300000002008ULL, 0x0000200000006008ULL, 0x0000300000006008ULL,
+      0x000020000000200cULL, 0x000030000000200cULL, 0x000020000000600cULL, 0x000030000000600cULL,
+      0x0001000000000008ULL, 0x0001100000000008ULL, 0x0001000000004008ULL, 0x0001100000004008ULL,
+      0x000100000000000cULL, 0x000110000000000cULL, 0x000100000000400cULL, 0x000110000000400cULL,
+      0x0001000000002008ULL, 0x0001100000002008ULL, 0x0001000000006008ULL, 0x0001100000006008ULL,
+      0x000100000000200cULL, 0x000110000000200cULL, 0x000100000000600cULL, 0x000110000000600cULL,
+      0x0001200000000008ULL, 0x0001300000000008ULL, 0x0001200000004008ULL, 0x0001300000004008ULL,
+      0x000120000000000cULL, 0x000130000000000cULL, 0x000120000000400cULL, 0x000130000000400cULL,
+      0x0001200000002008ULL, 0x0001300000002008ULL, 0x0001200000006008ULL, 0x0001300000006008ULL,
+      0x000120000000200cULL, 0x000130000000200cULL, 0x000120000000600cULL, 0x000130000000600cULL,
+      0x1000000000000000ULL, 0x1000100000000000ULL, 0x1000000000004000ULL, 0x1000100000004000ULL,
+      0x1000000000000004ULL, 0x1000100000000004ULL, 0x1000000000004004ULL, 0x1000100000004004ULL,
+      0x1000000000002000ULL, 0x1000100000002000ULL, 0x1000000000006000ULL, 0x1000100000006000ULL,
+      0x1000000000002004ULL, 0x1000100000002004ULL, 0x1000000000006004ULL, 0x1000100000006004ULL,
+      0x1000200000000000ULL, 0x1000300000000000ULL, 0x1000200000004000ULL, 0x1000300000004000ULL,
+      0x1000200000000004ULL, 0x1000300000000004ULL, 0x1000200000004004ULL, 0x1000300000004004ULL,
+      0x1000200000002000ULL, 0x1000300000002000ULL, 0x1000200000006000ULL, 0x1000300000006000ULL,
+      0x1000200000002004ULL, 0x1000300000002004ULL, 0x1000200000006004ULL, 0x1000300000006004ULL,
+      0x1001000000000000ULL, 0x1001100000000000ULL, 0x1001000000004000ULL, 0x1001100000004000ULL,
+      0x1001000000000004ULL, 0x1001100000000004ULL, 0x1001000000004004ULL, 0x1001100000004004ULL,
+      0x1001000000002000ULL, 0x1001100000002000ULL, 0x1001000000006000ULL, 0x1001100000006000ULL,
+      0x1001000000002004ULL, 0x1001100000002004ULL, 0x1001000000006004ULL, 0x1001100000006004ULL,
+      0x1001200000000000ULL, 0x1001300000000000ULL, 0x1001200000004000ULL, 0x1001300000004000ULL,
+      0x1001200000000004ULL, 0x1001300000000004ULL, 0x1001200000004004ULL, 0x1001300000004004ULL,
+      0x1001200000002000ULL, 0x1001300000002000ULL, 0x1001200000006000ULL, 0x1001300000006000ULL,
+      0x1001200000002004ULL, 0x1001300000002004ULL, 0x1001200000006004ULL, 0x1001300000006004ULL,
+      0x1000000000000008ULL, 0x1000100000000008ULL, 0x1000000000004008ULL, 0x1000100000004008ULL,
+      0x100000000000000cULL, 0x100010000000000cULL, 0x100000000000400cULL, 0x100010000000400cULL,
+      0x1000000000002008ULL, 0x1000100000002008ULL, 0x1000000000006008ULL, 0x1000100000006008ULL,
+      0x100000000000200cULL, 0x100010000000200cULL, 0x100000000000600cULL, 0x100010000000600cULL,
+      0x1000200000000008ULL, 0x1000300000000008ULL, 0x1000200000004008ULL, 0x1000300000004008ULL,
+      0x100020000000000cULL, 0x100030000000000cULL, 0x100020000000400cULL, 0x100030000000400cULL,
+      0x1000200000002008ULL, 0x1000300000002008ULL, 0x1000200000006008ULL, 0x1000300000006008ULL,
+      0x100020000000200cULL, 0x100030000000200cULL, 0x100020000000600cULL, 0x100030000000600cULL,
+      0x1001000000000008ULL, 0x1001100000000008ULL, 0x1001000000004008ULL, 0x1001100000004008ULL,
+      0x100100000000000cULL, 0x100110000000000cULL, 0x100100000000400cULL, 0x100110000000400cULL,
+      0x1001000000002008ULL, 0x1001100000002008ULL, 0x1001000000006008ULL, 0x1001100000006008ULL,
+      0x100100000000200cULL, 0x100110000000200cULL, 0x100100000000600cULL, 0x100110000000600cULL,
+      0x1001200000000008ULL, 0x1001300000000008ULL, 0x1001200000004008ULL, 0x1001300000004008ULL,
+      0x100120000000000cULL, 0x100130000000000cULL, 0x100120000000400cULL, 0x100130000000400cULL,
+      0x1001200000002008ULL, 0x1001300000002008ULL, 0x1001200000006008ULL, 0x1001300000006008ULL,
+      0x100120000000200cULL, 0x100130000000200cULL, 0x100120000000600cULL, 0x100130000000600cULL,
+    },
+    {
+      0x0000000000000000ULL, 0x0002000000000000ULL, 0x0000000000000100ULL, 0x0002000000000100ULL,
+      0x0000000400000000ULL, 0x0002000400000000ULL, 0x0000000400000100ULL, 0x0002000400000100ULL,
+      0x0000000000000020ULL, 0x0002000000000020ULL, 0x0000000000000120ULL, 0x0002000000000120ULL,
+      0x0000000400000020ULL, 0x0002000400000020ULL, 0x0000000400000120ULL, 0x0002000400000120ULL,
+      0x0000000000000200ULL, 0x0002000000000200ULL, 0x0000000000000300ULL, 0x0002000000000300ULL,
+      0x0000000400000200ULL, 0x0002000400000200ULL, 0x0000000400000300ULL, 0x0002000400000300ULL,
+      0x0000000000000220ULL, 0x0002000000000220ULL, 0x0000000000000320ULL, 0x0002000000000320ULL,
+      0x0000000400000220ULL, 0x0002000400000220ULL, 0x0000000400000320ULL, 0x0002000400000320ULL,
+      0x0000040000000000ULL, 0x0002040000000000ULL, 0x0000040000000100ULL, 0x0002040000000100ULL,
+      0x0000040400000000ULL, 0x0002040400000000ULL, 0x0000040400000100ULL, 0x0002040400000100ULL,
+      0x0000040000000020ULL, 0x0002040000000020ULL, 0x0000040000000120ULL, 0x0002040000000120ULL,
+      0x0000040400000020ULL, 0x0002040400000020ULL, 0x0000040400000120ULL, 0x0002040400000120ULL,
+      0x0000040000000200ULL, 0x0002040000000200ULL, 0x0000040000000300ULL, 0x0002040000000300ULL,
+      0x0000040400000200ULL, 0x0002040400000200ULL, 0x0000040400000300ULL, 0x0002040400000300ULL,
+      0x0000040000000220ULL, 0x0002040000000220ULL, 0x0000040000000320ULL, 0x0002040000000320ULL,
+      0x0000040400000220ULL, 0x0002040400000220ULL, 0x0000040400000320ULL, 0x0002040400000320ULL,
+      0x0200000000000000ULL, 0x0202000000000000ULL, 0x0200000000000100ULL, 0x0202000000000100ULL,
+      0x0200000400000000ULL, 0x0202000400000000ULL, 0x0200000400000100ULL, 0x0202000400000100ULL,
+      0x0200000000000020ULL, 0x0202000000000020ULL, 0x0200000000000120ULL, 0x0202000000000120ULL,
+      0x0200000400000020ULL, 0x0202000400000020ULL, 0x0200000400000120ULL, 0x0202000400000120ULL,
+      0x0200000000000200ULL, 0x0202000000000200ULL, 0x0200000000000300ULL, 0x0202000000000300ULL,
+      0x0200000400000200ULL, 0x0202000400000200ULL, 0x0200000400000300ULL, 0x0202000400000300ULL,
+      0x0200000000000220ULL, 0x0202000000000220ULL, 0x0200000000000320ULL, 0x0202000000000320ULL,
+      0x0200000400000220ULL, 0x0202000400000220ULL, 0x0200000400000320ULL, 0x0202000400000320ULL,
+      0x0200040000000000ULL, 0x0202040000000000ULL, 0x0200040000000100ULL, 0x0202040000000100ULL,
+      0x0200040400000000ULL, 0x0202040400000000ULL, 0x0200040400000100ULL, 0x0202040400000100ULL,
+      0x0200040000000020ULL, 0x0202040000000020ULL, 0x0200040000000120ULL, 0x0202040000000120ULL,
+      0x0200040400000020ULL, 0x0202040400000020ULL, 0x0200040400000120ULL, 0x0202040400000120ULL,
+      0x0200040000000200ULL, 0x0202040000000200ULL, 0x0200040000000300ULL, 0x0202040000000300ULL,
+      0x0200040400000200ULL, 0x0202040400000200ULL, 0x0200040400000300ULL, 0x0202040400000300ULL,
+      0x0200040000000220ULL, 0x0202040000000220ULL, 0x0200040000000320ULL, 0x0202040000000320ULL,
+      0x0200040400000220ULL, 0x0202040400000220ULL, 0x0200040400000320ULL, 0x0202040400000320ULL,
+      0x0000000001000000ULL, 0x0002000001000000ULL, 0x0000000001000100ULL, 0x0002000001000100ULL,
+      0x0000000401000000ULL, 0x0002000401000000ULL, 0x0000000401000100ULL, 0x0002000401000100ULL,
+      0x0000000001000020ULL, 0x0002000001000020ULL, 0x0000000001000120ULL, 0x0002000001000120ULL,
+      0x0000000401000020ULL, 0x0002000401000020ULL, 0x0000000401000120ULL, 0x0002000401000120ULL,
+      0x0000000001000200ULL, 0x0002000001000200ULL, 0x0000000001000300ULL, 0x0002000001000300ULL,
+      0x0000000401000200ULL, 0x0002000401000200ULL, 0x0000000401000300ULL, 0x0002000401000300ULL,
+      0x0000000001000220ULL, 0x0002000001000220ULL, 0x0000000001000320ULL, 0x0002000001000320ULL,
+      0x0000000401000220ULL, 0x0002000401000220ULL, 0x0000000401000320ULL, 0x0002000401000320ULL,
+      0x0000040001000000ULL, 0x0002040001000000ULL, 0x0000040001000100ULL, 0x0002040001000100ULL,
+      0x0000040401000000ULL, 0x0002040401000000ULL, 0x0000040401000100ULL, 0x0002040401000100ULL,
+      0x0000040001000020ULL, 0x0002040001000020ULL, 0x0000040001000120ULL, 0x0002040001000120ULL,
+      0x0000040401000020ULL, 0x0002040401000020ULL, 0x0000040401000120ULL, 0x0002040401000120ULL,
+      0x0000040001000200ULL, 0x0002040001000200ULL, 0x0000040001000300ULL, 0x0002040001000300ULL,
+      0x0000040401000200ULL, 0x0002040401000200ULL, 0x0000040401000300ULL, 0x0002040401000300ULL,
+      0x0000040001000220ULL, 0x0002040001000220ULL, 0x0000040001000320ULL, 0x0002040001000320ULL,
+      0x0000040401000220ULL, 0x0002040401000220ULL, 0x0000040401000320ULL, 0x0002040401000320ULL,
+      0x0200000001000000ULL, 0x0202000001000000ULL, 0x0200000001000100ULL, 0x0202000001000100ULL,
+      0x0200000401000000ULL, 0x0202000401000000ULL, 0x0200000401000100ULL, 0x0202000401000100ULL,
+      0x0200000001000020ULL, 0x0202000001000020ULL, 0x0200000001000120ULL, 0x0202000001000120ULL,
+      0x0200000401000020ULL, 0x0202000401000020ULL, 0x0200000401000120ULL, 0x0202000401000120ULL,
+      0x0200000001000200ULL, 0x0202000001000200ULL, 0x0200000001000300ULL, 0x0202000001000300ULL,
+      0x0200000401000200ULL, 0x0202000401000200ULL, 0x0200000401000300ULL, 0x0202000401000300ULL,
+      0x0200000001000220ULL, 0x0202000001000220ULL, 0x0200000001000320ULL, 0x0202000001000320ULL,
+      0x0200000401000220ULL, 0x0202000401000220ULL, 0x0200000401000320ULL, 0x0202000401000320ULL,
+      0x0200040001000000ULL, 0x0202040001000000ULL, 0x0200040001000100ULL, 0x0202040001000100ULL,
+      0x0200040401000000ULL, 0x0202040401000000ULL, 0x0200040401000100ULL, 0x0202040401000100ULL,
+      0x0200040001000020ULL, 0x0202040001000020ULL, 0x0200040001000120ULL, 0x0202040001000120ULL,
+      0x0200040401000020ULL, 0x0202040401000020ULL, 0x0200040401000120ULL, 0x0202040401000120ULL,
+      0x0200040001000200ULL, 0x0202040001000200ULL, 0x0200040001000300ULL, 0x0202040001000300ULL,
+      0x0200040401000200ULL, 0x0202040401000200ULL, 0x0200040401000300ULL, 0x0202040401000300ULL,
+      0x0200040001000220ULL, 0x0202040001000220ULL, 0x0200040001000320ULL, 0x0202040001000320ULL,
+      0x0200040401000220ULL, 0x0202040401000220ULL, 0x0200040401000320ULL, 0x0202040401000320ULL,
+    },
+  };
+
+static inline uint64_t dvbcsa_key_permute_block(uint64_t k)
+{
+  uint64_t n = 0;
+  int i;
+
+  for (i = 0; i < 8; i++)
+    {
+      n |= kperm[i][k & 0xff];
+      k >>= 8;
+    }
+
+  return n;
+}
+
+void
+dvbcsa_key_schedule_block(const dvbcsa_cw_t cw, uint8_t * kk)
+{
+  uint64_t k[7];
+  int i, j;
+
+  k[6] = dvbcsa_load_le64(cw);
+  for (i = 6; i > 0; i--)
+    k[i - 1] = dvbcsa_key_permute_block(k[i]);
+
+  for (i = 0; i < 7; i++)
+    for (j = 0; j < 8; j++)
+      kk[i*8+j] = (k[i]>>(j*8)) ^ i;
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_pv.h b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_pv.h
new file mode 100644
index 0000000..af40d6f
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_pv.h
@@ -0,0 +1,175 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#ifndef DVBCSA_PV_H_
+# define DVBCSA_PV_H_
+
+#include "config.h"
+
+#if STDC_HEADERS
+#ifdef __KERNEL__
+#include <linux/stddef.h>
+#else
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+#else
+#if HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#endif
+#if HAVE_STRING_H
+#if !STDC_HEADERS && HAVE_MEMORY_H
+#include <memory.h>
+#endif
+#ifdef __KERNEL__
+#include <linux/string.h>
+#else
+#include <string.h>
+#endif
+#endif
+#if HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#if HAVE_INTTYPES_H
+#include <inttypes.h>
+#else
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+#endif
+
+#if !defined(DVBCSA_DEBUG) && defined(__GNUC__)
+#define DVBCSA_INLINE __attribute__ ((always_inline))
+#else
+#define DVBCSA_INLINE
+#endif
+
+void worddump (const char *str, const void *data, size_t len, size_t ws);
+
+#define DVBCSA_DATA_SIZE	8
+#define DVBCSA_KEYSBUFF_SIZE	56
+#define DVBCSA_CWBITS_SIZE	64
+
+typedef uint8_t			dvbcsa_block_t[DVBCSA_DATA_SIZE];
+typedef uint8_t			dvbcsa_keys_t[DVBCSA_KEYSBUFF_SIZE];
+
+struct dvbcsa_key_s
+{
+  dvbcsa_cw_t		cw;
+  dvbcsa_cw_t		cws;	/* nibble swapped CW */
+  dvbcsa_keys_t		sch;
+};
+
+extern const uint8_t dvbcsa_block_sbox[256];
+
+void dvbcsa_block_decrypt (const dvbcsa_keys_t key, const dvbcsa_block_t in, dvbcsa_block_t out);
+void dvbcsa_block_encrypt (const dvbcsa_keys_t key, const dvbcsa_block_t in, dvbcsa_block_t out);
+
+void dvbcsa_stream_xor (const dvbcsa_cw_t cw, const dvbcsa_block_t iv,
+			uint8_t *stream, unsigned int len);
+
+void dvbcsa_key_schedule_block(const dvbcsa_cw_t cw, uint8_t * kk);
+
+DVBCSA_INLINE static inline void
+dvbcsa_xor_64 (uint8_t *b, const uint8_t *a)
+{
+#if defined(__i386__) || defined(__x86_64__)
+  /* target support non aligned memory access */
+  *(uint64_t*)b ^= *(uint64_t*)a;
+#else
+  unsigned int i;
+
+  for (i = 0; i < 8; i++)
+    b[i] ^= a[i];
+#endif
+}
+
+DVBCSA_INLINE static inline uint32_t
+dvbcsa_load_le32(const uint8_t *p)
+{
+#if defined(__i386__) || defined(__x86_64__)
+  /* target support non aligned le memory access */
+  return *(uint32_t*)p;
+#else
+  return ((uint32_t)p[3] << 24) |
+         ((uint32_t)p[2] << 16) |
+         ((uint32_t)p[1] << 8 ) |
+          (uint32_t)p[0];
+#endif
+}
+
+DVBCSA_INLINE static inline uint64_t
+dvbcsa_load_le64(const uint8_t *p)
+{
+#if defined(__i386__) || defined(__x86_64__)
+  /* target support non aligned le memory access */
+  return *(uint64_t*)p;
+#else
+  return (uint64_t)( ((uint64_t)p[7] << 56) |
+		     ((uint64_t)p[6] << 48) |
+		     ((uint64_t)p[5] << 40) |
+		     ((uint64_t)p[4] << 32) |
+		     ((uint64_t)p[3] << 24) |
+		     ((uint64_t)p[2] << 16) |
+		     ((uint64_t)p[1] << 8 ) |
+		      (uint64_t)p[0]
+		     );
+#endif
+}
+
+DVBCSA_INLINE static inline void
+dvbcsa_store_le32(uint8_t *p, const uint32_t w)
+{
+#if defined(__i386__) || defined(__x86_64__)
+  /* target support non aligned le memory access */
+  *(uint32_t*)p = w;
+#else
+  p[3] = (w >> 24);
+  p[2] = (w >> 16);
+  p[1] = (w >> 8);
+  p[0] = (w);
+#endif
+}
+
+DVBCSA_INLINE static inline void
+dvbcsa_store_le64(uint8_t *p, const uint64_t w)
+{
+#if defined(__i386__) || defined(__x86_64__)
+  /* target support non aligned le memory access */
+  *(uint64_t*)p = w;
+#else
+  p[7] = (w >> 56);
+  p[6] = (w >> 48);
+  p[5] = (w >> 40);
+  p[4] = (w >> 32);
+  p[3] = (w >> 24);
+  p[2] = (w >> 16);
+  p[1] = (w >> 8);
+  p[0] = (w);
+#endif
+}
+
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_stream.c b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_stream.c
new file mode 100644
index 0000000..74a6f53
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/dvbcsa2/dvbcsa_stream.c
@@ -0,0 +1,348 @@
+/*
+
+    This file is part of libdvbcsa.
+
+    libdvbcsa is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2 of the License,
+    or (at your option) any later version.
+
+    libdvbcsa is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with libdvbcsa; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+    02111-1307 USA
+
+    (c) 2006-2008 Alexandre Becoulet <alexandre.becoulet@free.fr>
+
+*/
+
+#include "dvbcsa/dvbcsa.h"
+#include "dvbcsa_pv.h"
+
+/*
+** Get nibble from A and B 40 bits registers
+*/
+
+#define	NBGET(r, n)	(r >> (n * 4))
+
+
+
+/*
+** CSA algorithm is using X, Y, Z, D, E, F 4 bits registers
+** and P, Q, C 1 bits registers. these registers are stored
+** in `pqzyx' and `cfed' variables to improve speed.
+*/
+
+#define GETX(x)	(x)
+#define GETY(x)	((x) >> 4)
+#define GETZ(x)	((x) >> 8)
+#define TSTP(x)	((x) & 0x1000)
+#define TSTQ(x)	((x) & 0x2000)
+#define GETD(x)	(x)
+#define GETE(x)	((x) >> 4)
+#define GETF(x)	((x) >> 8)
+#define GETC(x)	((x) >> 12)
+
+
+
+/*
+** swap nibbles in byte
+*/
+
+DVBCSA_INLINE
+static inline uint8_t swap_nbl (register uint8_t byte)
+{
+  return ((byte >> 4) | (byte << 4));
+}
+
+
+/*
+** conditional rotation used in stream round
+*/
+
+DVBCSA_INLINE
+static inline uint8_t csa_stream_rotate (register uint32_t pqzyx,
+					 register uint32_t x)
+{
+  return TSTP(pqzyx) ? ((x << 1) | ((x >> 3) & 1)) & 0xf : x;
+}
+
+
+
+/*
+** process bit selection, permutation and sboxes
+*/
+
+DVBCSA_INLINE
+static inline uint32_t csa_stream_sboxes(register uint64_t A)
+{
+  /* modified sboxes tables */
+  static const uint16_t sbox[7][32] =
+    {
+      {
+	0x0001, 0x0000, 0x0400, 0x0400, 0x0001, 0x0401, 0x0401, 0x0000, 0x0401, 0x0001, 0x0001, 0x0000, 0x0400, 0x0400, 0x0000, 0x0401,
+	0x0000, 0x0401, 0x0401, 0x0000, 0x0001, 0x0001, 0x0400, 0x0400, 0x0001, 0x0001, 0x0000, 0x0401, 0x0400, 0x0400, 0x0401, 0x0000,
+      },
+      {
+	0x0802, 0x0800, 0x0002, 0x0800, 0x0802, 0x0002, 0x0002, 0x0800, 0x0800, 0x0802, 0x0000, 0x0002, 0x0000, 0x0000, 0x0000, 0x0802,
+	0x0802, 0x0800, 0x0800, 0x0002, 0x0002, 0x0802, 0x0800, 0x0802, 0x0000, 0x0000, 0x0000, 0x0802, 0x0800, 0x0002, 0x0002, 0x0000,
+      },
+      {
+	0x0010, 0x0000, 0x0010, 0x0010, 0x0010, 0x0014, 0x0000, 0x0004, 0x0004, 0x0014, 0x0014, 0x0014, 0x0014, 0x0000, 0x0004, 0x0000,
+	0x0014, 0x0000, 0x0004, 0x0010, 0x0004, 0x0014, 0x0014, 0x0004, 0x0000, 0x0004, 0x0000, 0x0004, 0x0010, 0x0000, 0x0010, 0x0010,
+      },
+      {
+	0x0028, 0x0008, 0x0020, 0x0028, 0x0020, 0x0000, 0x0020, 0x0008, 0x0008, 0x0020, 0x0000, 0x0008, 0x0000, 0x0028, 0x0028, 0x0000,
+	0x0008, 0x0000, 0x0028, 0x0008, 0x0028, 0x0020, 0x0028, 0x0000, 0x0000, 0x0028, 0x0020, 0x0000, 0x0020, 0x0008, 0x0008, 0x0020,
+      },
+      {
+	0x0100, 0x0000, 0x0000, 0x0040, 0x0140, 0x0100, 0x0140, 0x0100, 0x0140, 0x0140, 0x0000, 0x0040, 0x0100, 0x0040, 0x0040, 0x0000,
+	0x0140, 0x0100, 0x0000, 0x0100, 0x0140, 0x0000, 0x0040, 0x0040, 0x0100, 0x0140, 0x0000, 0x0040, 0x0100, 0x0000, 0x0040, 0x0140,
+      },
+      {
+	0x0000, 0x0080, 0x0200, 0x0280, 0x0080, 0x0200, 0x0200, 0x0000, 0x0000, 0x0080, 0x0280, 0x0000, 0x0200, 0x0280, 0x0080, 0x0280,
+	0x0200, 0x0280, 0x0000, 0x0200, 0x0280, 0x0000, 0x0080, 0x0080, 0x0200, 0x0080, 0x0080, 0x0200, 0x0000, 0x0280, 0x0280, 0x0000,
+      },
+      {
+	0x0000, 0x0000, 0x1000, 0x2000, 0x3000, 0x3000, 0x0000, 0x1000, 0x3000, 0x1000, 0x2000, 0x2000, 0x2000, 0x0000, 0x1000, 0x3000,
+	0x3000, 0x1000, 0x2000, 0x2000, 0x2000, 0x3000, 0x0000, 0x0000, 0x2000, 0x1000, 0x1000, 0x3000, 0x0000, 0x0000, 0x1000, 0x3000,
+      },
+    };
+
+  uint32_t		res;
+  uint64_t		t;
+
+  t = A & 0x2018004200LL;
+  res =  sbox[1][ ((t >> 37) ^ (t >> 27) ^ (t >> 25) ^ (t >> 11) ^ (t >>  5)) & 0x1f ];
+
+  t = A & 0x4201480000LL;
+  res |= sbox[4][ ((t >> 38) ^ (t >> 32) ^ (t >> 22) ^ (t >> 16) ^ (t >> 18)) & 0x1f ];
+
+  t = A & 0x8040122000LL;
+  res |= sbox[5][ ((t >> 39) ^ (t >> 29) ^ (t >> 18) ^ (t >> 14) ^ (t >>  9)) & 0x1f ];
+
+  t = A & 0x1082010040LL;
+  res |= sbox[0][ ((t >> 36) ^ (t >> 30) ^ (t >> 23) ^ (t >>  3) ^ (t >> 12)) & 0x1f ];
+
+  t = A & 0x0004a00180LL;
+  res |= sbox[2][ ((t >> 26) ^ (t >> 22) ^ (t >> 19) ^ (t >>  5) ^ (t >>  3)) & 0x1f ];
+
+  t = A & 0x0100048820LL;
+  res |= sbox[3][ ((t >> 32) ^ (t >> 17) ^ (t >>  9) ^ (t >>  2) ^ (t >> 11)) & 0x1f ];
+
+  t = A & 0x0c20001400LL;
+  res |= sbox[6][ ((t >> 35) ^ (t >> 33) ^ (t >> 27) ^ (t >>  9) ^ (t >>  6)) & 0x1f ];
+
+  return res;
+}
+
+
+
+/*
+** bit selection and XOR from B
+*/
+
+DVBCSA_INLINE
+static inline uint32_t csa_stream_B_sel	(register uint64_t B)
+{
+  uint32_t	t = B >> 9;
+
+  /*    10000000 01000010000000000001000000000000 */
+  /*   00000010 00000001000001001000000000000000 */
+  /*  00000100 00000000101000010000000000000000 */
+  /* 01000001 00001000000000000010000000000000 */
+
+  return
+    (((t      )                         ^ (t >> 27)) & 0x8) ^
+    (((t >> 18)                                    ) & 0x9) ^
+    ((            (t >> 22)             ^ (t >>  7)) & 0x4) ^
+    (((t >> 4 )                                    ) & 0x5) ^
+    ((            (t >> 24) ^ (t >>  6) ^ (t >> 11)) & 0x2) ^
+    (((t >> 29) ^                         (t >> 23)) & 0x1) ^
+    (((t >> 13)                                    ) & 0xe);
+}
+
+
+
+/*
+** cfed precomputed operations
+*/
+
+DVBCSA_INLINE
+static inline uint32_t csa_stream_cfed (uint32_t pqzyx, uint32_t cfed)
+{
+  static const uint16_t csa_stream_cdef[0x400] =
+    {
+      0x0000, 0x0101, 0x0202, 0x0303, 0x0404, 0x0505, 0x0606, 0x0707, 0x0808, 0x0909, 0x0a0a, 0x0b0b, 0x0c0c, 0x0d0d, 0x0e0e, 0x0f0f,
+      0x0001, 0x0100, 0x0203, 0x0302, 0x0405, 0x0504, 0x0607, 0x0706, 0x0809, 0x0908, 0x0a0b, 0x0b0a, 0x0c0d, 0x0d0c, 0x0e0f, 0x0f0e,
+      0x0002, 0x0103, 0x0200, 0x0301, 0x0406, 0x0507, 0x0604, 0x0705, 0x080a, 0x090b, 0x0a08, 0x0b09, 0x0c0e, 0x0d0f, 0x0e0c, 0x0f0d,
+      0x0003, 0x0102, 0x0201, 0x0300, 0x0407, 0x0506, 0x0605, 0x0704, 0x080b, 0x090a, 0x0a09, 0x0b08, 0x0c0f, 0x0d0e, 0x0e0d, 0x0f0c,
+      0x0004, 0x0105, 0x0206, 0x0307, 0x0400, 0x0501, 0x0602, 0x0703, 0x080c, 0x090d, 0x0a0e, 0x0b0f, 0x0c08, 0x0d09, 0x0e0a, 0x0f0b,
+      0x0005, 0x0104, 0x0207, 0x0306, 0x0401, 0x0500, 0x0603, 0x0702, 0x080d, 0x090c, 0x0a0f, 0x0b0e, 0x0c09, 0x0d08, 0x0e0b, 0x0f0a,
+      0x0006, 0x0107, 0x0204, 0x0305, 0x0402, 0x0503, 0x0600, 0x0701, 0x080e, 0x090f, 0x0a0c, 0x0b0d, 0x0c0a, 0x0d0b, 0x0e08, 0x0f09,
+      0x0007, 0x0106, 0x0205, 0x0304, 0x0403, 0x0502, 0x0601, 0x0700, 0x080f, 0x090e, 0x0a0d, 0x0b0c, 0x0c0b, 0x0d0a, 0x0e09, 0x0f08,
+      0x0008, 0x0109, 0x020a, 0x030b, 0x040c, 0x050d, 0x060e, 0x070f, 0x0800, 0x0901, 0x0a02, 0x0b03, 0x0c04, 0x0d05, 0x0e06, 0x0f07,
+      0x0009, 0x0108, 0x020b, 0x030a, 0x040d, 0x050c, 0x060f, 0x070e, 0x0801, 0x0900, 0x0a03, 0x0b02, 0x0c05, 0x0d04, 0x0e07, 0x0f06,
+      0x000a, 0x010b, 0x0208, 0x0309, 0x040e, 0x050f, 0x060c, 0x070d, 0x0802, 0x0903, 0x0a00, 0x0b01, 0x0c06, 0x0d07, 0x0e04, 0x0f05,
+      0x000b, 0x010a, 0x0209, 0x0308, 0x040f, 0x050e, 0x060d, 0x070c, 0x0803, 0x0902, 0x0a01, 0x0b00, 0x0c07, 0x0d06, 0x0e05, 0x0f04,
+      0x000c, 0x010d, 0x020e, 0x030f, 0x0408, 0x0509, 0x060a, 0x070b, 0x0804, 0x0905, 0x0a06, 0x0b07, 0x0c00, 0x0d01, 0x0e02, 0x0f03,
+      0x000d, 0x010c, 0x020f, 0x030e, 0x0409, 0x0508, 0x060b, 0x070a, 0x0805, 0x0904, 0x0a07, 0x0b06, 0x0c01, 0x0d00, 0x0e03, 0x0f02,
+      0x000e, 0x010f, 0x020c, 0x030d, 0x040a, 0x050b, 0x0608, 0x0709, 0x0806, 0x0907, 0x0a04, 0x0b05, 0x0c02, 0x0d03, 0x0e00, 0x0f01,
+      0x000f, 0x010e, 0x020d, 0x030c, 0x040b, 0x050a, 0x0609, 0x0708, 0x0807, 0x0906, 0x0a05, 0x0b04, 0x0c03, 0x0d02, 0x0e01, 0x0f00,
+      0x1000, 0x1101, 0x1202, 0x1303, 0x1404, 0x1505, 0x1606, 0x1707, 0x1808, 0x1909, 0x1a0a, 0x1b0b, 0x1c0c, 0x1d0d, 0x1e0e, 0x1f0f,
+      0x1001, 0x1100, 0x1203, 0x1302, 0x1405, 0x1504, 0x1607, 0x1706, 0x1809, 0x1908, 0x1a0b, 0x1b0a, 0x1c0d, 0x1d0c, 0x1e0f, 0x1f0e,
+      0x1002, 0x1103, 0x1200, 0x1301, 0x1406, 0x1507, 0x1604, 0x1705, 0x180a, 0x190b, 0x1a08, 0x1b09, 0x1c0e, 0x1d0f, 0x1e0c, 0x1f0d,
+      0x1003, 0x1102, 0x1201, 0x1300, 0x1407, 0x1506, 0x1605, 0x1704, 0x180b, 0x190a, 0x1a09, 0x1b08, 0x1c0f, 0x1d0e, 0x1e0d, 0x1f0c,
+      0x1004, 0x1105, 0x1206, 0x1307, 0x1400, 0x1501, 0x1602, 0x1703, 0x180c, 0x190d, 0x1a0e, 0x1b0f, 0x1c08, 0x1d09, 0x1e0a, 0x1f0b,
+      0x1005, 0x1104, 0x1207, 0x1306, 0x1401, 0x1500, 0x1603, 0x1702, 0x180d, 0x190c, 0x1a0f, 0x1b0e, 0x1c09, 0x1d08, 0x1e0b, 0x1f0a,
+      0x1006, 0x1107, 0x1204, 0x1305, 0x1402, 0x1503, 0x1600, 0x1701, 0x180e, 0x190f, 0x1a0c, 0x1b0d, 0x1c0a, 0x1d0b, 0x1e08, 0x1f09,
+      0x1007, 0x1106, 0x1205, 0x1304, 0x1403, 0x1502, 0x1601, 0x1700, 0x180f, 0x190e, 0x1a0d, 0x1b0c, 0x1c0b, 0x1d0a, 0x1e09, 0x1f08,
+      0x1008, 0x1109, 0x120a, 0x130b, 0x140c, 0x150d, 0x160e, 0x170f, 0x1800, 0x1901, 0x1a02, 0x1b03, 0x1c04, 0x1d05, 0x1e06, 0x1f07,
+      0x1009, 0x1108, 0x120b, 0x130a, 0x140d, 0x150c, 0x160f, 0x170e, 0x1801, 0x1900, 0x1a03, 0x1b02, 0x1c05, 0x1d04, 0x1e07, 0x1f06,
+      0x100a, 0x110b, 0x1208, 0x1309, 0x140e, 0x150f, 0x160c, 0x170d, 0x1802, 0x1903, 0x1a00, 0x1b01, 0x1c06, 0x1d07, 0x1e04, 0x1f05,
+      0x100b, 0x110a, 0x1209, 0x1308, 0x140f, 0x150e, 0x160d, 0x170c, 0x1803, 0x1902, 0x1a01, 0x1b00, 0x1c07, 0x1d06, 0x1e05, 0x1f04,
+      0x100c, 0x110d, 0x120e, 0x130f, 0x1408, 0x1509, 0x160a, 0x170b, 0x1804, 0x1905, 0x1a06, 0x1b07, 0x1c00, 0x1d01, 0x1e02, 0x1f03,
+      0x100d, 0x110c, 0x120f, 0x130e, 0x1409, 0x1508, 0x160b, 0x170a, 0x1805, 0x1904, 0x1a07, 0x1b06, 0x1c01, 0x1d00, 0x1e03, 0x1f02,
+      0x100e, 0x110f, 0x120c, 0x130d, 0x140a, 0x150b, 0x1608, 0x1709, 0x1806, 0x1907, 0x1a04, 0x1b05, 0x1c02, 0x1d03, 0x1e00, 0x1f01,
+      0x100f, 0x110e, 0x120d, 0x130c, 0x140b, 0x150a, 0x1609, 0x1708, 0x1807, 0x1906, 0x1a05, 0x1b04, 0x1c03, 0x1d02, 0x1e01, 0x1f00,
+      0x0000, 0x0101, 0x0202, 0x0303, 0x0404, 0x0505, 0x0606, 0x0707, 0x0808, 0x0909, 0x0a0a, 0x0b0b, 0x0c0c, 0x0d0d, 0x0e0e, 0x0f0f,
+      0x0101, 0x0200, 0x0303, 0x0402, 0x0505, 0x0604, 0x0707, 0x0806, 0x0909, 0x0a08, 0x0b0b, 0x0c0a, 0x0d0d, 0x0e0c, 0x0f0f, 0x100e,
+      0x0202, 0x0303, 0x0400, 0x0501, 0x0606, 0x0707, 0x0804, 0x0905, 0x0a0a, 0x0b0b, 0x0c08, 0x0d09, 0x0e0e, 0x0f0f, 0x100c, 0x110d,
+      0x0303, 0x0402, 0x0501, 0x0600, 0x0707, 0x0806, 0x0905, 0x0a04, 0x0b0b, 0x0c0a, 0x0d09, 0x0e08, 0x0f0f, 0x100e, 0x110d, 0x120c,
+      0x0404, 0x0505, 0x0606, 0x0707, 0x0800, 0x0901, 0x0a02, 0x0b03, 0x0c0c, 0x0d0d, 0x0e0e, 0x0f0f, 0x1008, 0x1109, 0x120a, 0x130b,
+      0x0505, 0x0604, 0x0707, 0x0806, 0x0901, 0x0a00, 0x0b03, 0x0c02, 0x0d0d, 0x0e0c, 0x0f0f, 0x100e, 0x1109, 0x1208, 0x130b, 0x140a,
+      0x0606, 0x0707, 0x0804, 0x0905, 0x0a02, 0x0b03, 0x0c00, 0x0d01, 0x0e0e, 0x0f0f, 0x100c, 0x110d, 0x120a, 0x130b, 0x1408, 0x1509,
+      0x0707, 0x0806, 0x0905, 0x0a04, 0x0b03, 0x0c02, 0x0d01, 0x0e00, 0x0f0f, 0x100e, 0x110d, 0x120c, 0x130b, 0x140a, 0x1509, 0x1608,
+      0x0808, 0x0909, 0x0a0a, 0x0b0b, 0x0c0c, 0x0d0d, 0x0e0e, 0x0f0f, 0x1000, 0x1101, 0x1202, 0x1303, 0x1404, 0x1505, 0x1606, 0x1707,
+      0x0909, 0x0a08, 0x0b0b, 0x0c0a, 0x0d0d, 0x0e0c, 0x0f0f, 0x100e, 0x1101, 0x1200, 0x1303, 0x1402, 0x1505, 0x1604, 0x1707, 0x1806,
+      0x0a0a, 0x0b0b, 0x0c08, 0x0d09, 0x0e0e, 0x0f0f, 0x100c, 0x110d, 0x1202, 0x1303, 0x1400, 0x1501, 0x1606, 0x1707, 0x1804, 0x1905,
+      0x0b0b, 0x0c0a, 0x0d09, 0x0e08, 0x0f0f, 0x100e, 0x110d, 0x120c, 0x1303, 0x1402, 0x1501, 0x1600, 0x1707, 0x1806, 0x1905, 0x1a04,
+      0x0c0c, 0x0d0d, 0x0e0e, 0x0f0f, 0x1008, 0x1109, 0x120a, 0x130b, 0x1404, 0x1505, 0x1606, 0x1707, 0x1800, 0x1901, 0x1a02, 0x1b03,
+      0x0d0d, 0x0e0c, 0x0f0f, 0x100e, 0x1109, 0x1208, 0x130b, 0x140a, 0x1505, 0x1604, 0x1707, 0x1806, 0x1901, 0x1a00, 0x1b03, 0x1c02,
+      0x0e0e, 0x0f0f, 0x100c, 0x110d, 0x120a, 0x130b, 0x1408, 0x1509, 0x1606, 0x1707, 0x1804, 0x1905, 0x1a02, 0x1b03, 0x1c00, 0x1d01,
+      0x0f0f, 0x100e, 0x110d, 0x120c, 0x130b, 0x140a, 0x1509, 0x1608, 0x1707, 0x1806, 0x1905, 0x1a04, 0x1b03, 0x1c02, 0x1d01, 0x1e00,
+      0x0100, 0x0201, 0x0302, 0x0403, 0x0504, 0x0605, 0x0706, 0x0807, 0x0908, 0x0a09, 0x0b0a, 0x0c0b, 0x0d0c, 0x0e0d, 0x0f0e, 0x100f,
+      0x0201, 0x0300, 0x0403, 0x0502, 0x0605, 0x0704, 0x0807, 0x0906, 0x0a09, 0x0b08, 0x0c0b, 0x0d0a, 0x0e0d, 0x0f0c, 0x100f, 0x110e,
+      0x0302, 0x0403, 0x0500, 0x0601, 0x0706, 0x0807, 0x0904, 0x0a05, 0x0b0a, 0x0c0b, 0x0d08, 0x0e09, 0x0f0e, 0x100f, 0x110c, 0x120d,
+      0x0403, 0x0502, 0x0601, 0x0700, 0x0807, 0x0906, 0x0a05, 0x0b04, 0x0c0b, 0x0d0a, 0x0e09, 0x0f08, 0x100f, 0x110e, 0x120d, 0x130c,
+      0x0504, 0x0605, 0x0706, 0x0807, 0x0900, 0x0a01, 0x0b02, 0x0c03, 0x0d0c, 0x0e0d, 0x0f0e, 0x100f, 0x1108, 0x1209, 0x130a, 0x140b,
+      0x0605, 0x0704, 0x0807, 0x0906, 0x0a01, 0x0b00, 0x0c03, 0x0d02, 0x0e0d, 0x0f0c, 0x100f, 0x110e, 0x1209, 0x1308, 0x140b, 0x150a,
+      0x0706, 0x0807, 0x0904, 0x0a05, 0x0b02, 0x0c03, 0x0d00, 0x0e01, 0x0f0e, 0x100f, 0x110c, 0x120d, 0x130a, 0x140b, 0x1508, 0x1609,
+      0x0807, 0x0906, 0x0a05, 0x0b04, 0x0c03, 0x0d02, 0x0e01, 0x0f00, 0x100f, 0x110e, 0x120d, 0x130c, 0x140b, 0x150a, 0x1609, 0x1708,
+      0x0908, 0x0a09, 0x0b0a, 0x0c0b, 0x0d0c, 0x0e0d, 0x0f0e, 0x100f, 0x1100, 0x1201, 0x1302, 0x1403, 0x1504, 0x1605, 0x1706, 0x1807,
+      0x0a09, 0x0b08, 0x0c0b, 0x0d0a, 0x0e0d, 0x0f0c, 0x100f, 0x110e, 0x1201, 0x1300, 0x1403, 0x1502, 0x1605, 0x1704, 0x1807, 0x1906,
+      0x0b0a, 0x0c0b, 0x0d08, 0x0e09, 0x0f0e, 0x100f, 0x110c, 0x120d, 0x1302, 0x1403, 0x1500, 0x1601, 0x1706, 0x1807, 0x1904, 0x1a05,
+      0x0c0b, 0x0d0a, 0x0e09, 0x0f08, 0x100f, 0x110e, 0x120d, 0x130c, 0x1403, 0x1502, 0x1601, 0x1700, 0x1807, 0x1906, 0x1a05, 0x1b04,
+      0x0d0c, 0x0e0d, 0x0f0e, 0x100f, 0x1108, 0x1209, 0x130a, 0x140b, 0x1504, 0x1605, 0x1706, 0x1807, 0x1900, 0x1a01, 0x1b02, 0x1c03,
+      0x0e0d, 0x0f0c, 0x100f, 0x110e, 0x1209, 0x1308, 0x140b, 0x150a, 0x1605, 0x1704, 0x1807, 0x1906, 0x1a01, 0x1b00, 0x1c03, 0x1d02,
+      0x0f0e, 0x100f, 0x110c, 0x120d, 0x130a, 0x140b, 0x1508, 0x1609, 0x1706, 0x1807, 0x1904, 0x1a05, 0x1b02, 0x1c03, 0x1d00, 0x1e01,
+      0x100f, 0x110e, 0x120d, 0x130c, 0x140b, 0x150a, 0x1609, 0x1708, 0x1807, 0x1906, 0x1a05, 0x1b04, 0x1c03, 0x1d02, 0x1e01, 0x1f00,
+    };
+
+  return ((cfed & 0x0f00) >> 4) | csa_stream_cdef[((cfed & 0x10ff) | (pqzyx & 0x2f00)) >> 4];
+}
+
+
+/*
+** stream cipher initialization rounds
+*/
+
+static inline void csa_stream_init_round(uint32_t iv,
+					 uint64_t *A, uint64_t *B,
+					 uint32_t *pqzyx, uint32_t *cfed)
+{
+  uint32_t tmp;
+
+  *A <<= 4;
+  *A |= (NBGET(*A, 10) ^ GETX(*pqzyx) ^ GETD(*cfed) ^ (iv >> 4)) & 0x0f;
+
+  tmp = (NBGET(*B, 6) ^ NBGET(*B, 9) ^ GETY(*pqzyx) ^ (iv)) & 0x0f;
+  tmp = csa_stream_rotate(*pqzyx, tmp);
+
+  *B <<= 4;
+  *B |= tmp;
+
+  *cfed = csa_stream_cfed(*pqzyx, *cfed) ^ csa_stream_B_sel(*B);
+
+  *pqzyx = csa_stream_sboxes(*A);
+}
+
+
+
+
+/*
+** stream cipher stream generation rounds
+*/
+
+//DVBCSA_INLINE
+//static inline void csa_stream_round(uint64_t *A, uint64_t *B,
+//				    uint32_t *pqzyx, uint32_t *cfed)
+static void csa_stream_round(uint64_t *A, uint64_t *B,
+				    uint32_t *pqzyx, uint32_t *cfed)
+{
+  uint32_t tmp;
+
+  *A <<= 4;
+  *A |= (NBGET(*A, 10) ^ GETX(*pqzyx)) & 0xf;
+
+  tmp = (NBGET(*B, 6) ^	NBGET(*B, 9) ^ GETY(*pqzyx)) & 0xf;
+
+  *B <<= 4;
+  *B |= csa_stream_rotate(*pqzyx, tmp);
+
+  *cfed = csa_stream_cfed(*pqzyx, *cfed) ^ csa_stream_B_sel(*B);
+
+  *pqzyx = csa_stream_sboxes(*A);
+}
+
+/*
+** xor data buffer with generated stream
+*/
+
+void dvbcsa_stream_xor (const dvbcsa_cw_t cw, const dvbcsa_block_t iv,
+			uint8_t *data, unsigned int len)
+{
+  unsigned int		i;
+
+  uint64_t		A, B;
+  uint32_t		pqzyx = 0;
+  uint32_t		cfed = 0;
+
+  A = dvbcsa_load_le32(cw);
+  B = dvbcsa_load_le32(cw + 4);
+
+  for (i = 0; i < 8; i++)
+    {
+      csa_stream_init_round(iv[i]		, &A, &B, &pqzyx, &cfed);
+      csa_stream_init_round(swap_nbl(iv[i])	, &A, &B, &pqzyx, &cfed);
+      csa_stream_init_round(iv[i]		, &A, &B, &pqzyx, &cfed);
+      csa_stream_init_round(swap_nbl(iv[i])	, &A, &B, &pqzyx, &cfed);
+    }
+
+  for (i = 0; i < len; i++) /* 4 round = 1 stream byte */
+    {
+      static const uint8_t csa_stream_out[16] =
+	{
+	  0x00, 0x55, 0x55, 0x00, 0xaa, 0xff, 0xff, 0xaa,
+	  0xaa, 0xff, 0xff, 0xaa, 0x00, 0x55, 0x55, 0x00,
+	};
+
+      csa_stream_round(&A, &B, &pqzyx, &cfed);
+      data[i] ^= csa_stream_out[GETD(cfed) & 0xf] & 0xc0;
+
+      csa_stream_round(&A, &B, &pqzyx, &cfed);
+      data[i] ^= csa_stream_out[GETD(cfed) & 0xf] & 0x30;
+
+      csa_stream_round(&A, &B, &pqzyx, &cfed);
+      data[i] ^= csa_stream_out[GETD(cfed) & 0xf] & 0x0c;
+
+      csa_stream_round(&A, &B, &pqzyx, &cfed);
+      data[i] ^= csa_stream_out[GETD(cfed) & 0xf] & 0x03;
+    }
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdemux.h b/drivers/stream_input/parser/demux/sw_demux/swdemux.h
new file mode 100644
index 0000000..78a9aa1
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdemux.h
@@ -0,0 +1,534 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#ifndef _SWDEMUX_H
+#define _SWDEMUX_H
+
+#include <linux/types.h>
+//#include <stdlib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**Boolean value.*/
+typedef uint8_t                          SWDMX_Bool;
+/**Boolean value true.*/
+#define SWDMX_TRUE  1
+/**Boolean value false.*/
+#define SWDMX_FALSE 0
+
+/**Function result.*/
+typedef int                              SWDMX_Result;
+/**Function result: OK.*/
+#define SWDMX_OK   1
+/**Function result: no error but do nothing.*/
+#define SWDMX_NONE 0
+/**Function result: error.*/
+#define SWDMX_ERR -1
+
+/**Size.*/
+typedef size_t                           SWDMX_Size;
+/**Integer.*/
+typedef int                              SWDMX_Int;
+/**Unsigned 8 bits integer.*/
+typedef uint8_t                          SWDMX_UInt8;
+/**Unsigned 16 bits integer.*/
+typedef uint16_t                         SWDMX_UInt16;
+/**Unsigned 32 bits integer.*/
+typedef uint32_t                         SWDMX_UInt32;
+/**Generic pointer.*/
+typedef void*                            SWDMX_Ptr;
+/**Transport stream parser.*/
+typedef struct SWDMX_TsParser_s          SWDMX_TsParser;
+/**Descrambler.*/
+typedef struct SWDMX_Descrambler_s       SWDMX_Descrambler;
+/**Descrambler channel.*/
+typedef struct SWDMX_DescChannel_s       SWDMX_DescChannel;
+/**Descramble algorithm.*/
+typedef struct SWDMX_DescAlgo_s          SWDMX_DescAlgo;
+/**TS packet filter.*/
+typedef struct SWDMX_TsFilter_s          SWDMX_TsFilter;
+/**Section packet filter.*/
+typedef struct SWDMX_SecFilter_s         SWDMX_SecFilter;
+/**Demux.*/
+typedef struct SWDMX_Demux_s             SWDMX_Demux;
+/**Transport stream packet.*/
+typedef struct SWDMX_TsPacket_s          SWDMX_TsPacket;
+/**TS packet filter's parameters.*/
+typedef struct SWDMX_TsFilterParams_s    SWDMX_TsFilterParams;
+/**Section filter's parameters.*/
+typedef struct SWDMX_SecFilterParams_s   SWDMX_SecFilterParams;
+
+/**Descramble algorithm's set parameter function.*/
+typedef SWDMX_Result (*SWDMX_DescAlgoSetFn) (
+			SWDMX_DescAlgo *algo,
+			SWDMX_Int       type,
+			SWDMX_Ptr       param
+			);
+/**Descramble function.*/
+typedef SWDMX_Result (*SWDMX_DescAlgoDescFn) (
+			SWDMX_DescAlgo *algo,
+			SWDMX_TsPacket *pkt
+			);
+/**Descramble algorithm data free function.*/
+typedef void (*SWDMX_DescAlgoFreeFn) (
+			SWDMX_DescAlgo *algo
+			);
+/**TS packet callback function.*/
+typedef void (*SWDMX_TsPacketCb) (
+			SWDMX_TsPacket *pkt,
+			SWDMX_Ptr       udata);
+/**Section data callback function.*/
+typedef void (*SWDMX_SecCb) (
+			SWDMX_UInt8  *data,
+			SWDMX_Int     len,
+			SWDMX_Ptr     udata);
+
+/**Length of the section filter.*/
+#define SWDMX_SEC_FILTER_LEN 16
+
+/**TS packet filter's parameters.*/
+struct SWDMX_TsFilterParams_s {
+	SWDMX_UInt16 pid; /**< PID of the stream.*/
+};
+
+/**Section filter's parameters.*/
+struct SWDMX_SecFilterParams_s {
+	SWDMX_UInt16 pid;                         /**< PID of the section.*/
+	SWDMX_Bool   crc32;                       /**< CRC32 check.*/
+	SWDMX_UInt8  value[SWDMX_SEC_FILTER_LEN]; /**< Value array.*/
+	SWDMX_UInt8  mask[SWDMX_SEC_FILTER_LEN];  /**< Mask array.*/
+	SWDMX_UInt8  mode[SWDMX_SEC_FILTER_LEN];  /**< Match mode array.*/
+};
+
+/**TS packet.*/
+struct SWDMX_TsPacket_s {
+	SWDMX_UInt16  pid;           /**< PID.*/
+	SWDMX_Bool    payload_start; /**< Payload start flag.*/
+	SWDMX_Bool    priority;      /**< TS packet priority.*/
+	SWDMX_Bool    error;         /**< Error flag.*/
+	SWDMX_UInt8   scramble;      /**< Scramble flag.*/
+	SWDMX_UInt8   cc;            /**< Continuous counter.*/
+	SWDMX_UInt8  *packet;        /**< Packet buffer.*/
+	SWDMX_Int     packet_len;    /**< Packet length.*/
+	SWDMX_UInt8  *adp_field;     /**< Adaptation field buffer.*/
+	SWDMX_Int     adp_field_len; /**< Adaptation field length.*/
+	SWDMX_UInt8  *payload;       /**< Payload buffer.*/
+	SWDMX_Int     payload_len;   /**< Payload length.*/
+};
+
+/**DVBCSA2 parameter.*/
+enum {
+	SWDMX_DVBCSA2_PARAM_ODD_KEY,  /**< 8 bytes odd key.*/
+	SWDMX_DVBCSA2_PARAM_EVEN_KEY  /**< 8 bytes even key.*/
+};
+
+/**Scrambled data alignment.*/
+enum {
+	SWDMX_DESC_ALIGN_HEAD, /**< Align to payload head.*/
+	SWDMX_DESC_ALIGN_TAIL  /**< Align to payload tail.*/
+};
+
+/**AES ECB parameter.*/
+enum {
+	SWDMX_AES_ECB_PARAM_ODD_KEY,  /**< 16 bytes odd key.*/
+	SWDMX_AES_ECB_PARAM_EVEN_KEY, /**< 16 bytes even key.*/
+	SWDMX_AES_ECB_PARAM_ALIGN     /**< Alignment.*/
+};
+
+/**AES CBC parameter.*/
+enum {
+	SWDMX_AES_CBC_PARAM_ODD_KEY,  /**< 16 bytes odd key.*/
+	SWDMX_AES_CBC_PARAM_EVEN_KEY, /**< 16 bytes even key.*/
+	SWDMX_AES_CBC_PARAM_ALIGN,    /**< Align to head.*/
+	SWDMX_AES_CBC_PARAM_ODD_IV,   /**< 16 bytes odd key's IV data.*/
+	SWDMX_AES_CBC_PARAM_EVEN_IV   /**< 16 bytes even key's ID data.*/
+};
+
+/**
+ * Create a new TS packet parser.
+ * \return The new TS parser.
+ */
+extern SWDMX_TsParser*
+swdmx_ts_parser_new (void);
+
+/**
+ * Set the TS packet size.
+ * \param tsp The TS parser.
+ * \param size The packet size.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_ts_parser_set_packet_size (
+			SWDMX_TsParser *tsp,
+			SWDMX_Int       size);
+
+/**
+ * Add a TS packet callback function to the TS parser.
+ * \param tsp The TS parser.
+ * \param cb The callback function.
+ * \param data The user defined data used as the callback's parameter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_ts_parser_add_ts_packet_cb (
+			SWDMX_TsParser   *tsp,
+			SWDMX_TsPacketCb  cb,
+			SWDMX_Ptr         data);
+
+/**
+ * Remove a TS packet callback function from the TS parser.
+ * \param tsp The TS parser.
+ * \param cb The callback function.
+ * \param data The user defined data used as the callback's parameter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_ts_parser_remove_ts_packet_cb (
+			SWDMX_TsParser   *tsp,
+			SWDMX_TsPacketCb  cb,
+			SWDMX_Ptr         data);
+
+/**
+ * Parse TS data.
+ * \param tsp The TS parser.
+ * \param data Input TS data.
+ * \param len Input data length in bytes.
+ * \return Parse data length in bytes.
+ */
+extern SWDMX_Int
+swdmx_ts_parser_run (
+			SWDMX_TsParser *tsp,
+			SWDMX_UInt8    *data,
+			SWDMX_Int       len);
+
+/**
+ * Free an unused TS parser.
+ * \param tsp The TS parser to be freed.
+ */
+extern void
+swdmx_ts_parser_free (SWDMX_TsParser *tsp);
+
+/**
+ * Create a new descrambler.
+ * \return The new descrambler.
+ */
+extern SWDMX_Descrambler*
+swdmx_descrambler_new (void);
+
+/**
+ * Allocate a channel from the descrambler.
+ * \param desc The descrambler.
+ * \return The new channel.
+ */
+extern SWDMX_DescChannel*
+swdmx_descrambler_alloc_channel (SWDMX_Descrambler *desc);
+
+/**
+ * The TS packet input function of the descrambler.
+ * \param pkt The input packet.
+ * \param desc The descrambler.
+ */
+extern void
+swdmx_descrambler_ts_packet_cb (
+			SWDMX_TsPacket *pkt,
+			SWDMX_Ptr       desc);
+
+/**
+ * Add a TS packet callback to the descrambler.
+ * \param desc The descrambler.
+ * \param cb The callback function.
+ * \param data The user defined data used as callback's parameter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_descrambler_add_ts_packet_cb (
+			SWDMX_Descrambler *desc,
+			SWDMX_TsPacketCb   cb,
+			SWDMX_Ptr          data);
+
+/**
+ * Remove a TS packet callback from the descrambler.
+ * \param desc The descrambler.
+ * \param cb The callback function.
+ * \param data The user defined data used as callback's parameter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_descrambler_remove_ts_packet_cb (
+			SWDMX_Descrambler *desc,
+			SWDMX_TsPacketCb   cb,
+			SWDMX_Ptr          data);
+
+/**
+ * Free an unused descrambler.
+ * \param desc The descrambler to be freed.
+ */
+extern void
+swdmx_descrambler_free (SWDMX_Descrambler *desc);
+
+/**
+ * Set the descrambler channel's algorithm.
+ * \param chan The descrambler channel.
+ * \param algo The algorithm data.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_desc_channel_set_algo (
+			SWDMX_DescChannel *chan,
+			SWDMX_DescAlgo    *algo);
+
+/**
+ * Set the descrambler channel's related PID.
+ * \param chan The descrambler channel.
+ * \param pid The PID.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_desc_channel_set_pid (
+			SWDMX_DescChannel *chan,
+			SWDMX_UInt16       pid);
+
+/**
+ * Set the parameter of a descrambler channel.
+ * \param chan The descrambler channel.
+ * \param type Parameter type.
+ * \param param Parameter value.
+ */
+extern SWDMX_Result
+swdmx_desc_channel_set_param (
+			SWDMX_DescChannel *chan,
+			SWDMX_Int          type,
+			SWDMX_Ptr          param);
+
+/**
+ * Enable a descrambler channel.
+ * \param chan The descrambler channel.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_desc_channel_enable (SWDMX_DescChannel *chan);
+
+/**
+ * Disable a descrambler channel.
+ * \param chan The descrambler channel.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_desc_channel_disable (SWDMX_DescChannel *chan);
+
+/**
+ * Free an unused descrambler channel.
+ * \param chan The descrambler channel to be freed.
+ */
+extern void
+swdmx_desc_channel_free (SWDMX_DescChannel *chan);
+
+/**
+ * Create a new demux.
+ * \return The new demux.
+ */
+extern SWDMX_Demux*
+swdmx_demux_new (void);
+
+/**
+ * Allocate a new TS packet filter from the demux.
+ * \param dmx The demux.
+ * \return The new TS packet filter.
+ */
+extern SWDMX_TsFilter*
+swdmx_demux_alloc_ts_filter (SWDMX_Demux *dmx);
+
+/**
+ * Allocate a new section filter from the demux.
+ * \param dmx The demux.
+ * \return The new section filter.
+ */
+extern SWDMX_SecFilter*
+swdmx_demux_alloc_sec_filter (SWDMX_Demux *dmx);
+
+/**
+ * TS packet input function of the demux.
+ * \param pkt Input TS packet.
+ * \param dmx The demux.
+ */
+extern void
+swdmx_demux_ts_packet_cb (
+			SWDMX_TsPacket *pkt,
+			SWDMX_Ptr       dmx);
+
+/**
+ * Free an unused demux.
+ * \param dmx The demux to be freed.
+ */
+extern void
+swdmx_demux_free (SWDMX_Demux *dmx);
+
+/**
+ * Set the TS filter's parameters.
+ * \param filter The filter.
+ * \param params Parameters of the filter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_ts_filter_set_params (
+			SWDMX_TsFilter       *filter,
+			SWDMX_TsFilterParams *params);
+
+/**
+ * Add a TS packet callback to the TS filter.
+ * \param filter The TS filter.
+ * \param cb The callback function.
+ * \param data User defined data used as callback's parameter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_ts_filter_add_ts_packet_cb (
+			SWDMX_TsFilter   *filter,
+			SWDMX_TsPacketCb  cb,
+			SWDMX_Ptr         data);
+
+/**
+ * Remove a TS packet callback from the TS filter.
+ * \param filter The TS filter.
+ * \param cb The callback function.
+ * \param data User defined data used as callback's parameter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_ts_filter_remove_ts_packet_cb (
+			SWDMX_TsFilter   *filter,
+			SWDMX_TsPacketCb  cb,
+			SWDMX_Ptr         data);
+
+/**
+ * Enable the TS filter.
+ * \param filter The TS filter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_ts_filter_enable (SWDMX_TsFilter *filter);
+
+/**
+ * Disable the TS filter.
+ * \param filter The filter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_ts_filter_disable (SWDMX_TsFilter *filter);
+
+/**
+ * Free an unused TS filter.
+ * \param filter The ts filter to be freed.
+ */
+extern void
+swdmx_ts_filter_free (SWDMX_TsFilter *filter);
+
+/**
+ * Set the section filter's parameters.
+ * \param filter The section filter.
+ * \param params Parameters of the filter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_sec_filter_set_params (
+			SWDMX_SecFilter       *filter,
+			SWDMX_SecFilterParams *params);
+
+/**
+ * Add a section callback to the section filter.
+ * \param filter The section filter.
+ * \param cb The callback function.
+ * \param data User defined data used as callback's parameter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_sec_filter_add_section_cb (
+			SWDMX_SecFilter *filter,
+			SWDMX_SecCb      cb,
+			SWDMX_Ptr        data);
+
+/**
+ * Remove a section callback from the section filter.
+ * \param filter The section filter.
+ * \param cb The callback function.
+ * \param data User defined data used as callback's parameter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_sec_filter_remove_section_cb (
+			SWDMX_SecFilter *filter,
+			SWDMX_SecCb      cb,
+			SWDMX_Ptr        data);
+
+/**
+ * Enable the section filter.
+ * \param filter The section filter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_sec_filter_enable (SWDMX_SecFilter *filter);
+
+/**
+ * Disable the section filter.
+ * \param filter The section filter.
+ * \retval SWDMX_OK On success.
+ * \retval SWDMX_ERR On error.
+ */
+extern SWDMX_Result
+swdmx_sec_filter_disable (SWDMX_SecFilter *filter);
+
+/**
+ * Free an unused section filter.
+ * \param filter The section filter to be freed.
+ */
+extern void
+swdmx_sec_filter_free (SWDMX_SecFilter *filter);
+
+/**
+ * Create a new DVB-CSA2 descramble algorithm data.
+ * \return The new descramble algorithm data.
+ */
+extern SWDMX_DescAlgo*
+swdmx_dvbcsa2_algo_new (void);
+
+/**
+ * Create a new AES ECB descramble algorithm data.
+ * \return The new descramble algorithm data.
+ */
+extern SWDMX_DescAlgo*
+swdmx_aes_ecb_algo_new (void);
+
+/**
+ * Create a new AES CBC descramble algorithm data.
+ * \return The new descramble algorithm data.
+ */
+extern SWDMX_DescAlgo*
+swdmx_aes_cbc_algo_new (void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdemux_internal.h b/drivers/stream_input/parser/demux/sw_demux/swdemux_internal.h
new file mode 100644
index 0000000..fc2825e
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdemux_internal.h
@@ -0,0 +1,282 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#ifndef _SWDEMUX_INTERNAL_H
+#define _SWDEMUX_INTERNAL_H
+
+#include "swdemux.h"
+
+#ifdef __KERNEL__
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+#else
+#include <assert.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**Double linked list node.*/
+typedef struct SWDMX_List_s SWDMX_List;
+
+/**Double linked list node.*/
+struct SWDMX_List_s {
+	SWDMX_List *prev; /**< The previous node in the list.*/
+	SWDMX_List *next; /**< The next node in the list.*/
+};
+
+/**Callback entry.*/
+typedef struct {
+	SWDMX_List ln;    /**< List node data.*/
+	SWDMX_Ptr  cb;    /**< Callback function.*/
+	SWDMX_Ptr  data;  /**< User defined data.*/
+} SWDMX_CbEntry;
+
+/**TS packet parser.*/
+struct SWDMX_TsParser_s {
+	SWDMX_Int  packet_size; /**< Packet size.*/
+	SWDMX_List cb_list;     /**< Callback list.*/
+};
+
+/**Descrambler.*/
+struct SWDMX_Descrambler_s {
+	SWDMX_List chan_list; /**< Descrambler channel list.*/
+	SWDMX_List cb_list;   /**< Callback list.*/
+};
+
+/**Descrambler channel.*/
+struct SWDMX_DescChannel_s {
+	SWDMX_List      ln;     /**< List node data.*/
+	SWDMX_Bool      enable; /**< The channel is enabled.*/
+	SWDMX_UInt16    pid;    /**< PID of the stream.*/
+	SWDMX_DescAlgo *algo;   /**< Descrambler algorithm functions.*/
+};
+
+/**Descrambler algorithm.*/
+struct SWDMX_DescAlgo_s {
+	SWDMX_DescAlgoSetFn  set_fn;  /**< Set parameter function.*/
+	SWDMX_DescAlgoDescFn desc_fn; /**< Descramble function.*/
+	SWDMX_DescAlgoFreeFn free_fn; /**< Free function.*/
+};
+
+/**Demux PID filter.*/
+typedef struct {
+	SWDMX_List      ln;              /**< List node data.*/
+	SWDMX_UInt16    pid;             /**< PID.*/
+	SWDMX_List      ts_filter_list;  /**< TS filter list.*/
+	SWDMX_List      sec_filter_list; /**< Section filter list.*/
+	SWDMX_UInt8    *sec_data;        /**< Section data buffer.*/
+	SWDMX_Int       sec_recv;        /**< Section data received*/
+} SWDMX_PidFilter;
+
+/**Demux.*/
+struct SWDMX_Demux_s {
+	SWDMX_List pid_filter_list; /**< PID filter list.*/
+	SWDMX_List ts_filter_list;  /**< TS filter list.*/
+	SWDMX_List sec_filter_list; /**< Section filter list.*/
+};
+
+/**Filter's state.*/
+typedef enum {
+	SWDMX_FILTER_STATE_INIT, /**< Initialized.*/
+	SWDMX_FILTER_STATE_SET,  /**< Parameters has been set.*/
+	SWDMX_FILTER_STATE_RUN   /**< Running.*/
+} SWDMX_FilterState;
+
+/**TS filter.*/
+struct SWDMX_TsFilter_s {
+	SWDMX_Demux          *dmx;        /**< The demux contains this filter.*/
+	SWDMX_List            ln;         /**< List node data.*/
+	SWDMX_List            pid_ln;     /**< List node used in PID filter.*/
+	SWDMX_PidFilter      *pid_filter; /**< The PID filter contains this TS filter.*/
+	SWDMX_FilterState     state;      /**< State of the filter.*/
+	SWDMX_TsFilterParams  params;     /**< Parameters.*/
+	SWDMX_List            cb_list;    /**< Callback list.*/
+};
+
+/**Section filter.*/
+struct SWDMX_SecFilter_s {
+	SWDMX_Demux           *dmx;        /**< The demux contains this filter.*/
+	SWDMX_List             ln;         /**< List node data.*/
+	SWDMX_List             pid_ln;     /**< List node used in PID filter.*/
+	SWDMX_PidFilter       *pid_filter; /**< The PID filter contains this section filter.*/
+	SWDMX_FilterState      state;      /**< State of the filter.*/
+	SWDMX_SecFilterParams  params;     /**< Parameters.*/
+	SWDMX_UInt8            value[SWDMX_SEC_FILTER_LEN + 2]; /**< Value array.*/
+	SWDMX_UInt8            mam[SWDMX_SEC_FILTER_LEN + 2];   /**< Mask & mode array.*/
+	SWDMX_UInt8            manm[SWDMX_SEC_FILTER_LEN + 2];  /**< Mask & ~mode array.*/
+	SWDMX_List             cb_list;    /**< Callback list.*/
+};
+
+#define SWDMX_MAX(a, b)   ((a) > (b) ? (a) : (b))
+#define SWDMX_MIN(a, b)   ((a) < (b) ? (a) : (b))
+#define SWDMX_ASSERT(a)   while(!a);//assert(a)
+#define SWDMX_PTR2SIZE(p) ((SWDMX_Size)(p))
+#define SWDMX_SIZE2PTR(s) ((SWDMX_Ptr)(SWDMX_Size)(s))
+#define SWDMX_OFFSETOF(s, m)\
+	SWDMX_PTR2SIZE(&((s*)0)->m)
+#define SWDMX_CONTAINEROF(p, s, m)\
+	((s*)(SWDMX_PTR2SIZE(p) - SWDMX_OFFSETOF(s, m)))
+
+/**
+ * Output log message.
+ * \param fmt Output format string.
+ * \param ... Variable arguments.
+ */
+#if 0
+static inline void
+swdmx_log (const char *fmt, ...)
+{
+#if 0
+	va_list ap;
+
+	fprintf(stderr, "SWDMX: ");
+
+	va_start(ap, fmt);
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
+
+	fprintf(stderr, "\n");
+#endif
+}
+#else
+#define swdmx_log(f, a...) printk("%s:" f, __func__, ## a);
+#endif
+/**
+ * Check if the PID is valid.
+ * \param pid The PID.
+ * \retval SWDMX_TRUE The PID is valid.
+ * \retval SWDMX_FALSE The PID is invalid.
+ */
+static inline SWDMX_Bool
+swdmx_is_valid_pid (SWDMX_UInt16 pid)
+{
+	return (pid <= 0x1fff);
+}
+
+/**
+ * Allocate a new memory buffer.
+ * \param size The size of the buffer.
+ * \return The new buffer's pointer.
+ */
+static inline SWDMX_Ptr
+swdmx_malloc (SWDMX_Size size)
+{
+	return kmalloc(size,GFP_KERNEL);
+}
+
+/**
+ * Free an unused buffer.
+ * \param ptr The buffer to be freed.
+ */
+static inline void
+swdmx_free (SWDMX_Ptr ptr)
+{
+	kfree(ptr);
+}
+
+/**
+ * Check if the list is empty.
+ * \param l The list.
+ * \retval SWDMX_TRUE The list is empty.
+ * \retval SWDMX_FALSE The list is not empty.
+ */
+static inline SWDMX_Bool
+swdmx_list_is_empty (SWDMX_List *l)
+{
+	return l->next == l;
+}
+
+/**
+ * Initialize a list node.
+ * \param n The node to be initalize.
+ */
+static inline void
+swdmx_list_init (SWDMX_List *n)
+{
+	n->prev = n;
+	n->next = n;
+}
+
+/**
+ * Append a node to the list.
+ * \param l The list.
+ * \param n The node to be added.
+ */
+static inline void
+swdmx_list_append (SWDMX_List *l, SWDMX_List *n)
+{
+	n->prev = l->prev;
+	n->next = l;
+	l->prev->next = n;
+	l->prev = n;
+}
+
+/**
+ * Remove a node from the list.
+ * \param n The node to be removed.
+ */
+static inline void
+swdmx_list_remove (SWDMX_List *n)
+{
+	n->prev->next = n->next;
+	n->next->prev = n->prev;
+}
+
+/*Traverse the nodes in the list.*/
+#define SWDMX_LIST_FOR_EACH(i, l, m)\
+	for ((i) = SWDMX_CONTAINEROF((l)->next, typeof(*i), m);\
+				(i) != SWDMX_CONTAINEROF(l, typeof(*i), m);\
+				(i) = SWDMX_CONTAINEROF((i)->m.next, typeof(*i), m))
+
+/*Traverse the nodes in the list safely.*/
+#define SWDMX_LIST_FOR_EACH_SAFE(i, n, l, m)\
+	for ((i) = SWDMX_CONTAINEROF((l)->next, typeof(*i), m),\
+				(n) = SWDMX_CONTAINEROF((i)->m.next, typeof(*i), m);\
+				(i) != SWDMX_CONTAINEROF(l, typeof(*i), m);\
+				(i) = (n),\
+				(n) = SWDMX_CONTAINEROF((i)->m.next, typeof(*i), m))
+
+/**
+ * Add a callback to the list.
+ * \param l The callback list.
+ * \param cb The callback function.
+ * \param data The user defined parameter.
+ */
+extern void
+swdmx_cb_list_add (SWDMX_List *l, SWDMX_Ptr cb, SWDMX_Ptr data);
+
+/**
+ * Remove a callback from the list.
+ * \param l The callback list.
+ * \param cb The callback function to be removed.
+ * \param data The user defined parameter.
+ */
+extern void
+swdmx_cb_list_remove (SWDMX_List *l, SWDMX_Ptr cb, SWDMX_Ptr data);
+
+/**
+ * Clear the callback list.
+ * \param l The callback list to be cleared.
+ */
+extern void
+swdmx_cb_list_clear (SWDMX_List *l);
+
+/**
+ * CRC32.
+ */
+extern SWDMX_UInt32
+swdmx_crc32 (const SWDMX_UInt8 *data, SWDMX_Int len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdemux_test.c b/drivers/stream_input/parser/demux/sw_demux/swdemux_test.c
new file mode 100644
index 0000000..3762581
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdemux_test.c
@@ -0,0 +1,269 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#include "swdemux.h"
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <string.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+
+struct thread_args {
+	char *fname;
+	struct timeval start_tv;
+};
+static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
+static struct timeval start_tv;
+
+static void prdump(const char* m, const void* data, uint32_t len) {
+	if (m)
+		printf("%s:\n", m);
+	if (data) {
+		size_t i = 0;
+		const unsigned char *c __attribute__((unused)) = data;
+		while (len >= 16) {
+			printf("%02x %02x %02x %02x %02x %02x %02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+					c[i], c[i+1], c[i+2], c[i+3], c[i+4], c[i+5], c[i+6], c[i+7],
+					c[i+8], c[i+9], c[i+10], c[i+11], c[i+12], c[i+13], c[i+14], c[i+15]);
+			len -= 16;
+			i += 16;
+		}
+		while (len >= 8) {
+			printf("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+					c[i], c[i+1], c[i+2], c[i+3], c[i+4], c[i+5], c[i+6], c[i+7]);
+			len -= 8;
+			i += 8;
+		}
+		while (len >= 4) {
+			printf("%02x %02x %02x %02x\n",
+					c[i], c[i+1], c[i+2], c[i+3]);
+			len -= 4;
+			i += 4;
+		}
+		while (len >= 1) {
+			printf("%02x ", c[i]);
+			len -= 1;
+			i += 1;
+		}
+	}
+}
+static void
+ts_pkt_cb (SWDMX_TsPacket *pkt, SWDMX_Ptr data)
+{
+	return;
+	uint8_t *buf = pkt->packet;
+	//prdump("ts_data", pkt->packet, 32);
+	if (pkt->packet_len != 188) {
+		printf("ts data len wrong:%d\n", pkt->packet_len);
+	} else {
+		int i;
+		for (i = 5; i < 188; i++) {
+			if (buf[i] != buf[i-1] + 1) {
+				printf("ts data error i:%d, buf:%#x, %#x\n", i, buf[i], buf[i-1]);
+				break;
+			}
+		}
+	}
+}
+
+static void
+sec_cb (SWDMX_UInt8 *sec, SWDMX_Int len, SWDMX_Ptr data)
+{
+	SWDMX_Int i;
+
+	printf("section:\n");
+
+	for (i = 0; i < len; i ++) {
+		printf("%02x%s", sec[i], ((i + 1) & 0xf) ? " " : "\n");
+	}
+
+	if (len & 0xf)
+		printf("\n");
+}
+
+void thread_func(void *args)
+{
+	FILE *fp = NULL;
+	uint8_t buf[64*1024];
+	int ret;
+	int total = 0, left = 0, n = 0;
+	struct timeval tv;
+	struct timeval tv_limits;
+	struct thread_args targs;
+	char *file_name;
+	int diff_time;
+	int sleep_cnt = 0;
+	unsigned int total_ts_cnt = 0;
+	unsigned int ts_loop = 0;
+	SWDMX_TsFilter       *tsf;
+	SWDMX_SecFilter      *secf;
+	SWDMX_DescChannel    *dch;
+	SWDMX_DescAlgo       *algo;
+	SWDMX_TsFilterParams  tsfp;
+	SWDMX_SecFilterParams secfp;
+	SWDMX_TsParser    *tsp;
+	SWDMX_Descrambler *desc;
+	SWDMX_Demux       *dmx;
+	uint8_t odd_key[16] = {0x79, 0x4B, 0x21, 0x80, 0x13, 0x71, 0x00, 0xFA, 0x1E, 0xBD, 0xCB, 0x13, 0xB0, 0x63, 0xE5, 0x28};
+	uint8_t even_key[16] = {0x32, 0x6C, 0xD4, 0xE9, 0xE0, 0xD6, 0x74, 0x81, 0x1A, 0x00, 0xF0, 0xCE, 0x1B, 0x50, 0xBC, 0xD8};
+	uint8_t iv[16] = {0x49, 0x72, 0x64, 0x65, 0x74, 0x6F, 0xA9, 0x43, 0x6F, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74};
+
+	memcpy(&targs, args, sizeof(targs));
+	file_name = targs.fname;
+	fp = fopen(file_name, "rb");
+	if (fp == NULL) {
+		printf("thread open %s failed\n", file_name);
+		return;
+	}
+	printf("Begin to process %s, tid:%lu\n", file_name, pthread_self());
+
+	tsp  = swdmx_ts_parser_new();
+	desc = swdmx_descrambler_new();
+	dmx  = swdmx_demux_new();
+
+	swdmx_ts_parser_add_ts_packet_cb(tsp,
+				swdmx_descrambler_ts_packet_cb,
+				desc);
+	swdmx_descrambler_add_ts_packet_cb(desc,
+				swdmx_demux_ts_packet_cb,
+				dmx);
+
+	dch = swdmx_descrambler_alloc_channel(desc);
+	algo = swdmx_aes_cbc_algo_new();
+
+	swdmx_desc_channel_set_algo(dch, algo);
+	swdmx_desc_channel_set_pid(dch, 0x80);
+	swdmx_desc_channel_set_param(dch, SWDMX_AES_CBC_PARAM_ALIGN, SWDMX_DESC_ALIGN_HEAD);
+	swdmx_desc_channel_set_param(dch, SWDMX_AES_CBC_PARAM_ODD_KEY, odd_key);
+	swdmx_desc_channel_set_param(dch, SWDMX_AES_CBC_PARAM_EVEN_KEY, even_key);
+	swdmx_desc_channel_set_param(dch, SWDMX_AES_CBC_PARAM_ODD_IV, iv);
+	swdmx_desc_channel_set_param(dch, SWDMX_AES_CBC_PARAM_EVEN_IV, iv);
+
+	swdmx_desc_channel_enable(dch);
+	tsf = swdmx_demux_alloc_ts_filter(dmx);
+
+	tsfp.pid = 0x80;
+
+	swdmx_ts_filter_set_params(tsf, &tsfp);
+	swdmx_ts_filter_enable(tsf);
+	swdmx_ts_filter_add_ts_packet_cb(tsf, ts_pkt_cb, NULL);
+
+	secf = swdmx_demux_alloc_sec_filter(dmx);
+
+#if 1
+	memset(&secfp, 0, sizeof(secfp));
+	secfp.pid   = 0x0;
+	secfp.crc32 = SWDMX_TRUE;
+	secfp.value[0] = 0x0;
+	secfp.mask[0]  = 0xff;
+	swdmx_sec_filter_set_params(secf, &secfp);
+	swdmx_sec_filter_enable(secf);
+	swdmx_sec_filter_add_section_cb(secf, sec_cb, NULL);
+#endif
+	while (1) {
+		n = fread(buf + left, 1, sizeof(buf) - left, fp);
+		if (n == 0)
+		{
+			ts_loop++;
+			if (ts_loop > 1)
+				break;
+
+			fseek(fp, 0L, SEEK_SET);
+		}
+		total_ts_cnt += n;
+
+		left += n;
+
+		n = swdmx_ts_parser_run(tsp, buf, left);
+
+		left -= n;
+		if (left)
+			memmove(buf, buf + n, left);
+
+		gettimeofday(&tv_limits, NULL);
+		if (tv_limits.tv_usec < targs.start_tv.tv_usec) {
+			diff_time = (tv_limits.tv_sec - 1 - targs.start_tv.tv_sec) * 1000 +
+				(tv_limits.tv_usec + 1*1000*1000 - targs.start_tv.tv_usec) / 1000;
+		} else {
+			diff_time = (tv_limits.tv_sec - targs.start_tv.tv_sec) * 1000 +
+				(tv_limits.tv_usec - targs.start_tv.tv_usec) / 1000;
+		}
+		if ((total_ts_cnt/1024/1024*1000*8)/diff_time >= 20)
+		{
+				usleep(20*1000);
+		}
+	}
+
+	gettimeofday(&tv, NULL);
+	if (tv.tv_usec < targs.start_tv.tv_usec) {
+		diff_time = (tv.tv_sec - 1 - targs.start_tv.tv_sec) * 1000 +
+			(tv.tv_usec + 1*1000*1000 - targs.start_tv.tv_usec) / 1000;
+	} else {
+		diff_time = (tv.tv_sec - targs.start_tv.tv_sec) * 1000 +
+			(tv.tv_usec - targs.start_tv.tv_usec) / 1000;
+	}
+
+	swdmx_ts_parser_free(tsp);
+	swdmx_descrambler_free(desc);
+	swdmx_demux_free(dmx);
+	fclose(fp);
+	printf("----->> thread %s end, ts_pkt_num:%d, time:%d ms, Mbps:%d \n",
+			file_name, total_ts_cnt, diff_time, (total_ts_cnt/1024*1000/1024*8)/diff_time);
+
+	total_ts_cnt = 0;
+}
+int main (int argc, char **argv)
+{
+	char  buf[64*1024];
+	int   n, left = 0, i, ts_num, ret;
+	FILE *fp;
+	struct timeval tv;
+	int diff_time;
+	struct thread_args targs;
+	pthread_t tid[8] = {0};
+
+	if (argc < 2) {
+		fprintf(stderr, "input file no specified\n");
+		return 1;
+	}
+
+	ts_num = argc - 1;
+	printf("Decrypt %d ts\n", ts_num);
+
+	ret = pthread_mutex_init(&mutex, NULL);
+	if (ret) {
+		printf("mutex init failed\n");
+		return -1;
+	}
+	gettimeofday(&start_tv, NULL);
+
+	for (i = 0; i < ts_num; i++) {
+		memset(&targs, 0, sizeof(targs));
+		targs.fname = argv[i+1];
+		printf("----->> fname:%s\n", targs.fname);
+		memcpy(&targs.start_tv, &start_tv, sizeof(start_tv));
+		pthread_create(&tid[i], NULL, thread_func, &targs);
+		usleep(1*1000);
+	}
+
+	for (i = 0; i < ts_num; i++) {
+		pthread_join(tid[i], NULL);
+	}
+	gettimeofday(&tv, NULL);
+	if (tv.tv_usec < start_tv.tv_usec) {
+		diff_time = (tv.tv_sec - 1 - start_tv.tv_sec) * 1000 +
+			(tv.tv_usec + 1*1000*1000 - start_tv.tv_usec) / 1000;
+	} else {
+		diff_time = (tv.tv_sec - start_tv.tv_sec) * 1000 +
+			(tv.tv_usec - start_tv.tv_usec) / 1000;
+	}
+	printf("All decrypt end, time:%d ms\n", diff_time);
+	pthread_mutex_destroy(&mutex);
+
+	return 0;
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdmx_aes_cbc.c b/drivers/stream_input/parser/demux/sw_demux/swdmx_aes_cbc.c
new file mode 100644
index 0000000..47e14a6
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdmx_aes_cbc.c
@@ -0,0 +1,192 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#include "swdemux_internal.h"
+#ifdef __KERNEL__
+#include <linux/scatterlist.h>
+#include <linux/crypto.h>
+#else
+#include <crypto/aes.h>
+#endif
+
+typedef struct {
+	SWDMX_DescAlgo algo;
+	SWDMX_Int      align;
+#ifdef __KERNEL__
+	struct blkcipher_desc desc;
+	SWDMX_UInt8 odd_key[16];
+	SWDMX_UInt8 even_key[16];
+#else
+	AES_KEY        odd;
+	AES_KEY        even;
+#endif
+	SWDMX_UInt8    odd_iv[16];
+	SWDMX_UInt8    even_iv[16];
+} SWDMX_AesCbcAlgo;
+
+static SWDMX_Result
+aes_cbc_set (SWDMX_DescAlgo *p, SWDMX_Int type, SWDMX_Ptr param)
+{
+	SWDMX_AesCbcAlgo *algo = (SWDMX_AesCbcAlgo*)p;
+	SWDMX_UInt8      *key;
+	SWDMX_Result      r;
+
+	switch (type) {
+	case SWDMX_AES_CBC_PARAM_ODD_KEY:
+		key = param;
+		r   = SWDMX_OK;
+#ifdef __KERNEL__
+		memcpy(algo->odd_key,key,16);
+#else
+		AES_set_decrypt_key(key, 128, &algo->odd);
+#endif
+		break;
+	case SWDMX_AES_CBC_PARAM_EVEN_KEY:
+		key = param;
+		r   = SWDMX_OK;
+#ifdef __KERNEL__
+		memcpy(algo->even_key,key,16);
+#else
+		AES_set_decrypt_key(key, 128, &algo->even);
+#endif
+		break;
+	case SWDMX_AES_CBC_PARAM_ALIGN:
+		algo->align = SWDMX_PTR2SIZE(param);
+		r   = SWDMX_OK;
+		break;
+	case SWDMX_AES_CBC_PARAM_ODD_IV:
+		key = param;
+		r   = SWDMX_OK;
+		memcpy(algo->odd_iv, key, 16);
+		break;
+	case SWDMX_AES_CBC_PARAM_EVEN_IV:
+		key = param;
+		r   = SWDMX_OK;
+		memcpy(algo->even_iv, key, 16);
+		break;
+	default:
+		swdmx_log("illegal DVBCSA2 parameter");
+		r = SWDMX_ERR;
+		break;
+	}
+
+	return r;
+}
+
+static void
+aes_cbc_desc_pkt (SWDMX_AesCbcAlgo *algo, SWDMX_Int key_type, SWDMX_UInt8 *iv, SWDMX_TsPacket *pkt, SWDMX_Int align)
+{
+	SWDMX_UInt8 *p    = pkt->payload;
+	SWDMX_Int    left = pkt->payload_len, len;
+	SWDMX_UInt8  obuf[184];
+	SWDMX_UInt8  ivbuf[16];
+	SWDMX_UInt8 *in;
+	SWDMX_UInt8 *out  = obuf;
+#ifdef __KERNEL__
+	struct scatterlist dst[1];
+	struct scatterlist src[1];
+
+	u8 *key = NULL;
+#else
+	AES_KEY *key = NULL;
+#endif
+
+	if (align == SWDMX_DESC_ALIGN_TAIL) {
+		SWDMX_Int head = left & 15;
+
+		p    += head;
+		left -= head;
+	} else {
+		SWDMX_Int tail = left & 15;
+
+		left -= tail;
+	}
+#ifdef __KERNEL__
+	if (key_type == 0) {
+		key = (u8*)&algo->even_key;
+	}else{
+		key = (u8*)&algo->odd_key;
+	}
+	crypto_blkcipher_setkey(algo->desc.tfm,key, 16);
+#else
+	if (key_type == 0) {
+		key = &algo->even;
+	}else{
+		key = &algo->odd;
+	}
+#endif
+
+	memcpy(ivbuf, iv, 16);
+
+	in  = p;
+	len = left;
+
+#ifdef __KERNEL__
+	crypto_blkcipher_set_iv(algo->desc.tfm,ivbuf,16);
+
+	sg_init_table(dst,1);
+	sg_init_table(src,1);
+	sg_set_buf(dst,out,len);
+	sg_set_buf(src,in,len);
+	crypto_blkcipher_decrypt(&algo->desc,dst,src,len);
+#else
+	AES_cbc_encrypt(in, out, len, key, ivbuf, 0);
+#endif
+	memcpy(in, out, len);
+}
+
+static SWDMX_Result
+aes_cbc_desc (SWDMX_DescAlgo *p, SWDMX_TsPacket *pkt)
+{
+	SWDMX_AesCbcAlgo *algo = (SWDMX_AesCbcAlgo*)p;
+
+	if (pkt->scramble == 2) {
+		aes_cbc_desc_pkt(algo,0, algo->even_iv, pkt, algo->align);
+	} else if (pkt->scramble == 3) {
+		aes_cbc_desc_pkt(algo,1, algo->odd_iv, pkt, algo->align);
+	} else {
+		swdmx_log("illegal scramble control field");
+		return SWDMX_ERR;
+	}
+
+	return SWDMX_OK;
+}
+
+static void
+aes_cbc_free (SWDMX_DescAlgo *p)
+{
+	SWDMX_AesCbcAlgo *algo = (SWDMX_AesCbcAlgo*)p;
+
+	swdmx_free(algo);
+}
+
+SWDMX_DescAlgo*
+swdmx_aes_cbc_algo_new (void)
+{
+	SWDMX_AesCbcAlgo *algo;
+	SWDMX_UInt8       key[16] = {0};
+
+	algo = swdmx_malloc(sizeof(SWDMX_AesCbcAlgo));
+	SWDMX_ASSERT(algo);
+
+	algo->algo.set_fn  = aes_cbc_set;
+	algo->algo.desc_fn = aes_cbc_desc;
+	algo->algo.free_fn = aes_cbc_free;
+	algo->align        = SWDMX_DESC_ALIGN_HEAD;
+
+	memset(key,0,sizeof(key));
+#ifdef __KERNEL__
+	algo->desc.tfm = crypto_alloc_blkcipher("cbc(aes)", 0, CRYPTO_ALG_ASYNC);
+	algo->desc.flags = 0;
+	algo->desc.info = 0;
+	crypto_blkcipher_setkey(algo->desc.tfm,key, sizeof(key));
+#else
+	AES_set_decrypt_key(key, 128, &algo->odd);
+	AES_set_decrypt_key(key, 128, &algo->even);
+#endif
+	memset(algo->odd_iv, 0, 16);
+	memset(algo->even_iv, 0, 16);
+
+	return (SWDMX_DescAlgo*)algo;
+}
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdmx_aes_ecb.c b/drivers/stream_input/parser/demux/sw_demux/swdmx_aes_ecb.c
new file mode 100644
index 0000000..2e072f1
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdmx_aes_ecb.c
@@ -0,0 +1,172 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#include "swdemux_internal.h"
+#ifdef __KERNEL__
+#include <linux/crypto.h>
+#else
+#include "crypto/aes.h"
+#endif
+
+typedef struct {
+	SWDMX_DescAlgo algo;
+	SWDMX_Int      align;
+#ifdef __KERNEL__
+	struct crypto_cipher *tfm;
+	SWDMX_UInt8 odd_key[16];
+	SWDMX_UInt8 even_key[16];
+#else
+	AES_KEY        odd;
+	AES_KEY        even;
+#endif
+} SWDMX_AesEcbAlgo;
+
+static SWDMX_Result
+aes_ecb_set (SWDMX_DescAlgo *p, SWDMX_Int type, SWDMX_Ptr param)
+{
+	SWDMX_AesEcbAlgo *algo = (SWDMX_AesEcbAlgo*)p;
+	SWDMX_UInt8      *key;
+	SWDMX_Result      r;
+
+	switch (type) {
+	case SWDMX_AES_ECB_PARAM_ODD_KEY:
+		key = param;
+		r   = SWDMX_OK;
+#ifdef __KERNEL__
+		memcpy(&algo->odd_key,key,16);
+#else
+		AES_set_decrypt_key(key, 128, &algo->odd);
+#endif
+		break;
+	case SWDMX_AES_ECB_PARAM_EVEN_KEY:
+		key = param;
+		r   = SWDMX_OK;
+#ifdef __KERNEL__
+		memcpy(&algo->even_key,key,16);
+#else
+		AES_set_decrypt_key(key, 128, &algo->even);
+#endif
+		break;
+	case SWDMX_AES_ECB_PARAM_ALIGN:
+		algo->align = SWDMX_PTR2SIZE(param);
+		r   = SWDMX_OK;
+		break;
+	default:
+		swdmx_log("illegal DVBCSA2 parameter");
+		r = SWDMX_ERR;
+		break;
+	}
+
+	return r;
+}
+
+//key_type:
+//0:even_key
+//1:odd_key
+static void
+aes_ecb_desc_pkt (SWDMX_AesEcbAlgo *algo, SWDMX_Int key_type, SWDMX_TsPacket *pkt, SWDMX_Int align)
+{
+	SWDMX_UInt8 *p    = pkt->payload;
+	SWDMX_Int    left = pkt->payload_len, len;
+	SWDMX_UInt8  obuf[184];
+	SWDMX_UInt8 *in;
+	SWDMX_UInt8 *out  = obuf;
+#ifdef __KERNEL__
+	u8 *key = NULL;
+#else
+	AES_KEY *key = NULL;
+#endif
+
+	if (align == SWDMX_DESC_ALIGN_TAIL) {
+		SWDMX_Int head = left & 15;
+
+		p    += head;
+		left -= head;
+	} else {
+		SWDMX_Int tail = left & 15;
+
+		left -= tail;
+	}
+#ifdef __KERNEL__
+	if (key_type == 0) {
+		key = (u8*)&algo->even_key;
+	}else{
+		key = (u8*)&algo->odd_key;
+	}
+	crypto_cipher_setkey(algo->tfm,key, 16);
+#else
+	if (key_type == 0) {
+		key = &algo->even;
+	}else{
+		key = &algo->odd;
+	}
+#endif
+	in  = p;
+	len = left;
+
+	while (left >= 16) {
+#ifdef __KERNEL__
+		crypto_cipher_decrypt_one(algo->tfm,out, p);
+#else
+		AES_ecb_encrypt(p, out, key, 0);
+#endif
+		p    += 16;
+		out  += 16;
+		left -= 16;
+	}
+
+	memcpy(in, out, len);
+}
+
+static SWDMX_Result
+aes_ecb_desc (SWDMX_DescAlgo *p, SWDMX_TsPacket *pkt)
+{
+	SWDMX_AesEcbAlgo *algo = (SWDMX_AesEcbAlgo*)p;
+
+	if (pkt->scramble == 2) {
+		aes_ecb_desc_pkt(algo,0, pkt, algo->align);
+	} else if (pkt->scramble == 3) {
+		aes_ecb_desc_pkt(algo,1, pkt, algo->align);
+	} else {
+		swdmx_log("illegal scramble control field");
+		return SWDMX_ERR;
+	}
+
+	return SWDMX_OK;
+}
+
+static void
+aes_ecb_free (SWDMX_DescAlgo *p)
+{
+	SWDMX_AesEcbAlgo *algo = (SWDMX_AesEcbAlgo*)p;
+
+	swdmx_free(algo);
+}
+
+SWDMX_DescAlgo*
+swdmx_aes_ecb_algo_new (void)
+{
+	SWDMX_AesEcbAlgo *algo;
+	SWDMX_UInt8       key[16] = {0};
+
+	algo = swdmx_malloc(sizeof(SWDMX_AesEcbAlgo));
+	SWDMX_ASSERT(algo);
+
+	algo->algo.set_fn  = aes_ecb_set;
+	algo->algo.desc_fn = aes_ecb_desc;
+	algo->algo.free_fn = aes_ecb_free;
+	algo->align        = SWDMX_DESC_ALIGN_HEAD;
+
+	memset(key,0,sizeof(key));
+
+#ifdef __KERNEL__
+	algo->tfm = crypto_alloc_cipher("ecb(aes)", 0, CRYPTO_ALG_ASYNC);
+	crypto_cipher_setkey(algo->tfm,key, sizeof(key));
+#else
+	AES_set_decrypt_key(key, 128, &algo->odd);
+	AES_set_decrypt_key(key, 128, &algo->even);
+#endif
+	return (SWDMX_DescAlgo*)algo;
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdmx_cb_list.c b/drivers/stream_input/parser/demux/sw_demux/swdmx_cb_list.c
new file mode 100644
index 0000000..814a406
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdmx_cb_list.c
@@ -0,0 +1,49 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#include "swdemux_internal.h"
+
+void
+swdmx_cb_list_add (SWDMX_List *l, SWDMX_Ptr cb, SWDMX_Ptr data)
+{
+	SWDMX_CbEntry *ent;
+
+	SWDMX_ASSERT(l && cb);
+
+	ent = swdmx_malloc(sizeof(SWDMX_CbEntry));
+	SWDMX_ASSERT(ent);
+
+	ent->cb   = cb;
+	ent->data = data;
+
+	swdmx_list_append(l, &ent->ln);
+}
+
+void
+swdmx_cb_list_remove (SWDMX_List *l, SWDMX_Ptr cb, SWDMX_Ptr data)
+{
+	SWDMX_CbEntry *ent, *nent;
+
+	SWDMX_LIST_FOR_EACH_SAFE(ent, nent, l, ln) {
+		if ((ent->cb == cb) && (ent->data == data)) {
+			swdmx_list_remove(&ent->ln);
+			swdmx_free(ent);
+			break;
+		}
+	}
+}
+
+void
+swdmx_cb_list_clear (SWDMX_List *l)
+{
+	SWDMX_CbEntry *ent, *nent;
+
+	SWDMX_LIST_FOR_EACH_SAFE(ent, nent, l, ln) {
+		swdmx_list_remove(&ent->ln);
+		swdmx_free(ent);
+	}
+
+	swdmx_list_init(l);
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdmx_crc32.c b/drivers/stream_input/parser/demux/sw_demux/swdmx_crc32.c
new file mode 100644
index 0000000..dfd94fb
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdmx_crc32.c
@@ -0,0 +1,40 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#include "swdemux_internal.h"
+
+static SWDMX_UInt32 crc32_table[256];
+
+static void
+crc32_table_init(void)
+{
+	SWDMX_UInt32 i, j, k;
+
+	for (i = 0; i < 256; i++) {
+		k = 0;
+		for (j = (i << 24) | 0x800000; j != 0x80000000; j <<= 1)
+			k = (k << 1) ^ (((k ^ j) & 0x80000000) ? 0x04c11db7 : 0);
+		crc32_table[i] = k;
+	}
+}
+
+SWDMX_UInt32
+swdmx_crc32 (
+		const SWDMX_UInt8 *p,
+		SWDMX_Int          len)
+{
+      SWDMX_UInt32 i_crc = 0xffffffff;
+
+      if (!crc32_table[0])
+	      crc32_table_init();
+
+      while (len) {
+	      i_crc = (i_crc << 8) ^ crc32_table[(i_crc >> 24) ^ *p];
+	      p   ++;
+	      len --;
+      }
+
+      return i_crc;
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdmx_demux.c b/drivers/stream_input/parser/demux/sw_demux/swdmx_demux.c
new file mode 100644
index 0000000..588ee3d
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdmx_demux.c
@@ -0,0 +1,606 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#include "swdemux_internal.h"
+
+/*Get the PID filter with the PID.*/
+static SWDMX_PidFilter*
+pid_filter_get (SWDMX_Demux *dmx, SWDMX_UInt16 pid)
+{
+	SWDMX_PidFilter *f;
+
+	SWDMX_LIST_FOR_EACH(f, &dmx->pid_filter_list, ln) {
+		if (f->pid == pid)
+			return f;
+	}
+
+	f = swdmx_malloc(sizeof(SWDMX_PidFilter));
+	SWDMX_ASSERT(f);
+
+	f->pid      = pid;
+	f->sec_data = NULL;
+	f->sec_recv = 0;
+
+	swdmx_list_init(&f->sec_filter_list);
+	swdmx_list_init(&f->ts_filter_list);
+
+	swdmx_list_append(&dmx->pid_filter_list, &f->ln);
+
+	return f;
+}
+
+/*Try to remove a PID filter.*/
+static void
+pid_filter_remove (SWDMX_PidFilter *f)
+{
+	if (!swdmx_list_is_empty(&f->ts_filter_list)
+				|| !swdmx_list_is_empty(&f->sec_filter_list))
+		return;
+
+	swdmx_list_remove(&f->ln);
+
+	if (f->sec_data)
+		swdmx_free(f->sec_data);
+
+	swdmx_free(f);
+}
+
+/*Section filter match test.*/
+static SWDMX_Bool
+sec_filter_match (SWDMX_UInt8 *data, SWDMX_Int len, SWDMX_SecFilter *f)
+{
+	SWDMX_Int   i;
+	SWDMX_UInt8 m = 0, n = 0;
+	SWDMX_UInt8 has_n = 0;
+
+	for (i = 0; i < SWDMX_SEC_FILTER_LEN; i ++) {
+		SWDMX_UInt8 d, v;
+
+		d = data[i] & f->mam[i];
+		v = f->value[i] & f->mam[i];
+		m |= d ^ v;
+
+		d = data[i] & f->manm[i];
+		v = f->value[i] & f->manm[i];
+		n |= d ^ v;
+
+		has_n |= f->manm[i];
+	}
+
+	if (m)
+		return SWDMX_FALSE;
+
+	if (has_n && !n)
+		return SWDMX_FALSE;
+
+	return SWDMX_TRUE;
+}
+
+/*Section data resolve.*/
+static SWDMX_Int
+sec_data (SWDMX_PidFilter *pid_filter, SWDMX_UInt8 *p, SWDMX_Int len)
+{
+	SWDMX_Int    n, left = len, sec_len;
+	SWDMX_UInt8 *sec = pid_filter->sec_data;
+	SWDMX_Bool   crc = SWDMX_FALSE;
+
+	swdmx_log("%s enter\n",__FUNCTION__);
+
+	if (pid_filter->sec_recv < 3) {
+		n = SWDMX_MIN(left, 3 - pid_filter->sec_recv);
+
+		if (n) {
+			memcpy(sec + pid_filter->sec_recv, p, n);
+
+			p    += n;
+			left -= n;
+			pid_filter->sec_recv += n;
+		}
+	}
+
+	if (pid_filter->sec_recv < 3)
+		return len;
+
+	if (sec[0] == 0xff)
+		return len;
+
+	sec_len = (((sec[1] & 0xf) << 8) | sec[2]) + 3;
+	n       = SWDMX_MIN(sec_len - pid_filter->sec_recv, left);
+
+	if (n) {
+		memcpy(sec + pid_filter->sec_recv, p, n);
+
+		p    += n;
+		left -= n;
+		pid_filter->sec_recv += n;
+	}
+
+	if (pid_filter->sec_recv == sec_len) {
+		SWDMX_SecFilter *sec_filter, *n_sec_filter;
+		SWDMX_CbEntry   *ce, *nce;
+
+		SWDMX_LIST_FOR_EACH_SAFE(sec_filter,
+					n_sec_filter,
+					&pid_filter->sec_filter_list,
+					pid_ln) {
+
+			if (sec_filter->params.crc32) {
+				if (!crc) {
+					if (swdmx_crc32(pid_filter->sec_data,
+								pid_filter->sec_recv)) {
+						swdmx_log("section crc error");
+						break;
+					}
+
+					crc = SWDMX_TRUE;
+				}
+			}
+
+			if (!sec_filter_match(pid_filter->sec_data,
+						pid_filter->sec_recv,
+						sec_filter)) {
+				  swdmx_log("not sec_filter_match\n");
+			      continue;
+			}
+
+			SWDMX_LIST_FOR_EACH_SAFE(ce, nce, &sec_filter->cb_list,
+						ln) {
+				SWDMX_SecCb cb = ce->cb;
+
+				cb(pid_filter->sec_data, pid_filter->sec_recv,
+							ce->data);
+			}
+		}
+
+		pid_filter->sec_recv = 0;
+	}
+
+	return len - left;
+}
+
+/*PID filter receive TS data.*/
+static void
+pid_filter_data (SWDMX_PidFilter *pid_filter, SWDMX_TsPacket *pkt)
+{
+	SWDMX_TsFilter  *ts_filter, *n_ts_filter;
+	SWDMX_CbEntry   *ce, *nce;
+	SWDMX_UInt8     *p;
+	SWDMX_Int        left;
+
+	/*TS filters.*/
+	SWDMX_LIST_FOR_EACH_SAFE(ts_filter,
+				n_ts_filter,
+				&pid_filter->ts_filter_list,
+				pid_ln) {
+		SWDMX_LIST_FOR_EACH_SAFE(ce, nce, &ts_filter->cb_list, ln) {
+			SWDMX_TsPacketCb cb = ce->cb;
+
+			cb(pkt, ce->data);
+		}
+	}
+
+	if (swdmx_list_is_empty(&pid_filter->sec_filter_list))
+		return;
+
+	if (!pkt->payload || pkt->scramble)
+		return;
+
+	swdmx_log("%s handle section \n",__FUNCTION__);
+
+	/*Solve section data.*/
+	if (!pid_filter->sec_data) {
+		pid_filter->sec_data = swdmx_malloc(4096 + 3);
+		SWDMX_ASSERT(pid_filter->sec_data);
+	}
+
+	p    = pkt->payload;
+	left = pkt->payload_len;
+	if (pkt->payload_start) {
+		if (left) {
+			SWDMX_Int ptr = p[0];
+
+			p    ++;
+			left --;
+
+			if (ptr) {
+				if (ptr > left) {
+					swdmx_log("illegal section pointer field");
+					return;
+				}
+
+				if (pid_filter->sec_recv) {
+					sec_data(pid_filter, p, ptr);
+				}
+
+				p    += ptr;
+				left -= ptr;
+			}
+		}
+
+		pid_filter->sec_recv = 0;
+	}
+
+	while (left > 0) {
+		SWDMX_Int n;
+
+		n = sec_data(pid_filter, p, left);
+
+		p    += n;
+		left -= n;
+	}
+}
+
+SWDMX_Demux*
+swdmx_demux_new (void)
+{
+	SWDMX_Demux *dmx;
+
+	dmx = swdmx_malloc(sizeof(SWDMX_Demux));
+	SWDMX_ASSERT(dmx);
+
+	swdmx_list_init(&dmx->pid_filter_list);
+	swdmx_list_init(&dmx->ts_filter_list);
+	swdmx_list_init(&dmx->sec_filter_list);
+
+	return dmx;
+}
+
+SWDMX_TsFilter*
+swdmx_demux_alloc_ts_filter (SWDMX_Demux *dmx)
+{
+	SWDMX_TsFilter  *f;
+
+	SWDMX_ASSERT(dmx);
+
+	f = swdmx_malloc(sizeof(SWDMX_TsFilter));
+	SWDMX_ASSERT(f);
+
+	f->dmx        = dmx;
+	f->state      = SWDMX_FILTER_STATE_INIT;
+	f->pid_filter = NULL;
+
+	swdmx_list_init(&f->cb_list);
+
+	swdmx_list_append(&dmx->ts_filter_list, &f->ln);
+
+	return f;
+}
+
+SWDMX_SecFilter*
+swdmx_demux_alloc_sec_filter (SWDMX_Demux *dmx)
+{
+	SWDMX_SecFilter *f;
+
+	SWDMX_ASSERT(dmx);
+
+	f = swdmx_malloc(sizeof(SWDMX_SecFilter));
+
+	f->dmx        = dmx;
+	f->state      = SWDMX_FILTER_STATE_INIT;
+	f->pid_filter = NULL;
+
+	swdmx_list_init(&f->cb_list);
+
+	swdmx_list_append(&dmx->sec_filter_list, &f->ln);
+
+	return f;
+}
+
+void
+swdmx_demux_ts_packet_cb (
+			SWDMX_TsPacket *pkt,
+			SWDMX_Ptr       data)
+{
+	SWDMX_Demux     *dmx = (SWDMX_Demux*)data;
+	SWDMX_PidFilter *pid_filter;
+
+	SWDMX_ASSERT(pkt && dmx);
+
+	SWDMX_LIST_FOR_EACH(pid_filter, &dmx->pid_filter_list, ln) {
+		if (pkt->pid == pid_filter->pid) {
+			pid_filter_data(pid_filter, pkt);
+			break;
+		}
+	}
+}
+
+void
+swdmx_demux_free (SWDMX_Demux *dmx)
+{
+	SWDMX_ASSERT(dmx);
+
+	while (!swdmx_list_is_empty(&dmx->ts_filter_list)) {
+		SWDMX_TsFilter *f;
+
+		f = SWDMX_CONTAINEROF(dmx->ts_filter_list.next, SWDMX_TsFilter, ln);
+
+		swdmx_ts_filter_free(f);
+	}
+
+	while (!swdmx_list_is_empty(&dmx->sec_filter_list)) {
+		SWDMX_SecFilter *f;
+
+		f = SWDMX_CONTAINEROF(dmx->sec_filter_list.next, SWDMX_SecFilter, ln);
+
+		swdmx_sec_filter_free(f);
+	}
+
+	while (!swdmx_list_is_empty(&dmx->pid_filter_list)) {
+		SWDMX_PidFilter *f;
+
+		f = SWDMX_CONTAINEROF(dmx->pid_filter_list.next, SWDMX_PidFilter, ln);
+
+		pid_filter_remove(f);
+	}
+
+	swdmx_free(dmx);
+}
+
+SWDMX_Result
+swdmx_ts_filter_set_params (
+			SWDMX_TsFilter       *filter,
+			SWDMX_TsFilterParams *params)
+{
+	SWDMX_ASSERT(filter && params);
+
+	if (!swdmx_is_valid_pid(params->pid) || (params->pid == 0x1fff)) {
+		swdmx_log("illegal PID 0x%04x", params->pid);
+		return SWDMX_ERR;
+	}
+
+	if (filter->state == SWDMX_FILTER_STATE_RUN) {
+		SWDMX_ASSERT(filter->pid_filter);
+
+		if (filter->params.pid != params->pid) {
+			swdmx_list_remove(&filter->pid_ln);
+			pid_filter_remove(filter->pid_filter);
+
+			filter->pid_filter = NULL;
+		}
+	}
+
+	filter->params = *params;
+	if (filter->state == SWDMX_FILTER_STATE_INIT)
+		filter->state = SWDMX_FILTER_STATE_SET;
+
+	if ((filter->state == SWDMX_FILTER_STATE_RUN) && !filter->pid_filter) {
+		SWDMX_PidFilter *pid_filter;
+
+		pid_filter = pid_filter_get(filter->dmx, params->pid);
+
+		filter->pid_filter = pid_filter;
+
+		swdmx_list_append(&pid_filter->ts_filter_list, &filter->pid_ln);
+	}
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_ts_filter_add_ts_packet_cb (
+			SWDMX_TsFilter   *filter,
+			SWDMX_TsPacketCb  cb,
+			SWDMX_Ptr         data)
+{
+	SWDMX_ASSERT(filter && cb);
+
+	swdmx_cb_list_add(&filter->cb_list, cb, data);
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_ts_filter_remove_ts_packet_cb (
+			SWDMX_TsFilter   *filter,
+			SWDMX_TsPacketCb  cb,
+			SWDMX_Ptr         data)
+{
+	SWDMX_ASSERT(filter && cb);
+
+	swdmx_cb_list_remove(&filter->cb_list, cb, data);
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_ts_filter_enable (SWDMX_TsFilter *filter)
+{
+	SWDMX_ASSERT(filter);
+
+	if (filter->state == SWDMX_FILTER_STATE_INIT) {
+		swdmx_log("the ts filter's parameters has not been set");
+		return SWDMX_ERR;
+	}
+
+	if (filter->state == SWDMX_FILTER_STATE_SET) {
+		SWDMX_PidFilter *pid_filter;
+
+		pid_filter = pid_filter_get(filter->dmx, filter->params.pid);
+
+		filter->pid_filter = pid_filter;
+		filter->state      = SWDMX_FILTER_STATE_RUN;
+
+		swdmx_list_append(&pid_filter->ts_filter_list, &filter->pid_ln);
+	}
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_ts_filter_disable (SWDMX_TsFilter *filter)
+{
+	SWDMX_ASSERT(filter);
+
+	if (filter->state == SWDMX_FILTER_STATE_RUN) {
+		SWDMX_ASSERT(filter->pid_filter);
+
+		swdmx_list_remove(&filter->pid_ln);
+		pid_filter_remove(filter->pid_filter);
+
+		filter->pid_filter = NULL;
+		filter->state      = SWDMX_FILTER_STATE_SET;
+	}
+
+	return SWDMX_OK;
+}
+
+void
+swdmx_ts_filter_free (SWDMX_TsFilter *filter)
+{
+	SWDMX_ASSERT(filter);
+
+	swdmx_ts_filter_disable(filter);
+
+	swdmx_list_remove(&filter->ln);
+	swdmx_cb_list_clear(&filter->cb_list);
+
+	swdmx_free(filter);
+}
+
+SWDMX_Result
+swdmx_sec_filter_set_params (
+			SWDMX_SecFilter       *filter,
+			SWDMX_SecFilterParams *params)
+{
+	SWDMX_Int i;
+
+	SWDMX_ASSERT(filter && params);
+
+	if (!swdmx_is_valid_pid(params->pid) || (params->pid == 0x1fff)) {
+		swdmx_log("illegal PID 0x%04x", params->pid);
+		return SWDMX_ERR;
+	}
+
+	if (filter->state == SWDMX_FILTER_STATE_RUN) {
+		SWDMX_ASSERT(filter->pid_filter);
+
+		if (filter->params.pid != params->pid) {
+			swdmx_list_remove(&filter->pid_ln);
+			pid_filter_remove(filter->pid_filter);
+
+			filter->pid_filter = NULL;
+		}
+	}
+
+	filter->params = *params;
+
+	for (i = 0; i < SWDMX_SEC_FILTER_LEN; i ++) {
+		SWDMX_Int   j = i ? i + 2 : i;
+		SWDMX_UInt8 v, mask, mode;
+
+		v    = params->value[i];
+		mask = params->mask[i];
+		mode = ~params->mode[i];
+
+		filter->value[j] = v;
+		filter->mam[j]   = mask & mode;
+		filter->manm[j]  = mask & ~mode;
+	}
+
+	filter->value[1] = 0;
+	filter->mam[1]   = 0;
+	filter->manm[1]  = 0;
+	filter->value[2] = 0;
+	filter->mam[2]   = 0;
+	filter->manm[2]  = 0;
+
+	if (filter->state == SWDMX_FILTER_STATE_INIT)
+		filter->state = SWDMX_FILTER_STATE_SET;
+
+	if ((filter->state == SWDMX_FILTER_STATE_RUN) && !filter->pid_filter) {
+		SWDMX_PidFilter *pid_filter;
+
+		pid_filter = pid_filter_get(filter->dmx, params->pid);
+
+		filter->pid_filter = pid_filter;
+
+		swdmx_list_append(&pid_filter->sec_filter_list, &filter->pid_ln);
+	}
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_sec_filter_add_section_cb (
+			SWDMX_SecFilter *filter,
+			SWDMX_SecCb      cb,
+			SWDMX_Ptr        data)
+{
+	SWDMX_ASSERT(filter && cb);
+
+	swdmx_cb_list_add(&filter->cb_list, cb, data);
+
+	return SWDMX_OK;
+}
+
+
+SWDMX_Result
+swdmx_sec_filter_remove_section_cb (
+			SWDMX_SecFilter *filter,
+			SWDMX_SecCb      cb,
+			SWDMX_Ptr        data)
+{
+	SWDMX_ASSERT(filter && cb);
+
+	swdmx_cb_list_remove(&filter->cb_list, cb, data);
+
+	return SWDMX_OK;
+}
+
+
+SWDMX_Result
+swdmx_sec_filter_enable (SWDMX_SecFilter *filter)
+{
+	SWDMX_ASSERT(filter);
+
+	if (filter->state == SWDMX_FILTER_STATE_INIT) {
+		swdmx_log("the section filter's parameters has not been set");
+		return SWDMX_ERR;
+	}
+
+	if (filter->state == SWDMX_FILTER_STATE_SET) {
+		SWDMX_PidFilter *pid_filter;
+
+		pid_filter = pid_filter_get(filter->dmx, filter->params.pid);
+
+		filter->pid_filter = pid_filter;
+		filter->state      = SWDMX_FILTER_STATE_RUN;
+
+		swdmx_list_append(&pid_filter->sec_filter_list, &filter->pid_ln);
+	}
+
+	return SWDMX_OK;
+}
+
+
+SWDMX_Result
+swdmx_sec_filter_disable (SWDMX_SecFilter *filter)
+{
+	SWDMX_ASSERT(filter);
+
+	if (filter->state == SWDMX_FILTER_STATE_RUN) {
+		SWDMX_ASSERT(filter->pid_filter);
+
+		swdmx_list_remove(&filter->pid_ln);
+		pid_filter_remove(filter->pid_filter);
+
+		filter->pid_filter = NULL;
+		filter->state      = SWDMX_FILTER_STATE_SET;
+	}
+
+	return SWDMX_OK;
+}
+
+void
+swdmx_sec_filter_free (SWDMX_SecFilter *filter)
+{
+	SWDMX_ASSERT(filter);
+	swdmx_sec_filter_disable(filter);
+
+	swdmx_list_remove(&filter->ln);
+	swdmx_cb_list_clear(&filter->cb_list);
+
+	swdmx_free(filter);
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdmx_descrambler.c b/drivers/stream_input/parser/demux/sw_demux/swdmx_descrambler.c
new file mode 100644
index 0000000..71d41a8
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdmx_descrambler.c
@@ -0,0 +1,205 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#include "swdemux_internal.h"
+
+SWDMX_Descrambler*
+swdmx_descrambler_new (void)
+{
+	SWDMX_Descrambler *desc;
+
+	desc = swdmx_malloc(sizeof(SWDMX_Descrambler));
+	SWDMX_ASSERT(desc);
+
+	swdmx_list_init(&desc->chan_list);
+	swdmx_list_init(&desc->cb_list);
+
+	return desc;
+}
+
+SWDMX_DescChannel*
+swdmx_descrambler_alloc_channel (SWDMX_Descrambler *desc)
+{
+	SWDMX_DescChannel *chan;
+
+	SWDMX_ASSERT(desc);
+
+	chan = swdmx_malloc(sizeof(SWDMX_DescChannel));
+	SWDMX_ASSERT(chan);
+
+	chan->algo   = NULL;
+	chan->pid    = 0xffff;
+	chan->enable = SWDMX_FALSE;
+
+	swdmx_list_append(&desc->chan_list, &chan->ln);
+
+	return chan;
+}
+
+void
+swdmx_descrambler_ts_packet_cb (
+			SWDMX_TsPacket *pkt,
+			SWDMX_Ptr       data)
+{
+	SWDMX_Descrambler *desc = (SWDMX_Descrambler*)data;
+	SWDMX_DescChannel *ch, *nch;
+	SWDMX_CbEntry     *ce, *nce;
+
+	SWDMX_ASSERT(pkt && desc);
+
+	if (pkt->scramble && pkt->payload) {
+		SWDMX_LIST_FOR_EACH_SAFE(ch, nch, &desc->chan_list, ln) {
+			if ((ch->enable) && (ch->pid == pkt->pid)) {
+				SWDMX_Result r;
+
+				r = ch->algo->desc_fn(ch->algo, pkt);
+				if (r == SWDMX_OK) {
+					pkt->scramble   = 0;
+					pkt->packet[3] &= 0x3f;
+				}
+
+				break;
+			}
+		}
+	}
+
+	SWDMX_LIST_FOR_EACH_SAFE(ce, nce, &desc->cb_list, ln) {
+		SWDMX_TsPacketCb cb = ce->cb;
+		cb(pkt, ce->data);
+	}
+}
+
+SWDMX_Result
+swdmx_descrambler_add_ts_packet_cb (
+			SWDMX_Descrambler *desc,
+			SWDMX_TsPacketCb   cb,
+			SWDMX_Ptr          data)
+{
+	SWDMX_ASSERT(desc && cb);
+
+	swdmx_cb_list_add(&desc->cb_list, cb, data);
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_descrambler_remove_ts_packet_cb (
+			SWDMX_Descrambler *desc,
+			SWDMX_TsPacketCb   cb,
+			SWDMX_Ptr          data)
+{
+	SWDMX_ASSERT(desc && cb);
+
+	swdmx_cb_list_remove(&desc->cb_list, cb, data);
+
+	return SWDMX_OK;
+}
+
+void
+swdmx_descrambler_free (SWDMX_Descrambler *desc)
+{
+	SWDMX_ASSERT(desc);
+
+	while (!swdmx_list_is_empty(&desc->chan_list)) {
+		SWDMX_DescChannel *chan;
+
+		chan = SWDMX_CONTAINEROF(desc->chan_list.next,
+					SWDMX_DescChannel, ln);
+
+		swdmx_desc_channel_free(chan);
+	}
+
+	swdmx_cb_list_clear(&desc->cb_list);
+
+	swdmx_free(desc);
+}
+
+SWDMX_Result
+swdmx_desc_channel_set_algo (
+			SWDMX_DescChannel *chan,
+			SWDMX_DescAlgo    *algo)
+{
+	SWDMX_ASSERT(chan && algo);
+
+	if (chan->algo && chan->algo->free_fn) {
+		chan->algo->free_fn(chan->algo);
+	}
+
+	chan->algo = algo;
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_desc_channel_set_pid (
+			SWDMX_DescChannel *chan,
+			SWDMX_UInt16       pid)
+{
+	SWDMX_ASSERT(chan);
+
+	if (!swdmx_is_valid_pid(pid) || (pid == 0x1fff)) {
+		swdmx_log("illegal PID 0x%04x", pid);
+		return SWDMX_ERR;
+	}
+
+	chan->pid = pid;
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_desc_channel_set_param (
+			SWDMX_DescChannel *chan,
+			SWDMX_Int          type,
+			SWDMX_Ptr          param)
+{
+	SWDMX_ASSERT(chan && chan->algo && chan->algo->set_fn);
+
+	return chan->algo->set_fn(chan->algo, type, param);
+}
+
+
+SWDMX_Result
+swdmx_desc_channel_enable (SWDMX_DescChannel *chan)
+{
+	SWDMX_ASSERT(chan);
+
+	if (!swdmx_is_valid_pid(chan->pid)) {
+		swdmx_log("descrambler channel's PID has not been set");
+		return SWDMX_ERR;
+	}
+
+	if (!chan->algo) {
+		swdmx_log("descrambler channel's algorithm has not been set");
+		return SWDMX_ERR;
+	}
+
+	chan->enable = SWDMX_TRUE;
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_desc_channel_disable (SWDMX_DescChannel *chan)
+{
+	SWDMX_ASSERT(chan);
+
+	chan->enable = SWDMX_FALSE;
+
+	return SWDMX_OK;
+}
+
+void
+swdmx_desc_channel_free (SWDMX_DescChannel *chan)
+{
+	SWDMX_ASSERT(chan);
+
+	swdmx_list_remove(&chan->ln);
+
+	if (chan->algo && chan->algo->free_fn)
+		chan->algo->free_fn(chan->algo);
+
+	swdmx_free(chan);
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdmx_dvbcsa2.c b/drivers/stream_input/parser/demux/sw_demux/swdmx_dvbcsa2.c
new file mode 100644
index 0000000..bbd5abc
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdmx_dvbcsa2.c
@@ -0,0 +1,90 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#include "swdemux_internal.h"
+#include "dvbcsa2/dvbcsa/dvbcsa.h"
+
+typedef struct {
+	SWDMX_DescAlgo  algo;
+	dvbcsa_key_t   *odd_key;
+	dvbcsa_key_t   *even_key;
+} SWDMX_DvbCsa2Algo;
+
+static SWDMX_Result
+dvbcsa2_set (SWDMX_DescAlgo *p, SWDMX_Int type, SWDMX_Ptr param)
+{
+	SWDMX_DvbCsa2Algo *algo = (SWDMX_DvbCsa2Algo*)p;
+	SWDMX_UInt8       *key;
+	SWDMX_Result       r;
+
+	switch (type) {
+	case SWDMX_DVBCSA2_PARAM_ODD_KEY:
+		key = param;
+		r   = SWDMX_OK;
+		dvbcsa_key_set(key, algo->odd_key);
+		break;
+	case SWDMX_DVBCSA2_PARAM_EVEN_KEY:
+		key = param;
+		r   = SWDMX_OK;
+		dvbcsa_key_set(key, algo->even_key);
+		break;
+	default:
+		swdmx_log("illegal DVBCSA2 parameter");
+		r = SWDMX_ERR;
+		break;
+	}
+
+	return r;
+}
+
+static SWDMX_Result
+dvbcsa2_desc (SWDMX_DescAlgo *p, SWDMX_TsPacket *pkt)
+{
+	SWDMX_DvbCsa2Algo *algo = (SWDMX_DvbCsa2Algo*)p;
+
+	if (pkt->scramble == 2) {
+		dvbcsa_decrypt(algo->even_key, pkt->payload, pkt->payload_len);
+	} else if (pkt->scramble == 3) {
+		dvbcsa_decrypt(algo->odd_key, pkt->payload, pkt->payload_len);
+	} else {
+		swdmx_log("illegal scramble control field");
+		return SWDMX_ERR;
+	}
+
+	return SWDMX_OK;
+}
+
+static void
+dvbcsa2_free (SWDMX_DescAlgo *p)
+{
+	SWDMX_DvbCsa2Algo *algo = (SWDMX_DvbCsa2Algo*)p;
+
+	dvbcsa_key_free(algo->odd_key);
+	dvbcsa_key_free(algo->even_key);
+
+	swdmx_free(algo);
+}
+
+SWDMX_DescAlgo*
+swdmx_dvbcsa2_algo_new (void)
+{
+	SWDMX_DvbCsa2Algo *algo;
+	SWDMX_UInt8        key[8] = {0};
+
+	algo = swdmx_malloc(sizeof(SWDMX_DvbCsa2Algo));
+	SWDMX_ASSERT(algo);
+
+	algo->algo.set_fn  = dvbcsa2_set;
+	algo->algo.desc_fn = dvbcsa2_desc;
+	algo->algo.free_fn = dvbcsa2_free;
+
+	algo->odd_key  = dvbcsa_key_alloc();
+	algo->even_key = dvbcsa_key_alloc();
+
+	dvbcsa_key_set(key, algo->odd_key);
+	dvbcsa_key_set(key, algo->even_key);
+
+	return (SWDMX_DescAlgo*)algo;
+}
+
diff --git a/drivers/stream_input/parser/demux/sw_demux/swdmx_ts_parser.c b/drivers/stream_input/parser/demux/sw_demux/swdmx_ts_parser.c
new file mode 100644
index 0000000..344f000
--- /dev/null
+++ b/drivers/stream_input/parser/demux/sw_demux/swdmx_ts_parser.c
@@ -0,0 +1,160 @@
+/***************************************************************************
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.                   *
+ ***************************************************************************/
+
+#include "swdemux_internal.h"
+
+SWDMX_TsParser*
+swdmx_ts_parser_new (void)
+{
+	SWDMX_TsParser *tsp;
+
+	tsp = swdmx_malloc(sizeof(SWDMX_TsParser));
+	SWDMX_ASSERT(tsp);
+
+	tsp->packet_size = 188;
+
+	swdmx_list_init(&tsp->cb_list);
+
+	return tsp;
+}
+
+SWDMX_Result
+swdmx_ts_parser_set_packet_size (
+			SWDMX_TsParser *tsp,
+			SWDMX_Int       size)
+{
+	SWDMX_ASSERT(tsp);
+
+	if (size < 188) {
+		swdmx_log("packet size should >= 188");
+		return SWDMX_ERR;
+	}
+
+	tsp->packet_size = size;
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_ts_parser_add_ts_packet_cb (
+			SWDMX_TsParser   *tsp,
+			SWDMX_TsPacketCb  cb,
+			SWDMX_Ptr         data)
+{
+	SWDMX_ASSERT(tsp && cb);
+
+	swdmx_cb_list_add(&tsp->cb_list, cb, data);
+
+	return SWDMX_OK;
+}
+
+SWDMX_Result
+swdmx_ts_parser_remove_ts_packet_cb (
+			SWDMX_TsParser   *tsp,
+			SWDMX_TsPacketCb  cb,
+			SWDMX_Ptr         data)
+{
+	SWDMX_ASSERT(tsp && cb);
+
+	swdmx_cb_list_remove(&tsp->cb_list, cb, data);
+
+	return SWDMX_OK;
+}
+/*Parse the TS packet.*/
+static void
+ts_packet (SWDMX_TsParser *tsp, SWDMX_UInt8 *data)
+{
+	SWDMX_TsPacket  pkt;
+	SWDMX_UInt8    *p = data;
+	SWDMX_Int       len;
+	SWDMX_UInt8     afc;
+	SWDMX_CbEntry  *e, *ne;
+
+	pkt.pid = ((p[1] & 0x1f) << 8) | p[2];
+	if (pkt.pid == 0x1fff)
+		return;
+
+	pkt.packet        = p;
+	pkt.packet_len    = tsp->packet_size;
+	pkt.error         = (p[1] & 0x80) >> 7;
+	pkt.payload_start = (p[1] & 0x40) >> 6;
+	pkt.priority      = (p[1] & 0x20) >> 5;
+	pkt.scramble      = p[3] >> 6;
+	afc               = (p[3] >> 4) & 0x03;
+	pkt.cc            = p[3] & 0x0f;
+
+	p   += 4;
+	len = 184;
+
+	if (afc & 2) {
+		pkt.adp_field_len = p[0];
+
+		p   ++;
+		len --;
+
+		pkt.adp_field = p;
+
+		p   += pkt.adp_field_len;
+		len -= pkt.adp_field_len;
+
+		if (len < 0) {
+			swdmx_log("kernel:illegal adaptation field length\n");
+			return;
+		}
+	} else {
+		pkt.adp_field     = NULL;
+		pkt.adp_field_len = 0;
+	}
+
+	if (afc & 1) {
+		pkt.payload     = p;
+		pkt.payload_len = len;
+	} else {
+		pkt.payload     = NULL;
+		pkt.payload_len = 0;
+	}
+
+	SWDMX_LIST_FOR_EACH_SAFE(e, ne, &tsp->cb_list, ln) {
+		SWDMX_TsPacketCb cb = e->cb;
+
+		cb(&pkt, e->data);
+	}
+}
+
+SWDMX_Int
+swdmx_ts_parser_run (
+			SWDMX_TsParser *tsp,
+			SWDMX_UInt8    *data,
+			SWDMX_Int       len)
+{
+	SWDMX_UInt8    *p    = data;
+	SWDMX_Int       left = len;
+
+	SWDMX_ASSERT(tsp && data);
+
+	while (left >= tsp->packet_size) {
+		if (*p == 0x47) {
+			ts_packet(tsp, p);
+
+			p    += tsp->packet_size;
+			left -= tsp->packet_size;
+		} else {
+			p    ++;
+			left --;
+		}
+	}
+
+	return len - left;
+}
+
+void
+swdmx_ts_parser_free (SWDMX_TsParser *tsp)
+{
+	SWDMX_ASSERT(tsp);
+
+	swdmx_cb_list_clear(&tsp->cb_list);
+	swdmx_free(tsp);
+}
+
+
diff --git a/drivers/stream_input/parser/dvb_ci/Makefile b/drivers/stream_input/parser/dvb_ci/Makefile
new file mode 100644
index 0000000..bbfbdd4
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/Makefile
@@ -0,0 +1,15 @@
+obj-m += ci.o cimax-usb.o
+
+ci-objs = $(amlci-objs) $(cimax-objs)
+
+amlci-objs = aml_pcmcia.o  aml_ci.o
+cimax-objs = cimax/dvb_ca_en50221_cimax.o cimax/aml_cimax.o  cimax/dvb_ringbuffer.o
+cimax-usb-objs += cimax/usb/SRC/cimax+usb-driver.o cimax/usb/SRC/cimax+usb_fw.o
+cimax-usb-objs += cimax/usb/SRC/cimax+usb_config.o
+cimax-objs += cimax/aml_cimax_usb.o
+
+ccflags-y += -I$(srctree)/
+ccflags-y += -I$(srctree)/include
+ccflags-y += -I$(srctree)/drivers/gpio
+ccflags-y += -I$(srctree)/drivers/media/dvb-core
+
diff --git a/drivers/stream_input/parser/dvb_ci/aml_ci.c b/drivers/stream_input/parser/dvb_ci/aml_ci.c
new file mode 100644
index 0000000..227eea2
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/aml_ci.c
@@ -0,0 +1,758 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include "aml_ci.h"
+#include "aml_spi.h"
+#include "cimax/aml_cimax.h"
+#include <dvbdev.h>
+
+MODULE_PARM_DESC(aml_ci_debug, "\n\t\t dvb ci debug");
+static int aml_ci_debug = 1;
+module_param(aml_ci_debug, int, S_IRUGO);
+
+#define pr_dbg(args...)\
+	do {\
+		if (aml_ci_debug)\
+			printk(args);\
+	} while (0)
+#define pr_error(fmt, args...) printk("DVBCI: " fmt, ## args)
+
+
+extern struct dvb_adapter *aml_get_dvb_adapter(void);
+/**\brief aml_ci_mem_read:mem read from cam
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param addr: read addr
+ * \return
+ *   - read value:ok
+ *   - -EINVAL : error
+ */
+static int aml_ci_mem_read(struct dvb_ca_en50221 *en50221, int slot, int addr)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_mem_read != NULL)
+		return ci->ci_mem_read(ci, slot, addr);
+
+	pr_error("ci_mem_read is null %s\r\n", __func__);
+	return -EINVAL;
+}
+/**\brief aml_ci_mem_write:mem write to cam
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param addr: write addr
+ * \param addr: write value
+ * \return
+ *   - 0:ok
+ *   - -EINVAL : error
+ */
+static int aml_ci_mem_write(struct dvb_ca_en50221 *en50221,
+		int slot, int addr, u8 data)
+{
+
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot not 0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_mem_write != NULL)
+		return ci->ci_mem_write(ci, slot, addr, data);
+	pr_error("ci_mem_write is null %s\r\n", __func__);
+	return -EINVAL;
+}
+/**\brief aml_ci_io_read:io read from cam
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param addr: read addr
+ * \return
+ *   - read value:ok
+ *   - -EINVAL : error
+ */
+static int aml_ci_io_read(struct dvb_ca_en50221 *en50221, int slot, u8 addr)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_io_read != NULL)
+		return ci->ci_io_read(ci, slot, addr);
+
+	pr_error("ci_io_read is null %s\r\n", __func__);
+	return -EINVAL;
+}
+/**\brief aml_ci_io_write:io write to cam
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param addr: write addr
+ * \param addr: write value
+ * \return
+ *   - 0:ok
+ *   - -EINVAL : error
+ */
+static int aml_ci_io_write(struct dvb_ca_en50221 *en50221,
+		int slot, u8 addr, u8 data)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_mem_write != NULL)
+		return ci->ci_io_write(ci, slot, addr, data);
+
+	pr_error("ci_io_write is null %s\r\n", __func__);
+	return -EINVAL;
+}
+/**\brief aml_ci_slot_reset:reset slot
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \return
+ *   - 0:ok
+ *   - -EINVAL : error
+ */
+static int aml_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)
+{
+	struct aml_ci *ci = en50221->data;
+	pr_dbg("Slot(%d): Slot RESET\n", slot);
+	if (ci->ci_slot_reset != NULL) {
+		ci->ci_slot_reset(ci, slot);
+	} else {
+		pr_error("ci_slot_reset is null %s\r\n", __func__);
+		return -EINVAL;
+	}
+	return 0;
+}
+/**\brief aml_ci_slot_shutdown:show slot
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \return
+ *   - 0:ok
+ *   - -EINVAL : error
+ */
+static int aml_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)
+{
+	struct aml_ci *ci = en50221->data;
+	pr_dbg("Slot(%d): Slot shutdown\n", slot);
+	if (ci->ci_slot_shutdown != NULL) {
+		ci->ci_slot_shutdown(ci, slot);
+	} else {
+		pr_error("aml_ci_slot_shutdown is null %s\r\n", __func__);
+		return -EINVAL;
+	}
+	return 0;
+}
+/**\brief aml_ci_ts_control:control slot ts
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \return
+ *   - 0:ok
+ *   - -EINVAL : error
+ */
+static int aml_ci_ts_control(struct dvb_ca_en50221 *en50221, int slot)
+{
+
+		struct aml_ci *ci = en50221->data;
+		pr_dbg("Slot(%d): TS control\n", slot);
+		if (ci->ci_slot_ts_enable != NULL) {
+			ci->ci_slot_ts_enable(ci, slot);
+		} else {
+			pr_error("aml_ci_ts_control is null %s\r\n", __func__);
+			return -EINVAL;
+		}
+		return 0;
+}
+/**\brief aml_ci_slot_status:get slot status
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param open: no used
+ * \return
+ *   - cam status
+ *   - -EINVAL : error
+ */
+static int aml_ci_slot_status(struct dvb_ca_en50221 *en50221,
+		int slot, int open)
+{
+	struct aml_ci *ci = en50221->data;
+
+	pr_dbg("Slot(%d): Poll Slot status\n", slot);
+
+	if (ci->ci_poll_slot_status != NULL) {
+		return ci->ci_poll_slot_status(ci, slot, open);
+	} else {
+		pr_error("ci_poll_slot_status is null %s\r\n", __func__);
+		return -EINVAL;
+	}
+
+	return -EINVAL;
+}
+static int aml_ci_cimax_slot_reset(struct dvb_ca_en50221_cimax *en50221,
+		int slot)
+{
+	struct aml_ci *ci = en50221->data;
+	pr_dbg("Slot(%d): Slot RESET\n", slot);
+	if (ci->ci_slot_reset != NULL) {
+		ci->ci_slot_reset(ci, slot);
+	} else {
+		pr_error("ci_slot_reset is null %s\r\n", __func__);
+		return -EINVAL;
+	}
+	return 0;
+}
+/**\brief aml_ci_slot_shutdown:show slot
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \return
+ *   - 0:ok
+ *   - -EINVAL : error
+ */
+static int aml_ci_cimax_slot_shutdown(struct dvb_ca_en50221_cimax *en50221,
+		int slot)
+{
+	struct aml_ci *ci = en50221->data;
+	pr_dbg("Slot(%d): Slot shutdown\n", slot);
+	if (ci->ci_slot_shutdown != NULL) {
+		ci->ci_slot_shutdown(ci, slot);
+	} else {
+		pr_error("aml_ci_slot_shutdown is null %s\r\n", __func__);
+		return -EINVAL;
+	}
+	return 0;
+}
+/**\brief aml_ci_ts_control:control slot ts
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \return
+ *   - 0:ok
+ *   - -EINVAL : error
+ */
+static int aml_ci_cimax_ts_control(struct dvb_ca_en50221_cimax *en50221,
+		int slot)
+{
+
+	struct aml_ci *ci = en50221->data;
+	pr_dbg("Slot(%d): TS control\n", slot);
+	if (ci->ci_slot_ts_enable != NULL) {
+		ci->ci_slot_ts_enable(ci, slot);
+	} else {
+		pr_error("aml_ci_ts_control is null %s\r\n", __func__);
+		return -EINVAL;
+	}
+	return 0;
+}
+/**\brief aml_ci_slot_status:get slot status
+ * \param en50221: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param open: no used
+ * \return
+ *   - cam status
+ *   - -EINVAL : error
+ */
+static int aml_ci_cimax_slot_status(
+	struct dvb_ca_en50221_cimax *en50221, int slot, int open)
+{
+	struct aml_ci *ci = en50221->data;
+
+	/*pr_dbg("Slot(%d): Poll Slot status\n", slot);*/
+
+	if (ci->ci_poll_slot_status != NULL) {
+		return ci->ci_poll_slot_status(ci, slot, open);
+	} else {
+		pr_error("ci_poll_slot_status is null %s\r\n", __func__);
+		return -EINVAL;
+	}
+
+	return -EINVAL;
+}
+
+/**\brief aml_ci_read_cis: read cis
+ * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param buf: buf for cis data
+ * \param size: buf size
+ * \return
+ *   --EINVAL : error
+ *   -        : actual size read
+ */
+static int aml_ci_read_cis(struct dvb_ca_en50221_cimax *en50221,
+		int slot, u8 *buf, int size)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_read_cis != NULL)
+		return ci->ci_read_cis(ci, slot, buf, size);
+
+	pr_error("ci_read_cis is null %s\r\n", __func__);
+	return -EINVAL;
+}
+/**\brief aml_ci_write_cor: write cor
+ * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param addr:
+ * \param buf:
+ * \return
+ *   --EINVAL : error
+ *   -0       : ok
+ */
+static int aml_ci_write_cor(struct dvb_ca_en50221_cimax *en50221,
+		int slot, int address, u8 *buf)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_write_cor != NULL)
+		return ci->ci_write_cor(ci, slot, address, buf);
+
+	pr_error("ci_write_cor is null %s\r\n", __func__);
+	return -EINVAL;
+}
+/**\brief aml_ci_negociate: negotiate
+ * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param size: suggested size
+ * \return
+ *   --EINVAL : error
+ *   -        : size negotiated
+ */
+static int aml_ci_negotiate(struct dvb_ca_en50221_cimax *en50221,
+		int slot, int size)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_negotiate != NULL)
+		return ci->ci_negotiate(ci, slot, size);
+
+	pr_error("ci_negotiate is null %s\r\n", __func__);
+	return -EINVAL;
+}
+/**\brief aml_ci_read_lpdu: read lpdu
+ * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param buf:  buf
+ * \param size: buf size
+ * \return
+ *   --EINVAL : error
+ *   -        : size read
+ */
+static int aml_ci_read_lpdu(struct dvb_ca_en50221_cimax *en50221,
+		int slot, u8 *buf, int size)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_read_lpdu != NULL)
+		return ci->ci_read_lpdu(ci, slot, buf, size);
+
+	pr_error("ci_read_lpdu is null %s\r\n", __func__);
+	return -EINVAL;
+}
+
+/**\brief aml_ci_write_lpdu: write lpdu
+ * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \param buf:  buf
+ * \param size: write size
+ * \return
+ *   --EINVAL : error
+ *   -        : size written
+ */
+static int aml_ci_write_lpdu(struct dvb_ca_en50221_cimax *en50221,
+		int slot, u8 *buf, int size)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_write_lpdu != NULL)
+		return ci->ci_write_lpdu(ci, slot, buf, size);
+
+	pr_error("ci_write_lpdu is null %s\r\n", __func__);
+	return -EINVAL;
+}
+
+static int aml_ci_read_cam_status(struct dvb_ca_en50221_cimax *en50221,
+		int slot)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_read_cam_status != NULL)
+		return ci->ci_read_cam_status(ci, slot);
+
+	pr_error("ci_read_cam_status is null %s\r\n", __func__);
+	return -EINVAL;
+}
+
+static int aml_ci_cam_reset(struct dvb_ca_en50221_cimax *en50221, int slot)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_cam_reset != NULL)
+		return ci->ci_cam_reset(ci, slot);
+
+	pr_error("ci_cam_reset is null %s\r\n", __func__);
+	return -EINVAL;
+}
+
+/**\brief aml_ci_get_capbility
+ * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
+ * \param slot: slot index
+ * \return
+ *   -        : capbilities
+ */
+static int aml_ci_get_capbility(struct dvb_ca_en50221_cimax *en50221, int slot)
+{
+	struct aml_ci *ci = en50221->data;
+
+	if (slot != 0) {
+		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
+		return -EINVAL;
+	}
+
+	if (ci->ci_get_capbility != NULL)
+		return ci->ci_get_capbility(ci, slot);
+
+	pr_error("ci_get_capbility is null %s\r\n", __func__);
+	return -EINVAL;
+}
+
+
+/**\brief get ci config from dts
+ * \param np: device node
+ * \return
+ *   - 0 
+ *   -  :
+ */
+static int aml_ci_get_config_from_dts(struct platform_device *pdev,
+		struct aml_ci *ci)
+{
+	char buf[32];
+	int ret = 0;
+	int value;
+
+	snprintf(buf, sizeof(buf), "%s", "io_type");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (!ret) {
+		pr_dbg("%s: 0x%x\n", buf, value);
+		ci->io_type = value;
+	}
+	return 0;
+}
+
+/**\brief aml_ci_init:ci dev init
+ * \param pdev: platform_device device node,used to get dts info
+ * \param dvb: aml_dvb obj,used to get dvb_adapter for en0211 to use
+ * \param cip: ci_dev pp
+ * \return
+ *   - 0 
+ *   -  :
+ */
+int aml_ci_init(struct platform_device *pdev,
+	struct dvb_adapter *dvb_adapter, struct aml_ci **cip)
+{
+	struct aml_ci *ci = NULL;
+	int ca_flags = 0, result;
+
+	ci = kzalloc(sizeof(struct aml_ci), GFP_KERNEL);
+	if (!ci) {
+		pr_error("Out of memory!, exiting ..\n");
+		result = -ENOMEM;
+		goto err;
+	}
+	ci->id = 0;
+	aml_ci_get_config_from_dts(pdev, ci);
+
+//	ci->priv		= dvb;
+	/* register CA interface */
+	if (ci->io_type == AML_DVB_IO_TYPE_CIMAX) {
+		ci->en50221_cimax.owner = THIS_MODULE;
+		ci->en50221_cimax.read_cis = aml_ci_read_cis;
+		ci->en50221_cimax.write_cor = aml_ci_write_cor;
+		ci->en50221_cimax.negotiate = aml_ci_negotiate;
+		ci->en50221_cimax.read_lpdu = aml_ci_read_lpdu;
+		ci->en50221_cimax.write_lpdu = aml_ci_write_lpdu;
+		ci->en50221_cimax.read_cam_status = aml_ci_read_cam_status;
+		ci->en50221_cimax.cam_reset = aml_ci_cam_reset;
+		ci->en50221_cimax.get_capbility = aml_ci_get_capbility;
+		ci->en50221_cimax.slot_reset = aml_ci_cimax_slot_reset;
+		ci->en50221_cimax.slot_shutdown = aml_ci_cimax_slot_shutdown;
+		ci->en50221_cimax.slot_ts_enable = aml_ci_cimax_ts_control;
+		ci->en50221_cimax.poll_slot_status = aml_ci_cimax_slot_status;
+		ci->en50221_cimax.data = ci;
+
+		pr_dbg("Registering EN50221 CIMAX device\n");
+		result = dvb_ca_en50221_cimax_init(dvb_adapter,
+			&ci->en50221_cimax, ca_flags, 1);
+		if (result != 0) {
+			pr_error("EN50221 CIMAX: Initialization failed <%d>\n",
+				result);
+			goto err;
+		}
+	} else {
+		ca_flags		= DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE;
+		ci->en50221.read_attribute_mem	= aml_ci_mem_read;
+		ci->en50221.write_attribute_mem	= aml_ci_mem_write;
+		ci->en50221.read_cam_control	= aml_ci_io_read;
+		ci->en50221.write_cam_control	= aml_ci_io_write;
+		ci->en50221.slot_reset		= aml_ci_slot_reset;
+		ci->en50221.slot_shutdown	= aml_ci_slot_shutdown;
+		ci->en50221.slot_ts_enable	= aml_ci_ts_control;
+		ci->en50221.poll_slot_status	= aml_ci_slot_status;
+		ci->en50221.data		= ci;
+
+
+		pr_dbg("Registering EN50221 device\n");
+		result = dvb_ca_en50221_init(dvb_adapter,
+			&ci->en50221, ca_flags, 1);
+		if (result != 0) {
+			pr_error("EN50221: Initialization failed <%d>\n",
+				result);
+			goto err;
+		}
+	}
+	*cip = ci;
+	pr_dbg("Registered EN50221 device\n");
+
+	if (ci->io_type == AML_DVB_IO_TYPE_SPI) {
+		/* spi init */
+		//ci->ci_init = aml_spi_init;
+		//ci->ci_exit = aml_spi_exit;
+	} else if (ci->io_type == AML_DVB_IO_TYPE_CIMAX) {
+		ci->ci_init = aml_cimax_init;
+		ci->ci_exit = aml_cimax_exit;
+	} else {
+		/* no io dev init,is error */
+		pr_dbg("unknown io type, please check io_type in dts file\r\n");
+	}
+
+	if (ci->ci_init)
+		result = ci->ci_init(pdev, ci);
+
+	if (result)
+		dvb_ca_en50221_cimax_release(&ci->en50221_cimax);
+
+	return result;
+err:
+	kfree(ci);
+	return result;
+}
+
+void aml_ci_exit(struct aml_ci *ci)
+{
+	pr_dbg("Unregistering EN50221 device\n");
+	if (ci) {
+		if (ci->io_type == AML_DVB_IO_TYPE_CIMAX)
+			dvb_ca_en50221_cimax_release(&ci->en50221_cimax);
+		else
+			dvb_ca_en50221_release(&ci->en50221);
+		if (ci->ci_exit)
+			ci->ci_exit(ci);
+		kfree(ci);
+	}
+}
+
+static struct aml_ci *ci_dev;
+
+static ssize_t aml_ci_ts_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+		int ret;
+		ret = sprintf(buf, "ts%d\n", 1);
+	return ret;
+}
+
+static struct class_attribute amlci_class_attrs[] = {
+	__ATTR(ts,  S_IRUGO | S_IWUSR, aml_ci_ts_show, NULL),
+	__ATTR_NULL
+};
+
+static int aml_ci_register_class(struct aml_ci *ci)
+{
+	#define CLASS_NAME_LEN 48
+	int ret;
+	struct class *clp;
+
+	clp = &(ci->class);
+
+	clp->name = kzalloc(CLASS_NAME_LEN, GFP_KERNEL);
+	if (!clp->name)
+		return -ENOMEM;
+
+	snprintf((char *)clp->name, CLASS_NAME_LEN, "amlci-%d", ci->id);
+	clp->owner = THIS_MODULE;
+	clp->class_attrs = amlci_class_attrs;
+	ret = class_register(clp);
+	if (ret)
+		kfree(clp->name);
+
+	return 0;
+}
+
+static int aml_ci_unregister_class(struct aml_ci *ci)
+{
+	class_unregister(&ci->class);
+	kzfree(ci->class.name);
+	return 0;
+}
+
+
+static int aml_ci_probe(struct platform_device *pdev)
+{
+	struct dvb_adapter *dvb_adapter = aml_get_dvb_adapter();
+	int err = 0;
+	pr_dbg("---Amlogic CI Init---\n");
+	err = aml_ci_init(pdev, dvb_adapter, &ci_dev);
+	if (err < 0)
+		return err;
+	platform_set_drvdata(pdev, ci_dev);
+	aml_ci_register_class(ci_dev);
+	return 0;
+}
+
+static int aml_ci_remove(struct platform_device *pdev)
+{
+	aml_ci_unregister_class(ci_dev);
+	platform_set_drvdata(pdev, NULL);
+	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI) {
+		//aml_spi_exit(ci_dev);
+		}
+	else if (ci_dev->io_type == AML_DVB_IO_TYPE_CIMAX)
+		aml_cimax_exit(ci_dev);
+	else
+		pr_dbg("---Amlogic CI remove unkown io type---\n");
+
+	aml_ci_exit(ci_dev);
+	return 0;
+}
+
+static int aml_ci_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	pr_dbg("Amlogic CI Suspend!\n");
+	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI) {
+		//aml_spi_exit(ci_dev);
+		}
+	else if (ci_dev->io_type == AML_DVB_IO_TYPE_CIMAX)
+		aml_cimax_exit(ci_dev);
+	else
+		pr_dbg("---Amlogic CI remove unkown io type---\n");
+
+	return 0;
+}
+
+static int aml_ci_resume(struct platform_device *pdev)
+{
+	int err = 0;
+	pr_dbg("Amlogic CI Resume!\n");
+	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI) {
+		//aml_spi_init(pdev, ci_dev);
+		}
+	else if (ci_dev->io_type == AML_DVB_IO_TYPE_CIMAX)
+		aml_cimax_init(pdev, ci_dev);
+	else
+		pr_dbg("---Amlogic CI remove unkown io type---\n");
+	return err;
+}
+
+static const struct of_device_id dvbci_dev_dt_match[] = {
+	{
+		.compatible = "amlogic, dvbci",
+	},
+	{},
+};
+
+
+
+static struct platform_driver aml_ci_driver = {
+	.probe		= aml_ci_probe,
+	.remove		= aml_ci_remove,
+	.suspend        = aml_ci_suspend,
+	.resume         = aml_ci_resume,
+	.driver		= {
+		.name	= "dvbci",
+		.of_match_table = dvbci_dev_dt_match,
+		.owner	= THIS_MODULE,
+	}
+};
+
+static int  aml_ci_mod_init(void)
+{
+	pr_dbg("Amlogic CI mode init\n");
+	return platform_driver_register(&aml_ci_driver);
+}
+
+static void  aml_ci_mod_exit(void)
+{
+	pr_dbg("Amlogic CI mode Exit\n");
+	platform_driver_unregister(&aml_ci_driver);
+}
+
+module_init(aml_ci_mod_init);
+module_exit(aml_ci_mod_exit);
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/stream_input/parser/dvb_ci/aml_ci.h b/drivers/stream_input/parser/dvb_ci/aml_ci.h
new file mode 100644
index 0000000..2d52334
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/aml_ci.h
@@ -0,0 +1,101 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+
+#ifndef __AML_CI_H_
+#define __AML_CI_H_
+
+#include "drivers/media/dvb-core/dvb_ca_en50221.h"
+#include "cimax/dvb_ca_en50221_cimax.h"
+
+enum aml_dvb_io_type_e {
+	AML_DVB_IO_TYPE_IOBUS = 0,
+	AML_DVB_IO_TYPE_SPI,
+	AML_DVB_IO_TYPE_CIMAX,
+	AML_DVB_IO_TYPE_MAX,
+};
+
+struct aml_ci {
+	struct dvb_ca_en50221		en50221;
+	struct mutex			ci_lock;
+	int				io_type;
+	void				*priv;
+	int				id;
+	struct class			class;
+
+	int (*ci_init)(struct platform_device *pdev, struct aml_ci *ci);
+	int (*ci_exit)(struct aml_ci *ci);
+
+	/* NOTE: the read_*, write_* and poll_slot_status functions will be
+	 * called for different slots concurrently and need to use locks where
+	 * and if appropriate. There will be no concurrent access to one slot.
+	 */
+
+	/* functions for accessing attribute memory on the CAM */
+	int (*ci_mem_read)(struct aml_ci *ca, int slot, int address);
+	int (*ci_mem_write)(struct aml_ci *ca, int slot, int address, u8 value);
+
+	/* functions for accessing the control interface on the CAM */
+	int (*ci_io_read)(struct aml_ci *ca, int slot, int address);
+	int (*ci_io_write)(struct aml_ci *ca, int slot, int address, u8 value);
+
+	/* Functions for controlling slots */
+	int (*ci_slot_reset)(struct aml_ci *ca, int slot);
+	int (*ci_slot_shutdown)(struct aml_ci *ca, int slot);
+	int (*ci_slot_ts_enable)(struct aml_ci *ca, int slot);
+
+	/*
+	* Poll slot status.
+	* Only necessary if DVB_CA_FLAG_EN50221_IRQ_CAMCHANGE is not set
+	*/
+	int (*ci_poll_slot_status)(struct aml_ci *ca, int slot, int open);
+
+
+	struct dvb_ca_en50221_cimax en50221_cimax;
+
+	int (*ci_read_cis)(struct aml_ci *ca, int slot, u8 *buf, int size);
+	int (*ci_write_cor)(struct aml_ci *ca, int slot, int address, u8 *buf);
+      /*return the final size or -1 for error*/
+	int (*ci_negotiate)(struct aml_ci *ca, int slot, int size);
+
+	/* functions for accessing the control interface on the CAM */
+	int (*ci_read_lpdu)(struct aml_ci *ca, int slot, u8 *buf, int size);
+	int (*ci_write_lpdu)(struct aml_ci *ca, int slot, u8 *buf, int size);
+
+	int (*ci_get_capbility)(struct aml_ci *ca, int slot);
+
+	int (*ci_cam_reset)(struct aml_ci *ca, int slot);
+	int (*ci_read_cam_status)(struct aml_ci *ca, int slot);
+
+	/* private data, used by caller */
+	void *data;
+};
+
+struct ci_dev_config_s {
+	char name[20];
+	unsigned char type;
+	int cs_hold_delay;
+	int cs_clk_delay;
+};
+extern int aml_ci_init(struct platform_device *pdev,
+		struct dvb_adapter *dvb_adapter, struct aml_ci **cip);
+extern void aml_ci_exit(struct aml_ci *ci);
+
+#endif /* __AML_CI_H_ */
+
diff --git a/drivers/stream_input/parser/dvb_ci/aml_pcmcia.c b/drivers/stream_input/parser/dvb_ci/aml_pcmcia.c
new file mode 100644
index 0000000..ac8c87d
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/aml_pcmcia.c
@@ -0,0 +1,199 @@
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+
+#include "aml_pcmcia.h"
+
+static int aml_pcmcia_debug = 1;
+
+module_param_named(pcmcia_debug, aml_pcmcia_debug, int, 0644);
+MODULE_PARM_DESC(pcmcia_debug, "enable verbose debug messages");
+
+#define pr_dbg(args...)\
+	do {\
+		if (aml_pcmcia_debug)\
+			printk(args);\
+	} while (0)
+#define pr_error(fmt, args...) printk("PCMCIA: " fmt, ## args)
+
+
+static int pcmcia_plugin(struct aml_pcmcia *pc)
+{
+	if (pc->slot_state == MODULE_XTRACTED) {
+		pr_dbg(" CAM Plugged IN: Adapter(%d) Slot(0)\n", 0);
+		udelay(50);
+		aml_pcmcia_reset(pc);
+		/*wait unplug*/
+		pc->init_irq(pc, IRQF_TRIGGER_RISING);
+		udelay(500);
+		pc->slot_state = MODULE_INSERTED;
+	} else {
+		pr_error("repeat into pcmcia insert \r\n");
+		aml_pcmcia_reset(pc);
+	}
+	udelay(100);
+	pc->pcmcia_plugin(pc, 1);
+
+	return 0;
+}
+
+static int pcmcia_unplug(struct aml_pcmcia *pc)
+{
+	if (pc->slot_state == MODULE_INSERTED) {
+		pr_dbg(" CAM Unplugged: Adapter(%d) Slot(0)\n", 0);
+		/*udelay(50);*/
+		/*aml_pcmcia_reset(pc);*/
+		/*wait plugin*/
+		pc->init_irq(pc, IRQF_TRIGGER_FALLING);
+		udelay(500);
+		pc->slot_state = MODULE_XTRACTED;
+	}
+	udelay(100);
+	pc->pcmcia_plugin(pc, 0);
+
+	return 0;
+}
+
+static irqreturn_t pcmcia_irq_handler(int irq, void *dev_id)
+{
+	struct aml_pcmcia *pc = (struct aml_pcmcia *)dev_id;
+	pr_dbg("pcmcia_irq_handler--into--\r\n");
+	disable_irq_nosync(pc->irq);
+	schedule_work(&pc->pcmcia_work);
+	enable_irq(pc->irq);
+	return IRQ_HANDLED;
+}
+
+static void aml_pcmcia_work(struct work_struct *work)
+{
+	int cd1, cd2;
+	struct aml_pcmcia *pc = container_of(
+		work, struct aml_pcmcia, pcmcia_work);
+
+	cd1 = pc->get_cd1(pc);
+	cd2 = pc->get_cd2(pc);
+
+	if (cd1 != cd2)
+		pr_error("CAM card not inerted.\n");
+	else {
+		if (!cd1) {
+			pr_error("Adapter(%d) Slot(0): CAM Plugin\n", 0);
+			pcmcia_plugin(pc);
+		} else {
+			pr_error("Adapter(%d) Slot(0): CAM Unplug\n", 0);
+			pcmcia_unplug(pc);
+		}
+	}
+}
+
+static struct aml_pcmcia *pc_cur;
+
+int aml_pcmcia_init(struct aml_pcmcia *pc)
+{
+	int err = 0;
+	pr_dbg("aml_pcmcia_init start pc->irq=%d\r\n", pc->irq);
+	pc->rst(pc, AML_L);
+	/*power on*/
+	pc->pwr(pc, AML_PWR_OPEN);/*hi is open power*/
+	/*assuming cam unpluged, config the INT to waiting-for-plugin mode*/
+	pc->init_irq(pc, IRQF_TRIGGER_LOW);
+
+	INIT_WORK(&pc->pcmcia_work, aml_pcmcia_work);
+
+	err = request_irq(pc->irq,
+	pcmcia_irq_handler,
+	IRQF_ONESHOT, "aml-pcmcia", pc);
+	if (err != 0) {
+		pr_error("ERROR: IRQ registration failed ! <%d>", err);
+		return -ENODEV;
+	}
+
+	pc_cur = pc;
+	pr_dbg("aml_pcmcia_init ok\r\n");
+	return 0;
+}
+EXPORT_SYMBOL(aml_pcmcia_init);
+
+int aml_pcmcia_exit(struct aml_pcmcia *pc)
+{
+	free_irq(pc->irq, pc);
+	return 0;
+}
+EXPORT_SYMBOL(aml_pcmcia_exit);
+
+int aml_pcmcia_reset(struct aml_pcmcia *pc)
+{
+		pr_dbg("CAM RESET-->\n");
+		/* viaccess neotion cam need delay 2000 and 3000 */
+		/* smit cam need delay 1000 and 1500 */
+		/* need change delay according cam vendor */
+		pc->rst(pc, AML_H);/*HI is reset*/
+		mdelay(1000);
+		pc->rst(pc, AML_L);/*defaule LOW*/
+		pr_dbg("CAM RESET--\n");
+		mdelay(1500);
+		pr_dbg("CAM RESET--end\n");
+	return 0;
+}
+EXPORT_SYMBOL(aml_pcmcia_reset);
+
+
+#if 0
+static ssize_t aml_pcmcia_test_cmd(struct class *class,
+struct class_attribute *attr, const char *buf, size_t size)
+{
+	pr_dbg("pcmcia cmd: %s\n", buf);
+	if (pc_cur) {
+		if (memcmp(buf, "reset", 5) == 0)
+			aml_pcmcia_reset(pc_cur);
+		else if (memcmp(buf, "on", 2) == 0)
+			pc_cur->pwr(pc_cur, AML_PWR_OPEN);
+		else if (memcmp(buf, "off", 3) == 0)
+			pc_cur->pwr(pc_cur, AML_PWR_CLOSE);
+		else if (memcmp(buf, "poll", 4) == 0)
+			schedule_work(&pc_cur->pcmcia_work);
+		else if (memcmp(buf, "intr", 4) == 0)
+			pc_cur->init_irq(pc_cur, IRQF_TRIGGER_RISING);
+		else if (memcmp(buf, "intf", 4) == 0)
+			pc_cur->init_irq(pc_cur, IRQF_TRIGGER_FALLING);
+	}
+	return size;
+}
+
+static struct class_attribute aml_pcmcia_class_attrs[] = {
+	__ATTR(cmd,  S_IRUGO | S_IWUSR, NULL, aml_pcmcia_test_cmd),
+	__ATTR_NULL
+};
+
+static struct class aml_pcmcia_class = {
+	.name = "aml_pcmcia_test",
+	.class_attrs = aml_pcmcia_class_attrs,
+};
+
+static int __init aml_pcmcia_mod_init(void)
+{
+	pr_dbg("Amlogic PCMCIA Init\n");
+
+	class_register(&aml_pcmcia_class);
+
+	return 0;
+}
+
+static void __exit aml_pcmcia_mod_exit(void)
+{
+	pr_dbg("Amlogic PCMCIA Exit\n");
+
+	class_unregister(&aml_pcmcia_class);
+}
+
+
+
+module_init(aml_pcmcia_mod_init);
+module_exit(aml_pcmcia_mod_exit);
+
+MODULE_LICENSE("GPL");
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/aml_pcmcia.h b/drivers/stream_input/parser/dvb_ci/aml_pcmcia.h
new file mode 100644
index 0000000..612d577
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/aml_pcmcia.h
@@ -0,0 +1,59 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+
+#ifndef _AML_PCMCIA_
+#define _AML_PCMCIA_
+
+enum aml_slot_state {
+	MODULE_INSERTED			= 3,
+	MODULE_XTRACTED			= 4
+};
+
+enum aml_pwr_cmd {
+	AML_PWR_OPEN			= 0,
+	AML_PWR_CLOSE			= 1
+};
+enum aml_reset_cmd {
+	AML_L	    = 0,
+	AML_H		= 1
+};
+struct aml_pcmcia {
+	enum aml_slot_state		slot_state;
+	struct work_struct		pcmcia_work;
+	int run_type;/*0irq;1:poll*/
+	int irq;
+	int (*init_irq)(struct aml_pcmcia *pc, int flag);
+	int (*get_cd1)(struct aml_pcmcia *pc);
+	int (*get_cd2)(struct aml_pcmcia *pc);
+	int (*pwr)(struct aml_pcmcia *pc, int enable);
+	int (*rst)(struct aml_pcmcia *pc, int enable);
+
+	int (*pcmcia_plugin)(struct aml_pcmcia *pc, int plugin);
+
+	void *priv;
+};
+
+int aml_pcmcia_init(struct aml_pcmcia *pc);
+int aml_pcmcia_exit(struct aml_pcmcia *pc);
+int aml_pcmcia_reset(struct aml_pcmcia *pc);
+
+
+#endif /*_AML_PCMCIA_*/
+
diff --git a/drivers/stream_input/parser/dvb_ci/aml_spi.c b/drivers/stream_input/parser/dvb_ci/aml_spi.c
new file mode 100644
index 0000000..62f4f53
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/aml_spi.c
@@ -0,0 +1,1666 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/amlogic/sd.h>
+#include <linux/of_irq.h>
+#include <linux/irq.h>
+#include "aml_spi.h"
+#include "aml_ci.h"
+
+#define AML_MODE_NAME       "aml_dvbci_spi"
+static int  AML_CI_GPIO_IRQ_BASE = 251;
+static struct aml_spi *g_spi_dev;
+static int aml_spi_debug = 1;
+static int G_rec_flag = AM_SPI_STEP_INIT;
+
+
+module_param_named(spi_debug, aml_spi_debug, int, 0644);
+MODULE_PARM_DESC(spi_debug, "enable verbose debug messages");
+
+
+#define pr_dbg(args...)\
+	do {\
+		if (aml_spi_debug)\
+			printk(args);\
+	} while (0)
+#define pr_error(fmt, args...) printk("AML_CI_SPI: " fmt, ## args)
+
+struct spi_board_info aml_ci_spi_bdinfo = {
+	.modalias = "ci_spi_dev",
+	.mode = SPI_MODE_0,
+	.max_speed_hz = 1000000, /* 1MHz */
+	.bus_num = 0, /* SPI bus No. */
+	.chip_select = 0, /* the device index on the spi bus */
+	.controller_data = NULL,
+};
+
+#define NORMAL_MSG      (0<<7)
+#define BROADCAST_MSG   (1<<7)
+#define BLOCK_DATA      (0<<6)
+#define SINGLE_DATA     (1<<6)
+#define CISPI_DEV_ADDR  1
+
+#define INPUT 0
+#define OUTPUT 1
+#define OUTLEVEL_LOW 0
+#define OUTLEVEL_HIGH 1
+#define PULLLOW 1
+#define PULLHIGH 0
+
+/*
+sendbuf data struct
+----------------------------------------------------
+|start flag| cmd   | data  |  addr   |end flag  |
+----------------------------------------------------
+| 2 byte   | 1byte | 1byte |   2 byte|   2 byte |
+----------------------------------------------------
+*/
+
+#define SENDBUFLEN  8
+static u8 sendbuf[SENDBUFLEN];/* send data */
+static u8 rbuf[SENDBUFLEN];/*save get data */
+/**\brief aml_init_send_buf:init spi send buf
+* \param cmd: ci cmd
+* \param data: write value
+* \param addr: read or write addr
+* \return
+*   - read value:ok
+*   - -EINVAL : error
+*/
+static int aml_init_send_buf(u8 cmd, u8 data, u16 addr)
+{
+	/* start flag */
+	sendbuf[0] = DATASTART;
+	sendbuf[1] = DATASTART;
+	/* cmd */
+	sendbuf[2] = cmd;
+	/* data */
+	sendbuf[3] = data;
+	/* addr senf low 8 bit first,and then send hi 8bit */
+	sendbuf[4] = addr & 0x00ff;
+	sendbuf[5] = (addr>>8) & 0xff;
+	/* end flag */
+	sendbuf[6] = DATAEND;
+	sendbuf[7] = DATAEND;
+	return 0;
+}
+/**\brief aml_ci_spi_reciver
+* \param[out] None
+* \param[in] value,get from spi
+* \return
+*   - 0:reciver end,-1:reciver
+*   -
+*/
+/*
+data strouct
+----------------------------------------------------
+|start flag| cmd   | data  |  addr   |end flag  |
+----------------------------------------------------
+| 2 byte   | 1byte | 1byte |   2 byte|   2 byte |
+----------------------------------------------------
+*/
+int aml_ci_spi_paser_bit(uint8_t value)
+{
+	/* read spi data from slave */
+	if (G_rec_flag == AM_SPI_STEP_INIT) {
+		/* start type first */
+		if (value == DATASTART) {
+			rbuf[0] = value;
+			G_rec_flag = AM_SPI_STEP_START1;
+		}
+	} else if (G_rec_flag == AM_SPI_STEP_START1) {
+		/* start2 type seccond */
+		if (value == DATASTART) {
+			rbuf[1] = value;
+			G_rec_flag = AM_SPI_STEP_START2;
+		}
+	} else if (G_rec_flag == AM_SPI_STEP_START2) {
+		/* cmd type */
+		/* pr_dbg("spi value=%d\r\n",value); */
+		rbuf[2] = value;
+		G_rec_flag = AM_SPI_STEP_CMD;
+	} else if (G_rec_flag == AM_SPI_STEP_CMD) {
+		/* data  */
+		rbuf[3] = value;
+		G_rec_flag = AM_SPI_STEP_DATA;
+	} else if (G_rec_flag == AM_SPI_STEP_DATA) {
+		/* ADDR1  */
+		rbuf[4] = value;
+		G_rec_flag = AM_SPI_STEP_ADDR1;
+	} else if (G_rec_flag == AM_SPI_STEP_ADDR1) {
+		/* ADDR2 type */
+		rbuf[5] = value;
+		G_rec_flag = AM_SPI_STEP_ADDR2;
+	} else if (G_rec_flag == AM_SPI_STEP_ADDR2) {
+		/*  END1 type */
+		if (value == DATAEND) {
+			rbuf[6] = value;
+			G_rec_flag = AM_SPI_STEP_END1;
+		}
+	} else if (G_rec_flag == AM_SPI_STEP_END1) {
+		/* END2 type */
+		if (value == DATAEND) {
+			rbuf[7] = value;
+			G_rec_flag = AM_SPI_STEP_END2;
+			/* pr_dbg("spi read value ok end\r\n"); */
+			return 0;
+		}
+	}
+	return -1;
+}
+
+/**\brief aml_spi_io_api:spi read or write api with mcu
+* \param spi_dev: aml_spi obj,used this data to get spi obj
+* \param val: write value
+* \param len: write value len
+* \param mode: read or write
+* \return
+*   - read value:ok
+*   - -EINVAL : error
+*/
+static int aml_spi_io_api(struct aml_spi *spi_dev, u8 *val, int len, int mode)
+{
+	u8 rb[32] = {0};
+	int ret = 0;
+	int i = 0;
+	u8 rd = 0;
+	if (spi_dev->spi == NULL) {
+		pr_error("%s spi is null\r\n", __func__);
+		return -EINVAL;
+	}
+	spin_lock(&spi_dev->spi_lock);
+	if (spi_dev->cs_hold_delay)
+		udelay(spi_dev->cs_hold_delay);
+	dirspi_start(spi_dev->spi);
+	if (spi_dev->cs_clk_delay)
+		udelay(spi_dev->cs_clk_delay);
+
+	dirspi_xfer(spi_dev->spi, val, rb, len);
+	/* wait mcu io */
+	udelay(1000);
+	/* init rec flag */
+	G_rec_flag = AM_SPI_STEP_INIT;
+	memset(rbuf, 0, 8);
+	for (i = 0; i < 4*len; i++) {
+		udelay(50);
+		ret = dirspi_read(spi_dev->spi, &rd, 1);
+		if (ret != 0)
+			pr_dbg("spi read value timeout:%x\r\n", rd);
+		ret = aml_ci_spi_paser_bit(rd);
+		if (ret == 0)
+			break;
+	}
+	if (ret == 0) {
+		rd = rbuf[3];/* data */
+	} else {
+		pr_dbg("spi read value error\r\n");
+		rd = 0;
+	}
+
+	if (spi_dev->cs_clk_delay)
+		udelay(spi_dev->cs_clk_delay);
+
+	/* pr_error("ci spi is stop in %s rd=%d\r\n",__func__,rd);*/
+	dirspi_stop(spi_dev->spi);
+
+	spin_unlock(&spi_dev->spi_lock);
+
+	return rd;
+}
+
+/********************************************************/
+/********************************************************/
+/*******             gpio api               *************/
+/********************************************************/
+/********************************************************/
+/**\brief aml_set_gpio_out:set gio out and set val value
+* \param gpio: gpio_desc obj,
+* \param val:  set val
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int aml_set_gpio_out(struct gpio_desc *gpio, int val)
+{
+	int ret = 0;
+	if (val < 0) {
+		pr_dbg("gpio out val = -1.\n");
+		return -1;
+	}
+	if (val != 0)
+		val = 1;
+	ret = gpiod_direction_output(gpio, val);
+	pr_dbg("dvb ci gpio out ret %d set val:%d\n", ret, val);
+	return ret;
+}
+#if 0
+/**\brief aml_set_gpio_in:set gio in
+* \param gpio: gpio_desc obj,
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int aml_set_gpio_in(struct gpio_desc *gpio)
+{
+	gpiod_direction_input(gpio);
+	return 0;
+}
+#endif
+
+/**\brief aml_get_gpio_value:get gio value
+* \param gpio: gpio_desc obj,
+* \return
+*   - gpio value:ok
+*   - -EINVAL : error
+*/
+static int aml_get_gpio_value(struct gpio_desc *gpio)
+{
+	int ret = 0;
+	ret = gpiod_get_value(gpio);
+	return ret;
+}
+/**\brief aml_gpio_free:free gio
+* \param gpio: gpio_desc obj,
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int aml_gpio_free(struct gpio_desc *gpio)
+{
+	gpiod_put(gpio);
+	return 0;
+}
+/**\brief spi_get_gpio_by_name:get gpio desc from dts file
+* \param spi_dev: aml_spi obj
+* \param gpiod:   gpio_desc * obj
+* \param str: gpio name at dts file
+* \param input_output: gpio input or output type
+* \param output_value: gpio out put value
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int spi_get_gpio_by_name(struct aml_spi *spi_dev,
+struct gpio_desc **gpiod, int *pin_value,
+char *str, int input_output, int output_level)
+{
+	int ret = 0;
+	struct device_node *child = NULL;
+	struct platform_device *pdev = spi_dev->pdev;
+	struct device_node *np = pdev->dev.of_node;
+
+	/*get spi and gpio config from dts*/
+	/* get device config for dvbci_io*/
+	child = of_get_child_by_name(np, "dvbci_io");
+	if (IS_ERR(*gpiod)) {
+		pr_dbg("dvb ci spi %s request failed\n", str);
+		return -1;
+	}
+
+	*pin_value = of_get_named_gpio_flags(child, str, 0, NULL);
+	*gpiod = gpio_to_desc(*pin_value);
+	if (IS_ERR(*gpiod)) {
+		pr_dbg("spi %s request failed\n", str);
+		return -1;
+	}
+	pr_dbg("spi get_gpio %s %p  %d\n", str, *gpiod, *pin_value);
+	gpio_request(*pin_value, AML_MODE_NAME);
+
+	if (input_output == OUTPUT) {
+		ret = gpiod_direction_output(*gpiod, output_level);
+	} else if (input_output == INPUT)	{
+		ret = gpiod_direction_input(*gpiod);
+		/*ret |= gpiod_set_pullup(*gpiod, 1);*/
+	} else {
+		pr_error("spi Request gpio direction invalid\n");
+	}
+	return ret;
+}
+/********************************************************/
+/********************************************************/
+/*******             gpio api end           *************/
+/********************************************************/
+/********************************************************/
+#if 0
+/**\brief aml_ci_cis_test_by_spi:test cis
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \param addr: read addr
+* \return
+*   - test :ok
+*   - -EINVAL : error
+*/
+/**\brief aml_ci_full_test_by_spi:ci full test
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \param addr: read addr
+* \return
+*   - read value:ok
+*   - -EINVAL : error
+*/
+static  int aml_ci_full_test_by_spi(
+	struct aml_ci *ci_dev, int slot, int addr)
+{
+	u8  data = 0;
+	u16 addres = addr;
+	int value = 0;
+	struct aml_spi *spi_dev = ci_dev->data;
+	aml_init_send_buf(AM_CI_CMD_FULLTEST, data, addres);
+	value = aml_spi_io_api(spi_dev,
+		sendbuf, SENDBUFLEN, AM_CI_CMD_FULLTEST);
+	pr_dbg("FULL : TEST END \r\n");
+	return value;
+}
+#endif
+/**\brief aml_ci_mem_read_by_spi:io read from cam
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \param addr: read addr
+* \return
+*   - read value:ok
+*   - -EINVAL : error
+*/
+static  int aml_ci_mem_read_by_spi(
+	struct aml_ci *ci_dev, int slot, int addr)
+{
+	u8  data = 0;
+	u16 addres = addr;
+	int value = 0;
+	struct aml_spi *spi_dev = ci_dev->data;
+	aml_init_send_buf(AM_CI_CMD_MEMR, data, addres);
+	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_MEMR);
+	/*pr_dbg("Read : mem[%d] = 0x%x\n", addr, value);*/
+	return value;
+}
+/**\brief aml_ci_mem_write_by_spi:io write to cam by spi api
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \param addr: write addr
+* \param addr: write value
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int aml_ci_mem_write_by_spi(
+	struct aml_ci *ci_dev, int slot, int addr,  u8 val)
+{
+	u8  data = val;
+	u16 addres = addr;
+	int value = 0;
+	struct aml_spi *spi_dev = ci_dev->data;
+	aml_init_send_buf(AM_CI_CMD_MEMW, data, addres);
+	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_MEMW);
+	/*pr_dbg("write : mem[%d] = 0x%x\n", addr, data);*/
+return value;
+}
+/**\brief aml_ci_io_read_by_spi:io read from cam by spi api
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \param addr: read addr
+* \return
+*   - read value:ok
+*   - -EINVAL : error
+*/
+static int aml_ci_io_read_by_spi(
+	struct aml_ci *ci_dev, int slot, int addr)
+{
+	u8  data = 0;
+	u16 addres = addr;
+	int value = 0;
+	struct aml_spi *spi_dev = ci_dev->data;
+	aml_init_send_buf(AM_CI_CMD_IOR, data, addres);
+	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_IOR);
+	/*pr_dbg("read : io[%d] = 0x%x\n", addr, value);*/
+	return value;
+}
+/**\brief aml_ci_io_write_by_spi:io write to cam
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \param addr: write addr
+* \param addr: write value
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int aml_ci_io_write_by_spi(
+	struct aml_ci *ci_dev, int slot, int addr, u8 val)
+{
+	u8  data = val;
+	u16 addres = addr;
+	int value = 0;
+	struct aml_spi *spi_dev = ci_dev->data;
+	/*add by chl,need add time delay*/
+	mdelay(10);
+	aml_init_send_buf(AM_CI_CMD_IOW, data, addres);
+	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_IOW);
+	/*pr_dbg("write : ATTR[%d] = 0x%x\n", addr, data);*/
+	return value;
+}
+
+
+/**\brief aml_ci_slot_reset:reset slot
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+*/
+static int aml_ci_slot_reset(struct aml_ci *ci_dev, int slot)
+{
+	struct aml_spi *spi_dev = ci_dev->data;
+	pr_dbg("Slot(%d): Slot RESET\n", slot);
+	aml_pcmcia_reset(&spi_dev->pc);
+	dvb_ca_en50221_camready_irq(&ci_dev->en50221, 0);
+	return 0;
+}
+/**\brief aml_ci_slot_shutdown:show slot
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+* readme:no use this api
+*/
+static int aml_ci_slot_shutdown(struct aml_ci *ci_dev, int slot)
+{
+	pr_dbg("Slot(%d): Slot shutdown\n", slot);
+	return 0;
+}
+/**\brief aml_ci_ts_control:control slot ts
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \return
+*   - 0:ok
+*   - -EINVAL : error
+* readme:no use this api
+*/
+static int aml_ci_ts_control(struct aml_ci *ci_dev, int slot)
+{
+	pr_dbg("Slot(%d): TS control\n", slot);
+	return 0;
+}
+/**\brief aml_ci_slot_status:get slot status
+* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
+* \param slot: slot index
+* \param open: no used
+* \return
+*   - cam status
+*   - -EINVAL : error
+*/
+static int aml_ci_slot_status(struct aml_ci *ci_dev, int slot, int open)
+{
+	struct aml_spi *spi_dev = ci_dev->data;
+
+	pr_dbg("Slot(%d): Poll Slot status\n", slot);
+
+	if (spi_dev->pc.slot_state == MODULE_INSERTED) {
+		pr_dbg("CA Module present and ready\n");
+		return DVB_CA_EN50221_POLL_CAM_PRESENT |
+		DVB_CA_EN50221_POLL_CAM_READY;
+	} else {
+		pr_error("CA Module not present or not ready\n");
+	}
+	return -EINVAL;
+}
+#if 0
+/**\brief aml_ci_gio_get_irq:get gpio cam irq pin value
+* \return
+*   - irq pin value
+*   - -EINVAL : error
+*/
+static int aml_ci_gio_get_irq(void)
+{
+	int ret = 0;
+	ret = aml_get_gpio_value(g_spi_dev->irq_cam_pin);
+	return ret;
+}
+#endif
+
+/********************************************************/
+/********************************************************/
+/*******        for pcmcid api              *************/
+/********************************************************/
+/********************************************************/
+/**\brief aml_gio_power:set power gpio hi or low
+* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
+* \param enable: power pin hi or low
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+static int aml_gio_power(struct aml_pcmcia *pc, int enable)
+{
+	int ret = 0;
+	struct aml_spi *spi_dev = pc->priv;
+	if (spi_dev == NULL) {
+		pr_dbg("spi dev is null %s : %d\r\n", __func__, enable);
+		return -1;
+	}
+	pr_dbg("%s : %d\r\n", __func__, enable);
+	if (enable == AML_PWR_OPEN) {
+		/*hi level ,open power*/
+		ret = aml_set_gpio_out(spi_dev->pwr_pin, AML_GPIO_HIGH);
+	} else {
+		/*low level ,close power*/
+		ret = aml_set_gpio_out(spi_dev->pwr_pin, AML_GPIO_LOW);
+	}
+	return ret;
+}
+/**\brief aml_gio_reset:set reset gpio hi or low
+* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
+* \param enable: reset pin hi or low
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+static int aml_gio_reset(struct aml_pcmcia *pc, int enable)
+{
+	/*need set hi and sleep set low*/
+	int ret = 0;
+	struct aml_spi *spi_dev = pc->priv;
+	pr_dbg("%s : %d\r\n", __func__, enable);
+	if (enable == AML_L)
+		ret = aml_set_gpio_out(spi_dev->reset_pin, AML_GPIO_LOW);
+	else
+		ret = aml_set_gpio_out(spi_dev->reset_pin, AML_GPIO_HIGH);
+	return ret;
+}
+
+/**\brief aml_gio_init_irq:set gpio irq
+* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
+* \param flag: rising or falling or hi or low
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+/*need change*/
+static int aml_gio_init_irq(struct aml_pcmcia *pc, int flag)
+	{
+		struct aml_spi *spi_dev = (struct aml_spi *)pc->priv;
+	
+#if 0
+		int cd1_pin = desc_to_gpio(spi_dev->cd_pin1);
+	
+		int irq = pc->irq-AML_CI_GPIO_IRQ_BASE;
+	
+		printk("----cd1_pin=%d irq=%d\r\n", cd1_pin, irq);
+		aml_set_gpio_in(spi_dev->cd_pin1);
+	
+		if (flag == IRQF_TRIGGER_RISING)
+			gpio_for_irq(cd1_pin,
+				AML_GPIO_IRQ(irq, FILTER_NUM7, GPIO_IRQ_RISING));
+		else if (flag == IRQF_TRIGGER_FALLING)
+			gpio_for_irq(cd1_pin,
+				AML_GPIO_IRQ(irq, FILTER_NUM7, GPIO_IRQ_FALLING));
+		else if (flag == IRQF_TRIGGER_HIGH)
+			gpio_for_irq(cd1_pin,
+				AML_GPIO_IRQ(irq, FILTER_NUM7, GPIO_IRQ_HIGH));
+		else if (flag == IRQF_TRIGGER_LOW)
+			gpio_for_irq(cd1_pin,
+				AML_GPIO_IRQ(irq, FILTER_NUM7, GPIO_IRQ_LOW));
+		else
+			return -1;
+#endif
+		gpiod_to_irq(spi_dev->cd_pin1);
+	
+		return 0;
+	}
+
+/**\brief aml_gio_get_cd1:get gpio cd1 pin value
+* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
+* \return
+*   - cd1 pin value
+*   - -EINVAL : error
+*/
+static int aml_gio_get_cd1(struct aml_pcmcia *pc)
+{
+	int ret = 0;
+	struct aml_spi *spi_dev = pc->priv;
+	ret = aml_get_gpio_value(spi_dev->cd_pin1);
+	return ret;
+}
+/**\brief aml_gio_get_cd2:get gpio cd2 pin value
+* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
+* \return
+*   - cd2 pin value
+*   - -EINVAL : error
+*/
+static int aml_gio_get_cd2(struct aml_pcmcia *pc)
+{
+	int ret = 0;
+	struct aml_spi *spi_dev = pc->priv;
+	ret = aml_get_gpio_value(spi_dev->cd_pin2);
+	pr_dbg("%s : %d\r\n", __func__, ret);
+	return ret;
+}
+/**\brief aml_cam_plugin:notify en50221 cam card in or out
+* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
+* \plugin: 0:remove;1:in
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+static int aml_cam_plugin(struct aml_pcmcia *pc, int plugin)
+{
+	struct aml_ci *ci = (struct aml_ci *)
+	((struct aml_spi *)(pc->priv))->priv;
+	pr_dbg("%s : %d\r\n", __func__, plugin);
+	if (plugin) {
+		dvb_ca_en50221_camchange_irq(&ci->en50221,
+			0, DVB_CA_EN50221_CAMCHANGE_INSERTED);
+	} else {
+		dvb_ca_en50221_camchange_irq(&ci->en50221,
+			0, DVB_CA_EN50221_CAMCHANGE_REMOVED);
+	}
+	return 0;
+}
+/**\brief aml_pcmcia_alloc:alloc nad init pcmcia obj
+* \param spi_dev: aml_spi obj,
+* \param pcmcia: aml_pcmcia * obj,
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+static void aml_pcmcia_alloc(struct aml_spi *spi_dev,
+	struct aml_pcmcia **pcmcia)
+{
+	pr_dbg("aml_pcmcia_alloc----\n");
+	*pcmcia = &spi_dev->pc;
+	(*pcmcia)->irq = spi_dev->irq;
+	(*pcmcia)->init_irq = aml_gio_init_irq;
+	(*pcmcia)->get_cd1 = aml_gio_get_cd1;
+	(*pcmcia)->get_cd2 = aml_gio_get_cd2;
+	(*pcmcia)->pwr = aml_gio_power;
+	(*pcmcia)->rst = aml_gio_reset;
+	(*pcmcia)->pcmcia_plugin = aml_cam_plugin;
+	(*pcmcia)->slot_state = MODULE_XTRACTED;
+	(*pcmcia)->priv = spi_dev;
+	(*pcmcia)->run_type = 0;/*0:irq;1:poll*/
+}
+
+/**\brief aml_spi_get_config_from_dts:get spi config and gpio config from dts
+* \param spi_dev: aml_spi obj,
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+static int aml_spi_get_config_from_dts(struct aml_spi *spi_dev)
+{
+	struct device_node *child = NULL;
+	struct platform_device *pdev = spi_dev->pdev;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp[5], val;
+	int ret = 0;
+	pr_dbg("into get spi dts \r\n");
+
+	/*get spi and gpio config from dts*/
+	/* get device config for dvbci_io*/
+	child = of_get_child_by_name(np, "dvbci_io");
+	if (child == NULL) {
+		pr_error("failed to get dvbci_io\n");
+		return -1;
+	}
+	spi_dev->spi_bdinfo = &aml_ci_spi_bdinfo;
+	/* get spi config */
+	ret = of_property_read_u32_array(child, "spi_bus_num", temp, 1);
+	if (ret) {
+		pr_error("failed to get spi_bus_num\n");
+	} else {
+		aml_ci_spi_bdinfo.bus_num = temp[0];
+		pr_dbg("bus_num: %d\n", aml_ci_spi_bdinfo.bus_num);
+	}
+	ret = of_property_read_u32_array(child, "spi_chip_select",
+	temp, 1);
+	if (ret) {
+		pr_error("failed to get spi_chip_select\n");
+	} else {
+		aml_ci_spi_bdinfo.chip_select = temp[0];
+		pr_dbg("chip_select: %d\n", aml_ci_spi_bdinfo.chip_select);
+	}
+	ret = of_property_read_u32_array(child, "spi_max_frequency",
+	temp, 1);
+	if (ret) {
+		pr_error("failed to get spi_chip_select\n");
+	} else {
+		aml_ci_spi_bdinfo.max_speed_hz = temp[0];
+		pr_dbg("max_speed_hz: %d\n", aml_ci_spi_bdinfo.max_speed_hz);
+	}
+	ret = of_property_read_u32_array(child, "spi_mode", temp, 1);
+	if (ret) {
+		pr_error("failed to get spi_mode\n");
+	} else {
+		aml_ci_spi_bdinfo.mode = temp[0];
+		pr_dbg("mode: %d\n", aml_ci_spi_bdinfo.mode);
+	}
+	ret = of_property_read_u32_array(child, "spi_cs_delay",
+	&temp[0], 2);
+	if (ret) {
+		spi_dev->cs_hold_delay = 0;
+		spi_dev->cs_clk_delay = 0;
+	} else {
+		spi_dev->cs_hold_delay = temp[0];
+		spi_dev->cs_clk_delay = temp[1];
+	}
+	ret = of_property_read_u32(child, "spi_write_check", &val);
+	if (ret)
+		spi_dev->write_check = 0;
+	else
+		spi_dev->write_check = (unsigned char)val;
+	/*get  cd1 irq num*/
+	ret = of_property_read_u32(child, "irq_cd1", &val);
+	if (ret) {
+		spi_dev->irq = 5;
+	} else {
+		/*set irq value need add
+		AML_CI_GPIO_IRQ_BASE,but
+		we need minus
+		AML_CI_GPIO_IRQ_BASE
+		when gpio request irq */
+		spi_dev->irq = val+AML_CI_GPIO_IRQ_BASE;
+	}
+
+	spi_dev->irq = irq_of_parse_and_map(
+	pdev->dev.of_node, 0);
+	AML_CI_GPIO_IRQ_BASE = spi_dev->irq - val;
+	pr_dbg("get spi irq : %d  0:%d USEDBASE:%d val:%d\r\n",
+		spi_dev->irq, INT_GPIO_0, AML_CI_GPIO_IRQ_BASE, val);
+	/*get reset pwd cd1 cd2 gpio pin*/
+	spi_dev->reset_pin = NULL;
+	ret = spi_get_gpio_by_name(spi_dev, &spi_dev->reset_pin,
+	&spi_dev->reset_pin_value, "reset_pin",
+	OUTPUT, OUTLEVEL_HIGH);
+	if (ret) {
+		pr_error("dvb ci reset pin request failed\n");
+		return -1;
+	}
+	spi_dev->cd_pin1 = NULL;
+	ret = spi_get_gpio_by_name(spi_dev,
+		&spi_dev->cd_pin1,
+		&spi_dev->cd_pin1_value, "cd_pin1",
+		INPUT, OUTLEVEL_HIGH);
+	if (ret) {
+		pr_error("dvb ci cd_pin1 pin request failed\n");
+		return -1;
+	}
+	spi_dev->cd_pin2 = spi_dev->cd_pin1;
+	spi_dev->cd_pin2_value = spi_dev->cd_pin1_value;
+	spi_dev->pwr_pin = NULL;
+	pr_dbg("spi_dev->cd_pin1_value==%d\r\n", spi_dev->cd_pin1_value);
+	ret = spi_get_gpio_by_name(spi_dev,
+		&spi_dev->pwr_pin, &spi_dev->pwr_pin_value,
+		"pwr_pin", OUTPUT, OUTLEVEL_HIGH);
+	if (ret) {
+		pr_error("dvb ci pwr_pin pin request failed\n");
+		return -1;
+	}
+	spi_dev->irq_cam_pin = NULL;
+	ret = spi_get_gpio_by_name(spi_dev,
+		&spi_dev->irq_cam_pin, &spi_dev->irq_cam_pin_value,
+		"irq_cam_pin", INPUT, OUTLEVEL_HIGH);
+	if (ret) {
+		pr_error("dvbci  irq_cam_pin pin request failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+/**\brief aml_ci_free_gpio:free ci gpio
+* \param spi_dev: aml_spi obj,
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+static void aml_ci_free_gpio(struct aml_spi *spi_dev)
+{
+	if (spi_dev == NULL) {
+		pr_error("spi_dev is NULL,no need free gpio res\r\n");
+		return;
+	}
+
+	if (spi_dev->pwr_pin) {
+		aml_gpio_free(spi_dev->pwr_pin);
+		spi_dev->pwr_pin = NULL;
+	}
+	if (spi_dev->cd_pin1) {
+		aml_gpio_free(spi_dev->cd_pin1);
+		spi_dev->cd_pin1 = NULL;
+		spi_dev->cd_pin2 = NULL;
+	}
+	if (spi_dev->reset_pin) {
+		aml_gpio_free(spi_dev->reset_pin);
+		spi_dev->reset_pin = NULL;
+	}
+	if (spi_dev->irq_cam_pin) {
+		aml_gpio_free(spi_dev->irq_cam_pin);
+		spi_dev->irq_cam_pin = NULL;
+	}
+	return;
+}
+
+
+/**\brief ci_spi_dev_remove:spi probe api
+* \param spi: spi obj,
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+static int ci_spi_dev_probe(struct spi_device *spi)
+{
+	int ret;
+	pr_dbg("spi Dev probe--\n");
+	if (g_spi_dev)
+		g_spi_dev->spi = spi;
+	 else
+		pr_dbg("spi Dev probe-error-\n");
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret)
+		pr_dbg("spi setup failed\n");
+	return ret;
+}
+/**\brief ci_spi_dev_remove:spi remove api
+* \param spi: spi obj,
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+static int ci_spi_dev_remove(struct spi_device *spi)
+{
+	pr_dbg("spi Dev remove--\n");
+	if (g_spi_dev)
+		g_spi_dev->spi = NULL;
+
+	return 0;
+}
+
+static struct spi_driver ci_spi_dev_driver = {
+	.probe = ci_spi_dev_probe,
+	.remove = ci_spi_dev_remove,
+	.driver = {
+		.name = "ci_spi_dev",/*set same with board info modalias*/
+		.owner = THIS_MODULE,
+	},
+};
+/**\brief aml_spi_init:spi_dev init
+* \param ci_dev: aml_ci obj,
+* \param pdev: platform_device obj,used to get dts info
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+int aml_spi_init(struct platform_device *pdev, struct aml_ci *ci_dev)
+{
+	struct aml_spi *spi_dev = NULL;
+	struct aml_pcmcia *pc;
+	int result;
+
+	spi_dev = kmalloc(sizeof(struct aml_spi), GFP_KERNEL);
+	if (!spi_dev) {
+		pr_error("Out of memory!, exiting ..\n");
+		result = -ENOMEM;
+		goto err;
+	}
+	g_spi_dev = spi_dev;
+	spi_dev->pdev = pdev;
+	spi_dev->priv = ci_dev;
+	/*get config from dts*/
+	aml_spi_get_config_from_dts(spi_dev);
+	/*regist api dev*/
+	spi_register_board_info(spi_dev->spi_bdinfo, 1);
+	result = spi_register_driver(&ci_spi_dev_driver);
+	if (result) {
+		pr_error("register amlspi_dev spi driver failed\n");
+		goto fail1;
+	}
+	aml_pcmcia_alloc(spi_dev, &pc);
+	result = aml_pcmcia_init(pc);
+	if (result < 0) {
+		pr_error("aml_pcmcia_init failed\n");
+		goto fail2;
+	}
+
+	/*init ci_dev used api.*/
+	ci_dev->ci_mem_read  = aml_ci_mem_read_by_spi;
+	ci_dev->ci_mem_write = aml_ci_mem_write_by_spi;
+	ci_dev->ci_io_read = aml_ci_io_read_by_spi;
+	ci_dev->ci_io_write = aml_ci_io_write_by_spi;
+	ci_dev->ci_slot_reset = aml_ci_slot_reset;
+	ci_dev->ci_slot_shutdown = aml_ci_slot_shutdown;
+	ci_dev->ci_slot_ts_enable = aml_ci_ts_control;
+	ci_dev->ci_poll_slot_status = aml_ci_slot_status;
+	ci_dev->data = spi_dev;
+	/*init spi_lock*/
+	spin_lock_init(&(spi_dev->spi_lock));
+	return 0;
+fail2:
+	spi_unregister_driver(&ci_spi_dev_driver);
+fail1:
+	kfree(spi_dev);
+	spi_dev = NULL;
+err:
+	return -1;
+}
+EXPORT_SYMBOL(aml_spi_init);
+/**\brief aml_spi_exit:spi exit
+* \return
+*   - 0
+*   - -EINVAL : error
+*/
+int aml_spi_exit(struct aml_ci *ci)
+{
+	/*exit pc card*/
+	aml_pcmcia_exit(&g_spi_dev->pc);
+	/*un regist spi driver*/
+	spi_unregister_driver(&ci_spi_dev_driver);
+	/*free gpio*/
+	aml_ci_free_gpio(g_spi_dev);
+	/*free spi dev*/
+	kfree(g_spi_dev);
+	g_spi_dev = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(aml_spi_exit);
+
+
+#if 0
+/********************************************************/
+/********************************************************/
+/*******        for spi test api            *************/
+/********************************************************/
+/********************************************************/
+
+/*cam difines*/
+#define DA	0x80
+#define FR	0x40
+#define WE	0x02
+#define RE	0x01
+
+#define RS	0x08
+#define SR	0x04
+#define SW	0x02
+#define HC	0x01
+#define DATA_REG	  0
+#define COM_STA_REG	1
+#define SIZE_REG_L	2
+#define SIZE_REG_M	3
+static void aml_spi_ca_full_test(struct aml_ci *ci_dev)
+{
+		unsigned int BUF_SIZE = 0;
+		unsigned int i = 0;
+		unsigned char cc = 0;
+		unsigned char reg;
+		unsigned int  bsize = 0;
+		int cnt = 0;
+		unsigned char buf[10];
+		int count = 1000;
+		mdelay(1000);
+		pr_dbg("READ CIS START\r\n");
+		for (i = 0; i < 267; i++) {
+			mdelay(100);
+			cc = aml_ci_mem_read_by_spi(ci_dev, 0, i);
+			pr_dbg("0x%x ", cc);
+			if ((i + 1) % 16 == 0)
+				pr_dbg(" \r\n");
+		}
+		pr_dbg("READ CIS OVER\r\n");
+		mdelay(1000);
+		pr_dbg("SW rst CAM...\r\n");
+		aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, RS);
+		pr_dbg("SW rst over.\r\n");
+		pr_dbg("-----------------------------------\r\n");
+		pr_dbg("TO delay 2000ms\r\n");
+		mdelay(2000);
+		pr_dbg("\r\n");
+		pr_dbg("--------------clear rs--!!!-YOU MUST CLEAR RS BIT--no sleep--------\r\n");
+		aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, 0);
+		pr_dbg("--------------sleep---------------------\r\n");
+		mdelay(2000);
+		pr_dbg("TO check sw-rst is OK\r\n");
+		pr_dbg("start read fr \r\n");
+		if (1) {
+			unsigned char reg;
+			unsigned char reg1;
+			int count1 = 4000;
+			while (1) {
+				mdelay(20);
+				count1--;
+				reg1 = aml_ci_io_read_by_spi(
+					ci_dev, 0, COM_STA_REG);
+				if (FR != (FR & reg1)) {
+						continue;
+					} else {
+						pr_dbg("CAM Reset Ok\r\n");
+						break;
+					}
+			}
+			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+			pr_dbg("STA_REG = 0x%2.2x\r\n", reg);
+			if (FR & reg) {
+				pr_dbg("SW-RST is OK!\r\n");
+			} else {
+				pr_dbg("SW-RST is ERR!\r\n");
+				goto end;
+			}
+		}
+end:
+		pr_dbg("TO check sw-rst over.\r\n");
+		pr_dbg("\r\n");
+		pr_dbg("-----------------------------------\r\n");
+		pr_dbg("TO buffer size negotiation protocol...\r\n");
+		pr_dbg("Get which buf size CAM can support\r\n");
+		aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, SR);
+		mdelay(1000);
+		while (1) {
+
+			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+			if ((reg & DA) == DA) {
+				pr_dbg("Buffer negotiate size date avalible.\r\n");
+				break;
+			} else {
+				/*pr_dbg("Buffer negotiate
+				size date NOT avalible\r\n");*/
+				continue;
+			}
+			mdelay(100);
+		}
+		cnt = (aml_ci_io_read_by_spi(ci_dev, 0, SIZE_REG_L)) +
+		((aml_ci_io_read_by_spi(ci_dev, 0, SIZE_REG_M)) * 256);
+		pr_dbg("Moudle have <%d> Bytes send to host.\r\n", cnt);
+		if (cnt != 2) {
+			pr_dbg("The Bytes will be tx is ERR!\r\n");
+			return;
+		}
+		for (i = 0; i < cnt; i++)
+			buf[i] = aml_ci_io_read_by_spi(ci_dev, 0, DATA_REG);
+
+		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+		if (RE == (RE & reg)) {
+			pr_dbg("(1)Read CAM buf size ERR!\r\n");
+			return;
+		}
+		aml_ci_io_write_by_spi(ci_dev, 0, (COM_STA_REG), 0);
+
+		mdelay(1000);
+
+		while (count--) {
+			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+			if (FR != (FR & reg)) {
+				pr_dbg("CAM is busy 2, waiting...\r\n");
+				continue;
+			} else {
+				pr_dbg("CAM is OK 2.\r\n");
+				break;
+			}
+		}
+		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+		if (FR != (FR & reg)) {
+			pr_dbg("(2)Read CAM buf size ERR!-\r\n");
+			return;
+		}
+		bsize = (buf[0] * 256) + buf[1];
+
+		pr_dbg("CAM can support buf size is: <%d>B\r\n", bsize);
+
+		pr_dbg("Tell CAM which size buf is be used\r\n");
+		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+		if (FR != (FR & reg))
+			pr_dbg("CAM is busy, waiting free\r\n");
+		while (1) {
+			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+			if (FR != (FR & reg)) {
+				pr_dbg("CAM is busy 3, waiting\r\n");
+				continue;
+			} else {
+				pr_dbg("CAM is OK 3\r\n");
+				break;
+			}
+		}
+
+		bsize = bsize - 0;
+		BUF_SIZE = bsize;
+		pr_dbg("We will use this  buf size: <%d>B\r\n", bsize);
+		aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, SW);
+		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+		if (FR != (FR & reg))
+			pr_dbg("CAM is busy, waiting\r\n");
+
+		while (1) {
+			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+			if (FR != (FR & reg)) {
+				pr_dbg("CAM is busy 4, waiting\r\n");
+				continue;
+			} else {
+				pr_dbg("CAM is OK 4\r\n");
+				break;
+			}
+		}
+		/*SHOULD CHECK DA!!!!!*/
+		/*PLS ADD THIS CHECK CODE:*/
+		pr_dbg("PRIOR to check CAM'S DA\r\n");
+		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+		if ((reg & DA) == DA) {
+			pr_dbg("CAM have data send to HOST\r\n");
+			return;
+		}
+
+
+		buf[0] = (unsigned char)((bsize >> 8) & 0xff);
+		buf[1] = (unsigned char)(bsize & 0xff);
+
+		while (1) {
+			mdelay(10);
+			aml_ci_io_write_by_spi(ci_dev,
+			0, COM_STA_REG, HC | SW);
+			mdelay(100);
+			reg = aml_ci_io_read_by_spi(ci_dev,
+				0, COM_STA_REG);
+			if (FR != (FR & reg)) {
+				pr_dbg("CAM is busy 5, waiting\r\n");
+				aml_ci_io_write_by_spi(ci_dev,
+					0, COM_STA_REG, SW);
+				continue;
+			} else {
+				pr_dbg("CAM is OK 5\r\n");
+				break;
+			}
+		}
+		pr_dbg("<2> Bytes send to CAM\r\n");
+		aml_ci_io_write_by_spi(ci_dev, 0, SIZE_REG_M, 0);
+		aml_ci_io_write_by_spi(ci_dev, 0, SIZE_REG_L, 2);
+		for (i = 0; i < 2; i++)
+			aml_ci_io_write_by_spi(ci_dev, 0, DATA_REG, buf[i]);
+
+		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
+		if (WE == (WE & reg)) {
+			pr_dbg("Write CAM ERR!\r\n");
+			return;
+		} else {
+			aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, SW);
+			mdelay(100);
+			aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, 0);
+			pr_dbg("Buffer size negotiation over!\r\n");
+			pr_dbg("NOW, HOST can communicates with CAM\r\n");
+			pr_dbg("NOW, TEST END\r\n");
+		}
+}
+
+/**
+* Read a tuple from attribute memory.
+*
+* @param ca CA instance.
+* @param slot Slot id.
+* @param address Address to read from. Updated.
+* @param tupleType Tuple id byte. Updated.
+* @param tupleLength Tuple length. Updated.
+* @param tuple Dest buffer for tuple (must be 256 bytes). Updated.
+*
+* @return 0 on success, nonzero on error.
+*/
+static int dvb_ca_en50221_read_tuple(
+int *address, int *tupleType, int *tupleLength, u8 *tuple)
+{
+	int i;
+	int _tupleType;
+	int _tupleLength;
+	int _address = *address;
+
+	/* grab the next tuple length and type */
+	_tupleType = aml_ci_mem_read_by_spi((struct aml_ci *)
+		g_spi_dev->priv, 0, _address);
+	if (_tupleType < 0)
+		return _tupleType;
+	if (_tupleType == 0xff) {
+		pr_dbg("END OF CHAIN TUPLE type:0x%x\n", _tupleType);
+		*address += 2;
+		*tupleType = _tupleType;
+		*tupleLength = 0;
+		return 0;
+	}
+	_tupleLength = aml_ci_mem_read_by_spi((struct aml_ci *)
+		g_spi_dev->priv, 0, _address + 2);
+	if (_tupleLength < 0)
+		return _tupleLength;
+	_address += 4;
+
+	pr_dbg("TUPLE type:0x%x length:%i\n", _tupleType, _tupleLength);
+
+	/* read in the whole tuple */
+	for (i = 0; i < _tupleLength; i++) {
+		tuple[i] = aml_ci_mem_read_by_spi((struct aml_ci *)
+			g_spi_dev->priv, 0, _address + (i * 2));
+		pr_dbg("  0x%02x: 0x%02x %c\n",
+		i, tuple[i] & 0xff,
+		((tuple[i] > 31) && (tuple[i] < 127)) ? tuple[i] : '.');
+	}
+	_address += (_tupleLength * 2);
+
+	/* success */
+	*tupleType = _tupleType;
+	*tupleLength = _tupleLength;
+	*address = _address;
+	return 0;
+}
+static char *findstr(char *haystack, int hlen, char *needle, int nlen)
+{
+	int i;
+
+	if (hlen < nlen)
+		return NULL;
+
+	for (i = 0; i <= hlen - nlen; i++) {
+		if (!strncmp(haystack + i, needle, nlen))
+			return haystack + i;
+	}
+
+	return NULL;
+}
+
+/**
+* Parse attribute memory of a CAM module, extracting Config register, and checking
+* it is a DVB CAM module.
+*
+* @param ca CA instance.
+* @param slot Slot id.
+*
+* @return 0 on success, <0 on failure.
+*/
+static int dvb_ca_en50221_parse_attributes(void)
+{
+	int address = 0;
+	int tupleLength;
+	int tupleType;
+	u8 tuple[257];
+	char *dvb_str;
+	int rasz;
+	int status;
+	int got_cftableentry = 0;
+	int end_chain = 0;
+	int i;
+	u16 manfid = 0;
+	u16 devid = 0;
+	int config_base = 0;
+	int config_option;
+
+	/* CISTPL_DEVICE_0A */
+	status = dvb_ca_en50221_read_tuple(&address,
+	&tupleType, &tupleLength, tuple);
+	if (status < 0) {
+		pr_error("read status error\r\n");
+		return status;
+	}
+	if (tupleType != 0x1D) {
+		pr_error("read tupleType error [0x%x]\r\n", tupleType);
+		return -EINVAL;
+	}
+
+
+
+	/* CISTPL_DEVICE_0C */
+	status = dvb_ca_en50221_read_tuple(&address,
+	&tupleType, &tupleLength, tuple);
+	if (status < 0) {
+		pr_error("read read cis  error\r\n");
+		return status;
+	}
+	if (tupleType != 0x1C) {
+		pr_error("read read cis type error\r\n");
+		return -EINVAL;
+	}
+
+
+
+	/* CISTPL_VERS_1 */
+	status = dvb_ca_en50221_read_tuple(&address,
+	&tupleType, &tupleLength, tuple);
+	if (status < 0) {
+		pr_error("read read cis  version error\r\n");
+		return status;
+	}
+	if (tupleType != 0x15) {
+		pr_error("read read cis version type error\r\n");
+		return -EINVAL;
+	}
+
+
+
+	/* CISTPL_MANFID */
+	status = dvb_ca_en50221_read_tuple(&address, &tupleType,
+	&tupleLength, tuple);
+	if (status < 0) {
+		pr_error("read read cis manfid error\r\n");
+		return status;
+	}
+	if (tupleType != 0x20) {
+		pr_error("read read cis manfid type error\r\n");
+		return -EINVAL;
+	}
+	if (tupleLength != 4) {
+		pr_error("read read cis manfid len error\r\n");
+		return -EINVAL;
+	}
+	manfid = (tuple[1] << 8) | tuple[0];
+	devid = (tuple[3] << 8) | tuple[2];
+
+
+
+	/* CISTPL_CONFIG */
+	status = dvb_ca_en50221_read_tuple(&address, &tupleType,
+	&tupleLength, tuple);
+	if (status < 0) {
+		pr_error("read read cis config error\r\n");
+		return status;
+	}
+	if (tupleType != 0x1A) {
+		pr_error("read read cis config type error\r\n");
+		return -EINVAL;
+	}
+	if (tupleLength < 3) {
+		pr_error("read read cis config len error\r\n");
+		return -EINVAL;
+	}
+
+	/* extract the configbase */
+	rasz = tuple[0] & 3;
+	if (tupleLength < (3 + rasz + 14)) {
+		pr_error("read extract the configbase  error\r\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < rasz + 1; i++)
+		config_base |= (tuple[2 + i] << (8 * i));
+
+
+	/* check it contains the correct DVB string */
+	dvb_str = findstr((char *)tuple, tupleLength, "DVB_CI_V", 8);
+	if (dvb_str == NULL) {
+		pr_error("find dvb str DVB_CI_V  error\r\n");
+		return -EINVAL;
+	}
+	if (tupleLength < ((dvb_str - (char *) tuple) + 12)) {
+		pr_error("find dvb str DVB_CI_V len error\r\n");
+		return -EINVAL;
+	}
+
+	/* is it a version we support? */
+	if (strncmp(dvb_str + 8, "1.00", 4)) {
+		pr_error(" Unsupported DVB CAM module version %c%c%c%c\n",
+		dvb_str[8], dvb_str[9], dvb_str[10], dvb_str[11]);
+		return -EINVAL;
+	}
+
+/* process the CFTABLE_ENTRY tuples, and any after those */
+while ((!end_chain) && (address < 0x1000)) {
+		status = dvb_ca_en50221_read_tuple(&address, &tupleType,
+	&tupleLength, tuple);
+	if (status < 0) {
+		pr_error("process the CFTABLE_ENTRY tuples error\r\n");
+		return status;
+	}
+
+	switch (tupleType) {
+	case 0x1B:	/* CISTPL_CFTABLE_ENTRY */
+			if (tupleLength < (2 + 11 + 17))
+				break;
+
+			/* if we've already parsed one, just use it */
+			if (got_cftableentry)
+				break;
+
+			/* get the config option */
+			config_option = tuple[0] & 0x3f;
+
+			/* OK, check it contains the correct strings */
+			if ((findstr((char *)tuple,
+				tupleLength, "DVB_HOST", 8) == NULL) ||
+			(findstr((char *)tuple,
+			tupleLength, "DVB_CI_MODULE", 13) == NULL))
+				break;
+
+
+			got_cftableentry = 1;
+			break;
+
+	case 0x14:	/* CISTPL_NO_LINK*/
+			break;
+
+	case 0xFF:	/* CISTPL_END */
+			end_chain = 1;
+			break;
+
+	default:
+		/* Unknown tuple type - just skip
+		*this tuple and move to the next one
+		*/
+pr_error("Skipping unknown tupletype:0x%x L:0x%x\n",
+				tupleType, tupleLength);
+			break;
+		}
+	}
+
+	if ((address > 0x1000) || (!got_cftableentry)) {
+		pr_error("got_cftableentry :%d\r\n", got_cftableentry);
+		return -EINVAL;
+	}
+
+	pr_error("----------ci cis ok-----\r\n");
+	return 0;
+}
+
+static ssize_t aml_spi_ci_reset_help(struct class *class,
+struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "echo 1 > %s\n\t", attr->attr.name);
+	return ret;
+}
+
+static ssize_t aml_spi_ci_reset(struct class *class,
+struct class_attribute *attr, const char *buf, size_t size)
+{
+	int ret;
+	struct aml_ci *ci = (struct aml_ci *)g_spi_dev->priv;
+	ret = aml_ci_slot_reset(ci, 0);
+	return size;
+}
+
+static ssize_t aml_spi_ci_pwr_help(struct class *class,
+struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "echo 1|0> %s\n\t", attr->attr.name);
+	return ret;
+}
+
+static ssize_t aml_spi_ci_pwr(struct class *class,
+struct class_attribute *attr, const char *buf, size_t size)
+{
+	int ret = 0;
+	int enable = 0;
+	long value;
+	if (kstrtol(buf, 0, &value) == 0)
+		enable = (int)value;
+	ret = aml_gio_power(&g_spi_dev->pc, enable);
+	return size;
+}
+static ssize_t aml_spi_ci_state_show(struct class *class,
+struct class_attribute *attr, char *buf)
+{
+	int ret;
+	struct aml_ci *ci = (struct aml_ci *)g_spi_dev->priv;
+	ret = aml_ci_slot_status(ci, 0, 0);
+	ret = sprintf(buf, "%s: %d;\n\t", attr->attr.name, ret);
+	return ret;
+}
+
+static ssize_t aml_spi_ci_irq_show(struct class *class,
+struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = aml_ci_gio_get_irq();
+	ret = sprintf(buf, "%s irq: %d\n\t", attr->attr.name, ret);
+	return ret;
+}
+
+static ssize_t aml_spi_io_test_help(struct class *class,
+struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "echo (r|w|f|c)(i|a) addr data > %s\n",
+	attr->attr.name);
+	return ret;
+}
+
+static ssize_t aml_spi_io_test(struct class *class,
+struct class_attribute *attr, const char *buf, size_t size)
+{
+	int n = 0;
+	char *buf_orig, *ps, *token;
+	char *parm[3];
+	unsigned int addr = 0, val = 0, retval = 0;
+	long value = 0;
+	struct aml_ci *ci = (struct aml_ci *)g_spi_dev->priv;
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	ps = buf_orig;
+	while (1) {
+		/*need set '\n' to ' \n'*/
+		token = strsep(&ps, "\n");
+		if (token == NULL)
+			break;
+		if (*token == '\0')
+			continue;
+		parm[n++] = token;
+	}
+
+	if (!n || ((n > 0) && (strlen(parm[0]) != 2))) {
+		pr_err("invalid command\n");
+		kfree(buf_orig);
+		return size;
+	}
+
+	if ((parm[0][0] == 'r')) {
+		if (n != 2) {
+			pr_err("read: invalid parameter\n");
+			kfree(buf_orig);
+			return size;
+		}
+	if (kstrtol(parm[1], 0, &value) == 0)
+		addr = (int)value;
+		pr_err("%s 0x%x\n", parm[0], addr);
+	/*	switch ((char)parm[0][1]) {
+			case 'i':
+				retval = aml_ci_io_read_by_spi(ci, 0, addr);
+				break;
+			case 'a':
+				retval = aml_ci_mem_read_by_spi(ci, 0, addr);
+				break;
+			default:
+				break;
+		}*/
+		pr_dbg("%s: 0x%x --> 0x%x\n", parm[0], addr, retval);
+	} else if ((parm[0][0] == 'w')) {
+		if (n != 3) {
+			pr_err("write: invalid parameter\n");
+			kfree(buf_orig);
+			return size;
+		}
+		if (kstrtol(parm[1], 0, &value) == 0)
+				addr = (int)value;
+		if (kstrtol(parm[2], 0, &value) == 0)
+				val = (int)value;
+
+		pr_err("%s 0x%x 0x%x", parm[0], addr, val);
+		/*switch ((char)parm[0][1]) {
+			case 'i':
+retval = aml_ci_io_write_by_spi(ci, 0, addr, val);
+				break;
+			case 'a':
+retval = aml_ci_mem_write_by_spi(ci, 0, addr, val);
+				break;
+			default:
+				break;
+		}*/
+		pr_dbg("%s: 0x%x <-- 0x%x\n", parm[0], addr, retval);
+	} else if ((parm[0][0] == 'f')) {
+		pr_dbg("full test----\r\n");
+		aml_spi_ca_full_test(ci);
+	} else if ((parm[0][0] == 'c')) {
+		pr_dbg("cis test----\r\n");
+		aml_ci_full_test_by_spi(ci, 0, addr);
+	} else if ((parm[0][0] == 'p')) {
+		pr_dbg("cis dvb_ca_en50221_parse_attributes----\r\n");
+		dvb_ca_en50221_parse_attributes();
+	}
+
+	kfree(buf_orig);
+	return size;
+}
+
+static struct class_attribute aml_spi_class_attrs[] = {
+	__ATTR(reset,  S_IRUGO | S_IWUSR,
+		aml_spi_ci_reset_help, aml_spi_ci_reset),
+	__ATTR(pwr,  S_IRUGO | S_IWUSR,
+		aml_spi_ci_pwr_help, aml_spi_ci_pwr),
+	__ATTR(irq,  S_IRUGO | S_IWUSR,
+		aml_spi_ci_irq_show, NULL),
+	__ATTR(status,  S_IRUGO | S_IWUSR,
+		aml_spi_ci_state_show, NULL),
+	__ATTR(iotest,  S_IRUGO | S_IWUSR,
+		aml_spi_io_test_help, aml_spi_io_test),
+	__ATTR_NULL
+};
+
+static struct class aml_spi_class = {
+	.name = "aml_dvb_spi_test",
+	.class_attrs = aml_spi_class_attrs,
+};
+
+static int  aml_spi_mod_init(void)
+{
+	int ret;
+	pr_dbg("Amlogic DVB SPI Init\n");
+	ret = class_register(&aml_spi_class);
+	return 0;
+}
+
+static void  aml_spi_mod_exit(void)
+{
+	pr_dbg("Amlogic DVB SPI Exit\n");
+	class_unregister(&aml_spi_class);
+}
+
+module_init(aml_spi_mod_init);
+module_exit(aml_spi_mod_exit);
+
+MODULE_LICENSE("GPL");
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/aml_spi.h b/drivers/stream_input/parser/dvb_ci/aml_spi.h
new file mode 100644
index 0000000..1b04caf
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/aml_spi.h
@@ -0,0 +1,100 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef __AML_SPI_H_
+#define __AML_SPI_H_
+
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/gpio/consumer.h>
+#include "aml_pcmcia.h"
+#include "aml_ci.h"
+#include "drivers/media/dvb-core/dvb_ca_en50221.h"
+
+/*
+aml spi dev
+*/
+struct aml_spi {
+		spinlock_t spi_lock;
+
+		/* add SPI DEV */
+		struct spi_board_info *spi_bdinfo;
+		struct spi_device *spi;
+		struct platform_device *pdev;
+		struct device *dev;
+
+		/* spi otherconfig */
+		int cs_hold_delay;
+		int cs_clk_delay;
+		int write_check;
+
+		/* add gpio pin */
+		struct gpio_desc *reset_pin;
+		int reset_pin_value;
+		struct gpio_desc *cd_pin1;
+		int cd_pin1_value;
+		struct gpio_desc *cd_pin2;
+		int cd_pin2_value;
+		struct gpio_desc *pwr_pin;
+		int pwr_pin_value;
+
+		/* cam and mcu irq */
+		struct gpio_desc *irq_cam_pin;
+		int irq_cam_pin_value;
+		int irq;
+		struct aml_pcmcia pc;
+		void *priv;
+};
+enum aml_gpio_level_e {
+		AML_GPIO_LOW = 0,
+		AML_GPIO_HIGH
+};
+
+/* used to mcu */
+#define DATASTART 0xef
+#define DATAEND   0xfe
+enum AM_CI_CMD {
+		AM_CI_CMD_IOR = 0,
+		AM_CI_CMD_IOW,
+		AM_CI_CMD_MEMR,
+		AM_CI_CMD_MEMW,
+		AM_CI_CMD_FULLTEST,
+		AM_CI_CMD_CISTEST
+};
+enum AM_SPI_RECIVERSTEP {
+		AM_SPI_STEP_INIT = 0,
+		AM_SPI_STEP_START1,
+		AM_SPI_STEP_START2,
+		AM_SPI_STEP_CMD,
+		AM_SPI_STEP_DATA,
+		AM_SPI_STEP_ADDR1,
+		AM_SPI_STEP_ADDR2,
+		AM_SPI_STEP_END1,
+		AM_SPI_STEP_END2
+};
+extern int dirspi_xfer(struct spi_device *spi, u8 *tx_buf, u8 *rx_buf,
+		       int len);
+extern int dirspi_write(struct spi_device *spi, u8 *buf, int len);
+extern int dirspi_read(struct spi_device *spi, u8 *buf, int len);
+extern void dirspi_start(struct spi_device *spi);
+extern void dirspi_stop(struct spi_device *spi);
+extern void dvb_ca_en50221_camready_irq(struct dvb_ca_en50221 *pubca, int slot);
+extern int aml_spi_init(struct platform_device *pdev, struct aml_ci *ci_dev);
+extern int aml_spi_exit(struct aml_ci *ci_dev);
+
+#endif				/* __AML_SPI_H_ */
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax.c b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax.c
new file mode 100644
index 0000000..d6565a0
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax.c
@@ -0,0 +1,279 @@
+
+/***************************************************************************
+ * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
+ *
+ * This source code is subject to the terms and conditions defined in the
+ * file 'LICENSE' which is part of this source code package.
+ *
+ * Description:
+ *
+***************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/kthread.h>
+#include <linux/of.h>
+#include "../aml_ci.h"
+#include "aml_cimax.h"
+#include "aml_cimax_spi.h"
+#include "aml_cimax_usb.h"
+
+#define MODUDLE_NAME       "aml_cimax"
+
+MODULE_PARM_DESC(cimax_debug, "enable verbose debug messages");
+static int aml_cimax_debug = 1;
+module_param_named(cimax_debug, aml_cimax_debug, int, 0644);
+
+//static struct switch_dev slot_state = {
+//	.name = "ci_slot",
+//};
+
+#define pr_dbg(fmt...)\
+	do {\
+		if (aml_cimax_debug)\
+			pr_info("AML_CIMAX: " fmt);\
+	} while (0)
+#define pr_error(fmt...) pr_err("AML_CIMAX: " fmt)
+
+static int aml_cimax_slot_reset(struct aml_ci *ci, int slot)
+{
+	int ret = 0;
+	struct aml_cimax *cimax = ci->data;
+	pr_dbg("cimax: slot(%d) reset\n", slot);
+	if (cimax->ops.slot_reset)
+		ret = cimax->ops.slot_reset(cimax, slot);
+	return ret;
+}
+
+static int aml_cimax_slot_shutdown(struct aml_ci *ci, int slot)
+{
+	pr_dbg("slot(%d) shutdown\n", slot);
+	return 0;
+}
+
+static int aml_cimax_slot_ts_enable(struct aml_ci *ci, int slot)
+{
+	pr_dbg("slot(%d) ts control\n", slot);
+	return 0;
+}
+
+static int aml_cimax_slot_status(struct aml_ci *ci, int slot, int open)
+{
+	int ret = 0;
+	struct aml_cimax *cimax = ci->data;
+
+	/*pr_dbg("cimax: slot(%d) poll\n", slot);*/
+	if (cimax->ops.slot_status)
+		ret = cimax->ops.slot_status(cimax, slot);
+	return ret;
+}
+
+#define DEF_FUNC_WRAPPER3(_pre, _fn, _S, _P1, _P2, _P3) \
+static int _pre##_fn(_S s, _P1 p1, _P2 p2, _P3 p3)\
+{\
+	struct aml_cimax *cimax = s->data;\
+	/*pr_dbg("%s\n", #_fn);*/\
+	if (cimax->ops._fn)\
+		return cimax->ops._fn(cimax, p1, p2, p3);\
+	return 0;\
+}
+
+/*DEF_FUNC_WRAPPER3(aml_cimax_, read_reg, struct aml_ci*, int, u8*, int)*/
+/*DEF_FUNC_WRAPPER3(aml_cimax_, write_reg, struct aml_ci*, int, u8*, int)*/
+DEF_FUNC_WRAPPER3(aml_cimax_, read_cis, struct aml_ci*, int, u8*, int)
+DEF_FUNC_WRAPPER3(aml_cimax_, read_lpdu, struct aml_ci*, int, u8*, int)
+DEF_FUNC_WRAPPER3(aml_cimax_, write_lpdu, struct aml_ci*, int, u8*, int)
+
+static int aml_cimax_write_cor(struct aml_ci *ci, int slot, int addr, u8 *buf)
+{
+	struct aml_cimax *cimax = ci->data;
+	pr_dbg("write_cor\n");
+	if (cimax->ops.write_cor)
+		return cimax->ops.write_cor(cimax, slot, addr, buf);
+	return 0;
+}
+
+static int aml_cimax_negotiate(struct aml_ci *ci, int slot, int size)
+{
+	struct aml_cimax *cimax = ci->data;
+	pr_dbg("negotiate\n");
+	if (cimax->ops.negotiate)
+		return cimax->ops.negotiate(cimax, slot, size);
+	return 0;
+}
+
+static int aml_cimax_read_cam_status(struct aml_ci *ci, int slot)
+{
+	struct aml_cimax *cimax = ci->data;
+	if (cimax->ops.read_cam_status)
+		return cimax->ops.read_cam_status(cimax, slot);
+	return 0;
+}
+
+static int aml_cimax_cam_reset(struct aml_ci *ci, int slot)
+{
+	struct aml_cimax *cimax = ci->data;
+	if (cimax->ops.cam_reset)
+		return cimax->ops.cam_reset(cimax, slot);
+	return 0;
+}
+
+static int aml_cimax_get_capbility(struct aml_ci *ci, int slot)
+{
+	return 0;
+}
+
+int aml_cimax_camchanged(struct aml_cimax *cimax, int slot, int plugin)
+{
+	struct aml_ci *ci = cimax->ci;
+	if (plugin) {
+		dvb_ca_en50221_cimax_camchange_irq(&ci->en50221_cimax,
+			slot, DVB_CA_EN50221_CAMCHANGE_INSERTED);
+	} else {
+		dvb_ca_en50221_cimax_camchange_irq(&ci->en50221_cimax,
+			slot, DVB_CA_EN50221_CAMCHANGE_REMOVED);
+	}
+	return 0;
+}
+
+static int aml_cimax_start(struct aml_cimax *cimax)
+{
+	int ret = 0;
+	if (cimax->ops.start)
+		ret = cimax->ops.start(cimax);
+	return ret;
+}
+
+static int aml_cimax_stop(struct aml_cimax *cimax)
+{
+	int ret = 0;
+	if (cimax->ops.stop)
+		ret = cimax->ops.stop(cimax);
+	return ret;
+}
+
+static int aml_cimax_get_config_from_dts(struct aml_cimax *cimax)
+{
+	struct device_node *child = NULL;
+	struct platform_device *pdev = cimax->pdev;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int val;
+	int ret = 0;
+	pr_dbg("get cimax dts\n");
+
+	child = of_get_child_by_name(np, "cimax");
+	if (child == NULL) {
+		pr_error("failed to get cimax\n");
+		return -1;
+	}
+	ret = of_property_read_u32(child, "io_type", &val);
+	if (ret)
+		cimax->io_type = IO_TYPE_SPI;
+	else
+		cimax->io_type = val;
+
+	return 0;
+}
+
+int aml_cimax_init(struct platform_device *pdev, struct aml_ci *ci)
+{
+	struct aml_cimax *cimax = NULL;
+	int ret = 0;
+
+	cimax = kzalloc(sizeof(struct aml_cimax), GFP_KERNEL);
+	if (!cimax) {
+		pr_error("Out of memory!, exiting ..\n");
+		return -ENOMEM;
+	}
+	cimax->pdev = pdev;
+	cimax->ci = ci;
+
+	aml_cimax_get_config_from_dts(cimax);
+
+	if (cimax->io_type == IO_TYPE_SPI) {
+		//ret = aml_cimax_spi_init(pdev, cimax);
+	}
+	else {
+		ret = aml_cimax_usb_init(pdev, cimax);
+	}
+
+	if (ret != 0) {
+		kfree(cimax);
+		cimax = NULL;
+		return -EIO;
+	}
+
+	ret = aml_cimax_start(cimax);
+	if (ret != 0)
+		return ret;
+
+	ci->ci_read_cis = aml_cimax_read_cis;
+	ci->ci_write_cor = aml_cimax_write_cor;
+	ci->ci_negotiate = aml_cimax_negotiate;
+	ci->ci_read_lpdu = aml_cimax_read_lpdu;
+	ci->ci_write_lpdu = aml_cimax_write_lpdu;
+	ci->ci_read_cam_status = aml_cimax_read_cam_status;
+	ci->ci_cam_reset = aml_cimax_cam_reset;
+	ci->ci_get_capbility = aml_cimax_get_capbility;
+	ci->ci_slot_reset = aml_cimax_slot_reset;
+	ci->ci_slot_shutdown = aml_cimax_slot_shutdown;
+	ci->ci_slot_ts_enable = aml_cimax_slot_ts_enable;
+	ci->ci_poll_slot_status = aml_cimax_slot_status;
+
+	ci->data = cimax;
+	return 0;
+}
+EXPORT_SYMBOL(aml_cimax_init);
+
+int aml_cimax_exit(struct aml_ci *ci)
+{
+	struct aml_cimax *cimax = ci->data;
+
+	aml_cimax_stop(cimax);
+
+	if (cimax->io_type == IO_TYPE_SPI) {
+        //aml_cimax_spi_exit(cimax);
+	}
+	else {
+		aml_cimax_usb_exit(cimax);
+	}
+	kfree(cimax);
+	ci->data = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(aml_cimax_exit);
+
+int aml_cimax_slot_state_changed(struct aml_cimax *cimax, int slot, int state)
+{
+	//if (slot == 0)
+	//	switch_set_state(&slot_state, state);
+	return 0;
+}
+EXPORT_SYMBOL(aml_cimax_slot_state_changed);
+#if 0
+static int __init aml_cimax_mod_init(void)
+{
+	pr_dbg("Amlogic DVB CIMAX Init\n");
+	//switch_dev_register(&slot_state);
+	//switch_set_state(&slot_state, 0);
+	return 0;
+}
+
+static void __exit aml_cimax_mod_exit(void)
+{
+	pr_dbg("Amlogic DVB CIMAX Exit\n");
+	//switch_dev_unregister(&slot_state);
+}
+
+module_init(aml_cimax_mod_init);
+module_exit(aml_cimax_mod_exit);
+
+MODULE_LICENSE("GPL");
+#endif
+
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax.h b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax.h
new file mode 100644
index 0000000..17c62fa
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax.h
@@ -0,0 +1,61 @@
+/***************************************************************************
+ * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
+ *
+ * This source code is subject to the terms and conditions defined in the
+ * file 'LICENSE' which is part of this source code package.
+ *
+ * Description:
+ *
+***************************************************************************/
+
+#ifndef __AML_CIMAX_H_
+#define __AML_CIMAX_H_
+
+#include "../aml_ci.h"
+#include "dvb_ca_en50221_cimax.h"
+
+struct aml_cimax;
+
+struct aml_cimax_ops {
+	int (*read_cis)(struct aml_cimax *cimax, int slot, u8 *buf, int size);
+	int (*write_cor)(struct aml_cimax *cimax,
+			int slot, int address, u8 *buf);
+	int (*negotiate)(struct aml_cimax *cimax, int slot, int size);
+	int (*read_lpdu)(struct aml_cimax *cimax, int slot, u8 *buf, int size);
+	int (*write_lpdu)(struct aml_cimax *cimax, int slot, u8 *buf, int size);
+	int (*read_cam_status)(struct aml_cimax *cimax, int slot);
+	int (*cam_reset)(struct aml_cimax *cimax, int slot);
+	int (*get_capblility)(struct aml_cimax *cimax, int slot);
+
+	int (*slot_reset)(struct aml_cimax *cimax, int slot);
+	int (*slot_shutdown)(struct aml_cimax *cimax, int slot);
+	int (*slot_ts_enable)(struct aml_cimax *cimax, int slot);
+	int (*slot_status)(struct aml_cimax *cimax, int slot);
+
+	/*load fw etc.*/
+	int (*start)(struct aml_cimax *cimax);
+	int (*stop)(struct aml_cimax *cimax);
+
+	/*cimax reg*/
+	int (*read_reg)(struct aml_cimax *cimax, int addr, u8 *buf, int size);
+	int (*write_reg)(struct aml_cimax *cimax, int addr, u8 *buf, int size);
+};
+
+struct aml_cimax {
+	struct platform_device *pdev;
+	struct device *dev;
+	struct aml_ci *ci;
+
+	int io_type;
+#define IO_TYPE_SPI 0
+#define IO_TYPE_USB 1
+	struct aml_cimax_ops ops;
+	void *priv;
+};
+
+int aml_cimax_init(struct platform_device *pdev, struct aml_ci *ci_dev);
+int aml_cimax_exit(struct aml_ci *ci_dev);
+
+int aml_cimax_camchanged(struct aml_cimax *cimax, int slot, int plugin);
+int aml_cimax_slot_state_changed(struct aml_cimax *cimax, int slot, int state);
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_spi.c b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_spi.c
new file mode 100644
index 0000000..a4aadda
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_spi.c
@@ -0,0 +1,2139 @@
+/***************************************************************************
+ * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
+ *
+ * This source code is subject to the terms and conditions defined in the
+ * file 'LICENSE' which is part of this source code package.
+ *
+ * Description:
+ *
+***************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/amlogic/sd.h>
+#include <linux/of_irq.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+
+#include "aml_cimax.h"
+
+#define MOD_NAME       "aml_cimax_spi"
+
+#define pr_dbg(fmt...)\
+	do {\
+		if (cimax_spi_debug)\
+			pr_info("cimax_spi: "fmt);\
+	} while (0)
+#define pr_error(fmt...) pr_err("AML_CIMAX_SPI: " fmt)
+
+#define BUFFIN_CFG                        0x0000
+#define BUFFIN_ADDR_LSB                   0x0001
+#define BUFFIN_ADDR_MSB                   0x0002
+#define BUFFIN_DATA                       0x0003
+#define BUFFOUT_CFG                       0x0004
+#define BUFFOUT_ADDR_LSB                  0x0005
+#define BUFFOUT_ADDR_MSB                  0x0006
+#define BUFFOUT_DATA                      0x0007
+#define BOOT_Key                          0x0008
+#define BOOT_Status                       0x0009
+#define BOOT_Test                         0x000A
+#define usb2_0_irq_mask                   0x0010
+#define usb2_0_status                     0x0011
+#define usb2_0_rx                         0x0012
+#define usb2_0_tx                         0x0013
+#define SPI_Slave_Ctrl                    0x0018
+#define SPI_Slave_Status                  0x0019
+#define SPI_Slave_Rx                      0x001A
+#define SPI_Slave_Tx                      0x001B
+#define SPI_Slave_Mask                    0x001C
+#define UCSG_Ctrl                         0x0020
+#define UCSG_Status                       0x0021
+#define UCSG_RxData                       0x0022
+#define UCSG_TxData                       0x0023
+#define PCtrl_Ctrl                        0x0028
+#define PCtrl_Status                      0x0029
+#define PCtrl_NbByte_LSB                  0x002A
+#define PCtrl_NbByte_MSB                  0x002B
+#define SPI_Master_Ctl                    0x0030
+#define SPI_Master_NCS                    0x0031
+#define SPI_Master_Status                 0x0032
+#define SPI_Master_TxBuf                  0x0033
+#define SPI_Master_RxBuf                  0x0034
+#define BISTRAM_Ctl                       0x0038
+#define BISTRAM_Bank                      0x0039
+#define BISTRAM_Pat                       0x003A
+#define BISTRAM_SM                        0x003B
+#define BISTRAM_AddrLSB                   0x003C
+#define BISTROM_Config                    0x0040
+#define BISTROM_SignatureLSB              0x0041
+#define BISTROM_SignatureMSB              0x0042
+#define BISTROM_StartAddrLSB              0x0043
+#define BISTROM_StartAddrMSB              0x0043
+#define BISTROM_StopAddrLSB               0x0043
+#define BISTROM_StopAddrMSB               0x0043
+#define CkMan_Config                      0x0048
+#define CkMan_Select                      0x0049
+#define CkMan_Test                        0x004A
+#define Revision_Number                   0x004B
+#define ResMan_Config                     0x0050
+#define ResMan_Status                     0x0051
+#define ResMan_WD                         0x0052
+#define ResMan_WD_MSB                     0x0053
+#define CPU_Test                          0x0060
+#define IrqMan_Config0                    0x0068
+#define IrqMan_Config1                    0x0069
+#define IrqMan_Irq0                       0x006A
+#define IrqMan_NMI                        0x006B
+#define IrqMan_SleepKey                   0x006C
+#define Tim_Config                        0x0070
+#define Tim_Value_LSB                     0x0071
+#define Tim_Value_MSB                     0x0072
+#define Tim_Comp_LSB                      0x0073
+#define Tim_Comp_MSB                      0x0074
+#define TI_Config                         0x0076
+#define TI_Data                           0x0077
+#define TI_Reg0                           0x0078
+#define TI_Reg1                           0x0079
+#define TI_Reg2                           0x007A
+#define TI_Reg3                           0x007B
+#define TI_Reg4                           0x007C
+#define TI_ROM1                           0x007D
+#define TI_ROM2                           0x007E
+#define TI_ROM3                           0x007F
+#define DVBCI_START_ADDR                  0x0100
+#define DVBCI_END_ADDR                    0x017F
+#define DATA                              0x0180
+/*#define CTRL                            0x0181*/
+#define QB_HOST                           0x0182
+#define LEN_HOST_LSB                      0x0183
+#define LEN_HOST_MSB                      0x0184
+#define FIFO_TX_TH_LSB                    0x0185
+#define FIFO_TX_TH_MSB                    0x0186
+#define FIFO_TX_D_NB_LSB                  0x0187
+#define FIFO_TX_D_NB_MSB                  0x0188
+#define QB_MOD_CURR                       0x0189
+#define LEN_MOD_CURR_LSB                  0x018A
+#define LEN_MOD_CURR_MSB                  0x018B
+#define QB_MOD                            0x018C
+#define LEN_MOD_LSB                       0x018D
+#define LEN_MOD_MSB                       0x018E
+#define FIFO_RX_TH_LSB                    0x018F
+#define FIFO_RX_TH_MSB                    0x0190
+#define FIFO_RX_D_NB_LSB                  0x0191
+#define FIFO_RX_D_NB_MSB                  0x0192
+#define IT_STATUS_0                       0x0193
+#define IT_STATUS_1                       0x0194
+#define IT_MASK_0                         0x0195
+#define IT_MASK_1                         0x0196
+#define IT_HOST_PIN_CFG                   0x0200
+#define CFG_0                             0x0201
+#define CFG_1                             0x0202
+#define CFG_2                             0x0203
+#define IT_HOST                           0x0204
+#define MOD_IT_STATUS                     0x0205
+#define MOD_IT_MASK                       0x0206
+#define MOD_CTRL_A                        0x0207
+#define MOD_CTRL_B                        0x0208
+#define DEST_SEL                          0x0209
+#define CAM_MSB_ADD                       0x020A
+#define GPIO0_DIR                         0x020B
+#define GPIO0_DATA_IN                     0x020C
+#define GPIO0_DATA_OUT                    0x020D
+#define GPIO0_STATUS                      0x020E
+#define GPIO0_IT_MASK                     0x020F
+#define GPIO0_DFT                         0x0210
+#define GPIO0_MASK_DATA                   0x0211
+#define GPIO1_DIR                         0x0212
+#define GPIO1_DATA_IN                     0x0213
+#define GPIO1_DATA_OUT                    0x0214
+#define GPIO1_STATUS                      0x0215
+#define GPIO1_IT_MASK                     0x0216
+#define MEM_ACC_TIME_A                    0x0217
+#define MEM_ACC_TIME_B                    0x0218
+#define IO_ACC_TIME_A                     0x0219
+#define IO_ACC_TIME_B                     0x021A
+#define EXT_CH_ACC_TIME_A                 0x021B
+#define EXT_CH_ACC_TIME_B                 0x021C
+#define PAR_IF_0                          0x021D
+#define PAR_IF_1                          0x021E
+#define PAR_IF_CTRL                       0x021F
+#define PCK_LENGTH                        0x0220
+#define USB2TS_CTRL                       0x0221
+#define USB2TS0_RDL                       0x0222
+#define USB2TS1_RDL                       0x0223
+#define TS2USB_CTRL                       0x0224
+#define TSOUT_PAR_CTRL                    0x0225
+#define TSOUT_PAR_CLK_SEL                 0x0226
+#define S2P_CH0_CTRL                      0x0227
+#define S2P_CH1_CTRL                      0x0228
+#define P2S_CH0_CTRL                      0x0229
+#define P2S_CH1_CTRL                      0x022A
+#define TS_IT_STATUS                      0x022B
+#define TS_IT_MASK                        0x022C
+#define IN_SEL                            0x022D
+#define OUT_SEL                           0x022E
+#define ROUTER_CAM_CH                     0x022F
+#define ROUTER_CAM_MOD                    0x0230
+#define FIFO_CTRL                         0x0231
+#define FIFO1_2_STATUS                    0x0232
+#define FIFO3_4_STATUS                    0x0233
+#define GAP_REMOVER_CH0_CTRL              0x0234
+#define GAP_REMOVER_CH1_CTRL              0x0235
+#define SYNC_RTV_CTRL                     0x0236
+#define SYNC_RTV_CH0_SYNC_NB              0x0237
+#define SYNC_RTV_CH0_PATTERN              0x0238
+#define SYNC_RTV_CH1_SYNC_NB              0x0239
+#define SYNC_RTV_CH1_PATTERN              0x023A
+#define SYNC_RTV_OFFSET_PATT              0x023B
+#define CTRL_FILTER                       0x023D
+#define PID_EN_FILTER_CH0                 0x023E
+#define PID_EN_FILTER_CH1                 0x023F
+#define PID_LSB_FILTER_CH0_0              0x0240
+#define PID_MSB_FILTER_CH0_0              0x0241
+#define PID_LSB_FILTER_CH0_1              0x0242
+#define PID_MSB_FILTER_CH0_1              0x0243
+#define PID_LSB_FILTER_CH0_2              0x0244
+#define PID_MSB_FILTER_CH0_2              0x0245
+#define PID_LSB_FILTER_CH0_3              0x0246
+#define PID_MSB_FILTER_CH0_3              0x0247
+#define PID_LSB_FILTER_CH0_4              0x0248
+#define PID_MSB_FILTER_CH0_4              0x0249
+#define PID_LSB_FILTER_CH0_5              0x024A
+#define PID_MSB_FILTER_CH0_5              0x024B
+#define PID_LSB_FILTER_CH0_6              0x024C
+#define PID_MSB_FILTER_CH0_6              0x024D
+#define PID_LSB_FILTER_CH0_7              0x024E
+#define PID_MSB_FILTER_CH0_7              0x024F
+#define PID_LSB_FILTER_CH1_0              0x0260
+#define PID_MSB_FILTER_CH1_0              0x0261
+#define PID_LSB_FILTER_CH1_1              0x0262
+#define PID_MSB_FILTER_CH1_1              0x0263
+#define PID_LSB_FILTER_CH1_2              0x0264
+#define PID_MSB_FILTER_CH1_2              0x0265
+#define PID_LSB_FILTER_CH1_3              0x0266
+#define PID_MSB_FILTER_CH1_3              0x0267
+#define PID_LSB_FILTER_CH1_4              0x0268
+#define PID_MSB_FILTER_CH1_4              0x0269
+#define PID_LSB_FILTER_CH1_5              0x026A
+#define PID_MSB_FILTER_CH1_5              0x026B
+#define PID_LSB_FILTER_CH1_6              0x026C
+#define PID_MSB_FILTER_CH1_6              0x026D
+#define PID_LSB_FILTER_CH1_7              0x026E
+#define PID_MSB_FILTER_CH1_7              0x026F
+#define PID_OLD_LSB_REMAPPER_0            0x0280
+#define PID_OLD_MSB_REMAPPER_0            0x0281
+#define PID_OLD_LSB_REMAPPER_1            0x0282
+#define PID_OLD_MSB_REMAPPER_1            0x0283
+#define PID_OLD_LSB_REMAPPER_2            0x0284
+#define PID_OLD_MSB_REMAPPER_2            0x0285
+#define PID_OLD_LSB_REMAPPER_3            0x0286
+#define PID_OLD_MSB_REMAPPER_3            0x0287
+#define PID_OLD_LSB_REMAPPER_4            0x0288
+#define PID_OLD_MSB_REMAPPER_4            0x0289
+#define PID_OLD_LSB_REMAPPER_5            0x028A
+#define PID_OLD_MSB_REMAPPER_5            0x028B
+#define PID_OLD_LSB_REMAPPER_6            0x028C
+#define PID_OLD_MSB_REMAPPER_6            0x028D
+#define PID_OLD_LSB_REMAPPER_7            0x028E
+#define PID_OLD_MSB_REMAPPER_7            0x028F
+#define PID_NEW_LSB_REMAPPER_0            0x02A0
+#define PID_NEW_MSB_REMAPPER_0            0x02A1
+#define PID_NEW_LSB_REMAPPER_1            0x02A2
+#define PID_NEW_MSB_REMAPPER_1            0x02A3
+#define PID_NEW_LSB_REMAPPER_2            0x02A4
+#define PID_NEW_MSB_REMAPPER_2            0x02A5
+#define PID_NEW_LSB_REMAPPER_3            0x02A6
+#define PID_NEW_MSB_REMAPPER_3            0x02A7
+#define PID_NEW_LSB_REMAPPER_4            0x02A8
+#define PID_NEW_MSB_REMAPPER_4            0x02A9
+#define PID_NEW_LSB_REMAPPER_5            0x02AA
+#define PID_NEW_MSB_REMAPPER_5            0x02AB
+#define PID_NEW_LSB_REMAPPER_6            0x02AC
+#define PID_NEW_MSB_REMAPPER_6            0x02AD
+#define PID_NEW_LSB_REMAPPER_7            0x02AE
+#define PID_NEW_MSB_REMAPPER_7            0x02AF
+#define MERGER_DIV_MICLK                  0x02C0
+#define PID_AND_SYNC_REMAPPER_CTRL        0x02C1
+#define PID_EN_REMAPPER                   0x02C2
+#define SYNC_SYMBOL                       0x02C3
+#define PID_AND_SYNC_REMAPPER_INV_CTRL    0x02C4
+#define BITRATE_CH0_LSB                   0x02C5
+#define BITRATE_CH0_MSB                   0x02C6
+#define BITRATE_CH1_LSB                   0x02C7
+#define BITRATE_CH1_MSB                   0x02C8
+#define STATUS_CLK_SWITCH_0               0x02C9
+#define STATUS_CLK_SWITCH_1               0x02CA
+#define RESET_CLK_SWITCH_0                0x02CB
+#define RESET_CLK_SWITCH_1                0x02CC
+#define PAD_DRVSTR_CTRL                   0x02CD
+#define PAD_PUPD_CTRL                     0x02CE
+#define PRE_HEADER_ADDER_CH0_0            0x02D0
+#define PRE_HEADER_ADDER_CH0_1            0x02D1
+#define PRE_HEADER_ADDER_CH0_2            0x02D2
+#define PRE_HEADER_ADDER_CH0_3            0x02D3
+#define PRE_HEADER_ADDER_CH0_4            0x02D4
+#define PRE_HEADER_ADDER_CH0_5            0x02D5
+#define PRE_HEADER_ADDER_CH0_6            0x02D6
+#define PRE_HEADER_ADDER_CH0_7            0x02D7
+#define PRE_HEADER_ADDER_CH0_8            0x02D8
+#define PRE_HEADER_ADDER_CH0_9            0x02D9
+#define PRE_HEADER_ADDER_CH0_10           0x02DA
+#define PRE_HEADER_ADDER_CH0_11           0x02DB
+#define PRE_HEADER_ADDER_CH1_0            0x02E0
+#define PRE_HEADER_ADDER_CH1_1            0x02E1
+#define PRE_HEADER_ADDER_CH1_2            0x02E2
+#define PRE_HEADER_ADDER_CH1_3            0x02E3
+#define PRE_HEADER_ADDER_CH1_4            0x02E4
+#define PRE_HEADER_ADDER_CH1_5            0x02E5
+#define PRE_HEADER_ADDER_CH1_6            0x02E6
+#define PRE_HEADER_ADDER_CH1_7            0x02E7
+#define PRE_HEADER_ADDER_CH1_8            0x02E8
+#define PRE_HEADER_ADDER_CH1_9            0x02E9
+#define PRE_HEADER_ADDER_CH1_10           0x02EA
+#define PRE_HEADER_ADDER_CH1_11           0x02EB
+#define PRE_HEADER_ADDER_CTRL             0x02EC
+#define PRE_HEADER_ADDER_LEN              0x02ED
+#define PRE_HEADER_REMOVER_CTRL           0x02EE
+#define FSM_DVB                           0x02F0
+#define TS2USB_FSM_DEBUG                  0x02F2
+#define TSOUT_PAR_FSM_DEBUG               0x02F3
+#define GAP_REMOVER_FSM_DEBUG             0x02F4
+#define PID_AND_SYNC_REMAPPER_FSM_DEBUG   0x02F5
+#define PRE_HEADER_ADDER_FSM_DEBUG        0x02F6
+#define SYNC_RTV_FSM_DEBUG                0x02F7
+#define CHECK_PHY_CLK                     0x0E00
+#define USB_CTRL1                         0x0E01
+#define USB_ISO2_out                      0x0800
+#define USB_ISO1_out                      0x1000
+#define USB_Interrupt_out                 0x1E00
+#define USB_Bulk_in                       0x1F00
+#define CC2_Buffer_out                    0x2000
+#define USB_EP0                           0x30C0
+#define CC2_Buffer_in                     0x4000
+#define USB_ISO2_in                       0x5800
+#define USB_ISO1_in                       0x6000
+#define nmb_vector_address_lsb            0xFFFA
+#define nmb_vector_address_msb            0xFFFB
+#define reset_vector_address_lsb          0xFFFC
+#define reset_vector_address_msb          0xFFFD
+#define irb_vector_address_lsb            0xFFFE
+#define irb_vector_address_msb            0xFFFF
+
+
+#define CIMAX_REG_HDR_SIZE 4
+#define CIMAX_REG_PLD_SIZE 255
+#define CIMAX_CAM_HDR_SIZE 4
+#define CIMAX_CAM_PLD_SIZE 65535
+
+#define DEF_LOCK(_l_) struct mutex _l_
+
+struct cimax_spi {
+	struct platform_device *pdev;
+	struct spi_device *dev;
+
+	struct aml_cimax *cimax;
+
+	u8 buf[CIMAX_REG_HDR_SIZE + CIMAX_CAM_HDR_SIZE + CIMAX_CAM_PLD_SIZE];
+
+	int cam_inserted[2];
+	int cam_data_ready[2];
+
+	int poll_mode;
+#define STOP_MODE 0
+#define POLL_MODE 1
+#define INT_MODE  2
+
+	int irq;
+	int irq_io;
+	int rst_io;
+
+	struct workqueue_struct *workq;
+	struct delayed_work work;
+	int work_cnt;
+
+	DEF_LOCK(lock);
+#define lock_init(_spi) mutex_init(&(_spi)->lock)
+#define lock_lock(_spi) do {\
+	int err = mutex_lock_interruptible(&(_spi)->lock);\
+	if (err)\
+		return err;\
+} while (0)
+#define lock_unlock(_spi) mutex_unlock(&(_spi)->lock)
+
+	u8 *cis;
+#define CIS_MAX 512
+};
+
+static struct cimax_spi *g_spi;
+
+MODULE_PARM_DESC(debug, "enable verbose debug messages");
+static int cimax_spi_debug = 1;
+module_param_named(debug, cimax_spi_debug, int, 0644);
+
+MODULE_PARM_DESC(poll_interval, "interval for spi poll");
+static int spi_poll_interval = 100;
+module_param_named(poll_interval, spi_poll_interval, int, 0644);
+
+MODULE_PARM_DESC(poll_mode, "set cimax poll mode, need reset");
+static int cimax_poll_mode = 1;
+module_param_named(poll_mode, cimax_poll_mode, int, 0644);
+
+MODULE_PARM_DESC(cam_irq_mode, "set cam irq mode, need reset");
+static int cam_irq_mode;
+module_param_named(cam_irq_mode, cam_irq_mode, int, 0644);
+
+#define CIMAX_REG_READ     0xff
+#define CIMAX_REG_READ_OK  0x4c
+#define CIMAX_REG_WRITE    0x7f
+#define CIMAX_REG_WRITE_OK 0x4d
+#define CIMAX_REG_INIT     0x00
+#define CIMAX_REG_INIT_OK  0x4b
+#define CIMAX_REG_CMD_ERROR 0x51
+
+#define CIMAX_CAM_RESET    0x01
+#define CIMAX_CAM_RESET_OK 0x40
+#define CIMAX_CAM_CIS      0x02
+#define CIMAX_CAM_CIS_OK   0x41
+#define CIMAX_CAM_COR      0x03
+#define CIMAX_CAM_COR_OK   0x42
+#define CIMAX_CAM_NEG      0x04
+#define CIMAX_CAM_NEG_OK   0x43
+#define CIMAX_CAM_WLPDU    0x05
+#define CIMAX_CAM_WLPDU_OK 0x44
+#define CIMAX_CAM_RLPDU    0x06
+#define CIMAX_CAM_RLPDU_OK 0x46
+#define CIMAX_CAM_EVT         0x0d
+#define CIMAX_CAM_DET_OK      0x45
+#define CIMAX_CAM_NOCAM       0x49
+#define CIMAX_CAM_ERROR       0x4a
+#define CIMAX_CAM_NOEVT       0x55
+#define CIMAX_CAM_DATA_READY  0x4e
+#define CIMAX_CAM_WBUSY       0x54
+#define CIMAX_CAM_PENDING     0x56
+#define CIMAX_CAM_REGSTAT     0x0e
+#define CIMAX_CAM_REGSTAT_OK  0x57
+
+
+#define CIMAX_CAM_PKT_CNT_VAL 1
+
+#define CIMAX_SLOT_A 0
+#define CIMAX_SLOT_B 1
+
+#define CIMAX_CMD_RESP_MASK 0x7f
+
+#define cimax_to_spi(_c) ((struct cimax_spi *)((_c)->priv))
+#define dev_to_spi(_d) ((struct cimax_spi *)spi_get_drvdata(_d))
+
+#define byte_to_u16(_b1, _b2)   (((_b1)<<8) | (_b2))
+
+#define hdr_cmd_resp(_s)     ((_s)->buf[0] & CIMAX_CMD_RESP_MASK)
+
+#define reg_hdr(_s)          ((_s)->buf)
+#define reg_addr(_s)         byte_to_u16((_s)->buf[1], (_s)->buf[2])
+#define reg_hdr_dat_size(_s) ((_s)->buf[3])
+#define reg_dat(_s)          (&((_s)->buf[CIMAX_REG_HDR_SIZE]))
+
+#define cam_hdr(_s)          ((_s)->buf)
+#define cam_hdr_slot(_s)     (((_s)->buf[0] & 0x80) ? 1 : 0)
+#define cam_hdr_pkt_cnt(_s)  ((_s)->buf[1])
+#define cam_hdr_dat_size(_s) byte_to_u16((_s)->buf[2], (_s)->buf[3])
+#define cam_dat(_s)          (&((_s)->buf[CIMAX_CAM_HDR_SIZE]))
+
+#define REG_TIMEOUT 500
+#define CAM_TIMEOUT 5000
+
+#define USE_INT_PIO
+
+static int aml_cimax_spi_mod_init(void);
+static void aml_cimax_spi_mod_exit(void);
+
+static void dump(char *title, u8 *buf, int size)
+{
+	int i;
+	pr_info("%s\n", title);
+	for (i = 0; i < size; i++) {
+		if (!(i & 0xf))
+			pr_info("\n\t");
+		pr_info("%02x ", *(buf+i));
+	}
+	pr_info("\n");
+}
+
+static void perr(char *err, struct cimax_spi *spi)
+{
+	pr_error("error: %s\n", err);
+	dump("dump:", spi->buf, 16);
+}
+
+static inline unsigned long get_jiffies(void)
+{
+	return (unsigned long)(sched_clock()/10000000);
+}
+
+static inline void set_spi_cam_ready(struct cimax_spi *spi, int slot)
+{
+	if (spi->cam_inserted[slot] == 1) {
+		spi->cam_inserted[slot] = 2;
+		aml_cimax_slot_state_changed(spi->cimax,
+			slot, spi->cam_inserted[slot]);
+	}
+}
+
+
+static int cimax_spi_get_resp(struct cimax_spi *spi, int timeout)
+{
+	struct spi_device *dev = spi->dev;
+	int ret = 0;
+	unsigned long start = get_jiffies();
+#ifndef USE_INT_PIO
+	u8 t = 0;
+
+	while (!t && jiffies_to_msecs(get_jiffies() - start) < timeout) {
+		ret = spi_read(dev, &t, 1);
+		if (ret)
+			return ret;
+		usleep_range(1000, 2000);
+	}
+	if (!t) {
+		pr_error("resp timeout: %dms\n", timeout);
+		return -EIO;
+	}
+	cam_hdr(spi)[0] = t;
+	ret = spi_read(dev, cam_hdr(spi)+1, CIMAX_CAM_HDR_SIZE-1);
+	if (ret)
+		return ret;
+#else
+	do {
+		if (jiffies_to_msecs(get_jiffies() - start) >= timeout) {
+			pr_error("resp timeout: %dms\n", timeout);
+			return -EIO;
+		}
+		usleep_range(1000, 2000);
+	} while (gpio_get_value(spi->irq_io));
+
+	ret = spi_read(dev, cam_hdr(spi), CIMAX_CAM_HDR_SIZE);
+	if (ret)
+		return ret;
+#endif
+	/*pr_dbg("rp: %02x:%02x:%02x:%02x\n",
+		cam_hdr(spi)[0], cam_hdr(spi)[1],
+		cam_hdr(spi)[2], cam_hdr(spi)[3]);*/
+	switch (hdr_cmd_resp(spi)) {
+	case CIMAX_REG_READ_OK:
+	case CIMAX_REG_WRITE_OK:
+	case CIMAX_REG_INIT_OK:
+	case CIMAX_REG_CMD_ERROR: {
+		int len = reg_hdr_dat_size(spi);
+		if (len) {
+			ret = spi_read(dev, reg_dat(spi), len);
+			if (ret != 0)
+				return ret;
+		}
+		} break;
+	case CIMAX_CAM_RESET_OK:
+	case CIMAX_CAM_CIS_OK:
+	case CIMAX_CAM_COR_OK:
+	case CIMAX_CAM_NEG_OK:
+	case CIMAX_CAM_WLPDU_OK:
+	case CIMAX_CAM_RLPDU_OK:
+	case CIMAX_CAM_NOCAM:
+	case CIMAX_CAM_ERROR:
+	case CIMAX_CAM_WBUSY:
+	case CIMAX_CAM_DET_OK:
+	case CIMAX_CAM_DATA_READY:
+	case CIMAX_CAM_PENDING:
+	case CIMAX_CAM_REGSTAT_OK:
+	case CIMAX_CAM_NOEVT: {
+		int len = cam_hdr_dat_size(spi);
+		if (len) {
+			ret = spi_read(dev, cam_dat(spi), len);
+			if (ret != 0)
+				return ret;
+			/*if (len)
+				dump("dat:", cam_dat(spi), len);*/
+		}
+		}
+		break;
+	default:
+		pr_error("unknown resp:0x%02x\n", hdr_cmd_resp(spi));
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int init_reg_hdr(u8 *hdr, u8 tag, int addr, int size)
+{
+	hdr[0] = tag;
+	hdr[1] = (addr>>8) & 0xff;
+	hdr[2] = addr & 0xff;
+	hdr[3] = size;
+	return 0;
+}
+
+static int check_reg_hdr(u8 *hdr, u8 tag, int addr, int size)
+{
+	return hdr[0] != tag
+		|| hdr[1] != ((addr>>8) & 0xff)
+		|| hdr[2] != (addr & 0xff)
+		|| hdr[3] != size;
+}
+
+static int aml_cimax_spi_read_reg(struct aml_cimax *cimax, int addr,
+		u8 *buf, int size)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	struct spi_device *dev = spi->dev;
+	int err = 0;
+
+	init_reg_hdr(spi->buf, CIMAX_REG_READ, addr, size);
+
+	lock_lock(spi);
+
+	pr_dbg("rd %02x:%02x:%02x:%02x\n",
+		reg_hdr(spi)[0], reg_hdr(spi)[1],
+		reg_hdr(spi)[2], reg_hdr(spi)[3]);
+	err = spi_write(dev, spi->buf, CIMAX_REG_HDR_SIZE);
+	if (err)
+		goto end;
+	err = cimax_spi_get_resp(spi, REG_TIMEOUT);
+	if (err)
+		goto end;
+	if (check_reg_hdr(reg_hdr(spi), CIMAX_REG_READ_OK, addr, size) != 0) {
+		perr("read reg fail.", spi);
+		err = -EINVAL;
+		goto end;
+	}
+	memcpy(buf, reg_dat(spi), size);
+end:
+	lock_unlock(spi);
+	return err;
+}
+
+static int aml_cimax_spi_write_reg(struct aml_cimax *cimax, int addr,
+		u8 *buf, int size)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	struct spi_device *dev = spi->dev;
+	int err = 0;
+
+	init_reg_hdr(spi->buf, CIMAX_REG_WRITE, addr, size);
+	memcpy(&spi->buf[CIMAX_REG_HDR_SIZE], buf, size);
+
+	lock_lock(spi);
+
+	pr_dbg("wr %02x:%02x:%02x:%02x\n",
+		reg_hdr(spi)[0], reg_hdr(spi)[1],
+		reg_hdr(spi)[2], reg_hdr(spi)[3]);
+	err = spi_write(dev, spi->buf, CIMAX_REG_HDR_SIZE + size);
+	if (err)
+		goto end;
+	err = cimax_spi_get_resp(spi, REG_TIMEOUT);
+	if (err)
+		goto end;
+	if (check_reg_hdr(reg_hdr(spi), CIMAX_REG_WRITE_OK, addr, 0) != 0) {
+		perr("write reg fail.", spi);
+		err = -EINVAL;
+		goto end;
+	}
+end:
+	lock_unlock(spi);
+	return err;
+}
+
+static inline int init_cam_hdr(u8 *hdr, int cmd, int size)
+{
+	hdr[0] = cmd;
+	hdr[1] = CIMAX_CAM_PKT_CNT_VAL;
+	hdr[2] = (size>>8) & 0xff;
+	hdr[3] = size & 0xff;
+	return 0;
+}
+
+static inline int cam_err(struct cimax_spi *spi)
+{
+	if (hdr_cmd_resp(spi) != CIMAX_CAM_ERROR
+		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(spi) != 2)
+		return 0;
+	return byte_to_u16(cam_dat(spi)[0], cam_dat(spi)[1]);
+}
+
+static inline char *cam_err_str(int err)
+{
+#define CAMERROR_RESET           0x0101
+#define CAMERROR_CIS_BUF         0x0201
+#define CAMERROR_CIS_SIZE        0x0202
+#define CAMERROR_CAM_NOT_ACT     0x0203
+#define CAMERROR_COR_NOT_READY   0x0301
+#define CAMERROR_COR_VAL_CHK     0x0302
+#define CAMERROR_NEG_NO_RESP     0x0401
+#define CAMERROR_NEG_BAD_SIZE    0x0402
+#define CAMERROR_NEG_NOT_READY   0x0403
+#define CAMERROR_LPDU_NOT_AVAIL  0x0601
+	struct { int err; char *str; } cam_err_strings[] = {
+		{CAMERROR_RESET, "reset error, not ready."},
+		{CAMERROR_CIS_BUF, "cis error, buffer not allocated."},
+		{CAMERROR_CIS_SIZE, "cis error, bad cis size."},
+		{CAMERROR_CAM_NOT_ACT, "cam not activated."},
+		{CAMERROR_COR_NOT_READY, "cam not ready during write COR."},
+		{CAMERROR_COR_VAL_CHK, "COR value check failed."},
+		{CAMERROR_NEG_NO_RESP, "cam not responding when negotiation."},
+		{CAMERROR_NEG_BAD_SIZE, "cam buf size length != 2."},
+		{CAMERROR_NEG_NOT_READY, "cam not ready during negotiation."},
+		{CAMERROR_LPDU_NOT_AVAIL, "lpdu not available."}
+	};
+	int i;
+	for (i = 0;
+		i < sizeof(cam_err_strings)/sizeof(cam_err_strings[0]); i++) {
+		if (cam_err_strings[i].err == err)
+			return cam_err_strings[i].str;
+	}
+	return "err unknown.";
+}
+
+static int cimax_spi_access_cam(struct cimax_spi *spi, int slot,
+		int cmd, u8 *buf, int size)
+{
+	struct spi_device *dev = spi->dev;
+	int err = 0;
+
+	cmd |= slot ? 0x80 : 0;
+	init_cam_hdr(cam_hdr(spi), cmd, size);
+	memcpy(cam_dat(spi), buf, size);
+	/*dump("access cam:", cam_hdr(spi), CIMAX_CAM_HDR_SIZE+size);*/
+	err = spi_write(dev, cam_hdr(spi), CIMAX_CAM_HDR_SIZE + size);
+	if (err)
+		return err;
+	err = cimax_spi_get_resp(spi, CAM_TIMEOUT);
+	if (err)
+		return err;
+	if (cam_hdr_slot(spi) != slot) {
+		pr_error("expect slot(%d), but slot(%d)\n",
+			slot, cam_hdr_slot(spi));
+		return -EINVAL;
+	}
+	switch (hdr_cmd_resp(spi)) {
+	case CIMAX_CAM_NOCAM:
+		pr_dbg("no cam\n");
+		err = -ENODEV;
+		break;
+	case CIMAX_CAM_ERROR:
+		pr_error("cam error\n");
+		pr_error("err code: 0x%04x(%s)\n", cam_err(spi),
+			cam_err_str(cam_err(spi)));
+		err = -ENODEV;
+		break;
+	case CIMAX_CAM_WBUSY:
+		pr_dbg("cam busy\n");
+		err = -EBUSY;
+		break;
+	case CIMAX_CAM_PENDING:
+		pr_dbg("cam pending\n");
+		err = -EAGAIN;
+		break;
+	}
+	return err;
+}
+
+static int aml_cimax_spi_read_cis(struct aml_cimax *cimax, int slot,
+		u8 *buf, int size)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	int err = 0;
+	int len;
+
+	lock_lock(spi);
+
+	err = cimax_spi_access_cam(spi, slot, CIMAX_CAM_CIS, NULL, 0);
+	if (err)
+		goto end;
+	if (hdr_cmd_resp(spi) != CIMAX_CAM_CIS_OK
+		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL) {
+		perr("read cis fail.", spi);
+		err = -EINVAL;
+		goto end;
+	}
+	len = cam_hdr_dat_size(spi);
+	if (size < len) {
+		pr_error("cis size too large, expect<%d, but:%d\n", size, len);
+		perr("cis fail.", spi);
+		err = -EINVAL;
+		goto end;
+	}
+	memcpy(buf, cam_dat(spi), len);
+
+	if (!spi->cis)
+		spi->cis = kzalloc((len < 512) ? 512 : len, GFP_KERNEL);
+	if (spi->cis)
+		memcpy(spi->cis, cam_dat(spi), len);
+
+end:
+	lock_unlock(spi);
+	return err;
+}
+#define CIMAX_CAM_COR_PLD_SIZE 5
+static int aml_cimax_spi_write_cor(struct aml_cimax *cimax, int slot,
+		int addr, u8 *buf)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	int err = 0;
+	u8 out[CIMAX_CAM_COR_PLD_SIZE + 8];
+	int sz = CIMAX_CAM_COR_PLD_SIZE;
+
+	out[0] = addr>>8 & 0xff;
+	out[1] = addr & 0xff;
+	out[2] = buf[0];
+	out[3] = 0;
+	out[4] = 0;
+
+	if (!cam_irq_mode) {
+		out[5] = 0x40;/*cam poll mode*/
+		sz++;
+	}
+
+	lock_lock(spi);
+
+	err = cimax_spi_access_cam(spi, slot, CIMAX_CAM_COR, out, sz);
+	if (err)
+		goto end;
+	if (hdr_cmd_resp(spi) != CIMAX_CAM_COR_OK
+		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(spi) != 0) {
+		perr("write cor fail.", spi);
+		err = -EINVAL;
+		goto end;
+	}
+end:
+	lock_unlock(spi);
+	return err;
+}
+#define CIMAX_CAM_NEG_PLD_SIZE 2
+static int aml_cimax_spi_negotiate(struct aml_cimax *cimax, int slot, int size)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	int ret = 0;
+	u8 out[CIMAX_CAM_NEG_PLD_SIZE];
+
+	out[0] = (size>>8) & 0xff;
+	out[1] = size & 0xff;
+
+	lock_lock(spi);
+
+	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_NEG,
+			out, CIMAX_CAM_NEG_PLD_SIZE);
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(spi) != CIMAX_CAM_NEG_OK
+		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(spi) != 2) {
+		perr("negotiate fail.", spi);
+		ret = -EINVAL;
+		goto end;
+	}
+	ret = byte_to_u16(cam_dat(spi)[0], cam_dat(spi)[1]);
+
+	set_spi_cam_ready(spi, slot);
+end:
+	lock_unlock(spi);
+	return ret;
+}
+
+static int aml_cimax_spi_write_lpdu(struct aml_cimax *cimax, int slot,
+		u8 *buf, int size)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	int ret = 0;
+
+	lock_lock(spi);
+
+	/*dump("lpdu ->", buf, size);*/
+	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_WLPDU, buf, size);
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(spi) != CIMAX_CAM_WLPDU_OK
+		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(spi) != 0) {
+		perr("write lpdu fail.", spi);
+		ret = -EINVAL;
+		goto end;
+	}
+	ret = size;
+end:
+	lock_unlock(spi);
+	return ret;
+}
+
+static int aml_cimax_spi_read_lpdu(struct aml_cimax *cimax, int slot,
+		u8 *buf, int size)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	int ret = 0;
+
+	lock_lock(spi);
+
+	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_RLPDU, NULL, 0);
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(spi) != CIMAX_CAM_RLPDU_OK
+		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL) {
+		perr("read lpdu fail.", spi);
+		ret = -EINVAL;
+		goto end;
+	}
+	ret = cam_hdr_dat_size(spi);
+	memcpy(buf, cam_dat(spi), ret);
+
+	/*dump("lpdu <-", buf, ret);*/
+
+	spi->cam_data_ready[slot] = 0;
+end:
+	lock_unlock(spi);
+	return ret;
+}
+
+static int aml_cimax_spi_read_cam_status(struct aml_cimax *cimax, int slot)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	int ret = 0;
+
+	if (cam_irq_mode && spi->cam_data_ready[slot])
+		return 0x80;
+
+	lock_lock(spi);
+
+	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_REGSTAT, NULL, 0);
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(spi) != CIMAX_CAM_REGSTAT_OK
+		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(spi) != 1) {
+		perr("read cam status fail.", spi);
+		ret = -EINVAL;
+		goto end;
+	}
+
+	ret = cam_dat(spi)[0];
+end:
+	lock_unlock(spi);
+	return ret;
+}
+
+static int aml_cimax_spi_slot_reset(struct aml_cimax *cimax, int slot)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	int ret = 0;
+
+	spi->cam_data_ready[slot] = 0;
+
+	lock_lock(spi);
+
+	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_RESET, NULL, 0);
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(spi) != CIMAX_CAM_RESET_OK
+		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(spi) != 0) {
+		perr("slot reset fail.", spi);
+		ret = -EINVAL;
+		goto end;
+	}
+end:
+	lock_unlock(spi);
+	return ret;
+}
+
+static int aml_cimax_spi_cam_reset(struct aml_cimax *cimax, int slot)
+{
+	pr_dbg("Slot(%d): camreset\n", slot);
+	return 0;
+}
+
+static int aml_cimax_spi_slot_shutdown(struct aml_cimax *cimax, int slot)
+{
+	pr_dbg("Slot(%d): shutdown\n", slot);
+	return 0;
+}
+static int aml_cimax_spi_slot_ts_enable(struct aml_cimax *cimax, int slot)
+{
+	pr_dbg("Slot(%d): ts control\n", slot);
+	return 0;
+}
+static int aml_cimax_spi_slot_status(struct aml_cimax *cimax, int slot)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+	if (spi->cam_inserted[slot]) {
+		/*pr_dbg("CA Module present and ready\n");*/
+		return DVB_CA_EN50221_POLL_CAM_PRESENT |
+			DVB_CA_EN50221_POLL_CAM_READY;
+	} else {
+		/*pr_error("CA Module not present or not ready\n");*/
+	}
+	return 0;
+}
+
+static int cimax_spi_cam_plugin(struct cimax_spi *spi, int slot, int plugin)
+{
+	pr_dbg("cam plug: slot(%d) %s\n",
+		slot, plugin ? "plugged" : "unplugged");
+	return aml_cimax_camchanged(spi->cimax, slot, plugin);
+}
+
+static int cimax_spi_poll(struct cimax_spi *spi)
+{
+	struct spi_device *dev = spi->dev;
+	int err = 0;
+
+	lock_lock(spi);
+
+#ifdef USE_INT_PIO
+	if (gpio_get_value(spi->irq_io))
+		goto end;
+#endif
+
+	init_reg_hdr(spi->buf, CIMAX_CAM_EVT, 0x100, 0);
+	err = spi_write(dev, spi->buf, CIMAX_REG_HDR_SIZE);
+	if (err)
+		goto end;
+	err = cimax_spi_get_resp(spi, CAM_TIMEOUT);
+	if (err)
+		goto end;
+	switch (hdr_cmd_resp(spi)) {
+	case CIMAX_CAM_DET_OK: {
+		int slot = cam_hdr_slot(spi);
+		int insert = cam_dat(spi)[0];
+		if (!!spi->cam_inserted[slot] != insert) {
+			spi->cam_inserted[slot] = insert;
+			cimax_spi_cam_plugin(spi, slot, insert);
+			aml_cimax_slot_state_changed(spi->cimax, slot,
+				spi->cam_inserted[slot]);
+		}
+		} break;
+	case CIMAX_CAM_DATA_READY: {
+		int slot = cam_hdr_slot(spi);
+		spi->cam_data_ready[slot] = 1;
+		} break;
+	case CIMAX_CAM_NOEVT:
+		break;
+	default:
+		pr_error("unknown resp:%02x\n", hdr_cmd_resp(spi));
+		break;
+	}
+end:
+	queue_delayed_work(spi->workq, &spi->work, spi_poll_interval);
+	lock_unlock(spi);
+	return 0;
+}
+
+static void cimax_spi_poll_work(struct work_struct *work)
+{
+	struct cimax_spi *spi =
+		container_of(to_delayed_work(work), struct cimax_spi, work);
+	spi->work_cnt++;
+	cimax_spi_poll(spi);
+}
+
+static irqreturn_t cimax_irq_handler(int irq, void *para)
+{
+	return IRQ_HANDLED;
+}
+
+#define CTRL_DISABLE -1
+#define CTRL_STOP     0
+#define CTRL_START    1
+
+static inline int cimax_spi_poll_ctrl(struct cimax_spi *spi, int ctrl)
+{
+	if (ctrl == CTRL_START) {
+		spi->workq = create_singlethread_workqueue("cimax_spi");
+		INIT_DELAYED_WORK(&spi->work, &cimax_spi_poll_work);
+		queue_delayed_work(spi->workq,
+			&spi->work, spi_poll_interval);
+		pr_dbg("poll started\n");
+	} else {
+		if (!spi->workq)
+			return 0;
+		cancel_delayed_work_sync(&spi->work);
+		destroy_workqueue(spi->workq);
+		spi->workq = NULL;
+		pr_dbg("poll stopped\n");
+	}
+	return 0;
+}
+
+static inline int cimax_spi_intr_ctrl(struct cimax_spi *spi, int ctrl)
+{
+	if (ctrl == CTRL_START) {
+		int ret;
+		if (spi->irq == -1) {
+			pr_error("incorrect irq");
+			return -1;
+		}
+		ret = request_irq(spi->irq, cimax_irq_handler,
+			IRQF_SHARED|IRQF_TRIGGER_RISING,
+			"cimax irq", spi);
+		enable_irq(spi->irq);
+	} else {
+		if (spi->irq == -1)
+			return 0;
+		disable_irq(spi->irq);
+		free_irq(spi->irq, spi);
+	}
+	return 0;
+}
+
+static int cimax_spi_setup_poll(struct cimax_spi *spi, int poll_mode)
+{
+	if (poll_mode == spi->poll_mode)
+		return 0;
+	switch (poll_mode) {
+	case POLL_MODE:
+		if (spi->poll_mode == INT_MODE)
+			cimax_spi_intr_ctrl(spi, CTRL_DISABLE);
+		cimax_spi_poll_ctrl(spi, CTRL_START);
+		spi->poll_mode = POLL_MODE;
+		break;
+	case INT_MODE:
+		if (spi->poll_mode == POLL_MODE)
+			cimax_spi_poll_ctrl(spi, CTRL_DISABLE);
+		cimax_spi_intr_ctrl(spi, CTRL_START);
+		spi->poll_mode = INT_MODE;
+		break;
+	case STOP_MODE:
+		if (spi->poll_mode == POLL_MODE)
+			cimax_spi_poll_ctrl(spi, CTRL_DISABLE);
+		else if (spi->poll_mode == INT_MODE)
+			cimax_spi_intr_ctrl(spi, CTRL_DISABLE);
+		spi->poll_mode = STOP_MODE;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int cimax_spi_hw_reset(struct cimax_spi *spi, int reset_val)
+{
+	/*trigger reset io*/
+	if (spi->rst_io) {
+		gpio_direction_output(spi->rst_io, reset_val ? 1 : 0);
+		msleep(50);
+		gpio_direction_output(spi->rst_io, reset_val ? 0 : 1);
+	}
+	return 0;
+}
+
+
+enum regOperation_e {
+	/** Read register. */
+	REG_OP_READ,
+	/** Write register. */
+	REG_OP_WRITE,
+	/** Read register until some bits are set. */
+	REG_OP_WAIT_TO_BE_SET,
+	/** Read register until some bits are cleared. */
+	REG_OP_WAIT_TO_BE_CLEARED,
+	/** Read register until it's value is not equal to defined. */
+	REG_OP_WAIT_EQUAL,
+	/** Perform logical AND over register. */
+	REG_OP_LOGICAL_AND,
+	/** Perform logical OR over register. */
+	REG_OP_LOGICAL_OR,
+	/** Wait timeout in miliseconds. */
+	REG_OP_WAIT
+};
+
+struct regSettings_s {
+	/** CIMaX+ register address. */
+	u16         reg;
+	/** CIMaX+ register value. */
+	u16         val;
+	/** CIMaX+ register operation. */
+	enum regOperation_e op;
+};
+
+static struct regSettings_s spiRegSettings[] = {
+	/** TS interface init. */
+	{IN_SEL,          0x00, REG_OP_WRITE},          /** Close TS input. */
+	{OUT_SEL,         0x00, REG_OP_WRITE},          /** Close TS output. */
+	{FIFO_CTRL,       0x0f, REG_OP_WRITE},          /** Reset TS FIFO.  */
+	{SYNC_RTV_CTRL,   0x0f, REG_OP_WRITE},
+
+	/** CAM power. */
+	{GPIO0_DATA_OUT,  0x00, REG_OP_WRITE},
+	/** Unlock CFG. */
+	{CFG_2,           0x00, REG_OP_WRITE},
+	/** 1) DVB/CI/CI+/SCARD 2slot. */
+	{CFG_1,           0x00, REG_OP_WRITE},
+	/** 2) Set the Default "power off" state
+	such as VCC_MODA=VCC_MODB=VPPx_MODA=VPPx_MODB='Z'. */
+	{GPIO0_DFT,       0x00, REG_OP_WRITE},
+	/** 3) Set GPIO3 as external power switch driver. */
+	{GPIO0_MASK_DATA, 0x07, REG_OP_WRITE},
+	/** 4) Set "power on" state (VCC=VPP1=VPP2= 5V). */
+	{GPIO0_DATA_OUT,  0x03, REG_OP_WRITE},
+	/** 5) Lock config. */
+	{CFG_2,           0x01, REG_OP_WRITE},
+	/** 6) Write in the GPIO0_DIR_REG: defines the GPIOs,
+	which are used to drive the external power switch, in output mode. */
+	{GPIO0_DIR,       0x07, REG_OP_WRITE},
+	/** 7) Check VCCENable. */
+	{CFG_1,           0x20, REG_OP_WAIT_TO_BE_SET},
+	/** 8) Set & wait for PcmciaOutputEnable. */
+	{CFG_1,           0x08, REG_OP_LOGICAL_OR},
+	{CFG_1,           0x08, REG_OP_WAIT_TO_BE_SET},
+
+	/** Set router CAM. */
+	/** CH0 & CH1 from CAM A & B, CAM A & B from CH0 & CH1. */
+	{ROUTER_CAM_MOD,  0x21, REG_OP_WRITE},
+	{ROUTER_CAM_CH,   0x00, REG_OP_WRITE},
+	/** Wait 200 miliseconds. */
+	{0x0000,          200,  REG_OP_WAIT},
+
+	/** Set In/Out. */
+	/** Route CAM Channel 0 to Channel 0, Channel 1 null. */
+	{ROUTER_CAM_CH,   0x80, REG_OP_WRITE},
+
+#ifdef PARALLEL_OUT
+#else
+#if 1
+	/*72M internal clock source*/
+	/*CLK Select SER0->72M*/
+	{CkMan_Select,    0x20, REG_OP_WRITE},
+	/*Enable SER0 clk source, Enable 72M clk source*/
+	{CkMan_Config,    0x44, REG_OP_LOGICAL_OR},
+#else
+	/*108M internal clock source*/
+	/*CLK Select SER0->108M*/
+	{CkMan_Select,    0x30, REG_OP_WRITE},
+	/*Enable SER0 clk source, Enable 108M clk source*/
+	{CkMan_Config,    0x48, REG_OP_LOGICAL_OR},
+#endif
+	{P2S_CH0_CTRL,    0x19, REG_OP_WRITE},           /*Enable p2s*/
+	{OUT_SEL,         0x02, REG_OP_WRITE},           /*Out1=p2s0*/
+#endif /*Parallel out*/
+
+	/** Input Ch0=Parallel, Ch1=null. */
+	{IN_SEL,          0x01, REG_OP_WRITE},
+};
+
+int downloadCfg(struct cimax_spi *spi)
+{
+	u32   cnt;
+	u8    buf[CIMAX_REG_PLD_SIZE];
+	struct aml_cimax *cimax = spi->cimax;
+
+	pr_info("Download CIMaX+ configuration(register settings):\n");
+
+	for (cnt = 0; cnt < sizeof(spiRegSettings)/sizeof(struct regSettings_s);
+			cnt++) {
+		pr_dbg("reg:%04x, val:%02x, op:%d\n",
+				spiRegSettings[cnt].reg,
+				spiRegSettings[cnt].val,
+				spiRegSettings[cnt].op);
+		switch (spiRegSettings[cnt].op) {
+		case REG_OP_READ:
+			/* Read register. */
+			if (aml_cimax_spi_read_reg(cimax,
+					spiRegSettings[cnt].reg, buf, 1) < 0) {
+				/* CIMaX+ read error. */
+				pr_error("FAILED at REG_OP_READ operation.\n");
+				return -1;
+			}
+			break;
+		case REG_OP_WRITE:
+			/* Write register. */
+			if (aml_cimax_spi_write_reg(cimax,
+					spiRegSettings[cnt].reg,
+					(u8 *)&spiRegSettings[cnt].val,
+					1) < 0) {
+				/* CIMaX+ write error. */
+				pr_error("FAILED at REG_OP_WRITE operation.\n");
+				return -1;
+			}
+			break;
+		case REG_OP_WAIT_TO_BE_SET:
+			do {
+				if (aml_cimax_spi_read_reg(cimax,
+					spiRegSettings[cnt].reg, buf, 1) < 0) {
+					/* CIMaX+ read error. */
+					pr_error("E REG_OP_WAIT_TO_BE_SET\n");
+					return -1;
+				}
+			} while ((buf[0] & spiRegSettings[cnt].val)
+					!= spiRegSettings[cnt].val);
+			break;
+		case REG_OP_WAIT_TO_BE_CLEARED:
+			do {
+				if (aml_cimax_spi_read_reg(cimax,
+					spiRegSettings[cnt].reg, buf, 1) < 0) {
+					/* CIMaX+ read error. */
+					pr_error("REG_OP_WAIT_TO_BE_CLEARED\n");
+					return -1;
+				}
+			} while ((buf[0] & spiRegSettings[cnt].val) != 0);
+			break;
+		case REG_OP_WAIT_EQUAL:
+			do {
+				if (aml_cimax_spi_read_reg(cimax,
+					spiRegSettings[cnt].reg, buf, 1) < 0) {
+					/* CIMaX+ read error. */
+					pr_error("REG_OP_WAIT_EQUAL.\n");
+					return -1;
+				}
+			} while (buf[0] != spiRegSettings[cnt].val);
+			break;
+		case REG_OP_LOGICAL_AND:
+			if (aml_cimax_spi_read_reg(cimax,
+				spiRegSettings[cnt].reg, buf, 1) < 0) {
+				/* CIMaX+ read error. */
+				pr_error("FAILED at REG_OP_LOGICAL_AND(r).\n");
+				return -1;
+			}
+			buf[0] &=  spiRegSettings[cnt].val;
+			if (aml_cimax_spi_write_reg(cimax,
+				spiRegSettings[cnt].reg, buf, 1) < 0) {
+				/* CIMaX+ write error. */
+				pr_error("FAILED at REG_OP_LOGICAL_AND(w).\n");
+				return -1;
+			}
+			break;
+		case REG_OP_LOGICAL_OR:
+			if (aml_cimax_spi_read_reg(cimax,
+				spiRegSettings[cnt].reg, buf, 1) < 0) {
+				/* CIMaX+ read error. */
+				pr_error("FAILED at REG_OP_LOGICAL_OR(r).\n");
+				return -1;
+			}
+			buf[0] |=  spiRegSettings[cnt].val;
+			if (aml_cimax_spi_write_reg(cimax,
+				spiRegSettings[cnt].reg, buf, 1) < 0) {
+				/* CIMaX+ write error. */
+				pr_error("FAILED at REG_OP_LOGICAL_AND(w).\n");
+				return -1;
+			}
+			break;
+		case REG_OP_WAIT:
+			msleep(spiRegSettings[cnt].val);
+			break;
+		default:
+			pr_error("\nInvalid operation 0x%02x!\n",
+				spiRegSettings[cnt].op);
+		}
+	}
+	pr_info("config OK.\n");
+	return 0;
+}
+
+
+#define CIMAX_FW_PKT_SIZE    128
+#define CIMAX_FW_START_ADDR  0x8000
+#define CIMAX_FW_STOP_ADDR   0xcff9
+#define CIMAX_FW_VECT_ADDR   0xfffa
+#define CIMAX_FW_VECT_SIZE   6
+
+static u32 compute_bistrom(const u8 *ptr, int size, u32 sign)
+{
+	int k, i;
+	u16 s;
+
+	for (k = 0; k < size; k++) {
+		s = ptr[k]&0x01;
+		for (i = 0; i < 16; i++)
+			if (0x88B7 & (1<<i))
+				s ^= (sign>>i) & 0x01;
+		s |= ((sign<<1) ^ (ptr[k])) & 0x00FE;
+		s |= (sign<<1) & 0x00FF00;
+		sign = s;
+	}
+	return sign;
+}
+
+static int cimax_spi_upload_firmware(struct cimax_spi *spi,
+		const u8 *fw_data, u32 *sign)
+{
+	struct aml_cimax *cimax = spi->cimax;
+	int err = 0;
+	int addr;
+	const u8 *ptr;
+	int size;
+	int debug = cimax_spi_debug;
+	u8 *ptmp = kzalloc(CIMAX_FW_PKT_SIZE + CIMAX_REG_HDR_SIZE, GFP_KERNEL);
+
+	if (!ptmp)
+		return -ENOMEM;
+
+	cimax_spi_debug = 0;
+
+	addr = CIMAX_FW_START_ADDR;
+	ptr = fw_data + addr;
+	while (addr < CIMAX_FW_STOP_ADDR) {
+		size = (addr <= (CIMAX_FW_STOP_ADDR+1-CIMAX_FW_PKT_SIZE)) ?
+			CIMAX_FW_PKT_SIZE : (CIMAX_FW_STOP_ADDR+1-addr);
+
+		*sign = compute_bistrom(ptr, size, *sign);
+
+		pr_dbg(">>%x@%x\n", size, addr);
+
+		/*dump("w:", (u8*)ptr, size);*/
+		err = aml_cimax_spi_write_reg(cimax, addr, (u8 *)ptr, size);
+		if (err)
+			break;
+		err = aml_cimax_spi_read_reg(cimax, addr, ptmp, size);
+		if (err)
+			break;
+		/*dump("r:", ptmp, size);*/
+		if (memcmp(ptr, ptmp, size)) {
+			pr_error("fw write error.\n");
+			err = -ENODEV;
+			break;
+		}
+
+		addr += size;
+		ptr += size;
+	}
+
+	if (!err) {
+		addr = CIMAX_FW_VECT_ADDR;
+		ptr = fw_data + addr;
+		size = CIMAX_FW_VECT_SIZE;
+
+		*sign = compute_bistrom(ptr, size, *sign);
+
+		err = aml_cimax_spi_write_reg(cimax, addr, (u8 *)ptr, size);
+		if (err)
+			goto end;
+		err = aml_cimax_spi_read_reg(cimax, addr, ptmp, size);
+		if (err)
+			goto end;
+		if (memcmp(ptr, ptmp, size)) {
+			pr_error("fw vect write error.\n");
+			err = -ENODEV;
+			goto end;
+		}
+	}
+end:
+	kfree(ptmp);
+
+	cimax_spi_debug = debug;
+	return err;
+}
+
+static int cimax_spi_check_bistrom(struct cimax_spi *spi,
+		int start, int end, u32 sign)
+{
+	struct aml_cimax *cimax = spi->cimax;
+	int err = 0;
+	u8 buf[2];
+
+	buf[0] = (0xd000-start) & 0xff;
+	buf[1] = (0xd000-start) >> 8;
+	err = aml_cimax_spi_write_reg(cimax, 0x8d, buf, 2);
+	if (err)
+		return err;
+	buf[0] = sign & 0xff;
+	buf[1] = sign >> 8;
+	err = aml_cimax_spi_write_reg(cimax, 0x80, buf, 2);
+	if (err)
+		return err;
+	buf[0] = 0xf;
+	err = aml_cimax_spi_write_reg(cimax, 0x82, buf, 1);
+	if (err)
+		return err;
+	err = aml_cimax_spi_read_reg(cimax, 0x41, buf, 2);
+	if (err)
+		return err;
+	pr_dbg("bist checked: 0x%04x\n", byte_to_u16(buf[0], buf[1]));
+	err = aml_cimax_spi_read_reg(cimax, 0x09, buf, 1);
+	if (err)
+		return err;
+	pr_dbg("rom status: 0x%02x\n", buf[0]);
+	return buf[0];
+}
+
+static int cimax_spi_init_firmware(struct cimax_spi *spi)
+{
+	struct spi_device *dev = spi->dev;
+	int err = 0;
+
+	init_reg_hdr(spi->buf, CIMAX_REG_INIT, 0, 0);
+	err = spi_write(dev, spi->buf, CIMAX_REG_HDR_SIZE);
+	if (err)
+		return err;
+	err = cimax_spi_get_resp(spi, REG_TIMEOUT);
+	if (err)
+		return err;
+	if (check_reg_hdr(spi->buf, CIMAX_REG_INIT_OK, 0, 0)) {
+		perr("init fw fail.", spi);
+		return -EINVAL;
+	}
+	return err;
+}
+
+static void request_fw_callback(const struct firmware *fw, void *context)
+{
+	u32 sign = 0;
+	int err = 0;
+	struct cimax_spi *spi = (struct cimax_spi *)context;
+
+	if (!fw)
+		return;
+
+	pr_dbg("got fw: %zd @ %p\n", fw->size, fw->data);
+
+    /*cimax_spi_hw_reset(spi, 1);*/
+
+	err = cimax_spi_upload_firmware(spi, fw->data, &sign);
+	if (err)
+		goto end;
+	pr_dbg("upload fw done.\n");
+	err = cimax_spi_check_bistrom(spi,
+		CIMAX_FW_START_ADDR, CIMAX_FW_STOP_ADDR, sign);
+	if (err != 0x2)
+		goto end;
+	pr_dbg("check bistrom done.\n");
+	err = cimax_spi_init_firmware(spi);
+	if (err)
+		goto end;
+end:
+	if (fw)
+		release_firmware(fw);
+	if (err)
+		return;
+
+	if (downloadCfg(spi)) {
+		pr_error("download config fail.\n");
+		return;
+	}
+
+	cimax_spi_setup_poll(spi, cimax_poll_mode ? POLL_MODE : INT_MODE);
+
+	return;
+}
+
+static int cimax_spi_load_fw(struct cimax_spi *spi)
+{
+	char *name = "cimax_spidvb.bin";
+	return request_firmware_nowait(THIS_MODULE, 1, name,
+			&spi->dev->dev, GFP_KERNEL, spi, request_fw_callback);
+}
+
+static int cimax_spi_dev_probe(struct spi_device *spi)
+{
+	int ret;
+	struct cimax_spi *cimax_spi;
+
+	pr_dbg("dev probe\n");
+	/*setup again?*/
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret)
+		pr_dbg("spi setup failed\n");
+
+	cimax_spi = dev_get_platdata(&spi->dev);
+	cimax_spi->dev = spi;
+
+	spi_set_drvdata(spi, cimax_spi);
+
+	return cimax_spi_load_fw(cimax_spi);
+}
+
+static int cimax_spi_dev_remove(struct spi_device *spi)
+{
+	struct cimax_spi *cimax_spi = dev_get_drvdata(&spi->dev);
+
+	pr_dbg("dev remove\n");
+	cimax_spi_setup_poll(cimax_spi, STOP_MODE);
+	return 0;
+}
+
+static int cimax_spi_get_config_from_dts(struct cimax_spi *spi,
+		struct spi_board_info *bdinfo)
+{
+	struct device_node *child = NULL;
+	struct platform_device *pdev = spi->pdev;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int val;
+	int ret = 0;
+	pr_dbg("fetch cimax spi in dts\n");
+
+	child = of_get_child_by_name(np, "cimax");
+	if (child == NULL) {
+		pr_error("cimax not found in dts\n");
+		return -1;
+	}
+	child = of_get_child_by_name(child, "spi");
+	if (!child) {
+		pr_error("spi not found in cimax");
+		return -1;
+	}
+
+	/* get spi config */
+	ret = of_property_read_u32(child, "bus_num", &val);
+	if (ret)
+		pr_error("bus_num not found, use default.\n");
+	else
+		bdinfo->bus_num = val;
+	pr_dbg("bus_num: %d\n", bdinfo->bus_num);
+	ret = of_property_read_u32(child, "chip_select", &val);
+	if (ret)
+		pr_error("chip_select not found, use default.\n");
+	else
+		bdinfo->chip_select = val;
+	pr_dbg("chip_select: %d\n", bdinfo->chip_select);
+	ret = of_property_read_u32(child, "max_frequency", &val);
+	if (ret)
+		pr_error("max_frequency not found, use default.\n");
+	else
+		bdinfo->max_speed_hz = val;
+	pr_dbg("max_speed_hz: %d\n", bdinfo->max_speed_hz);
+	ret = of_property_read_u32(child, "mode", &val);
+	if (ret)
+		pr_error("mode not found, use default.\n");
+	else
+		bdinfo->mode = val;
+	pr_dbg("mode: %d\n", bdinfo->mode);
+/*
+dvbci {
+	compatible = "amlogic, dvbci";
+	dev_name = "dvbci";
+	io_type = <2>;//0:iobus,1:spi,2:cimax
+	cimax {
+		io_type = <0> //0:spi 1:usb
+		spi {
+			spi_bus_num = <0>;
+			spi_chip_select = <0>;
+			spi_max_frequency = <3000000>;
+
+			rst_gpio = <&gpio_ao GPIOAO_2 GPIO_ACTIVE_HIGH>;
+
+			irq_gpio = <&gpio_ao GPIOAO_2 GPIO_ACTIVE_HIGH>;
+			irq = <2>;
+			interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
+		};
+	};
+
+};
+*/
+#ifdef USE_INT_PIO
+	{
+		int ret = 0;
+		int gpio = -1;
+		gpio = of_get_named_gpio_flags(child, "irq-gpios", 0, NULL);
+		ret = gpio_request(gpio, "cimax-irq");
+		if (ret < 0) {
+			pr_error("irq-gpios request fail.\n");
+			return ret;
+		}
+
+		ret = gpio_direction_input(gpio);
+
+		spi->irq_io = gpio;
+		pr_dbg("irq_io: %d\n", spi->irq_io);
+	}
+#ifdef CIMAX_IRQ
+	{
+		int irq;
+		unsigned int irqflag;
+		ret = of_property_read_u32(child, "irq", &gpio_irq);
+		irq = irq_of_parse_and_map(child, 0);
+
+		gpio_for_irq(gpio,
+			AML_GPIO_IRQ(gpio_irq, FILTER_NUM7, GPIO_IRQ_FALLING));
+		spi->irq = irq;
+		pr_dbg("irq: %d\n", spi->irq);
+	}
+#else
+	spi->irq = -1;
+#endif
+#endif/*USE_INT_PIO*/
+	{
+		int ret = 0;
+		int gpio = -1;
+		gpio = of_get_named_gpio_flags(child, "rst-gpios", 0, NULL);
+		if (gpio != -1) {
+			ret = gpio_request(gpio, "cimax");
+			if (ret < 0) {
+				pr_error("rst-gpios request fail.\n");
+				return ret;
+			}
+
+			cimax_spi_hw_reset(spi, 1);
+
+			spi->rst_io = gpio;
+			pr_dbg("rst: %d\n", spi->rst_io);
+		} else {
+			pr_error("rst io got fail, %d\n", gpio);
+		}
+	}
+	return 0;
+}
+
+static struct spi_board_info cimax_spi_bdinfo = {
+	.modalias = "cimax_spi",
+	.mode = SPI_MODE_3,
+	.max_speed_hz = 1000000, /* 1MHz */
+	.bus_num = 0, /* SPI bus No. */
+	.chip_select = 0, /* the device index on the spi bus */
+	.controller_data = NULL,
+};
+
+static struct spi_driver cimax_spi_dev_driver = {
+	.probe = cimax_spi_dev_probe,
+	.remove = cimax_spi_dev_remove,
+	.driver = {
+		.name = "cimax_spi",
+		.owner = THIS_MODULE,
+	},
+};
+
+int aml_cimax_spi_init(struct platform_device *pdev, struct aml_cimax *cimax)
+{
+	int ret;
+	struct cimax_spi *cimax_spi;
+
+	cimax_spi = kzalloc(sizeof(struct cimax_spi), GFP_KERNEL);
+	if (!cimax_spi)
+		return -ENOMEM;
+
+	cimax_spi->pdev = pdev;
+	cimax_spi->cimax = cimax;
+	cimax_spi_get_config_from_dts(cimax_spi, &cimax_spi_bdinfo);
+
+	/*init spi_lock*/
+	lock_init(cimax_spi);
+
+	/*register device*/
+	cimax_spi_bdinfo.platform_data = cimax_spi;
+	spi_register_board_info(&cimax_spi_bdinfo, 1);
+
+	/*register driver*/
+	ret = spi_register_driver(&cimax_spi_dev_driver);
+	if (ret) {
+		pr_error("register cimax spi driver failed\n");
+		return ret;
+	}
+
+	/*init cimax used api.*/
+#define WI(_f)\
+	cimax->ops._f = aml_cimax_spi_##_f
+	WI(read_cis);
+	WI(write_cor);
+	WI(negotiate);
+	WI(read_lpdu);
+	WI(write_lpdu);
+	WI(read_cam_status);
+	WI(cam_reset);
+	WI(slot_reset);
+	WI(slot_shutdown);
+	WI(slot_ts_enable);
+	WI(slot_status);
+	/*WI(start);*/
+	/*WI(stop);*/
+	WI(read_reg);
+	WI(write_reg);
+
+	cimax->priv = cimax_spi;
+
+	g_spi = cimax_spi;
+
+	aml_cimax_spi_mod_init();
+	
+	return 0;
+}
+EXPORT_SYMBOL(aml_cimax_spi_init);
+
+int aml_cimax_spi_exit(struct aml_cimax *cimax)
+{
+	struct cimax_spi *spi = cimax_to_spi(cimax);
+
+	if (!spi)
+		return -ENODEV;
+
+	aml_cimax_spi_mod_exit();
+
+	/*unregister driver*/
+	spi_unregister_driver(&cimax_spi_dev_driver);
+	/*unregister device*/
+	spi_unregister_device(spi->dev);
+
+	if (spi->irq_io)
+		gpio_free(spi->irq_io);
+	if (spi->rst_io)
+		gpio_free(spi->rst_io);
+
+	kfree(spi->cis);
+
+	kfree(spi);
+	cimax->priv = NULL;
+
+	g_spi = NULL;
+	return 0;
+}
+EXPORT_SYMBOL(aml_cimax_spi_exit);
+
+static int cimax_spi_reset(struct cimax_spi *spi, int reset_val)
+{
+	pr_dbg("reset spi:%p, rst:%d\n", spi, spi ? spi->rst_io : -1);
+	if (!spi)
+		return -ENODEV;
+
+	pr_dbg("cimax spi reset\n");
+
+	cimax_spi_setup_poll(spi, STOP_MODE);
+
+	cimax_spi_hw_reset(spi, reset_val);
+
+	/*notify unplugged*/
+	aml_cimax_camchanged(spi->cimax, 0, 0);
+	aml_cimax_camchanged(spi->cimax, 1, 0);
+
+	spi->cam_inserted[0] = spi->cam_inserted[1] = 0;
+	spi->cam_data_ready[0] = spi->cam_data_ready[1] = 0;
+
+	/*async start fw*/
+	cimax_spi_load_fw(spi);
+
+	/*cimax_spi_setup_poll(spi, cimax_poll_mode? POLL_MODE : INT_MODE);*/
+	return 0;
+}
+
+static ssize_t reset_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "echo 1 > %s\n", attr->attr.name);
+	return ret;
+}
+
+static ssize_t reset_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int ret;
+	int val = 0;
+	if (!g_spi)
+		return size;
+	ret = sscanf(buf, "%i", &val);
+	if (ret == 1)
+		ret = cimax_spi_reset(g_spi, val);
+	return size;
+}
+
+static ssize_t debug_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	if (!g_spi)
+		return ret;
+
+	ret = sprintf(buf, "poll mode: %d\n", g_spi->poll_mode);
+	ret += sprintf(buf+ret, "status slot[0]=[%d] slot[1]=[%d]\n",
+		g_spi->cam_inserted[0], g_spi->cam_inserted[1]);
+	ret += sprintf(buf+ret, "data slot[0]=[%d] slot[1]=[%d]\n",
+		g_spi->cam_data_ready[0], g_spi->cam_data_ready[1]);
+	ret += sprintf(buf+ret, "work cnt:%d\n", g_spi->work_cnt);
+	return ret;
+}
+
+static int reg_addr;
+static ssize_t addr_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	ret = sprintf(buf, "addr = 0x%04x\n", reg_addr);
+	return ret;
+}
+
+static ssize_t addr_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	if (!g_spi)
+		return size;
+	if (sscanf(buf, "%i", &reg_addr) == 1)
+		return size;
+	return size;
+}
+
+static ssize_t reg_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	u8 reg_val = 0;
+	struct aml_cimax *cimax = NULL;
+
+	if (!g_spi)
+		return ret;
+
+	cimax = g_spi->cimax;
+	ret = aml_cimax_spi_read_reg(cimax, reg_addr, &reg_val, 1);
+	if (ret)
+		ret = sprintf(buf, "read fail, err=%d\n", ret);
+	else
+		ret = sprintf(buf, "reg[0x%04x] = 0x%02x\n", reg_addr, reg_val);
+	return ret;
+}
+
+static ssize_t reg_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int ret = 0;
+	struct aml_cimax *cimax = NULL;
+	int val = 0;
+	u8 reg_val = 0;
+
+	if (!g_spi)
+		return size;
+
+	if (sscanf(buf, "%i", &val) != 1)
+		return size;
+	reg_val = val;
+	cimax = g_spi->cimax;
+	ret = aml_cimax_spi_write_reg(cimax, reg_addr, &reg_val, 1);
+	if (ret)
+		return ret;
+	return size;
+}
+
+static int cis_mode; /*0:hex 1:binary*/
+static ssize_t cis_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+
+	if (!g_spi || !g_spi->cis)
+		return ret;
+
+	if (cis_mode == 0) {
+		int i;
+		for (i = 0; i < CIS_MAX; i++) {
+			if (i && !(i & 0xf))
+				ret += sprintf(buf+ret, "\n");
+			ret += sprintf(buf+ret, "%02X ", g_spi->cis[i]);
+		}
+		ret += sprintf(buf+ret, "\n");
+		return ret;
+	} else {
+		memcpy(buf, g_spi->cis, CIS_MAX);
+		return CIS_MAX;
+	}
+	return ret;
+}
+
+static ssize_t cis_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	if (size >= 3
+		&& !memcmp(buf, "bin", 3))
+		cis_mode = 1;
+	else
+		cis_mode = 0;
+	return size;
+}
+
+static ssize_t ts_rate_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	u8 lsb = 0, msb = 0, plen = 0;
+	struct aml_cimax *cimax = NULL;
+	int err = 0;
+
+	if (!g_spi)
+		return ret;
+
+	cimax = g_spi->cimax;
+	err = aml_cimax_spi_read_reg(cimax, PCK_LENGTH, &plen, 1);
+	err |= aml_cimax_spi_read_reg(cimax, BITRATE_CH0_LSB, &lsb, 1);
+	err |= aml_cimax_spi_read_reg(cimax, BITRATE_CH0_MSB, &msb, 1);
+	if (err || !byte_to_u16(msb, lsb))
+		ret += sprintf(buf+ret, "read fail, err=%d\n", err);
+	else
+		ret += sprintf(buf+ret, "rate[0] = %d Kbps\n",
+			540*plen*8/byte_to_u16(msb, lsb));
+	if (err)
+		return ret;
+
+	err = aml_cimax_spi_read_reg(cimax, BITRATE_CH1_LSB, &lsb, 1);
+	err |= aml_cimax_spi_read_reg(cimax, BITRATE_CH1_MSB, &msb, 1);
+	if (err || !byte_to_u16(msb, lsb))
+		ret += sprintf(buf+ret, "read fail, err=%d\n", err);
+	else
+		ret += sprintf(buf+ret, "rate[1] = %d Kbps\n",
+			540*plen*8/byte_to_u16(msb, lsb));
+	return ret;
+}
+
+static ssize_t loop_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	u8 ch = 0, mod = 0;
+	struct aml_cimax *cimax = NULL;
+	int err = 0;
+
+	if (!g_spi)
+		return ret;
+
+	cimax = g_spi->cimax;
+	err = aml_cimax_spi_read_reg(cimax, ROUTER_CAM_CH, &ch, 1);
+	err |= aml_cimax_spi_read_reg(cimax, ROUTER_CAM_MOD, &mod, 1);
+	if (err) {
+		ret = sprintf(buf, "read fail, err=%d\n", err);
+		return ret;
+	}
+	ret += sprintf(buf + ret, "OUT-0 <= ");
+	switch (ch & 0x0f) {
+	case 0x0:
+		ret += sprintf(buf + ret, "CAM-A"); break;
+	case 0x1:
+		ret += sprintf(buf + ret, "CH0-IN"); break;
+	case 0x2:
+		ret += sprintf(buf + ret, "CH1-IN"); break;
+	case 0x3:
+		ret += sprintf(buf + ret, "REMAPPER"); break;
+	case 0x4:
+		ret += sprintf(buf + ret, "PREHEADER"); break;
+	case 0x5:
+		ret += sprintf(buf + ret, "CAM-B"); break;
+	case 0x6:
+		ret += sprintf(buf + ret, "GAPREMOVER-0"); break;
+	case 0x7:
+		ret += sprintf(buf + ret, "GAPREMOVER-1"); break;
+	case 0x8:
+		ret += sprintf(buf + ret, "NONE"); break;
+	default:
+		ret += sprintf(buf + ret, "UNKNOWN"); break;
+	}
+	ret += sprintf(buf + ret, "\nCAM-A <= ");
+	switch (mod & 0x07) {
+	case 0x1:
+		ret += sprintf(buf + ret, "CH0-IN"); break;
+	case 0x2:
+		ret += sprintf(buf + ret, "CH1-IN"); break;
+	case 0x3:
+		ret += sprintf(buf + ret, "REMAPPER"); break;
+	case 0x4:
+		ret += sprintf(buf + ret, "PREHEADER"); break;
+	case 0x5:
+		ret += sprintf(buf + ret, "CAM-B"); break;
+	case 0x6:
+		ret += sprintf(buf + ret, "GAPREMOVER-0"); break;
+	case 0x7:
+		ret += sprintf(buf + ret, "GAPREMOVER-1"); break;
+	default:
+		ret += sprintf(buf + ret, "NONE"); break;
+	}
+	ret += sprintf(buf + ret, "\n");
+
+	return ret;
+}
+
+
+static ssize_t loop_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int loop = 0;
+	int err = 0;
+	struct aml_cimax *cimax = NULL;
+
+	if (!g_spi)
+		return size;
+
+	if (sscanf(buf, "%i", &loop) == 1) {
+		int a = g_spi->cam_inserted[0];
+		int b = g_spi->cam_inserted[1];
+		u8 cm[2];
+		cm[0] = loop ? (b ? 0x85 : 0x80) : 0x81;/*CH*/
+		cm[1] = loop ? (a ? 0x51 : 0x11) : 0x00;/*MOD*/
+		cimax = g_spi->cimax;
+		err = aml_cimax_spi_write_reg(cimax, ROUTER_CAM_CH, cm, 2);
+	}
+	return size;
+}
+
+static ssize_t slot_reset_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int err = 0;
+	int slot = 0;
+	struct aml_cimax *cimax = NULL;
+
+	if (!g_spi)
+		return size;
+
+	if (sscanf(buf, "%i", &slot) == 1) {
+		if (slot == 0 || slot == 1) {
+			pr_dbg("reset slot %d\n", slot);
+			cimax = g_spi->cimax;
+			err = aml_cimax_spi_slot_reset(cimax, slot);
+		}
+	}
+	return size;
+}
+
+static ssize_t detect_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int err = 0;
+	int slot = 0;
+	struct aml_cimax *cimax = NULL;
+
+	if (!g_spi)
+		return size;
+
+	if (sscanf(buf, "%i", &slot) == 1) {
+		if (slot == 0 || slot == 1) {
+			int addr = (!slot) ? MOD_CTRL_A : MOD_CTRL_B;
+			u8 reg = 0;
+			cimax = g_spi->cimax;
+			err = aml_cimax_spi_read_reg(cimax, addr, &reg, 1);
+			g_spi->cam_inserted[slot] = reg & 1;
+			pr_dbg("detect slot(%d): %d\n", slot, reg & 1);
+		}
+	}
+	return size;
+}
+
+static struct class_attribute cimax_spi_class_attrs[] = {
+	__ATTR_RW(reset),
+	__ATTR_RO(debug),
+	__ATTR_RW(addr),
+	__ATTR_RW(reg),
+	__ATTR_RW(cis),
+	__ATTR_RO(ts_rate),
+	__ATTR_RW(loop),
+	__ATTR_WO(slot_reset),
+	__ATTR_WO(detect),
+	__ATTR_NULL
+};
+
+static struct class cimax_spi_class = {
+	.name = "cimax_spi",
+	.class_attrs = cimax_spi_class_attrs,
+};
+
+static int aml_cimax_spi_mod_init(void)
+{
+	int ret;
+	pr_dbg("Amlogic CIMAX SPI Init\n");
+	ret = class_register(&cimax_spi_class);
+	return 0;
+}
+
+static void aml_cimax_spi_mod_exit(void)
+{
+	pr_dbg("Amlogic CIMAX SPI Exit\n");
+	class_unregister(&cimax_spi_class);
+}
+
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_spi.h b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_spi.h
new file mode 100644
index 0000000..3548de0
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_spi.h
@@ -0,0 +1,20 @@
+/***************************************************************************
+ * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
+ *
+ * This source code is subject to the terms and conditions defined in the
+ * file 'LICENSE' which is part of this source code package.
+ *
+ * Description:
+ *
+***************************************************************************/
+
+#ifndef _AML_CIMAX_SPI_H_
+#define _AML_CIMAX_SPI_H_
+
+#include <linux/platform_device.h>
+#include "aml_cimax.h"
+
+int aml_cimax_spi_init(struct platform_device *pdev, struct aml_cimax *ci);
+int aml_cimax_spi_exit(struct aml_cimax *ci);
+
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_usb.c b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_usb.c
new file mode 100644
index 0000000..b74b34a
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_usb.c
@@ -0,0 +1,1714 @@
+/***************************************************************************
+ * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
+ *
+ * This source code is subject to the terms and conditions defined in the
+ * file 'LICENSE' which is part of this source code package.
+ *
+ * Description:
+ *
+***************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/of_irq.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+//#include <linux/switch.h>
+
+#include "aml_cimax.h"
+#include "./usb/SRC/cimax+usb-driver.h"
+
+#define MOD_NAME       "aml_cimax_usb"
+
+#define pr_dbg(fmt...)\
+	do {\
+		if (cimax_usb_debug)\
+			pr_info("cimax_usb: "fmt);\
+	} while (0)
+#define pr_inf(fmt...) pr_info("cimax_usb: "fmt)
+#define pr_error(fmt...) pr_err("AML_CIMAX_USB: " fmt)
+
+/*
+  Uncomment below and enable permanent power in cfg
+  to disable dynamic power control mechanism
+*/
+/*#define DISABLE_POWER_PATCH*/
+
+#define BUFFIN_CFG                        0x0000
+#define BUFFIN_ADDR_LSB                   0x0001
+#define BUFFIN_ADDR_MSB                   0x0002
+#define BUFFIN_DATA                       0x0003
+#define BUFFOUT_CFG                       0x0004
+#define BUFFOUT_ADDR_LSB                  0x0005
+#define BUFFOUT_ADDR_MSB                  0x0006
+#define BUFFOUT_DATA                      0x0007
+#define BOOT_Key                          0x0008
+#define BOOT_Status                       0x0009
+#define BOOT_Test                         0x000A
+#define usb2_0_irq_mask                   0x0010
+#define usb2_0_status                     0x0011
+#define usb2_0_rx                         0x0012
+#define usb2_0_tx                         0x0013
+#define SPI_Slave_Ctrl                    0x0018
+#define SPI_Slave_Status                  0x0019
+#define SPI_Slave_Rx                      0x001A
+#define SPI_Slave_Tx                      0x001B
+#define SPI_Slave_Mask                    0x001C
+#define UCSG_Ctrl                         0x0020
+#define UCSG_Status                       0x0021
+#define UCSG_RxData                       0x0022
+#define UCSG_TxData                       0x0023
+#define PCtrl_Ctrl                        0x0028
+#define PCtrl_Status                      0x0029
+#define PCtrl_NbByte_LSB                  0x002A
+#define PCtrl_NbByte_MSB                  0x002B
+#define SPI_Master_Ctl                    0x0030
+#define SPI_Master_NCS                    0x0031
+#define SPI_Master_Status                 0x0032
+#define SPI_Master_TxBuf                  0x0033
+#define SPI_Master_RxBuf                  0x0034
+#define BISTRAM_Ctl                       0x0038
+#define BISTRAM_Bank                      0x0039
+#define BISTRAM_Pat                       0x003A
+#define BISTRAM_SM                        0x003B
+#define BISTRAM_AddrLSB                   0x003C
+#define BISTROM_Config                    0x0040
+#define BISTROM_SignatureLSB              0x0041
+#define BISTROM_SignatureMSB              0x0042
+#define BISTROM_StartAddrLSB              0x0043
+#define BISTROM_StartAddrMSB              0x0043
+#define BISTROM_StopAddrLSB               0x0043
+#define BISTROM_StopAddrMSB               0x0043
+#define CkMan_Config                      0x0048
+#define CkMan_Select                      0x0049
+#define CkMan_Test                        0x004A
+#define Revision_Number                   0x004B
+#define ResMan_Config                     0x0050
+#define ResMan_Status                     0x0051
+#define ResMan_WD                         0x0052
+#define ResMan_WD_MSB                     0x0053
+#define CPU_Test                          0x0060
+#define IrqMan_Config0                    0x0068
+#define IrqMan_Config1                    0x0069
+#define IrqMan_Irq0                       0x006A
+#define IrqMan_NMI                        0x006B
+#define IrqMan_SleepKey                   0x006C
+#define Tim_Config                        0x0070
+#define Tim_Value_LSB                     0x0071
+#define Tim_Value_MSB                     0x0072
+#define Tim_Comp_LSB                      0x0073
+#define Tim_Comp_MSB                      0x0074
+#define TI_Config                         0x0076
+#define TI_Data                           0x0077
+#define TI_Reg0                           0x0078
+#define TI_Reg1                           0x0079
+#define TI_Reg2                           0x007A
+#define TI_Reg3                           0x007B
+#define TI_Reg4                           0x007C
+#define TI_ROM1                           0x007D
+#define TI_ROM2                           0x007E
+#define TI_ROM3                           0x007F
+#define DVBCI_START_ADDR                  0x0100
+#define DVBCI_END_ADDR                    0x017F
+#define DATA                              0x0180
+/*#define CTRL                            0x0181*/
+#define QB_HOST                           0x0182
+#define LEN_HOST_LSB                      0x0183
+#define LEN_HOST_MSB                      0x0184
+#define FIFO_TX_TH_LSB                    0x0185
+#define FIFO_TX_TH_MSB                    0x0186
+#define FIFO_TX_D_NB_LSB                  0x0187
+#define FIFO_TX_D_NB_MSB                  0x0188
+#define QB_MOD_CURR                       0x0189
+#define LEN_MOD_CURR_LSB                  0x018A
+#define LEN_MOD_CURR_MSB                  0x018B
+#define QB_MOD                            0x018C
+#define LEN_MOD_LSB                       0x018D
+#define LEN_MOD_MSB                       0x018E
+#define FIFO_RX_TH_LSB                    0x018F
+#define FIFO_RX_TH_MSB                    0x0190
+#define FIFO_RX_D_NB_LSB                  0x0191
+#define FIFO_RX_D_NB_MSB                  0x0192
+#define IT_STATUS_0                       0x0193
+#define IT_STATUS_1                       0x0194
+#define IT_MASK_0                         0x0195
+#define IT_MASK_1                         0x0196
+#define IT_HOST_PIN_CFG                   0x0200
+#define CFG_0                             0x0201
+#define CFG_1                             0x0202
+#define CFG_2                             0x0203
+#define IT_HOST                           0x0204
+#define MOD_IT_STATUS                     0x0205
+#define MOD_IT_MASK                       0x0206
+#define MOD_CTRL_A                        0x0207
+#define MOD_CTRL_B                        0x0208
+#define DEST_SEL                          0x0209
+#define CAM_MSB_ADD                       0x020A
+#define GPIO0_DIR                         0x020B
+#define GPIO0_DATA_IN                     0x020C
+#define GPIO0_DATA_OUT                    0x020D
+#define GPIO0_STATUS                      0x020E
+#define GPIO0_IT_MASK                     0x020F
+#define GPIO0_DFT                         0x0210
+#define GPIO0_MASK_DATA                   0x0211
+#define GPIO1_DIR                         0x0212
+#define GPIO1_DATA_IN                     0x0213
+#define GPIO1_DATA_OUT                    0x0214
+#define GPIO1_STATUS                      0x0215
+#define GPIO1_IT_MASK                     0x0216
+#define MEM_ACC_TIME_A                    0x0217
+#define MEM_ACC_TIME_B                    0x0218
+#define IO_ACC_TIME_A                     0x0219
+#define IO_ACC_TIME_B                     0x021A
+#define EXT_CH_ACC_TIME_A                 0x021B
+#define EXT_CH_ACC_TIME_B                 0x021C
+#define PAR_IF_0                          0x021D
+#define PAR_IF_1                          0x021E
+#define PAR_IF_CTRL                       0x021F
+#define PCK_LENGTH                        0x0220
+#define USB2TS_CTRL                       0x0221
+#define USB2TS0_RDL                       0x0222
+#define USB2TS1_RDL                       0x0223
+#define TS2USB_CTRL                       0x0224
+#define TSOUT_PAR_CTRL                    0x0225
+#define TSOUT_PAR_CLK_SEL                 0x0226
+#define S2P_CH0_CTRL                      0x0227
+#define S2P_CH1_CTRL                      0x0228
+#define P2S_CH0_CTRL                      0x0229
+#define P2S_CH1_CTRL                      0x022A
+#define TS_IT_STATUS                      0x022B
+#define TS_IT_MASK                        0x022C
+#define IN_SEL                            0x022D
+#define OUT_SEL                           0x022E
+#define ROUTER_CAM_CH                     0x022F
+#define ROUTER_CAM_MOD                    0x0230
+#define FIFO_CTRL                         0x0231
+#define FIFO1_2_STATUS                    0x0232
+#define FIFO3_4_STATUS                    0x0233
+#define GAP_REMOVER_CH0_CTRL              0x0234
+#define GAP_REMOVER_CH1_CTRL              0x0235
+#define SYNC_RTV_CTRL                     0x0236
+#define SYNC_RTV_CH0_SYNC_NB              0x0237
+#define SYNC_RTV_CH0_PATTERN              0x0238
+#define SYNC_RTV_CH1_SYNC_NB              0x0239
+#define SYNC_RTV_CH1_PATTERN              0x023A
+#define SYNC_RTV_OFFSET_PATT              0x023B
+#define CTRL_FILTER                       0x023D
+#define PID_EN_FILTER_CH0                 0x023E
+#define PID_EN_FILTER_CH1                 0x023F
+#define PID_LSB_FILTER_CH0_0              0x0240
+#define PID_MSB_FILTER_CH0_0              0x0241
+#define PID_LSB_FILTER_CH0_1              0x0242
+#define PID_MSB_FILTER_CH0_1              0x0243
+#define PID_LSB_FILTER_CH0_2              0x0244
+#define PID_MSB_FILTER_CH0_2              0x0245
+#define PID_LSB_FILTER_CH0_3              0x0246
+#define PID_MSB_FILTER_CH0_3              0x0247
+#define PID_LSB_FILTER_CH0_4              0x0248
+#define PID_MSB_FILTER_CH0_4              0x0249
+#define PID_LSB_FILTER_CH0_5              0x024A
+#define PID_MSB_FILTER_CH0_5              0x024B
+#define PID_LSB_FILTER_CH0_6              0x024C
+#define PID_MSB_FILTER_CH0_6              0x024D
+#define PID_LSB_FILTER_CH0_7              0x024E
+#define PID_MSB_FILTER_CH0_7              0x024F
+#define PID_LSB_FILTER_CH1_0              0x0260
+#define PID_MSB_FILTER_CH1_0              0x0261
+#define PID_LSB_FILTER_CH1_1              0x0262
+#define PID_MSB_FILTER_CH1_1              0x0263
+#define PID_LSB_FILTER_CH1_2              0x0264
+#define PID_MSB_FILTER_CH1_2              0x0265
+#define PID_LSB_FILTER_CH1_3              0x0266
+#define PID_MSB_FILTER_CH1_3              0x0267
+#define PID_LSB_FILTER_CH1_4              0x0268
+#define PID_MSB_FILTER_CH1_4              0x0269
+#define PID_LSB_FILTER_CH1_5              0x026A
+#define PID_MSB_FILTER_CH1_5              0x026B
+#define PID_LSB_FILTER_CH1_6              0x026C
+#define PID_MSB_FILTER_CH1_6              0x026D
+#define PID_LSB_FILTER_CH1_7              0x026E
+#define PID_MSB_FILTER_CH1_7              0x026F
+#define PID_OLD_LSB_REMAPPER_0            0x0280
+#define PID_OLD_MSB_REMAPPER_0            0x0281
+#define PID_OLD_LSB_REMAPPER_1            0x0282
+#define PID_OLD_MSB_REMAPPER_1            0x0283
+#define PID_OLD_LSB_REMAPPER_2            0x0284
+#define PID_OLD_MSB_REMAPPER_2            0x0285
+#define PID_OLD_LSB_REMAPPER_3            0x0286
+#define PID_OLD_MSB_REMAPPER_3            0x0287
+#define PID_OLD_LSB_REMAPPER_4            0x0288
+#define PID_OLD_MSB_REMAPPER_4            0x0289
+#define PID_OLD_LSB_REMAPPER_5            0x028A
+#define PID_OLD_MSB_REMAPPER_5            0x028B
+#define PID_OLD_LSB_REMAPPER_6            0x028C
+#define PID_OLD_MSB_REMAPPER_6            0x028D
+#define PID_OLD_LSB_REMAPPER_7            0x028E
+#define PID_OLD_MSB_REMAPPER_7            0x028F
+#define PID_NEW_LSB_REMAPPER_0            0x02A0
+#define PID_NEW_MSB_REMAPPER_0            0x02A1
+#define PID_NEW_LSB_REMAPPER_1            0x02A2
+#define PID_NEW_MSB_REMAPPER_1            0x02A3
+#define PID_NEW_LSB_REMAPPER_2            0x02A4
+#define PID_NEW_MSB_REMAPPER_2            0x02A5
+#define PID_NEW_LSB_REMAPPER_3            0x02A6
+#define PID_NEW_MSB_REMAPPER_3            0x02A7
+#define PID_NEW_LSB_REMAPPER_4            0x02A8
+#define PID_NEW_MSB_REMAPPER_4            0x02A9
+#define PID_NEW_LSB_REMAPPER_5            0x02AA
+#define PID_NEW_MSB_REMAPPER_5            0x02AB
+#define PID_NEW_LSB_REMAPPER_6            0x02AC
+#define PID_NEW_MSB_REMAPPER_6            0x02AD
+#define PID_NEW_LSB_REMAPPER_7            0x02AE
+#define PID_NEW_MSB_REMAPPER_7            0x02AF
+#define MERGER_DIV_MICLK                  0x02C0
+#define PID_AND_SYNC_REMAPPER_CTRL        0x02C1
+#define PID_EN_REMAPPER                   0x02C2
+#define SYNC_SYMBOL                       0x02C3
+#define PID_AND_SYNC_REMAPPER_INV_CTRL    0x02C4
+#define BITRATE_CH0_LSB                   0x02C5
+#define BITRATE_CH0_MSB                   0x02C6
+#define BITRATE_CH1_LSB                   0x02C7
+#define BITRATE_CH1_MSB                   0x02C8
+#define STATUS_CLK_SWITCH_0               0x02C9
+#define STATUS_CLK_SWITCH_1               0x02CA
+#define RESET_CLK_SWITCH_0                0x02CB
+#define RESET_CLK_SWITCH_1                0x02CC
+#define PAD_DRVSTR_CTRL                   0x02CD
+#define PAD_PUPD_CTRL                     0x02CE
+#define PRE_HEADER_ADDER_CH0_0            0x02D0
+#define PRE_HEADER_ADDER_CH0_1            0x02D1
+#define PRE_HEADER_ADDER_CH0_2            0x02D2
+#define PRE_HEADER_ADDER_CH0_3            0x02D3
+#define PRE_HEADER_ADDER_CH0_4            0x02D4
+#define PRE_HEADER_ADDER_CH0_5            0x02D5
+#define PRE_HEADER_ADDER_CH0_6            0x02D6
+#define PRE_HEADER_ADDER_CH0_7            0x02D7
+#define PRE_HEADER_ADDER_CH0_8            0x02D8
+#define PRE_HEADER_ADDER_CH0_9            0x02D9
+#define PRE_HEADER_ADDER_CH0_10           0x02DA
+#define PRE_HEADER_ADDER_CH0_11           0x02DB
+#define PRE_HEADER_ADDER_CH1_0            0x02E0
+#define PRE_HEADER_ADDER_CH1_1            0x02E1
+#define PRE_HEADER_ADDER_CH1_2            0x02E2
+#define PRE_HEADER_ADDER_CH1_3            0x02E3
+#define PRE_HEADER_ADDER_CH1_4            0x02E4
+#define PRE_HEADER_ADDER_CH1_5            0x02E5
+#define PRE_HEADER_ADDER_CH1_6            0x02E6
+#define PRE_HEADER_ADDER_CH1_7            0x02E7
+#define PRE_HEADER_ADDER_CH1_8            0x02E8
+#define PRE_HEADER_ADDER_CH1_9            0x02E9
+#define PRE_HEADER_ADDER_CH1_10           0x02EA
+#define PRE_HEADER_ADDER_CH1_11           0x02EB
+#define PRE_HEADER_ADDER_CTRL             0x02EC
+#define PRE_HEADER_ADDER_LEN              0x02ED
+#define PRE_HEADER_REMOVER_CTRL           0x02EE
+#define FSM_DVB                           0x02F0
+#define TS2USB_FSM_DEBUG                  0x02F2
+#define TSOUT_PAR_FSM_DEBUG               0x02F3
+#define GAP_REMOVER_FSM_DEBUG             0x02F4
+#define PID_AND_SYNC_REMAPPER_FSM_DEBUG   0x02F5
+#define PRE_HEADER_ADDER_FSM_DEBUG        0x02F6
+#define SYNC_RTV_FSM_DEBUG                0x02F7
+#define CHECK_PHY_CLK                     0x0E00
+#define USB_CTRL1                         0x0E01
+#define USB_ISO2_out                      0x0800
+#define USB_ISO1_out                      0x1000
+#define USB_Interrupt_out                 0x1E00
+#define USB_Bulk_in                       0x1F00
+#define CC2_Buffer_out                    0x2000
+#define USB_EP0                           0x30C0
+#define CC2_Buffer_in                     0x4000
+#define USB_ISO2_in                       0x5800
+#define USB_ISO1_in                       0x6000
+#define nmb_vector_address_lsb            0xFFFA
+#define nmb_vector_address_msb            0xFFFB
+#define reset_vector_address_lsb          0xFFFC
+#define reset_vector_address_msb          0xFFFD
+#define irb_vector_address_lsb            0xFFFE
+#define irb_vector_address_msb            0xFFFF
+
+
+#define CIMAX_REG_HDR_SIZE 4
+#define CIMAX_REG_PLD_SIZE 255
+#define CIMAX_CAM_HDR_SIZE 4
+#define CIMAX_CAM_PLD_SIZE 65535
+
+#define DEF_LOCK(_l_) struct mutex _l_
+
+struct cimax_usb {
+	struct platform_device *pdev;
+	struct device_s *dev;
+
+	struct aml_cimax *cimax;
+
+	u8 buf[CIMAX_REG_HDR_SIZE + CIMAX_CAM_HDR_SIZE + CIMAX_CAM_PLD_SIZE];
+	int buf_size;
+
+	int cam_inserted[2];
+#define IN_INSERTED 0x01
+#define IN_POWERED  0x02
+#define IN_LINKED   0x04
+	int cam_data_ready[2];
+
+	int poll_mode;
+#define STOP_MODE 0
+#define POLL_MODE 1
+#define INT_MODE  2
+
+	int rst_io;
+
+	struct workqueue_struct *workq;
+	struct delayed_work work;
+	int work_auto_restart;
+	int work_cnt;
+
+	struct delayed_work power_work;
+	int power_work_cnt;
+	int cam_det;
+
+	DEF_LOCK(lock);
+#define lock_init(_usb) mutex_init(&(_usb)->lock)
+#define lock_lock(_usb) do {\
+	int err = mutex_lock_interruptible(&(_usb)->lock);\
+	if (err)\
+		return err;\
+} while (0)
+#define lock_unlock(_usb) mutex_unlock(&(_usb)->lock)
+
+	u8 *cis;
+#define CIS_MAX 512
+};
+
+static struct cimax_usb *g_usb;
+
+MODULE_PARM_DESC(usbdebug, "enable verbose debug messages");
+static int cimax_usb_debug = 1;
+module_param_named(usbdebug, cimax_usb_debug, int, 0644);
+
+MODULE_PARM_DESC(usbpoll_interval, "interval for usb poll");
+static int usb_poll_interval = 100;
+module_param_named(usbpoll_interval, usb_poll_interval, int, 0644);
+
+MODULE_PARM_DESC(usbpoll_mode, "set cimax poll mode, need reset");
+static int cimax_poll_mode = 1;
+module_param_named(usbpoll_mode, cimax_poll_mode, int, 0644);
+
+MODULE_PARM_DESC(usbcam_irq_mode, "set cam irq mode, need reset");
+static int cam_irq_mode;
+module_param_named(usbcam_irq_mode, cam_irq_mode, int, 0644);
+
+
+#define CIMAX_REG_READ     0xff
+#define CIMAX_REG_READ_OK  0x4c
+#define CIMAX_REG_WRITE    0x7f
+#define CIMAX_REG_WRITE_OK 0x4d
+#define CIMAX_REG_INIT     0x00
+#define CIMAX_REG_INIT_OK  0x4b
+#define CIMAX_REG_CMD_ERROR 0x51
+
+#define CIMAX_CAM_RESET    0x01
+#define CIMAX_CAM_RESET_OK 0x40
+#define CIMAX_CAM_CIS      0x02
+#define CIMAX_CAM_CIS_OK   0x41
+#define CIMAX_CAM_COR      0x03
+#define CIMAX_CAM_COR_OK   0x42
+#define CIMAX_CAM_NEG      0x04
+#define CIMAX_CAM_NEG_OK   0x43
+#define CIMAX_CAM_WLPDU    0x05
+#define CIMAX_CAM_WLPDU_OK 0x44
+#define CIMAX_CAM_RLPDU    0x06
+#define CIMAX_CAM_RLPDU_OK 0x46
+#define CIMAX_CAM_EVT         0x0d
+#define CIMAX_CAM_DET_OK      0x45
+#define CIMAX_CAM_NOCAM       0x49
+#define CIMAX_CAM_ERROR       0x4a
+#define CIMAX_CAM_NOEVT       0x55
+#define CIMAX_CAM_DATA_READY  0x4e
+#define CIMAX_CAM_WBUSY       0x54
+#define CIMAX_CAM_PENDING     0x56
+#define CIMAX_CAM_REGSTAT     0x0e
+#define CIMAX_CAM_REGSTAT_OK  0x57
+
+
+#define CIMAX_CAM_PKT_CNT_VAL 1
+
+#define CIMAX_SLOT_A 0
+#define CIMAX_SLOT_B 1
+
+#define CIMAX_CMD_RESP_MASK 0x7f
+
+#define cimax_to_usb(_c) ((struct cimax_usb *)((_c)->priv))
+#define dev_to_usb(_d) ((struct cimax_usb *)usb_get_drvdata(_d))
+
+#define byte_to_u16(_b1, _b2)   (((_b1)<<8) | (_b2))
+
+#define hdr_cmd_resp(_s)     ((_s)->buf[0] & CIMAX_CMD_RESP_MASK)
+
+#define reg_hdr(_s)          ((_s)->buf)
+#define reg_addr(_s)         byte_to_u16((_s)->buf[1], (_s)->buf[2])
+#define reg_hdr_dat_size(_s) ((_s)->buf[3])
+#define reg_dat(_s)          (&((_s)->buf[CIMAX_REG_HDR_SIZE]))
+
+#define cam_hdr(_s)          ((_s)->buf)
+#define cam_hdr_slot(_s)     (((_s)->buf[0] & 0x80) ? 1 : 0)
+#define cam_hdr_pkt_cnt(_s)  ((_s)->buf[1])
+#define cam_hdr_dat_size(_s) byte_to_u16((_s)->buf[2], (_s)->buf[3])
+#define cam_dat(_s)          (&((_s)->buf[CIMAX_CAM_HDR_SIZE]))
+
+#define REG_TIMEOUT 500
+#define CAM_TIMEOUT 5000
+
+static int aml_cimax_usb_mod_init(void);
+static void aml_cimax_usb_mod_exit(void);
+
+static int cimax_usb_set_loop(struct cimax_usb *usb, int loop);
+
+static void dump(char *title, u8 *buf, int size)
+{
+	int i;
+	pr_info("%s\n", title);
+	for (i = 0; i < size; i++) {
+		if (!(i & 0xf))
+			pr_info("\n\t");
+		pr_info("%02x ", *(buf+i));
+	}
+	pr_info("\n");
+}
+
+static void perr(char *err, struct cimax_usb *usb)
+{
+	pr_error("error: %s\n", err);
+	dump("dump:", usb->buf, 16);
+}
+
+static inline unsigned long get_jiffies(void)
+{
+	return (unsigned long)(sched_clock()/10000000);
+}
+
+static int cam_usb_cam_detect(struct cimax_usb *usb, int slot, int flag)
+{
+	usb->cam_inserted[slot] = flag;
+	pr_inf("detect slot(%d): 0x%x(%s)\n",
+		slot, usb->cam_inserted[slot],
+		(!flag) ? "none" :
+		(flag & IN_LINKED) ? "linked" :
+		(flag & IN_POWERED) ? "powered" :
+		(flag & IN_INSERTED) ? "inserted" :
+		"unknown");
+	aml_cimax_slot_state_changed(usb->cimax, slot,
+		usb->cam_inserted[slot]);
+	return 0;
+}
+
+static inline void set_usb_cam_ready(struct cimax_usb *usb, int slot)
+{
+	if (usb->cam_inserted[slot] & IN_POWERED) {
+		cam_usb_cam_detect(usb, slot,
+			usb->cam_inserted[slot] | IN_LINKED);
+		cimax_usb_set_loop(usb, 1);/*set auto-loop*/
+	}
+}
+
+static int init_reg_hdr(u8 *hdr, u8 tag, int addr, int size)
+{
+	hdr[0] = tag;
+	hdr[1] = (addr>>8) & 0xff;
+	hdr[2] = addr & 0xff;
+	hdr[3] = size;
+	return 0;
+}
+
+static int check_reg_hdr(u8 *hdr, u8 tag, int addr, int size)
+{
+	return hdr[0] != tag
+		|| hdr[1] != ((addr>>8) & 0xff)
+		|| hdr[2] != (addr & 0xff)
+		|| hdr[3] != size;
+}
+
+static int aml_cimax_usb_read_reg(struct aml_cimax *cimax, int addr,
+		u8 *buf, int size)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	struct device_s *dev = usb->dev;
+	u8 out[CIMAX_REG_HDR_SIZE];
+	int err = 0;
+
+	init_reg_hdr(out, CIMAX_REG_READ, addr, size);
+
+	lock_lock(usb);
+
+	/*pr_dbg("rd %02x:%02x:%02x:%02x\n",
+		out[0], out[1],
+		out[2], out[3]);*/
+	err = cimax_usb_ci_write(dev,
+			out, CIMAX_REG_HDR_SIZE, usb->buf, sizeof(usb->buf));
+	if (err)
+		goto end;
+	if (check_reg_hdr(reg_hdr(usb), CIMAX_REG_READ_OK, addr, size) != 0) {
+		pr_dbg("rd %02x:%02x:%02x:%02x\n",
+			out[0], out[1],
+			out[2], out[3]);
+		perr("read reg fail.", usb);
+		err = -EINVAL;
+		goto end;
+	}
+	memcpy(buf, reg_dat(usb), size);
+end:
+	lock_unlock(usb);
+	return err;
+}
+
+static int aml_cimax_usb_write_reg(struct aml_cimax *cimax, int addr,
+		u8 *buf, int size)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	struct device_s *dev = usb->dev;
+	u8 out[CIMAX_REG_HDR_SIZE + CIMAX_REG_PLD_SIZE];
+	int err = 0;
+
+	init_reg_hdr(out, CIMAX_REG_WRITE, addr, size);
+	memcpy(&out[CIMAX_REG_HDR_SIZE], buf, size);
+
+	lock_lock(usb);
+
+	pr_dbg("wr %02x:%02x:%02x:%02x\n",
+		out[0], out[1],
+		out[2], out[3]);
+	err = cimax_usb_ci_write(dev,
+		out, CIMAX_REG_HDR_SIZE + size, usb->buf, sizeof(usb->buf));
+	if (err)
+		goto end;
+	if (check_reg_hdr(reg_hdr(usb), CIMAX_REG_WRITE_OK, addr, 0) != 0) {
+		perr("write reg fail.", usb);
+		err = -EINVAL;
+		goto end;
+	}
+end:
+	lock_unlock(usb);
+	return err;
+}
+
+static inline int init_cam_hdr(u8 *hdr, int cmd, int size)
+{
+	hdr[0] = cmd;
+	hdr[1] = CIMAX_CAM_PKT_CNT_VAL;
+	hdr[2] = (size>>8) & 0xff;
+	hdr[3] = size & 0xff;
+	return 0;
+}
+
+static inline int cam_err(struct cimax_usb *usb)
+{
+	if (hdr_cmd_resp(usb) != CIMAX_CAM_ERROR
+		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(usb) != 2)
+		return 0;
+	return byte_to_u16(cam_dat(usb)[0], cam_dat(usb)[1]);
+}
+
+static inline char *cam_err_str(int err)
+{
+#define CAMERROR_RESET           0x0101
+#define CAMERROR_CIS_BUF         0x0201
+#define CAMERROR_CIS_SIZE        0x0202
+#define CAMERROR_CAM_NOT_ACT     0x0203
+#define CAMERROR_COR_NOT_READY   0x0301
+#define CAMERROR_COR_VAL_CHK     0x0302
+#define CAMERROR_NEG_NO_RESP     0x0401
+#define CAMERROR_NEG_BAD_SIZE    0x0402
+#define CAMERROR_NEG_NOT_READY   0x0403
+#define CAMERROR_LPDU_NOT_AVAIL  0x0601
+	struct { int err; char *str; } cam_err_strings[] = {
+		{CAMERROR_RESET, "reset error, not ready."},
+		{CAMERROR_CIS_BUF, "cis error, buffer not allocated."},
+		{CAMERROR_CIS_SIZE, "cis error, bad cis size."},
+		{CAMERROR_CAM_NOT_ACT, "cam not activated."},
+		{CAMERROR_COR_NOT_READY, "cam not ready during write COR."},
+		{CAMERROR_COR_VAL_CHK, "COR value check failed."},
+		{CAMERROR_NEG_NO_RESP, "cam not responding when negotiation."},
+		{CAMERROR_NEG_BAD_SIZE, "cam buf size length != 2."},
+		{CAMERROR_NEG_NOT_READY, "cam not ready during negotiation."},
+		{CAMERROR_LPDU_NOT_AVAIL, "lpdu not available."}
+	};
+	int i;
+	for (i = 0;
+		i < sizeof(cam_err_strings)/sizeof(cam_err_strings[0]); i++) {
+		if (cam_err_strings[i].err == err)
+			return cam_err_strings[i].str;
+	}
+	return "err unknown.";
+}
+
+static int cimax_usb_access_cam(struct cimax_usb *usb, int slot,
+		int cmd, u8 *tx, int tx_size, u8 *rx, int rx_size)
+{
+	struct device_s *dev = usb->dev;
+	u8 *out = NULL;
+	int err = 0;
+
+	out = kzalloc(CIMAX_CAM_HDR_SIZE + CIMAX_CAM_PLD_SIZE, GFP_KERNEL);
+	if (!out) {
+		pr_err("no mem for access cam.\n");
+		return -ENOMEM;
+	}
+
+	cmd |= slot ? 0x80 : 0;
+	init_cam_hdr(out, cmd, tx_size);
+	memcpy(&out[CIMAX_CAM_HDR_SIZE], tx, tx_size);
+	/*dump("access cam:", out, CIMAX_CAM_HDR_SIZE+size);*/
+
+	lock_lock(usb);
+
+	err = cimax_usb_ci_write(dev,
+			out, CIMAX_CAM_HDR_SIZE + tx_size, rx, rx_size);
+	if (err)
+		goto end;
+	if (cam_hdr_slot(usb) != slot) {
+		pr_error("expect slot(%d), but slot(%d)\n",
+			slot, cam_hdr_slot(usb));
+		err = -EINVAL;
+		goto end;
+	}
+	switch (hdr_cmd_resp(usb)) {
+	case CIMAX_CAM_NOCAM:
+		pr_dbg("no cam\n");
+		err = -ENODEV;
+		break;
+	case CIMAX_CAM_ERROR:
+		pr_error("cam error\n");
+		pr_error("err code: 0x%04x(%s)\n", cam_err(usb),
+			cam_err_str(cam_err(usb)));
+		err = -ENODEV;
+		break;
+	case CIMAX_CAM_WBUSY:
+		pr_dbg("cam busy\n");
+		err = -EBUSY;
+		break;
+	case CIMAX_CAM_PENDING:
+		pr_dbg("cam pending\n");
+		err = -EAGAIN;
+		break;
+	}
+end:
+	kfree(out);
+	lock_unlock(usb);
+	return err;
+}
+
+static int aml_cimax_usb_read_cis(struct aml_cimax *cimax, int slot,
+		u8 *buf, int size)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	int err = 0;
+	int len;
+
+	err = cimax_usb_access_cam(usb, slot, CIMAX_CAM_CIS,
+		NULL, 0, usb->buf, sizeof(usb->buf));
+	if (err)
+		goto end;
+	if (hdr_cmd_resp(usb) != CIMAX_CAM_CIS_OK
+		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL) {
+		perr("read cis fail.", usb);
+		err = -EINVAL;
+		goto end;
+	}
+	len = cam_hdr_dat_size(usb);
+	if (size < len) {
+		pr_error("cis size too large, expect<%d, but:%d\n", size, len);
+		perr("cis fail.", usb);
+		err = -EINVAL;
+		goto end;
+	}
+	memcpy(buf, cam_dat(usb), len);
+
+	if (!usb->cis)
+		usb->cis = kzalloc((len < 512) ? 512 : len, GFP_KERNEL);
+	if (usb->cis)
+		memcpy(usb->cis, cam_dat(usb), len);
+
+end:
+	return err;
+}
+#define CIMAX_CAM_COR_PLD_SIZE 5
+static int aml_cimax_usb_write_cor(struct aml_cimax *cimax, int slot,
+		int addr, u8 *buf)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	int err = 0;
+	u8 out[CIMAX_CAM_COR_PLD_SIZE + 8];
+	int sz = CIMAX_CAM_COR_PLD_SIZE;
+
+	out[0] = addr>>8 & 0xff;
+	out[1] = addr & 0xff;
+	out[2] = buf[0];
+	out[3] = 0;
+	out[4] = 0;
+
+	if (!cam_irq_mode) {
+		out[5] = 0x40;/*cam poll mode*/
+		sz++;
+	}
+
+	err = cimax_usb_access_cam(usb, slot, CIMAX_CAM_COR,
+			out, sz, usb->buf, sizeof(usb->buf));
+	if (err)
+		goto end;
+	if (hdr_cmd_resp(usb) != CIMAX_CAM_COR_OK
+		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(usb) != 0) {
+		perr("write cor fail.", usb);
+		err = -EINVAL;
+		goto end;
+	}
+end:
+	return err;
+}
+#define CIMAX_CAM_NEG_PLD_SIZE 2
+static int aml_cimax_usb_negotiate(struct aml_cimax *cimax, int slot, int size)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	int ret = 0;
+	u8 out[CIMAX_CAM_NEG_PLD_SIZE];
+
+	out[0] = (size>>8) & 0xff;
+	out[1] = size & 0xff;
+
+	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_NEG,
+			out, CIMAX_CAM_NEG_PLD_SIZE,
+			usb->buf, sizeof(usb->buf));
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(usb) != CIMAX_CAM_NEG_OK
+		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(usb) != 2) {
+		perr("negotiate fail.", usb);
+		ret = -EINVAL;
+		goto end;
+	}
+	ret = byte_to_u16(cam_dat(usb)[0], cam_dat(usb)[1]);
+
+	set_usb_cam_ready(usb, slot);
+end:
+	return ret;
+}
+
+static int aml_cimax_usb_write_lpdu(struct aml_cimax *cimax, int slot,
+		u8 *buf, int size)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	int ret = 0;
+
+	/*dump("lpdu ->", buf, size);*/
+	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_WLPDU,
+		buf, size, usb->buf, sizeof(usb->buf));
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(usb) != CIMAX_CAM_WLPDU_OK
+		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(usb) != 0) {
+		perr("write lpdu fail.", usb);
+		ret = -EINVAL;
+		goto end;
+	}
+	ret = size;
+end:
+	return ret;
+}
+
+static int aml_cimax_usb_read_lpdu(struct aml_cimax *cimax, int slot,
+		u8 *buf, int size)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	int ret = 0;
+
+	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_RLPDU,
+		NULL, 0, usb->buf, sizeof(usb->buf));
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(usb) != CIMAX_CAM_RLPDU_OK
+		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL) {
+		perr("read lpdu fail.", usb);
+		ret = -EINVAL;
+		goto end;
+	}
+	ret = cam_hdr_dat_size(usb);
+	memcpy(buf, cam_dat(usb), ret);
+
+	/*dump("lpdu <-", buf, ret);*/
+
+	usb->cam_data_ready[slot] = 0;
+end:
+	return ret;
+}
+
+static int aml_cimax_usb_read_cam_status(struct aml_cimax *cimax, int slot)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	int ret = 0;
+
+	if (cam_irq_mode && usb->cam_data_ready[slot])
+		return 0x80;
+
+	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_REGSTAT,
+		NULL, 0, usb->buf, sizeof(usb->buf));
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(usb) != CIMAX_CAM_REGSTAT_OK
+		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(usb) != 1) {
+		perr("read cam status fail.", usb);
+		ret = -EINVAL;
+		goto end;
+	}
+
+	ret = cam_dat(usb)[0];
+end:
+	return ret;
+}
+
+static int aml_cimax_usb_slot_reset(struct aml_cimax *cimax, int slot)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	int ret = 0;
+
+	usb->cam_data_ready[slot] = 0;
+
+	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_RESET,
+		NULL, 0, usb->buf, sizeof(usb->buf));
+	if (ret)
+		goto end;
+	if (hdr_cmd_resp(usb) != CIMAX_CAM_RESET_OK
+		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
+		|| cam_hdr_dat_size(usb) != 0) {
+		perr("slot reset fail.", usb);
+		ret = -EINVAL;
+		goto end;
+	}
+end:
+	return ret;
+}
+
+static int aml_cimax_usb_cam_reset(struct aml_cimax *cimax, int slot)
+{
+	pr_dbg("Slot(%d): camreset\n", slot);
+	return 0;
+}
+
+static int aml_cimax_usb_slot_shutdown(struct aml_cimax *cimax, int slot)
+{
+	pr_dbg("Slot(%d): shutdown\n", slot);
+	return 0;
+}
+static int aml_cimax_usb_slot_ts_enable(struct aml_cimax *cimax, int slot)
+{
+	pr_dbg("Slot(%d): ts control\n", slot);
+	return 0;
+}
+static int aml_cimax_usb_slot_status(struct aml_cimax *cimax, int slot)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+	if (usb->cam_inserted[slot] & IN_POWERED) {
+		/*pr_dbg("CA Module present and ready\n");*/
+		return DVB_CA_EN50221_POLL_CAM_PRESENT |
+			DVB_CA_EN50221_POLL_CAM_READY;
+	} else {
+		/*pr_error("CA Module not present or not ready\n");*/
+	}
+	return 0;
+}
+
+static int cimax_usb_cam_plugin(struct cimax_usb *usb, int slot, int plugin)
+{
+	pr_dbg("cam plug: slot(%d) %s\n",
+		slot, plugin ? "plugged" : "unplugged");
+	return aml_cimax_camchanged(usb->cimax, slot, plugin);
+}
+
+static int cimax_usb_set_power(struct cimax_usb *usb, int on)
+{
+	u8 reg = 0;
+	int err = 0;
+	if (!on) {
+		reg = 0;
+		err = aml_cimax_usb_read_reg(usb->cimax, MOD_IT_MASK, &reg, 1);
+		if (err)
+			return err;
+		reg |= 0x03;
+		reg &= 0xf3;
+
+		err = aml_cimax_usb_write_reg(usb->cimax, MOD_IT_MASK, &reg, 1);
+		if (err)
+			return err;
+	}
+	reg = on ? 0x3 : 0x0;
+	return aml_cimax_usb_write_reg(usb->cimax, GPIO0_DATA_OUT, &reg, 1);
+}
+
+static int cimax_usb_check_poe(struct cimax_usb *usb, int *on)
+{
+	u8 reg = 0;
+	int err = 0;
+
+	*on = 0;
+
+	err = aml_cimax_usb_read_reg(usb->cimax, CFG_1, &reg, 1);
+	if (err)
+		return err;
+	if (reg & 0x20) {/*if VCCEN*/
+		reg |= 0x08;/*set POE*/
+		err = aml_cimax_usb_write_reg(usb->cimax, CFG_1, &reg, 1);
+		if (err)
+			return err;
+		err = aml_cimax_usb_read_reg(usb->cimax, CFG_1, &reg, 1);
+		if (err)
+			return err;
+		if (reg & 0x08)/*if POE ok*/
+			*on = 1;
+	}
+	return err;
+}
+
+static void cimax_usb_power_work(struct work_struct *work)
+{
+	struct cimax_usb *usb = container_of(to_delayed_work(work),
+		struct cimax_usb, power_work);
+	int power = 0;
+	int err = 0;
+
+	usb->power_work_cnt++;
+	err = cimax_usb_set_power(usb, 1);
+	if (err)
+		return;
+
+	err = cimax_usb_check_poe(usb, &power);
+	if (err)
+		return;
+
+	if (power) {
+		return;
+	}
+
+	schedule_delayed_work(&usb->power_work, usb_poll_interval);
+}
+
+static int cimax_usb_cam_powerctrl(struct cimax_usb *usb,
+		int slot, int power)
+{
+	if (slot != 0)
+		return 0;
+
+#ifdef DISABLE_POWER_PATCH
+	if (power) {
+		cam_usb_cam_detect(usb, slot,
+			usb->cam_inserted[slot] | IN_POWERED);
+		cimax_usb_cam_plugin(usb, slot, 1);
+	}
+	return 0;
+#else
+	pr_inf("cancel power ctrl previous\n");
+	cancel_delayed_work_sync(&usb->power_work);
+
+	if (!power) {
+		int err = 0;
+		err = cimax_usb_set_power(usb, 0);
+		pr_inf("slot[%d] power off\n", slot);
+		return 0;
+	}
+
+	INIT_DELAYED_WORK(&usb->power_work, &cimax_usb_power_work);
+	schedule_delayed_work(&usb->power_work, usb_poll_interval);
+	pr_inf("slot[%d] power ctrl started\n", slot);
+#endif
+	return 0;
+}
+
+static int cimax_usb_poll(struct cimax_usb *usb)
+{
+	struct device_s *dev = usb->dev;
+	int power = 0;
+	int err = 0;
+	int slot = 0;
+
+	if (!usb->cam_det) {
+		for (slot = 0; slot < 2; slot++) {
+			int addr = (!slot) ? MOD_CTRL_A : MOD_CTRL_B;
+			u8 reg = 0;
+			err = aml_cimax_usb_read_reg(usb->cimax,
+					addr, &reg, 1);
+			if (reg & 1) {
+				cam_usb_cam_detect(usb, slot,
+					(reg & 1) ? IN_INSERTED : 0);
+				msleep(200);
+				err = cimax_usb_set_power(usb, (reg & 1));
+				err = cimax_usb_check_poe(usb, &power);
+				pr_inf("slot[%d] power on\n", slot);
+				msleep(200);
+				if (power) {
+					cam_usb_cam_detect(usb, slot,
+					usb->cam_inserted[slot] | IN_POWERED);
+					cimax_usb_cam_plugin(usb, slot, 1);
+					usb->cam_det = 1;
+				}
+			}
+		}
+		return 0;
+	}
+	err = cimax_usb_ci_read_evt(dev, CIMAX_SLOT_A,
+			usb->buf, sizeof(usb->buf));
+	if (err)
+		goto end;
+
+	switch (hdr_cmd_resp(usb)) {
+	case CIMAX_CAM_DET_OK: {
+		int slot = cam_hdr_slot(usb);
+		int insert = cam_dat(usb)[0];
+		if ((!!usb->cam_inserted[slot]) != insert) {
+			cam_usb_cam_detect(usb, slot,
+				insert ? IN_INSERTED : 0);
+			cimax_usb_cam_powerctrl(usb, slot, insert);
+		}
+		if (!insert)
+			usb->cam_det = 0;
+		} break;
+	case CIMAX_CAM_DATA_READY: {
+		int slot = cam_hdr_slot(usb);
+		usb->cam_data_ready[slot] = 1;
+		} break;
+	case CIMAX_CAM_NOEVT:
+		break;
+	default:
+		pr_error("unknown resp:%02x\n", hdr_cmd_resp(usb));
+		break;
+	}
+end:
+	return 0;
+}
+
+static void cimax_usb_poll_work(struct work_struct *work)
+{
+	struct cimax_usb *usb =
+		container_of(to_delayed_work(work), struct cimax_usb, work);
+	usb->work_cnt++;
+	cimax_usb_poll(usb);
+	if (usb->work_auto_restart)
+		queue_delayed_work(usb->workq, &usb->work, usb_poll_interval);
+}
+
+#define CTRL_DISABLE -1
+#define CTRL_STOP     0
+#define CTRL_START    1
+
+static inline int cimax_usb_poll_ctrl(struct cimax_usb *usb, int ctrl)
+{
+	if (ctrl == CTRL_START) {
+		if (usb->workq)
+			return 0;
+		usb->work_auto_restart = 1;
+		usb->workq = create_singlethread_workqueue("cimax_usb");
+		INIT_DELAYED_WORK(&usb->work, &cimax_usb_poll_work);
+		queue_delayed_work(usb->workq,
+			&usb->work, usb_poll_interval);
+		pr_inf("poll started\n");
+	} else {
+		if (!usb->workq)
+			return 0;
+		usb->work_auto_restart = 0;
+		cancel_delayed_work_sync(&usb->work);
+		destroy_workqueue(usb->workq);
+		usb->workq = NULL;
+		pr_inf("poll stopped\n");
+	}
+	return 0;
+}
+
+static int cimax_usb_setup_poll(struct cimax_usb *usb, int poll_mode)
+{
+	if (poll_mode == usb->poll_mode)
+		return 0;
+	switch (poll_mode) {
+	case POLL_MODE:
+		cimax_usb_poll_ctrl(usb, CTRL_START);
+		usb->poll_mode = POLL_MODE;
+		break;
+	case STOP_MODE:
+		if (usb->poll_mode == POLL_MODE)
+			cimax_usb_poll_ctrl(usb, CTRL_DISABLE);
+		usb->poll_mode = STOP_MODE;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int cimax_usb_hw_reset(struct cimax_usb *usb, int reset_val)
+{
+	/*trigger reset io*/
+	if (usb->rst_io) {
+		gpio_direction_output(usb->rst_io, reset_val ? 1 : 0);
+		msleep(50);
+		gpio_direction_output(usb->rst_io, reset_val ? 0 : 1);
+	}
+	return 0;
+}
+
+static int cimax_usb_set_loop(struct cimax_usb *usb, int loop)
+{
+	int a = usb->cam_inserted[0];
+	int b = usb->cam_inserted[1];
+	u8 cm[2];
+
+	pr_inf("set loop: %d\n", loop);
+
+	cm[0] = loop ? (b ? 0x85 : 0x80) : 0x81;/*CH*/
+	cm[1] = loop ? (a ? 0x51 : 0x11) : 0x00;/*MOD*/
+
+	return aml_cimax_usb_write_reg(usb->cimax, ROUTER_CAM_CH, cm, 2);
+}
+
+int cimax_usb_dev_add(struct device_s *dev, int id)
+{
+	pr_inf("dev add\n");
+	if (!g_usb)
+		return 0;
+
+	id = id;
+
+	cimax_usb_device_open(dev);
+	cimax_usb_select_interface(dev, 3);
+
+	lock_lock(g_usb);
+	g_usb->dev = dev;
+	lock_unlock(g_usb);
+
+	if (0)
+	{
+		/*
+		  the cimax's fw do not report cam status
+		  when board power on with cam plugged,
+		  have to check manually here.
+		*/
+		int slot = 0;
+		int err = 0;
+		for (slot = 0; slot < 2; slot++) {
+			int addr = (!slot) ? MOD_CTRL_A : MOD_CTRL_B;
+			u8 reg = 0;
+			err = aml_cimax_usb_read_reg(g_usb->cimax,
+					addr, &reg, 1);
+			cam_usb_cam_detect(g_usb, slot,
+				(reg & 1) ? IN_INSERTED : 0);
+			cimax_usb_cam_powerctrl(g_usb, slot, (reg & 1));
+		}
+	}
+	cimax_usb_set_power(g_usb, 0);
+	cimax_usb_setup_poll(g_usb, cimax_poll_mode ? POLL_MODE : INT_MODE);
+	return 0;
+}
+EXPORT_SYMBOL(cimax_usb_dev_add);
+
+int cimax_usb_dev_remove(struct device_s *dev, int id)
+{
+	pr_dbg("dev remove\n");
+	if (!g_usb)
+		return 0;
+	id = id;
+	pr_dbg("setup poll -> stop\n");
+	cimax_usb_setup_poll(g_usb, STOP_MODE);
+	pr_dbg("setup poll end\n");
+	lock_lock(g_usb);
+	g_usb->dev = NULL;
+	lock_unlock(g_usb);
+	return 0;
+}
+EXPORT_SYMBOL(cimax_usb_dev_remove);
+
+static int cimax_usb_get_config_from_dts(struct cimax_usb *usb)
+{
+	struct device_node *child = NULL;
+	struct platform_device *pdev = usb->pdev;
+	struct device_node *np = pdev->dev.of_node;
+	pr_dbg("fetch cimax usb in dts\n");
+
+	child = of_get_child_by_name(np, "cimax");
+	if (child == NULL) {
+		pr_error("cimax not found in dts\n");
+		return -1;
+	}
+	child = of_get_child_by_name(child, "usb");
+	if (!child) {
+		pr_error("usb not found in cimax");
+		return -1;
+	}
+/*
+dvbci {
+	compatible = "amlogic, dvbci";
+	dev_name = "dvbci";
+	io_type = <2>;//0:iobus,1:usb,2:cimax
+	cimax {
+		io_type = <1> //0:spi 1:usb
+		usb {
+			rst_gpio = <&gpio_ao GPIOAO_2 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+};
+*/
+	{
+		int ret = 0;
+		int gpio = -1;
+		gpio = of_get_named_gpio_flags(child, "rst-gpios", 0, NULL);
+		if (gpio != -1) {
+			ret = gpio_request(gpio, "cimax");
+			if (ret < 0) {
+				pr_error("rst-gpios request fail.\n");
+				return ret;
+			}
+			usb->rst_io = gpio;
+			cimax_usb_hw_reset(usb, 1);
+			pr_dbg("rst: %d\n", usb->rst_io);
+		} else {
+			pr_error("rst io got fail, %d\n", gpio);
+		}
+	}
+	return 0;
+}
+
+int aml_cimax_usb_init(struct platform_device *pdev, struct aml_cimax *cimax)
+{
+	struct cimax_usb *cimax_usb;
+
+	cimax_usb = kzalloc(sizeof(struct cimax_usb), GFP_KERNEL);
+	if (!cimax_usb)
+		return -ENOMEM;
+
+	cimax_usb->pdev = pdev;
+	cimax_usb->cimax = cimax;
+	cimax_usb_get_config_from_dts(cimax_usb);
+
+	/*init usb_lock*/
+	lock_init(cimax_usb);
+
+	/*init cimax used api.*/
+#define WI(_f)\
+	cimax->ops._f = aml_cimax_usb_##_f
+	WI(read_cis);
+	WI(write_cor);
+	WI(negotiate);
+	WI(read_lpdu);
+	WI(write_lpdu);
+	WI(read_cam_status);
+	WI(cam_reset);
+	WI(slot_reset);
+	WI(slot_shutdown);
+	WI(slot_ts_enable);
+	WI(slot_status);
+	WI(read_reg);
+	WI(write_reg);
+
+	cimax->priv = cimax_usb;
+
+	g_usb = cimax_usb;
+
+	aml_cimax_usb_mod_init();
+
+	cimax_usb_set_cb(cimax_usb_dev_add, cimax_usb_dev_remove);
+
+	return 0;
+}
+EXPORT_SYMBOL(aml_cimax_usb_init);
+
+int aml_cimax_usb_exit(struct aml_cimax *cimax)
+{
+	struct cimax_usb *usb = cimax_to_usb(cimax);
+
+	if (!usb)
+		return -ENODEV;
+
+	aml_cimax_usb_mod_exit();
+
+	cimax_usb_device_close(usb->dev);
+	cimax_usb_setup_poll(usb, STOP_MODE);
+
+	if (usb->rst_io)
+		gpio_free(usb->rst_io);
+
+	kfree(usb->cis);
+
+	kfree(usb);
+	cimax->priv = NULL;
+
+	g_usb = NULL;
+	return 0;
+}
+EXPORT_SYMBOL(aml_cimax_usb_exit);
+
+static int cimax_usb_reset(struct cimax_usb *usb, int reset_val)
+{
+	pr_dbg("reset usb:%p, rst:%d\n", usb, usb ? usb->rst_io : -1);
+	if (!usb)
+		return -ENODEV;
+
+	pr_inf("cimax usb reset\n");
+
+	/*notify unplugged*/
+	aml_cimax_camchanged(usb->cimax, 0, 0);
+	aml_cimax_camchanged(usb->cimax, 1, 0);
+
+	if (usb->dev)
+		cimax_usb_device_close(usb->dev);
+
+	cimax_usb_setup_poll(usb, STOP_MODE);
+
+	usb->cam_inserted[0] = usb->cam_inserted[1] = 0;
+	usb->cam_data_ready[0] = usb->cam_data_ready[1] = 0;
+
+	cimax_usb_hw_reset(usb, reset_val);
+
+	pr_inf("cimax usb reset end\n");
+	return 0;
+}
+
+static ssize_t reset_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "echo 1 > %s\n", attr->attr.name);
+	return ret;
+}
+
+static ssize_t reset_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int ret;
+	int val = 0;
+	if (!g_usb)
+		return size;
+	ret = sscanf(buf, "%i", &val);
+	if (ret == 1)
+		ret = cimax_usb_reset(g_usb, val);
+	return size;
+}
+
+static ssize_t debug_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	if (!g_usb)
+		return ret;
+
+	ret = sprintf(buf, "poll mode: %d\n", g_usb->poll_mode);
+	ret += sprintf(buf+ret, "status slot[0]=[%d] slot[1]=[%d]\n",
+		g_usb->cam_inserted[0], g_usb->cam_inserted[1]);
+	{
+		int power = 0;
+		int err = cimax_usb_check_poe(g_usb, &power);
+		ret += sprintf(buf+ret, "power slot[0]=[%d] slot[1]=[%d]\n",
+			err ? -1 : power, 0);
+	}
+	ret += sprintf(buf+ret, "data slot[0]=[%d] slot[1]=[%d]\n",
+		g_usb->cam_data_ready[0], g_usb->cam_data_ready[1]);
+	ret += sprintf(buf+ret, "work cnt:%d\n", g_usb->work_cnt);
+	ret += sprintf(buf+ret, "pwr work cnt:%d\n", g_usb->power_work_cnt);
+	return ret;
+}
+
+static int reg_addr;
+static ssize_t addr_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	ret = sprintf(buf, "addr = 0x%04x\n", reg_addr);
+	return ret;
+}
+
+static ssize_t addr_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	if (!g_usb)
+		return size;
+	if (sscanf(buf, "%i", &reg_addr) != 1)
+		return size;
+	return size;
+}
+
+static ssize_t reg_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	u8 reg_val = 0;
+	struct aml_cimax *cimax = NULL;
+
+	if (!g_usb)
+		return ret;
+
+	cimax = g_usb->cimax;
+	ret = aml_cimax_usb_read_reg(cimax, reg_addr, &reg_val, 1);
+	if (ret)
+		ret = sprintf(buf, "read fail, err=%d\n", ret);
+	else
+		ret = sprintf(buf, "reg[0x%04x] = 0x%02x\n", reg_addr, reg_val);
+	return ret;
+}
+
+static ssize_t reg_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int ret = 0;
+	struct aml_cimax *cimax = NULL;
+	int val = 0;
+	u8 reg_val = 0;
+
+	if (!g_usb)
+		return size;
+
+	if (sscanf(buf, "%i", &val) != 1)
+		return size;
+	reg_val = val;
+	cimax = g_usb->cimax;
+	ret = aml_cimax_usb_write_reg(cimax, reg_addr, &reg_val, 1);
+	if (ret)
+		return ret;
+	return size;
+}
+
+static int cis_mode; /*0:hex 1:binary*/
+static ssize_t cis_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+
+	if (!g_usb || !g_usb->cis)
+		return ret;
+
+	if (cis_mode == 0) {
+		int i;
+		for (i = 0; i < CIS_MAX; i++) {
+			if (i && !(i & 0xf))
+				ret += sprintf(buf+ret, "\n");
+			ret += sprintf(buf+ret, "%02X ", g_usb->cis[i]);
+		}
+		ret += sprintf(buf+ret, "\n");
+		return ret;
+	} else {
+		memcpy(buf, g_usb->cis, CIS_MAX);
+		return CIS_MAX;
+	}
+	return ret;
+}
+
+static ssize_t cis_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	if (size >= 3
+		&& !memcmp(buf, "bin", 3))
+		cis_mode = 1;
+	else
+		cis_mode = 0;
+	return size;
+}
+
+static ssize_t ts_rate_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	u8 lsb = 0, msb = 0, plen = 0;
+	struct aml_cimax *cimax = NULL;
+	int err = 0;
+
+	if (!g_usb)
+		return ret;
+
+	cimax = g_usb->cimax;
+	err = aml_cimax_usb_read_reg(cimax, PCK_LENGTH, &plen, 1);
+	err |= aml_cimax_usb_read_reg(cimax, BITRATE_CH0_LSB, &lsb, 1);
+	err |= aml_cimax_usb_read_reg(cimax, BITRATE_CH0_MSB, &msb, 1);
+	if (err)
+		ret += sprintf(buf+ret, "read fail, err=%d\n", err);
+	else if (!byte_to_u16(msb, lsb))
+		ret += sprintf(buf+ret, "rate[0] = 0 Kbps\n");
+	else
+		ret += sprintf(buf+ret, "rate[0] = %d Kbps\n",
+			540*plen*8/byte_to_u16(msb, lsb));
+	if (err)
+		return ret;
+
+	err = aml_cimax_usb_read_reg(cimax, BITRATE_CH1_LSB, &lsb, 1);
+	err |= aml_cimax_usb_read_reg(cimax, BITRATE_CH1_MSB, &msb, 1);
+	if (err)
+		ret += sprintf(buf+ret, "read fail, err=%d\n", err);
+	else if (!byte_to_u16(msb, lsb))
+		ret += sprintf(buf+ret, "rate[1] = 0 Kbps\n");
+	else
+		ret += sprintf(buf+ret, "rate[1] = %d Kbps\n",
+			540*plen*8/byte_to_u16(msb, lsb));
+	return ret;
+}
+
+static ssize_t loop_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	u8 ch = 0, mod = 0;
+	struct aml_cimax *cimax = NULL;
+	int err = 0;
+
+	if (!g_usb)
+		return ret;
+
+	cimax = g_usb->cimax;
+	err = aml_cimax_usb_read_reg(cimax, ROUTER_CAM_CH, &ch, 1);
+	err |= aml_cimax_usb_read_reg(cimax, ROUTER_CAM_MOD, &mod, 1);
+	if (err) {
+		ret = sprintf(buf, "read fail, err=%d\n", err);
+		return ret;
+	}
+	ret += sprintf(buf + ret, "OUT-0 <= ");
+	switch (ch & 0x0f) {
+	case 0x0:
+		ret += sprintf(buf + ret, "CAM-A"); break;
+	case 0x1:
+		ret += sprintf(buf + ret, "CH0-IN"); break;
+	case 0x2:
+		ret += sprintf(buf + ret, "CH1-IN"); break;
+	case 0x3:
+		ret += sprintf(buf + ret, "REMAPPER"); break;
+	case 0x4:
+		ret += sprintf(buf + ret, "PREHEADER"); break;
+	case 0x5:
+		ret += sprintf(buf + ret, "CAM-B"); break;
+	case 0x6:
+		ret += sprintf(buf + ret, "GAPREMOVER-0"); break;
+	case 0x7:
+		ret += sprintf(buf + ret, "GAPREMOVER-1"); break;
+	case 0x8:
+		ret += sprintf(buf + ret, "NONE"); break;
+	default:
+		ret += sprintf(buf + ret, "UNKNOWN"); break;
+	}
+	ret += sprintf(buf + ret, "\nCAM-A <= ");
+	switch (mod & 0x07) {
+	case 0x1:
+		ret += sprintf(buf + ret, "CH0-IN"); break;
+	case 0x2:
+		ret += sprintf(buf + ret, "CH1-IN"); break;
+	case 0x3:
+		ret += sprintf(buf + ret, "REMAPPER"); break;
+	case 0x4:
+		ret += sprintf(buf + ret, "PREHEADER"); break;
+	case 0x5:
+		ret += sprintf(buf + ret, "CAM-B"); break;
+	case 0x6:
+		ret += sprintf(buf + ret, "GAPREMOVER-0"); break;
+	case 0x7:
+		ret += sprintf(buf + ret, "GAPREMOVER-1"); break;
+	default:
+		ret += sprintf(buf + ret, "NONE"); break;
+	}
+	ret += sprintf(buf + ret, "\n");
+
+	return ret;
+}
+
+static ssize_t loop_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int loop = 0;
+
+	if (!g_usb)
+		return size;
+
+	if (sscanf(buf, "%i", &loop) == 1)
+		cimax_usb_set_loop(g_usb, loop);
+	return size;
+}
+
+static ssize_t slot_reset_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int err = 0;
+	int slot = 0;
+	struct aml_cimax *cimax = NULL;
+
+	if (!g_usb)
+		return size;
+
+	if (sscanf(buf, "%i", &slot) == 1) {
+		if (slot == 0 || slot == 1) {
+			pr_dbg("reset slot %d\n", slot);
+			cimax = g_usb->cimax;
+			err = aml_cimax_usb_slot_reset(cimax, slot);
+		}
+	}
+	return size;
+}
+
+static ssize_t detect_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t size)
+{
+	int err = 0;
+	int slot = 0;
+	struct aml_cimax *cimax = NULL;
+
+	if (!g_usb)
+		return size;
+
+	if (sscanf(buf, "%i", &slot) == 1) {
+		if (slot == 0 || slot == 1) {
+			int addr = (!slot) ? MOD_CTRL_A : MOD_CTRL_B;
+			u8 reg = 0;
+			cimax = g_usb->cimax;
+			err = aml_cimax_usb_read_reg(cimax, addr, &reg, 1);
+			cam_usb_cam_detect(g_usb, slot,
+				(reg & 1) ? IN_INSERTED : 0);
+			cimax_usb_cam_powerctrl(g_usb, slot, (reg & 1));
+		}
+	}
+	return size;
+}
+
+
+static struct class_attribute cimax_usb_class_attrs[] = {
+	__ATTR_RW(reset),
+	__ATTR_RO(debug),
+	__ATTR_RW(addr),
+	__ATTR_RW(reg),
+	__ATTR_RW(cis),
+	__ATTR_RO(ts_rate),
+	__ATTR_RW(loop),
+	__ATTR_WO(slot_reset),
+	__ATTR_WO(detect),
+	__ATTR_NULL
+};
+
+static struct class cimax_usb_class = {
+	.name = "cimax_usb",
+	.class_attrs = cimax_usb_class_attrs,
+};
+
+static int aml_cimax_usb_mod_init(void)
+{
+	int ret;
+	pr_dbg("Amlogic CIMAX USB Init\n");
+	ret = class_register(&cimax_usb_class);
+	return 0;
+}
+
+static void aml_cimax_usb_mod_exit(void)
+{
+	pr_dbg("Amlogic CIMAX USB Exit\n");
+	class_unregister(&cimax_usb_class);
+}
+
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_usb.h b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_usb.h
new file mode 100644
index 0000000..471d2da
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_usb.h
@@ -0,0 +1,20 @@
+/***************************************************************************
+ * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
+ *
+ * This source code is subject to the terms and conditions defined in the
+ * file 'LICENSE' which is part of this source code package.
+ *
+ * Description:
+ *
+***************************************************************************/
+
+#ifndef _AML_CIMAX_USB_H_
+#define _AML_CIMAX_USB_H_
+
+#include <linux/platform_device.h>
+#include "aml_cimax.h"
+
+int aml_cimax_usb_init(struct platform_device *pdev, struct aml_cimax *ci);
+int aml_cimax_usb_exit(struct aml_cimax *ci);
+
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_usb_priv.h b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_usb_priv.h
new file mode 100644
index 0000000..aec694c
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/aml_cimax_usb_priv.h
@@ -0,0 +1,22 @@
+/***************************************************************************
+ * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
+ *
+ * This source code is subject to the terms and conditions defined in the
+ * file 'LICENSE' which is part of this source code package.
+ *
+ * Description:
+ *
+***************************************************************************/
+
+#ifndef _CIMAX_USB_DEV_H_
+#define _CIMAX_USB_DEV_H_
+
+#if 0
+__attribute__ ((weak))
+int cimax_usb_dev_add(struct device_s *device, int id);
+__attribute__ ((weak))
+int cimax_usb_dev_remove(struct device_s *device, int id);
+#endif
+
+#endif
+
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.c b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.c
new file mode 100644
index 0000000..e8fb0ee
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.c
@@ -0,0 +1,1910 @@
+/*
+ * dvb_ca.c: generic DVB functions for EN50221 CAM CIMAX interfaces
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * based on code:
+ *
+ * Copyright (C) 1999-2002 Ralph  Metzler
+ *                       & Marcus Metzler for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+
+#include "dvb_ca_en50221_cimax.h"
+#include "dvb_ringbuffer.h"
+
+static int dvb_ca_en50221_debug = 1;
+
+module_param_named(cam_debug, dvb_ca_en50221_debug, int, 0644);
+MODULE_PARM_DESC(cam_debug, "enable verbose debug messages");
+
+#define HOST_LINK_BUF_SIZE 0x1000
+
+static int dvb_ca_en50221_link_size = HOST_LINK_BUF_SIZE;
+module_param_named(link_size, dvb_ca_en50221_link_size, int, 0644);
+MODULE_PARM_DESC(link_size, "debug only, no more than 0x1000");
+
+
+#define dprintk(args...)\
+	do {\
+		if (dvb_ca_en50221_debug)\
+			printk(args);\
+	} while (0)
+#define pr_error(fmt, args...) printk("CA EN50211: " fmt, ## args)
+
+#define INIT_TIMEOUT_SECS 40
+
+
+#define RX_BUFFER_SIZE 65535
+
+#define MAX_RX_PACKETS_PER_ITERATION 10
+
+#define CTRLIF_DATA      0
+#define CTRLIF_COMMAND   1
+#define CTRLIF_STATUS    1
+#define CTRLIF_SIZE_LOW  2
+#define CTRLIF_SIZE_HIGH 3
+
+#define CMDREG_HC        1	/* Host control */
+#define CMDREG_SW        2	/* Size write */
+#define CMDREG_SR        4	/* Size read */
+#define CMDREG_RS        8	/* Reset interface */
+#define CMDREG_FRIE   0x40	/* Enable FR interrupt */
+#define CMDREG_DAIE   0x80	/* Enable DA interrupt */
+#define IRQEN (CMDREG_DAIE)
+
+#define STATUSREG_RE     1	/* read error */
+#define STATUSREG_WE     2	/* write error */
+#define STATUSREG_FR  0x40	/* module free */
+#define STATUSREG_DA  0x80	/* data available */
+#define STATUSREG_TXERR (STATUSREG_RE|STATUSREG_WE)/* general transfer error */
+
+
+#define DVB_CA_SLOTSTATE_NONE           0
+#define DVB_CA_SLOTSTATE_UNINITIALISED  1
+#define DVB_CA_SLOTSTATE_RUNNING        2
+#define DVB_CA_SLOTSTATE_INVALID        3
+#define DVB_CA_SLOTSTATE_WAITREADY      4
+#define DVB_CA_SLOTSTATE_VALIDATE       5
+#define DVB_CA_SLOTSTATE_WAITFR         6
+#define DVB_CA_SLOTSTATE_LINKINIT       7
+#define DVB_CA_SLOTSTATE_WAITLINKINIT   8
+
+#define MAX_CIS_SIZE  512
+
+/* Information on a CA slot */
+struct dvb_ca_slot {
+
+	/* current state of the CAM */
+	int slot_state;
+
+	/* mutex used for serializing access to one CI slot */
+	struct mutex slot_lock;
+
+	/* Number of CAMCHANGES that have occurred since last processing */
+	atomic_t camchange_count;
+
+	/* Type of last CAMCHANGE */
+	int camchange_type;
+
+	/* base address of CAM config */
+	u32 config_base;
+
+	/* value to write into Config Control register */
+	u8 config_option;
+
+	/* if 1, the CAM supports DA IRQs */
+	u8 da_irq_supported:1;
+
+	/* size of the buffer to use when talking to the CAM */
+	int link_buf_size;
+
+	/* buffer for incoming packets */
+	struct dvb_ringbuffer rx_buffer;
+
+	/* timer used during various states of the slot */
+	unsigned long timeout;
+};
+
+/* Private CA-interface information */
+struct dvb_ca_private {
+
+	/* pointer back to the public data structure */
+	struct dvb_ca_en50221_cimax *pub;
+
+	/* the DVB device */
+	struct dvb_device *dvbdev;
+
+	/* Flags describing the interface (DVB_CA_FLAG_*) */
+	u32 flags;
+
+	/* number of slots supported by this CA interface */
+	unsigned int slot_count;
+
+	/* information on each slot */
+	struct dvb_ca_slot *slot_info;
+
+	/* wait queues for read() and write() operations */
+	wait_queue_head_t wait_queue;
+
+	/* PID of the monitoring thread */
+	struct task_struct *thread;
+
+	/* Flag indicating if the CA device is open */
+	unsigned int open:1;
+
+	/* Flag indicating the thread should wake up now */
+	unsigned int wakeup:1;
+
+	/* Delay the main thread should use */
+	unsigned long delay;
+
+	/* Slot to start looking for data
+	to read from in the next user-space read operation */
+	int next_read_slot;
+
+	/* mutex serializing ioctls */
+	struct mutex ioctl_mutex;
+
+	/*two bufs for read/write*/
+	u8 *rbuf;
+	u8 *wbuf;
+};
+
+static void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca);
+static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca,
+		int slot, u8 *ebuf, int ecount);
+static int dvb_ca_en50221_write_data(struct dvb_ca_private *ca,
+		int slot, u8 *ebuf, int ecount);
+
+
+/**
+ * Safely find needle in haystack.
+ *
+ * @param haystack Buffer to look in.
+ * @param hlen Number of bytes in haystack.
+ * @param needle Buffer to find.
+ * @param nlen Number of bytes in needle.
+ * @return Pointer into haystack needle was found at, or NULL if not found.
+ */
+static char *findstr(char *haystack, int hlen, char *needle, int nlen)
+{
+	int i;
+
+	if (hlen < nlen)
+		return NULL;
+
+	for (i = 0; i <= hlen - nlen; i++) {
+		if (!strncmp(haystack + i, needle, nlen))
+			return haystack + i;
+	}
+
+	return NULL;
+}
+
+
+
+/* ************************************************************************** */
+/* EN50221 physical interface functions */
+
+
+/**
+ * Check CAM status.
+ */
+static int dvb_ca_en50221_check_camstatus(struct dvb_ca_private *ca, int slot)
+{
+	int slot_status;
+	int cam_present;
+	int cam_changed;
+
+	/* IRQ mode */
+	if (ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)
+		return atomic_read(&ca->slot_info[slot].camchange_count) != 0;
+
+	/* poll mode */
+	slot_status = ca->pub->poll_slot_status(ca->pub, slot, ca->open);
+
+	cam_present = (slot_status & DVB_CA_EN50221_POLL_CAM_PRESENT) ? 1 : 0;
+	cam_changed = (slot_status & DVB_CA_EN50221_POLL_CAM_CHANGED) ? 1 : 0;
+	if (!cam_changed) {
+		int cam_present_old =
+			(ca->slot_info[slot].slot_state
+				!= DVB_CA_SLOTSTATE_NONE);
+		cam_changed = (cam_present != cam_present_old);
+	}
+
+	if (cam_changed) {
+		if (!cam_present) {
+			ca->slot_info[slot].camchange_type =
+				DVB_CA_EN50221_CAMCHANGE_REMOVED;
+		} else {
+			ca->slot_info[slot].camchange_type =
+				DVB_CA_EN50221_CAMCHANGE_INSERTED;
+		}
+		atomic_set(&ca->slot_info[slot].camchange_count, 1);
+	} else {
+		if ((ca->slot_info[slot].slot_state
+			== DVB_CA_SLOTSTATE_WAITREADY) &&
+				(slot_status & DVB_CA_EN50221_POLL_CAM_READY)) {
+			/* move to validate state if reset is completed */
+			ca->slot_info[slot].slot_state =
+				DVB_CA_SLOTSTATE_VALIDATE;
+		}
+	}
+	return cam_changed;
+}
+
+
+/**
+ * Initialise the link layer connection to a CAM.
+ *
+ * @param ca CA instance.
+ * @param slot Slot id.
+ *
+ * @return 0 on success, nonzero on failure.
+ */
+static int dvb_ca_en50221_link_init(struct dvb_ca_private *ca, int slot)
+{
+	int ret;
+	dprintk("%s\n", __func__);
+
+	/* we'll be determining these during this function */
+	ca->slot_info[slot].da_irq_supported = 0;
+
+	/* set the host link buffer size temporarily.
+	   it will be overwritten with the real negotiated size later. */
+	ca->slot_info[slot].link_buf_size = dvb_ca_en50221_link_size;
+	dprintk("negotiate: host(%i)\n", ca->slot_info[slot].link_buf_size);
+
+	ret = ca->pub->negotiate(ca->pub,
+		slot, ca->slot_info[slot].link_buf_size);
+	if (ret <= 0)
+		return ret;
+
+	ca->slot_info[slot].link_buf_size = ret;
+	dprintk("Chosen link buffer size of %i\n", ret);
+
+	/* success */
+	return 0;
+}
+
+/**
+ * Read a tuple from attribute memory.
+ *
+ * @param ca CA instance.
+ * @param slot Slot id.
+ * @param cis CIS data
+ * @param address Address to read from. Updated.
+ * @param tupleType Tuple id byte. Updated.
+ * @param tupleLength Tuple length. Updated.
+ * @param tuple Dest buffer for tuple (must be 256 bytes). Updated.
+ *
+ * @return 0 on success, nonzero on error.
+ */
+static int dvb_ca_en50221_read_tuple(struct dvb_ca_private *ca,
+		int slot, u8 *cis,
+		int *address, int *tupleType, int *tupleLength, u8 *tuple)
+{
+	int i;
+	int _tupleType;
+	int _tupleLength;
+	int _address = *address;
+
+	/* grab the next tuple length and type */
+	_tupleType = cis[_address];
+	if (_tupleType < 0)
+		return _tupleType;
+	if (_tupleType == 0xff) {
+		dprintk("END OF CHAIN TUPLE type:0x%x\n", _tupleType);
+		*address += 1;
+		*tupleType = _tupleType;
+		*tupleLength = 0;
+		return 0;
+	}
+	_tupleLength = cis[_address + 1];
+	if (_tupleLength < 0)
+		return _tupleLength;
+	_address += 2;
+
+	dprintk("TUPLE type:0x%x length:%i\n", _tupleType, _tupleLength);
+
+	/* read in the whole tuple */
+	for (i = 0; i < _tupleLength; i++) {
+		tuple[i] = cis[_address + (i)];
+		dprintk("  0x%02x: 0x%02x %c\n",
+			i, tuple[i] & 0xff,
+			((tuple[i] > 31) && (tuple[i] < 127)) ? tuple[i] : '.');
+	}
+	_address += (_tupleLength);
+
+	/* success */
+	*tupleType = _tupleType;
+	*tupleLength = _tupleLength;
+	*address = _address;
+	return 0;
+}
+
+
+/**
+ * Parse attribute memory of a CAM module, extracting Config register,
+ * and checking it is a DVB CAM module.
+ *
+ * @param ca CA instance.
+ * @param slot Slot id.
+ *
+ * @return 0 on success, <0 on failure.
+ */
+static int dvb_ca_en50221_parse_attributes(struct dvb_ca_private *ca, int slot)
+{
+	int address = 0;
+	int tupleLength;
+	int tupleType;
+	u8 tuple[257];
+	char *dvb_str;
+	int rasz;
+	int status;
+	int got_cftableentry = 0;
+	int end_chain = 0;
+	int i;
+	u16 manfid = 0;
+	u16 devid = 0;
+	u8 cis[MAX_CIS_SIZE];
+
+	status = ca->pub->read_cis(ca->pub, slot, cis, MAX_CIS_SIZE);
+	if (status != 0)
+		return -EINVAL;
+
+	/* CISTPL_DEVICE_0A */
+	status =
+	     dvb_ca_en50221_read_tuple(ca, slot, cis, &address,
+		&tupleType, &tupleLength, tuple);
+	if (status < 0) {
+			pr_error("read status error\r\n");
+			return status;
+		}
+	if (tupleType != 0x1D) {
+		pr_error("read tupleType error [0x%x]\r\n", tupleType);
+		return -EINVAL;
+	}
+
+
+
+	/* CISTPL_DEVICE_0C */
+	status = dvb_ca_en50221_read_tuple(ca, slot, cis, &address,
+			&tupleType, &tupleLength, tuple);
+
+	if (status < 0) {
+		pr_error("read read cis error\r\n");
+		return -EINVAL;
+	}
+	if (tupleType != 0x1C) {
+		pr_error("read read cis type error\r\n");
+		return -EINVAL;
+	}
+
+
+
+	/* CISTPL_VERS_1 */
+	status =
+	     dvb_ca_en50221_read_tuple(ca, slot, cis,
+		&address, &tupleType, &tupleLength, tuple);
+	if (status < 0) {
+		pr_error("read read cis  version error\r\n");
+		return status;
+	}
+	if (tupleType != 0x15) {
+		pr_error("read read cis version type error\r\n");
+		return -EINVAL;
+	}
+
+
+
+	/* CISTPL_MANFID */
+	status = dvb_ca_en50221_read_tuple(ca, slot, cis, &address, &tupleType,
+						&tupleLength, tuple);
+	if (status < 0) {
+		pr_error("read read cis manfid error\r\n");
+		return status;
+	}
+	if (tupleType != 0x20) {
+		pr_error("read read cis manfid type error\r\n");
+		return -EINVAL;
+	}
+	if (tupleLength != 4) {
+		pr_error("read read cis manfid len error\r\n");
+		return -EINVAL;
+	}
+	manfid = (tuple[1] << 8) | tuple[0];
+	devid = (tuple[3] << 8) | tuple[2];
+
+
+
+	/* CISTPL_CONFIG */
+	status = dvb_ca_en50221_read_tuple(ca, slot, cis, &address, &tupleType,
+						&tupleLength, tuple);
+	if (status < 0) {
+		pr_error("read read cis config error\r\n");
+		return status;
+	}
+	if (tupleType != 0x1A) {
+		pr_error("read read cis config type error\r\n");
+		return -EINVAL;
+	}
+	if (tupleLength < 3) {
+		pr_error("read read cis config len error\r\n");
+		return -EINVAL;
+	}
+
+	/* extract the configbase */
+	rasz = tuple[0] & 3;
+	if (tupleLength < (3 + rasz + 14)) {
+		pr_error("read extract the configbase  error\r\n");
+		return -EINVAL;
+	}
+	ca->slot_info[slot].config_base = 0;
+	for (i = 0; i < rasz + 1; i++)
+		ca->slot_info[slot].config_base |= (tuple[2 + i] << (8 * i));
+
+	/* check it contains the correct DVB string */
+	dvb_str = findstr((char *)tuple, tupleLength, "DVB_CI_V", 8);
+	if (dvb_str == NULL) {
+		pr_error("find dvb str DVB_CI_V  error\r\n");
+		return -EINVAL;
+	}
+	if (tupleLength < ((dvb_str - (char *) tuple) + 12)) {
+		pr_error("find dvb str DVB_CI_V len error\r\n");
+	    return -EINVAL;
+	}
+
+	/* is it a version we support? */
+	if (strncmp(dvb_str + 8, "1.00", 4)) {
+		pr_info("dvb_ca adapter %d: ", ca->dvbdev->adapter->num);
+		pr_info("Unsupported DVB CAM module version %c%c%c%c\n",
+			dvb_str[8], dvb_str[9], dvb_str[10], dvb_str[11]);
+		return -EINVAL;
+	}
+
+	/* process the CFTABLE_ENTRY tuples, and any after those */
+	while ((!end_chain) && (address < 0x1000)) {
+		status = dvb_ca_en50221_read_tuple(ca, slot, cis, &address,
+		&tupleType, &tupleLength, tuple);
+		if (status < 0) {
+				pr_error("process tuples error\r\n");
+			   return status;
+			}
+
+		switch (tupleType) {
+		case 0x1B:	/* CISTPL_CFTABLE_ENTRY */
+			if (tupleLength < (2 + 11 + 17))
+				break;
+
+			/* if we've already parsed one, just use it */
+			if (got_cftableentry)
+				break;
+
+			/* get the config option */
+			ca->slot_info[slot].config_option = tuple[0] & 0x3f;
+
+			/* OK, check it contains the correct strings */
+			if ((findstr((char *)tuple, tupleLength, "DVB_HOST", 8)
+				== NULL)
+				|| (findstr((char *)tuple,
+					tupleLength, "DVB_CI_MODULE", 13)
+					== NULL)) {
+				break;
+			}
+			got_cftableentry = 1;
+			break;
+
+		case 0x14:	/* CISTPL_NO_LINK */
+			break;
+
+		case 0xFF:	/* CISTPL_END */
+			end_chain = 1;
+			break;
+
+		default:	/* Unknown tuple type
+			-just skip this tuple and move to the next one */
+			dprintk("dvb_ca: Skipping unknown tuple type:0x%x",
+				tupleType);
+			dprintk(" length:0x%x\n", tupleLength);
+			break;
+		}
+	}
+
+	if ((address > 0x1000) || (!got_cftableentry)) {
+		pr_error("got_cftableentry :%d\r\n", got_cftableentry);
+		return -EINVAL;
+	}
+
+	dprintk("Valid DVB CAM detected MANID:%x DEVID:%x", manfid, devid);
+	dprintk(" CONFIGBASE:0x%x CONFIGOPTION:0x%x\n",
+		ca->slot_info[slot].config_base,
+		ca->slot_info[slot].config_option);
+
+	/* success! */
+	return 0;
+}
+
+
+/**
+ * Set CAM's configoption correctly.
+ *
+ * @param ca CA instance.
+ * @param slot Slot containing the CAM.
+ */
+static int dvb_ca_en50221_set_configoption(struct dvb_ca_private *ca, int slot)
+{
+	int configoption;
+
+	dprintk("%s\n", __func__);
+
+	/* set the config option */
+	ca->pub->write_cor(ca->pub, slot,
+				     ca->slot_info[slot].config_base,
+				     &ca->slot_info[slot].config_option);
+
+	configoption = ca->slot_info[slot].config_option;
+	dprintk("Set configoption 0x%x, base 0x%x\n",
+		ca->slot_info[slot].config_option,
+		ca->slot_info[slot].config_base);
+
+	/* fine! */
+	return 0;
+
+}
+
+
+/**
+ * This function talks to an EN50221 CAM control interface. It reads a buffer of
+ * data from the CAM. The data can either be stored in a supplied buffer, or
+ * automatically be added to the slot's rx_buffer.
+ *
+ * @param ca CA instance.
+ * @param slot Slot to read from.
+ * @param ebuf If non-NULL, the data will be written to this buffer. If NULL,
+ * the data will be added into the buffering system as a normal fragment.
+ * @param ecount Size of ebuf. Ignored if ebuf is NULL.
+ *
+ * @return Number of bytes read, or < 0 on error
+ */
+static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca,
+		int slot, u8 *ebuf, int ecount)
+{
+	int bytes_read;
+	int status;
+	u8 *buf = ca->rbuf;
+
+	/* dprintk("%s\n", __func__); */
+
+	/* check if we have space for a link buf in the rx_buffer */
+	if (ebuf == NULL) {
+		int buf_free;
+
+		if (ca->slot_info[slot].rx_buffer.data == NULL) {
+			status = -EIO;
+			goto exit;
+		}
+		buf_free = dvb_ringbuffer_free(&ca->slot_info[slot].rx_buffer);
+
+		if (buf_free < (ca->slot_info[slot].link_buf_size
+				+ DVB_RINGBUFFER_PKTHDRSIZE)) {
+			status = -EAGAIN;
+			goto exit;
+		}
+	}
+
+	/* check if there is data available */
+	status = ca->pub->read_cam_status(ca->pub, slot);
+	if (status < 0)
+		goto exit;
+	if (!(status & STATUSREG_DA)) {
+		/* no data */
+		status = 0;
+		goto exit;
+	}
+
+	/* read the amount of data */
+	status = ca->pub->read_lpdu(ca->pub,
+			slot, buf, dvb_ca_en50221_link_size);
+	if (status < 0) {
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+		status = -EIO;
+		goto exit;
+	}
+
+	bytes_read = status;
+
+	/* check it will fit */
+	if (ebuf == NULL) {
+		if (bytes_read > ca->slot_info[slot].link_buf_size) {
+			pr_error("dvb_ca adapter %d:",
+				ca->dvbdev->adapter->num);
+			pr_error(" CAM tried to send a buffer larger ");
+			pr_error("than the link buffer size(%i > %i)!\n",
+			       bytes_read, ca->slot_info[slot].link_buf_size);
+			ca->slot_info[slot].slot_state =
+				DVB_CA_SLOTSTATE_LINKINIT;
+			status = -EIO;
+			goto exit;
+		}
+		if (bytes_read < 2) {
+			pr_error("dvb_ca adapter %d: ",
+					ca->dvbdev->adapter->num);
+			pr_error("CAM sent a buffer");
+			pr_error("that was less than 2B!\n");
+			ca->slot_info[slot].slot_state =
+				DVB_CA_SLOTSTATE_LINKINIT;
+			status = -EIO;
+			goto exit;
+		}
+	} else {
+		if (bytes_read > ecount) {
+			pr_error("dvb_ca adapter %d:",
+				ca->dvbdev->adapter->num);
+			pr_error(" CAM tried to send a buffer larger");
+			pr_error(" than the ecount size!\n");
+			status = -EIO;
+			goto exit;
+		}
+	}
+
+	/* OK, add it to the receive buffer,
+	   or copy into external buffer if supplied */
+	if (ebuf == NULL) {
+		if (ca->slot_info[slot].rx_buffer.data == NULL) {
+			status = -EIO;
+			goto exit;
+		}
+		dvb_ringbuffer_pkt_write(&ca->slot_info[slot].rx_buffer,
+			buf, bytes_read);
+	} else {
+		memcpy(ebuf, buf, bytes_read);
+	}
+
+	/* wake up readers when a last_fragment is received */
+	if ((buf[1] & 0x80) == 0x00)
+		wake_up_interruptible(&ca->wait_queue);
+	status = bytes_read;
+
+exit:
+	return status;
+}
+
+
+/**
+ * This function talks to an EN50221 CAM control interface.
+ * It writes a buffer of data
+ * to a CAM.
+ *
+ * @param ca CA instance.
+ * @param slot Slot to write to.
+ * @param ebuf The data in this buffer
+ * is treated as a complete link-level packet to be written.
+ * @param count Size of ebuf.
+ *
+ * @return Number of bytes written, or < 0 on error.
+ */
+static int dvb_ca_en50221_write_data(struct dvb_ca_private *ca,
+		int slot, u8 *buf, int bytes_write)
+{
+	int status;
+
+	/* dprintk("%s\n", __func__); */
+
+	/* sanity check */
+	if (bytes_write > ca->slot_info[slot].link_buf_size)
+		return -EINVAL;
+
+	/* it is possible we are dealing with a single buffer implementation,
+	   thus if there is data available for read or if there is even a read
+	   already in progress, we do nothing but awake the kernel thread to
+	   process the data if necessary. */
+	status = ca->pub->read_cam_status(ca->pub, slot);
+	if (status < 0)
+		return status;
+	if (status & (STATUSREG_DA | STATUSREG_RE)) {
+		if (status & STATUSREG_DA)
+			dvb_ca_en50221_thread_wakeup(ca);
+		status = -EAGAIN;
+		return status;
+	}
+
+	if (!(status & STATUSREG_FR)) {
+		status = -EAGAIN;
+		return status;
+	}
+
+	status = ca->pub->write_lpdu(ca->pub, slot, buf, bytes_write);
+	if (status < 0) {
+		if (status == -EBUSY) {
+			status = -EAGAIN;
+			return status;
+		} else {
+			ca->slot_info[slot].slot_state =
+				DVB_CA_SLOTSTATE_LINKINIT;
+			status = -EIO;
+			return status;
+		}
+	}
+
+	status = bytes_write;
+
+	return status;
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimax_camchange_irq);
+
+
+
+/* ************************************************************************** */
+/* EN50221 higher level functions */
+
+
+/**
+ * A CAM has been removed => shut it down.
+ *
+ * @param ca CA instance.
+ * @param slot Slot to shut down.
+ */
+static int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private *ca, int slot)
+{
+	dprintk("%s\n", __func__);
+
+	ca->pub->slot_shutdown(ca->pub, slot);
+	ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
+
+	/* need to wake up all processes to check if they're now
+	   trying to write to a defunct CAM */
+	wake_up_interruptible(&ca->wait_queue);
+
+	dprintk("Slot %i shutdown\n", slot);
+
+	/* success */
+	return 0;
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimax_camready_irq);
+
+
+/**
+ * A CAMCHANGE IRQ has occurred.
+ *
+ * @param ca CA instance.
+ * @param slot Slot concerned.
+ * @param change_type One of the DVB_CA_CAMCHANGE_* values.
+ */
+void dvb_ca_en50221_cimax_camchange_irq(struct dvb_ca_en50221_cimax *pubca,
+		int slot, int change_type)
+{
+	struct dvb_ca_private *ca = pubca->private;
+
+	dprintk("CAMCHANGE IRQ slot:%i change_type:%i\n", slot, change_type);
+
+	switch (change_type) {
+	case DVB_CA_EN50221_CAMCHANGE_REMOVED:
+	case DVB_CA_EN50221_CAMCHANGE_INSERTED:
+		break;
+
+	default:
+		return;
+	}
+
+	ca->slot_info[slot].camchange_type = change_type;
+	atomic_inc(&ca->slot_info[slot].camchange_count);
+	dvb_ca_en50221_thread_wakeup(ca);
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimax_frda_irq);
+
+
+/**
+ * A CAMREADY IRQ has occurred.
+ *
+ * @param ca CA instance.
+ * @param slot Slot concerned.
+ */
+void dvb_ca_en50221_cimax_camready_irq(struct dvb_ca_en50221_cimax *pubca,
+		int slot)
+{
+	struct dvb_ca_private *ca = pubca->private;
+
+	dprintk("CAMREADY IRQ slot:%i\n", slot);
+
+	if (ca->slot_info[slot].slot_state == DVB_CA_SLOTSTATE_WAITREADY) {
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_VALIDATE;
+		dvb_ca_en50221_thread_wakeup(ca);
+	}
+}
+
+
+/**
+ * An FR or DA IRQ has occurred.
+ *
+ * @param ca CA instance.
+ * @param slot Slot concerned.
+ */
+void dvb_ca_en50221_cimax_frda_irq(struct dvb_ca_en50221_cimax *pubca,
+		int slot)
+{
+	struct dvb_ca_private *ca = pubca->private;
+	int flags;
+
+	dprintk("FR/DA IRQ slot:%i\n", slot);
+
+	switch (ca->slot_info[slot].slot_state) {
+	case DVB_CA_SLOTSTATE_LINKINIT:
+		flags = ca->pub->get_capbility(pubca, slot);
+		if (flags & DVB_CA_EN50221_CAP_IRQ) {
+			dprintk("CAM supports DA IRQ\n");
+			ca->slot_info[slot].da_irq_supported = 1;
+		}
+		break;
+
+	case DVB_CA_SLOTSTATE_RUNNING:
+		if (ca->open)
+			dvb_ca_en50221_thread_wakeup(ca);
+		break;
+	}
+}
+
+
+
+/* ************************************************************************** */
+/* EN50221 thread functions */
+
+/**
+ * Wake up the DVB CA thread
+ *
+ * @param ca CA instance.
+ */
+static void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca)
+{
+
+	dprintk("%s\n", __func__);
+
+	ca->wakeup = 1;
+	mb(); /*original*/
+	wake_up_process(ca->thread);
+}
+
+/**
+ * Update the delay used by the thread.
+ *
+ * @param ca CA instance.
+ */
+static void dvb_ca_en50221_thread_update_delay(struct dvb_ca_private *ca)
+{
+	int delay;
+	int curdelay = 100000000;
+	int slot;
+
+	/* Beware of too high polling frequency, because one polling
+	 * call might take several hundred milliseconds until timeout!
+	 */
+	for (slot = 0; slot < ca->slot_count; slot++) {
+		switch (ca->slot_info[slot].slot_state) {
+		default:
+		case DVB_CA_SLOTSTATE_NONE:
+			delay = HZ * 60;  /* 60s */
+			if (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
+				delay = HZ * 5;  /* 5s */
+			break;
+		case DVB_CA_SLOTSTATE_INVALID:
+			delay = HZ * 60;  /* 60s */
+			if (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
+				delay = HZ / 10;  /* 100ms */
+			break;
+
+		case DVB_CA_SLOTSTATE_UNINITIALISED:
+		case DVB_CA_SLOTSTATE_WAITREADY:
+		case DVB_CA_SLOTSTATE_VALIDATE:
+		case DVB_CA_SLOTSTATE_WAITFR:
+		case DVB_CA_SLOTSTATE_LINKINIT:
+			delay = HZ / 10;  /* 100ms */
+			break;
+		case DVB_CA_SLOTSTATE_WAITLINKINIT:
+			delay = HZ * 2;
+			break;
+
+		case DVB_CA_SLOTSTATE_RUNNING:
+			delay = HZ * 60;  /* 60s */
+			if (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
+				delay = HZ / 10;  /* 100ms */
+			if (ca->open) {
+				if ((!ca->slot_info[slot].da_irq_supported) ||
+				    (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_DA)))
+					delay = HZ / 10;  /* 100ms */
+			}
+			break;
+		}
+
+		if (delay < curdelay)
+			curdelay = delay;
+	}
+
+	ca->delay = curdelay;
+}
+
+static int dvb_ca_en50221_slot_process(struct dvb_ca_private *ca, int slot)
+{
+	int flags;
+	int status;
+	int pktcount;
+	void *rxbuf;
+
+	mutex_lock(&ca->slot_info[slot].slot_lock);
+
+	/*check the cam status + deal with CAMCHANGEs*/
+	while (dvb_ca_en50221_check_camstatus(ca, slot)) {
+		/* clear down an old CI slot if necessary */
+		if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE)
+			dvb_ca_en50221_slot_shutdown(ca, slot);
+
+		/* if a CAM is NOW present, initialise it */
+		if (ca->slot_info[slot].camchange_type
+				== DVB_CA_EN50221_CAMCHANGE_INSERTED)
+			ca->slot_info[slot].slot_state =
+				DVB_CA_SLOTSTATE_UNINITIALISED;
+
+		/* we've handled one CAMCHANGE */
+		dvb_ca_en50221_thread_update_delay(ca);
+		atomic_dec(&ca->slot_info[slot].camchange_count);
+	}
+
+	/* CAM state machine */
+	switch (ca->slot_info[slot].slot_state) {
+	case DVB_CA_SLOTSTATE_NONE:
+	case DVB_CA_SLOTSTATE_INVALID:
+		/* no action needed */
+		break;
+
+	case DVB_CA_SLOTSTATE_UNINITIALISED:
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITREADY;
+		ca->pub->slot_reset(ca->pub, slot);
+		ca->slot_info[slot].timeout = jiffies
+			+ (INIT_TIMEOUT_SECS * HZ);
+		break;
+
+	case DVB_CA_SLOTSTATE_WAITREADY:
+		if (time_after(jiffies, ca->slot_info[slot].timeout)) {
+			dprintk("%d: PC card did not respond\n",
+				ca->dvbdev->adapter->num);
+			ca->slot_info[slot].slot_state =
+				DVB_CA_SLOTSTATE_INVALID;
+			dvb_ca_en50221_thread_update_delay(ca);
+			break;
+		}
+		/* no other action needed; will automatically
+		 * change state when ready
+		 */
+		break;
+
+	case DVB_CA_SLOTSTATE_VALIDATE:
+		if (dvb_ca_en50221_parse_attributes(ca, slot) != 0) {
+			/* we need this extra check
+			   for annoying interfaces like the budget-av */
+			if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
+					&& (ca->pub->poll_slot_status)) {
+				status = ca->pub->poll_slot_status(ca->pub,
+						slot, 0);
+				if (!(status
+					& DVB_CA_EN50221_POLL_CAM_PRESENT)) {
+					ca->slot_info[slot].slot_state =
+						DVB_CA_SLOTSTATE_NONE;
+					dvb_ca_en50221_thread_update_delay(ca);
+					break;
+				}
+			}
+			dprintk(" %d: Invalid PC card inserted :(\n",
+			       ca->dvbdev->adapter->num);
+			ca->slot_info[slot].slot_state =
+					DVB_CA_SLOTSTATE_INVALID;
+			dvb_ca_en50221_thread_update_delay(ca);
+			break;
+		}
+		if (dvb_ca_en50221_set_configoption(ca, slot) != 0) {
+			dprintk("%d: Unable initialise CAM:(\n",
+			       ca->dvbdev->adapter->num);
+			ca->slot_info[slot].slot_state =
+					DVB_CA_SLOTSTATE_INVALID;
+			dvb_ca_en50221_thread_update_delay(ca);
+			break;
+		}
+
+		if (ca->pub->cam_reset(ca->pub, slot) != 0) {
+			dprintk("%d: Unable to reset CAM IF\n",
+			       ca->dvbdev->adapter->num);
+			ca->slot_info[slot].slot_state =
+					DVB_CA_SLOTSTATE_INVALID;
+			dvb_ca_en50221_thread_update_delay(ca);
+			break;
+		}
+
+		dprintk("DVB CAM validated successfully\n");
+
+		ca->slot_info[slot].timeout =
+				jiffies + (INIT_TIMEOUT_SECS * HZ);
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITFR;
+		ca->wakeup = 1;
+		break;
+
+	case DVB_CA_SLOTSTATE_WAITFR:
+		if (time_after(jiffies, ca->slot_info[slot].timeout)) {
+			pr_error("dvb_ca adapter %d: ",
+				ca->dvbdev->adapter->num);
+			pr_error("DVB CAM did not respond :(\n");
+			ca->slot_info[slot].slot_state =
+					DVB_CA_SLOTSTATE_INVALID;
+			dvb_ca_en50221_thread_update_delay(ca);
+			break;
+		}
+
+		/*flags = ca->pub->read_cam_status(ca->pub, slot);*/
+		flags = STATUSREG_FR;
+		if (flags & STATUSREG_FR) {
+			ca->slot_info[slot].slot_state =
+					DVB_CA_SLOTSTATE_LINKINIT;
+			ca->wakeup = 1;
+		}
+		break;
+
+	case DVB_CA_SLOTSTATE_WAITLINKINIT:
+		if (time_after(jiffies, ca->slot_info[slot].timeout)) {
+			pr_error("dvb_ca adapter %d: ",
+					ca->dvbdev->adapter->num);
+			pr_error("DVB CAM link initialisation failed :(\n");
+			ca->slot_info[slot].slot_state =
+					DVB_CA_SLOTSTATE_INVALID;
+			dvb_ca_en50221_thread_update_delay(ca);
+			break;
+		}
+
+	case DVB_CA_SLOTSTATE_LINKINIT:
+		if (dvb_ca_en50221_link_init(ca, slot) != 0) {
+			/* we need this extra check for annoying interfaces
+			   like the budget-av */
+			if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
+				&& (ca->pub->poll_slot_status)) {
+				status = ca->pub->poll_slot_status(ca->pub,
+						slot, 0);
+				if (!(status
+					& DVB_CA_EN50221_POLL_CAM_PRESENT)) {
+					ca->slot_info[slot].slot_state =
+							DVB_CA_SLOTSTATE_NONE;
+					dvb_ca_en50221_thread_update_delay(ca);
+					break;
+				}
+			}
+
+			ca->slot_info[slot].timeout =
+					jiffies + (INIT_TIMEOUT_SECS * HZ);
+			ca->slot_info[slot].slot_state =
+					DVB_CA_SLOTSTATE_WAITLINKINIT;
+			ca->wakeup = 1;
+			break;
+		}
+
+		if (ca->slot_info[slot].rx_buffer.data == NULL) {
+			rxbuf = vmalloc(RX_BUFFER_SIZE);
+			if (rxbuf == NULL) {
+				pr_error("dvb_ca adapter %d: ",
+						ca->dvbdev->adapter->num);
+				pr_error("Unable to allocate CAM rx buffer\n");
+				ca->slot_info[slot].slot_state =
+						DVB_CA_SLOTSTATE_INVALID;
+				dvb_ca_en50221_thread_update_delay(ca);
+				break;
+			}
+			dvb_ringbuffer_init(&ca->slot_info[slot].rx_buffer,
+					rxbuf, RX_BUFFER_SIZE);
+		}
+
+		ca->pub->slot_ts_enable(ca->pub, slot);
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;
+		dvb_ca_en50221_thread_update_delay(ca);
+		dprintk("%d: DVB CAM Initialised successfully\n",
+		ca->dvbdev->adapter->num);
+		break;
+
+	case DVB_CA_SLOTSTATE_RUNNING:
+		if (!ca->open)
+			break;
+
+		pktcount = 0;
+		while ((status = dvb_ca_en50221_read_data(ca, slot, NULL, 0))
+			> 0) {
+			if (!ca->open)
+				break;
+
+			/* if a CAMCHANGE occurred at some point,
+			   do not do any more processing of this slot */
+			if (dvb_ca_en50221_check_camstatus(ca, slot)) {
+				/* we dont want to sleep on the next iteration
+				   so we can handle the cam change*/
+				ca->wakeup = 1;
+				break;
+			}
+
+			/* check if we've hit our limit this time */
+			if (++pktcount >= MAX_RX_PACKETS_PER_ITERATION) {
+				/*dont sleep;
+				  there is likely to be more data to read*/
+				ca->wakeup = 1;
+				break;
+			}
+		}
+		break;
+	}
+
+	mutex_unlock(&ca->slot_info[slot].slot_lock);
+	return 0;
+}
+
+
+/**
+ * Kernel thread which monitors CA slots for CAM changes,
+ * and performs data transfers.
+ */
+static int dvb_ca_en50221_thread(void *data)
+{
+	struct dvb_ca_private *ca = data;
+	int slot;
+
+	dprintk(" %s\n", __func__);
+	/* choose the correct initial delay */
+	dvb_ca_en50221_thread_update_delay(ca);
+
+	/* main loop */
+	while (!kthread_should_stop()) {
+		/* sleep for a bit */
+		if (!ca->wakeup) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(ca->delay);
+			if (kthread_should_stop())
+				return 0;
+		}
+		ca->wakeup = 0;
+
+		/* go through all the slots processing them */
+		for (slot = 0; slot < ca->slot_count; slot++)
+			dvb_ca_en50221_slot_process(ca, slot);
+	}
+
+	return 0;
+}
+
+
+
+/* ************************************************************************** */
+/* EN50221 IO interface functions */
+
+/**
+ * Real ioctl implementation.
+ * NOTE: CA_SEND_MSG/CA_GET_MSG ioctls have userspace buffers passed to them.
+ *
+ * @param inode Inode concerned.
+ * @param file File concerned.
+ * @param cmd IOCTL command.
+ * @param arg Associated argument.
+ *
+ * @return 0 on success, <0 on error.
+ */
+static int dvb_ca_en50221_io_do_ioctl(struct file *file,
+				      unsigned int cmd, void *parg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	int err = 0;
+	int slot;
+
+	if (mutex_lock_interruptible(&ca->ioctl_mutex)) {
+		pr_error("ci lock interrupt error\r\n");
+		return -ERESTARTSYS;
+	}
+
+	switch (cmd) {
+	case CA_RESET:
+		dprintk("ci reset---\r\n");
+		for (slot = 0; slot < ca->slot_count; slot++) {
+			mutex_lock(&ca->slot_info[slot].slot_lock);
+			if (ca->slot_info[slot].slot_state
+				== DVB_CA_SLOTSTATE_NONE)
+				goto next;
+			dvb_ca_en50221_slot_shutdown(ca, slot);
+			if (ca->flags
+				& DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)
+				dvb_ca_en50221_cimax_camchange_irq(
+					ca->pub,
+					slot,
+					DVB_CA_EN50221_CAMCHANGE_INSERTED);
+next:
+			mutex_unlock(&ca->slot_info[slot].slot_lock);
+		}
+		ca->next_read_slot = 0;
+		dvb_ca_en50221_thread_wakeup(ca);
+		break;
+
+	case CA_GET_CAP: {
+		struct ca_caps *caps = parg;
+
+		caps->slot_num = ca->slot_count;
+		caps->slot_type = CA_CI_LINK;
+		caps->descr_num = 0;
+		caps->descr_type = 0;
+		break;
+	}
+
+	case CA_GET_SLOT_INFO: {
+		struct ca_slot_info *info = parg;
+
+		if ((info->num > ca->slot_count) || (info->num < 0)) {
+			err = -EINVAL;
+			pr_error("info num error :%d\r\n", info->num);
+			goto out_unlock;
+		}
+
+		info->type = CA_CI_LINK;
+		info->flags = 0;
+		if ((ca->slot_info[info->num].slot_state
+				!= DVB_CA_SLOTSTATE_NONE)
+			&& (ca->slot_info[info->num].slot_state
+				!= DVB_CA_SLOTSTATE_INVALID)) {
+			info->flags = CA_CI_MODULE_PRESENT;
+		}
+		if (ca->slot_info[info->num].slot_state
+				== DVB_CA_SLOTSTATE_RUNNING) {
+			info->flags |= CA_CI_MODULE_READY;
+		}
+		break;
+	}
+
+	default:
+	    pr_error("Invalid cmd :%d\r\n", cmd);
+		err = -EINVAL;
+		break;
+	}
+
+out_unlock:
+	mutex_unlock(&ca->ioctl_mutex);
+	return err;
+}
+
+
+static int dvb_usercopy__(struct file *file,
+		   unsigned int cmd, unsigned long arg,
+		   int (*func)(struct file *file,
+		   unsigned int cmd, void *arg))
+{
+  char	  sbuf[128];
+  void	  *mbuf = NULL;
+  void	  *parg = NULL;
+  int	  err  = -EINVAL;
+
+  /*  Copy arguments into temp kernel buffer  */
+  switch (_IOC_DIR(cmd)) {
+  case _IOC_NONE:
+	  /*
+	   * For this command, the pointer is actually an integer
+	   * argument.
+	   */
+	  parg = (void *) arg;
+	  break;
+  case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+  case _IOC_WRITE:
+  case (_IOC_WRITE | _IOC_READ):
+	  if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+		  parg = sbuf;
+	  } else {
+		  /* too big to allocate from stack */
+		  mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+		  if (NULL == mbuf)
+			  return -ENOMEM;
+		  parg = mbuf;
+	  }
+
+	  err = -EFAULT;
+	  if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+		  goto out;
+	  break;
+  }
+
+  /* call driver */
+  if ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)
+	  err = -ENOTTY;
+
+  if (err < 0)
+	  goto out;
+
+  /*  Copy results into user buffer  */
+  switch (_IOC_DIR(cmd))
+  {
+  case _IOC_READ:
+  case (_IOC_WRITE | _IOC_READ):
+	  if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+		  err = -EFAULT;
+	  break;
+  }
+
+out:
+  kfree(mbuf);
+  return err;
+}
+
+
+
+/**
+ * Wrapper for ioctl implementation.
+ *
+ * @param inode Inode concerned.
+ * @param file File concerned.
+ * @param cmd IOCTL command.
+ * @param arg Associated argument.
+ *
+ * @return 0 on success, <0 on error.
+ */
+static long dvb_ca_en50221_io_ioctl(struct file *file,
+				    unsigned int cmd, unsigned long arg)
+{
+	return dvb_usercopy__(file, cmd, arg, dvb_ca_en50221_io_do_ioctl);
+}
+
+
+/**
+ * Implementation of write() syscall.
+ *
+ * @param file File structure.
+ * @param buf Source buffer.
+ * @param count Size of source buffer.
+ * @param ppos Position in file (ignored).
+ *
+ * @return Number of bytes read, or <0 on error.
+ */
+static ssize_t dvb_ca_en50221_io_write(struct file *file,
+			const char __user *buf, size_t count, loff_t *ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	u8 slot, connection_id;
+	int status;
+	u8 *fragbuf = ca->wbuf;
+	int fragpos = 0;
+	int fraglen;
+	unsigned long timeout;
+	int written;
+
+	/* dprintk("%s\n", __func__); */
+
+	/* Incoming packet has a 2 byte header.
+	   hdr[0] = slot_id, hdr[1] = connection_id */
+	if (count < 2)
+		return -EINVAL;
+
+	/* extract slot & connection id */
+	if (copy_from_user(&slot, buf, 1))
+		return -EFAULT;
+	if (copy_from_user(&connection_id, buf + 1, 1))
+		return -EFAULT;
+	buf += 2;
+	count -= 2;
+
+	if (slot >= ca->slot_count)
+		return -EFAULT;
+	/* check if the slot is actually running */
+	if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
+		return -EINVAL;
+
+	/* fragment the packets & store in the buffer */
+	while (fragpos < count) {
+		fraglen = ca->slot_info[slot].link_buf_size - 2;
+		if (fraglen < 0)
+			break;
+		if (fraglen > dvb_ca_en50221_link_size - 2)
+			fraglen = dvb_ca_en50221_link_size - 2;
+		if ((count - fragpos) < fraglen)
+			fraglen = count - fragpos;
+
+		fragbuf[0] = connection_id;
+		fragbuf[1] = ((fragpos + fraglen) < count) ? 0x80 : 0x00;
+		status = copy_from_user(fragbuf + 2, buf + fragpos, fraglen);
+		if (status) {
+			status = -EFAULT;
+			goto exit;
+		}
+
+		timeout = jiffies + HZ / 2;
+		written = 0;
+		while (!time_after(jiffies, timeout)) {
+			/* check the CAM hasn't been removed/reset
+			   in the meantime */
+			if (ca->slot_info[slot].slot_state
+					!= DVB_CA_SLOTSTATE_RUNNING) {
+				status = -EIO;
+				goto exit;
+			}
+
+			mutex_lock(&ca->slot_info[slot].slot_lock);
+			status = dvb_ca_en50221_write_data(ca,
+					slot, fragbuf, fraglen + 2);
+			mutex_unlock(&ca->slot_info[slot].slot_lock);
+			if (status == (fraglen + 2)) {
+				written = 1;
+				break;
+			}
+			if (status != -EAGAIN)
+				goto exit;
+
+			msleep(20);
+		}
+		if (!written) {
+			status = -EIO;
+			goto exit;
+		}
+
+		fragpos += fraglen;
+	}
+	status = count + 2;
+
+exit:
+	return status;
+}
+
+
+/**
+ * Condition for waking up in dvb_ca_en50221_io_read_condition
+ */
+static int dvb_ca_en50221_io_read_condition(struct dvb_ca_private *ca,
+					    int *result, int *_slot)
+{
+	int slot;
+	int slot_count = 0;
+	int idx;
+	size_t fraglen;
+	int connection_id = -1;
+	int found = 0;
+	u8 hdr[2];
+
+	slot = ca->next_read_slot;
+	while ((slot_count < ca->slot_count) && (!found)) {
+		if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
+			goto nextslot;
+
+		if (ca->slot_info[slot].rx_buffer.data == NULL)
+			return 0;
+
+		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer,
+				-1, &fraglen);
+		while (idx != -1) {
+			dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer,
+					idx, 0, hdr, 2);
+			if (connection_id == -1)
+				connection_id = hdr[0];
+			if ((hdr[0] == connection_id)
+				&& ((hdr[1] & 0x80) == 0)) {
+				*_slot = slot;
+				found = 1;
+				break;
+			}
+
+			idx = dvb_ringbuffer_pkt_next(
+				&ca->slot_info[slot].rx_buffer,
+				idx,
+				&fraglen);
+		}
+
+nextslot:
+		slot = (slot + 1) % ca->slot_count;
+		slot_count++;
+	}
+
+	ca->next_read_slot = slot;
+	return found;
+}
+
+
+/**
+ * Implementation of read() syscall.
+ *
+ * @param file File structure.
+ * @param buf Destination buffer.
+ * @param count Size of destination buffer.
+ * @param ppos Position in file (ignored).
+ *
+ * @return Number of bytes read, or <0 on error.
+ */
+static ssize_t dvb_ca_en50221_io_read(struct file *file, char __user *buf,
+				      size_t count, loff_t *ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	int status;
+	int result = 0;
+	u8 hdr[2];
+	int slot;
+	int connection_id = -1;
+	size_t idx, idx2;
+	int last_fragment = 0;
+	size_t fraglen;
+	int pktlen;
+	int dispose = 0;
+
+	/* dprintk("%s\n", __func__); */
+
+	/* Outgoing packet has a 2 byte header.
+	   hdr[0] = slot_id, hdr[1] = connection_id */
+	if (count < 2)
+		return -EINVAL;
+
+	/* wait for some data */
+	status = dvb_ca_en50221_io_read_condition(ca, &result, &slot);
+	if (status == 0) {
+		/* if we're in nonblocking mode, exit immediately */
+		if (file->f_flags & O_NONBLOCK)
+			return -EWOULDBLOCK;
+
+		/* wait for some data */
+		status = wait_event_interruptible(ca->wait_queue,
+					  dvb_ca_en50221_io_read_condition
+					  (ca, &result, &slot));
+	}
+	if ((status < 0) || (result < 0)) {
+		if (result)
+			return result;
+		return status;
+	}
+
+	idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer,
+			-1, &fraglen);
+	pktlen = 2;
+	do {
+		if (idx == -1) {
+			pr_error("dvb_ca adapter %d: ",
+				ca->dvbdev->adapter->num);
+			pr_error("BUG: read packet ended");
+			pr_error("before last_fragment encountered\n");
+			status = -EIO;
+			goto exit;
+		}
+
+		dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer,
+				idx, 0, hdr, 2);
+		if (connection_id == -1)
+			connection_id = hdr[0];
+		if (hdr[0] == connection_id) {
+			if (pktlen < count) {
+				if ((pktlen + fraglen - 2) > count)
+					fraglen = count - pktlen;
+				else
+					fraglen -= 2;
+
+				status = dvb_ringbuffer_pkt_read_user(
+					&ca->slot_info[slot].rx_buffer,
+					idx,
+					2,
+					buf + pktlen,
+					fraglen);
+				if (status < 0)
+					goto exit;
+				pktlen += fraglen;
+			}
+
+			if ((hdr[1] & 0x80) == 0)
+				last_fragment = 1;
+			dispose = 1;
+		}
+
+		idx2 = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer,
+				idx, &fraglen);
+		if (dispose)
+			dvb_ringbuffer_pkt_dispose(
+				&ca->slot_info[slot].rx_buffer, idx);
+		idx = idx2;
+		dispose = 0;
+	} while (!last_fragment);
+
+	hdr[0] = slot;
+	hdr[1] = connection_id;
+	status = copy_to_user(buf, hdr, 2);
+	if (status) {
+		status = -EFAULT;
+		goto exit;
+	}
+	status = pktlen;
+
+exit:
+	return status;
+}
+
+
+/**
+ * Implementation of file open syscall.
+ *
+ * @param inode Inode concerned.
+ * @param file File concerned.
+ *
+ * @return 0 on success, <0 on failure.
+ */
+static int dvb_ca_en50221_io_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	int err;
+	int i;
+
+	dprintk("%s\n", __func__);
+
+	if (!try_module_get(ca->pub->owner))
+		return -EIO;
+
+	err = dvb_generic_open(inode, file);
+	if (err < 0) {
+		module_put(ca->pub->owner);
+		return err;
+	}
+
+	for (i = 0; i < ca->slot_count; i++) {
+
+		if (ca->slot_info[i].slot_state == DVB_CA_SLOTSTATE_RUNNING) {
+			if (ca->slot_info[i].rx_buffer.data != NULL) {
+				/* it is safe to call this here without locks
+				   because ca->open == 0.
+				   Data is not read in this case */
+				dvb_ringbuffer_flush(
+					&ca->slot_info[i].rx_buffer);
+			}
+		}
+	}
+
+	ca->open = 1;
+	dvb_ca_en50221_thread_update_delay(ca);
+	dvb_ca_en50221_thread_wakeup(ca);
+
+	return 0;
+}
+
+
+/**
+ * Implementation of file close syscall.
+ *
+ * @param inode Inode concerned.
+ * @param file File concerned.
+ *
+ * @return 0 on success, <0 on failure.
+ */
+static int dvb_ca_en50221_io_release(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	int err;
+
+	dprintk("%s\n", __func__);
+
+	/* mark the CA device as closed */
+	ca->open = 0;
+	dvb_ca_en50221_thread_update_delay(ca);
+
+	err = dvb_generic_release(inode, file);
+
+	module_put(ca->pub->owner);
+
+	return err;
+}
+
+
+/**
+ * Implementation of poll() syscall.
+ *
+ * @param file File concerned.
+ * @param wait poll wait table.
+ *
+ * @return Standard poll mask.
+ */
+static unsigned int dvb_ca_en50221_io_poll(struct file *file, poll_table *wait)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_ca_private *ca = dvbdev->priv;
+	unsigned int mask = 0;
+	int slot;
+	int result = 0;
+
+	/* dprintk("%s\n", __func__); */
+
+	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1)
+		mask |= POLLIN;
+
+	/* if there is something, return now */
+	if (mask)
+		return mask;
+
+	/* wait for something to happen */
+	poll_wait(file, &ca->wait_queue, wait);
+
+	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1)
+		mask |= POLLIN;
+
+	return mask;
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimax_init);
+
+#ifdef CONFIG_COMPAT
+static long dvb_ca_en50221_compat_ioctl(struct file *filp,
+			unsigned int cmd, unsigned long args)
+{
+	unsigned long ret;
+
+	args = (unsigned long)compat_ptr(args);
+	ret = dvb_ca_en50221_io_ioctl(filp, cmd, args);
+	return ret;
+}
+#endif
+static const struct file_operations dvb_ca_fops = {
+	.owner = THIS_MODULE,
+	.read = dvb_ca_en50221_io_read,
+	.write = dvb_ca_en50221_io_write,
+	.unlocked_ioctl = dvb_ca_en50221_io_ioctl,
+	.open = dvb_ca_en50221_io_open,
+	.release = dvb_ca_en50221_io_release,
+	.poll = dvb_ca_en50221_io_poll,
+	.llseek = noop_llseek,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= dvb_ca_en50221_compat_ioctl,
+#endif
+};
+
+static struct dvb_device dvbdev_ca = {
+	.priv = NULL,
+	.users = 1,
+	.readers = 1,
+	.writers = 1,
+	.fops = &dvb_ca_fops,
+};
+
+
+/* ************************************************************************** */
+/* Initialisation/shutdown functions */
+
+
+/**
+ * Initialise a new DVB CA EN50221 CIMAX interface device.
+ *
+ * @param dvb_adapter DVB adapter to attach the new CA device to.
+ * @param ca The dvb_ca instance.
+ * @param flags Flags describing the CA device (DVB_CA_FLAG_*).
+ * @param slot_count Number of slots supported.
+ *
+ * @return 0 on success, nonzero on failure
+ */
+int dvb_ca_en50221_cimax_init(struct dvb_adapter *dvb_adapter,
+			struct dvb_ca_en50221_cimax *pubca,
+			int flags, int slot_count)
+{
+	int ret;
+	struct dvb_ca_private *ca = NULL;
+	int i;
+
+	dprintk("%s\n", __func__);
+
+	if (slot_count < 1)
+		return -EINVAL;
+
+	/* initialise the system data */
+	ca = kzalloc(sizeof(struct dvb_ca_private), GFP_KERNEL);
+	if (ca == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	ca->pub = pubca;
+	ca->flags = flags;
+	ca->slot_count = slot_count;
+	ca->slot_info =
+		kcalloc(slot_count, sizeof(struct dvb_ca_slot), GFP_KERNEL);
+	if (ca->slot_info == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	init_waitqueue_head(&ca->wait_queue);
+	ca->open = 0;
+	ca->wakeup = 0;
+	ca->next_read_slot = 0;
+	ca->rbuf = kcalloc(HOST_LINK_BUF_SIZE, 1, GFP_KERNEL);
+	ca->wbuf = kcalloc(HOST_LINK_BUF_SIZE, 1, GFP_KERNEL);
+	if (ca->rbuf == NULL || ca->wbuf == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	pubca->private = ca;
+
+	/* register the DVB device */
+	ret = dvb_register_device(dvb_adapter,
+			&ca->dvbdev, &dvbdev_ca, ca, DVB_DEVICE_CA, 0);
+	if (ret)
+		goto error;
+
+	/* now initialise each slot */
+	for (i = 0; i < slot_count; i++) {
+		memset(&ca->slot_info[i], 0, sizeof(struct dvb_ca_slot));
+		ca->slot_info[i].slot_state = DVB_CA_SLOTSTATE_NONE;
+		atomic_set(&ca->slot_info[i].camchange_count, 0);
+		ca->slot_info[i].camchange_type =
+				DVB_CA_EN50221_CAMCHANGE_REMOVED;
+		mutex_init(&ca->slot_info[i].slot_lock);
+	}
+
+	mutex_init(&ca->ioctl_mutex);
+
+	if (signal_pending(current)) {
+		ret = -EINTR;
+		goto error;
+	}
+	mb();/*original*/
+
+	/* create a kthread for monitoring this CA device */
+	ca->thread = kthread_run(dvb_ca_en50221_thread, ca, "kdvb-ca-%i:%i",
+				 ca->dvbdev->adapter->num, ca->dvbdev->id);
+	if (IS_ERR(ca->thread)) {
+		ret = PTR_ERR(ca->thread);
+		printk("dvb_ca_init: failed to start kernel_thread (%d)\n",
+			ret);
+		goto error;
+	}
+	return 0;
+
+error:
+	if (ca != NULL) {
+		if (ca->dvbdev != NULL)
+			dvb_unregister_device(ca->dvbdev);
+		kfree(ca->slot_info);
+		kfree(ca->rbuf);
+		kfree(ca->wbuf);
+		kfree(ca);
+	}
+	pubca->private = NULL;
+	return ret;
+}
+EXPORT_SYMBOL(dvb_ca_en50221_cimax_release);
+
+
+
+/**
+ * Release a DVB CA EN50221 CIMAX interface device.
+ *
+ * @param ca_dev The dvb_struct device_s instance for the CA device.
+ * @param ca The associated dvb_ca instance.
+ */
+void dvb_ca_en50221_cimax_release(struct dvb_ca_en50221_cimax *pubca)
+{
+	struct dvb_ca_private *ca = pubca->private;
+	int i;
+
+	dprintk("%s\n", __func__);
+
+	/* shutdown the thread if there was one */
+	kthread_stop(ca->thread);
+
+	for (i = 0; i < ca->slot_count; i++) {
+		dvb_ca_en50221_slot_shutdown(ca, i);
+		vfree(ca->slot_info[i].rx_buffer.data);
+	}
+	kfree(ca->slot_info);
+	kfree(ca->rbuf);
+	kfree(ca->wbuf);
+	dvb_unregister_device(ca->dvbdev);
+	kfree(ca);
+	pubca->private = NULL;
+}
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.h b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.h
new file mode 100644
index 0000000..e2ebde6
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.h
@@ -0,0 +1,144 @@
+/*
+ * dvb_ca_cimax.h: generic DVB functions for EN50221 CA CIMAX interfaces
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DVB_CA_EN50221_CIMAX_H_
+#define _DVB_CA_EN50221_CIMAX_H_
+
+#include <linux/list.h>
+#include <linux/dvb/ca.h>
+
+#include "dvbdev.h"
+
+#define DVB_CA_EN50221_POLL_CAM_PRESENT	1
+#define DVB_CA_EN50221_POLL_CAM_CHANGED	2
+#define DVB_CA_EN50221_POLL_CAM_READY		4
+
+#define DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE	1
+#define DVB_CA_EN50221_FLAG_IRQ_FR		2
+#define DVB_CA_EN50221_FLAG_IRQ_DA		4
+
+#define DVB_CA_EN50221_CAMCHANGE_REMOVED		0
+#define DVB_CA_EN50221_CAMCHANGE_INSERTED		1
+
+#define DVB_CA_EN50221_CAP_IRQ	1
+
+/* Structure describing a CA interface */
+struct dvb_ca_en50221_cimax {
+
+	/* the module owning this structure */
+	struct module *owner;
+
+	/* NOTE: the read_*, write_* and poll_slot_status functions will be
+	 * called for different slots concurrently and need to use locks where
+	 * and if appropriate. There will be no concurrent access to one slot.
+	 */
+
+	/* functions for accessing attribute memory on the CAM */
+	int (*read_cis)(struct dvb_ca_en50221_cimax *ca,
+			int slot, u8 *buf, int size);
+	int (*write_cor)(struct dvb_ca_en50221_cimax *ca,
+			int slot, int address, u8 *buf);
+      /*return the final size or -1 for error*/
+	int (*negotiate)(struct dvb_ca_en50221_cimax *ca, int slot, int size);
+
+	/* functions for accessing the control interface on the CAM */
+	int (*read_lpdu)(struct dvb_ca_en50221_cimax *ca,
+			int slot, u8 *buf, int size);
+	int (*write_lpdu)(struct dvb_ca_en50221_cimax *ca,
+			int slot, u8 *buf, int size);
+
+	int (*cam_reset)(struct dvb_ca_en50221_cimax *ca, int slot);
+	int (*read_cam_status)(struct dvb_ca_en50221_cimax *ca, int slot);
+	int (*get_capbility)(struct dvb_ca_en50221_cimax *ca, int slot);
+
+	/* Functions for controlling slots */
+	int (*slot_reset)(struct dvb_ca_en50221_cimax *ca, int slot);
+	int (*slot_shutdown)(struct dvb_ca_en50221_cimax *ca, int slot);
+	int (*slot_ts_enable)(struct dvb_ca_en50221_cimax *ca, int slot);
+
+	/*
+	* Poll slot status.
+	* Only necessary if DVB_CA_FLAG_EN50221_IRQ_CAMCHANGE is not set
+	*/
+	int (*poll_slot_status)(struct dvb_ca_en50221_cimax *ca,
+			int slot, int open);
+
+	/* private data, used by caller */
+	void *data;
+
+	/* Opaque data used by the dvb_ca core. Do not modify! */
+	void *private;
+};
+
+
+
+
+/* ************************************************************************* */
+/* Functions for reporting IRQ events */
+
+/**
+ * A CAMCHANGE IRQ has occurred.
+ *
+ * @param ca CA instance.
+ * @param slot Slot concerned.
+ * @param change_type One of the DVB_CA_CAMCHANGE_* values
+ */
+void dvb_ca_en50221_cimax_camchange_irq(struct dvb_ca_en50221_cimax *pubca,
+		int slot, int change_type);
+
+/**
+ * A CAMREADY IRQ has occurred.
+ *
+ * @param ca CA instance.
+ * @param slot Slot concerned.
+ */
+void dvb_ca_en50221_cimax_camready_irq(struct dvb_ca_en50221_cimax *pubca,
+		int slot);
+
+/**
+ * An FR or a DA IRQ has occurred.
+ *
+ * @param ca CA instance.
+ * @param slot Slot concerned.
+ */
+void dvb_ca_en50221_cimax_frda_irq(struct dvb_ca_en50221_cimax *ca, int slot);
+
+
+
+/* ************************************************************************** */
+/* Initialisation/shutdown functions */
+
+/**
+ * Initialise a new DVB CA device.
+ *
+ * @param dvb_adapter DVB adapter to attach the new CA device to.
+ * @param ca The dvb_ca instance.
+ * @param flags Flags describing the CA device (DVB_CA_EN50221_FLAG_*).
+ * @param slot_count Number of slots supported.
+ *
+ * @return 0 on success, nonzero on failure
+ */
+extern int dvb_ca_en50221_cimax_init(struct dvb_adapter *dvb_adapter,
+		struct dvb_ca_en50221_cimax *ca, int flags, int slot_count);
+
+/**
+ * Release a DVB CA device.
+ *
+ * @param ca The associated dvb_ca instance.
+ */
+extern void dvb_ca_en50221_cimax_release(struct dvb_ca_en50221_cimax *ca);
+
+
+
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/dvb_ringbuffer.c b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ringbuffer.c
new file mode 100644
index 0000000..fa5c163
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ringbuffer.c
@@ -0,0 +1,381 @@
+/*
+ *
+ * dvb_ringbuffer.c: ring buffer implementation for the dvb driver
+ *
+ * Copyright (C) 2003 Oliver Endriss
+ * Copyright (C) 2004 Andrew de Quincey
+ *
+ * based on code originally found in av7110.c & dvb_ci.c:
+ * Copyright (C) 1999-2003 Ralph  Metzler
+ *                       & Marcus Metzler for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <asm/uaccess.h>
+
+#include "dvb_ringbuffer.h"
+
+#define PKT_READY 0
+#define PKT_DISPOSED 1
+
+
+void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data, size_t len)
+{
+	rbuf->pread=rbuf->pwrite=0;
+	rbuf->data=data;
+	rbuf->size=len;
+	rbuf->error=0;
+
+	init_waitqueue_head(&rbuf->queue);
+
+	spin_lock_init(&(rbuf->lock));
+}
+
+
+
+int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf)
+{
+	/* smp_load_acquire() to load write pointer on reader side
+	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),
+	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()
+	 *
+	 * for memory barriers also see Documentation/circular-buffers.txt
+	 */
+	return (rbuf->pread == smp_load_acquire(&rbuf->pwrite));
+}
+
+
+
+ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)
+{
+	ssize_t free;
+
+	/* ACCESS_ONCE() to load read pointer on writer side
+	 * this pairs with smp_store_release() in dvb_ringbuffer_read(),
+	 * dvb_ringbuffer_read_user(), dvb_ringbuffer_flush(),
+	 * or dvb_ringbuffer_reset()
+	 */
+	free = ACCESS_ONCE(rbuf->pread) - rbuf->pwrite;
+	if (free <= 0)
+		free += rbuf->size;
+	return free-1;
+}
+
+
+
+ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)
+{
+	ssize_t avail;
+
+	/* smp_load_acquire() to load write pointer on reader side
+	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),
+	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()
+	 */
+	avail = smp_load_acquire(&rbuf->pwrite) - rbuf->pread;
+	if (avail < 0)
+		avail += rbuf->size;
+	return avail;
+}
+
+
+
+void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf)
+{
+	/* dvb_ringbuffer_flush() counts as read operation
+	 * smp_load_acquire() to load write pointer
+	 * smp_store_release() to update read pointer, this ensures that the
+	 * correct pointer is visible for subsequent dvb_ringbuffer_free()
+	 * calls on other cpu cores
+	 */
+	smp_store_release(&rbuf->pread, smp_load_acquire(&rbuf->pwrite));
+	rbuf->error = 0;
+}
+//EXPORT_SYMBOL(dvb_ringbuffer_flush);
+
+void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf)
+{
+	/* dvb_ringbuffer_reset() counts as read and write operation
+	 * smp_store_release() to update read pointer
+	 */
+	smp_store_release(&rbuf->pread, 0);
+	/* smp_store_release() to update write pointer */
+	smp_store_release(&rbuf->pwrite, 0);
+	rbuf->error = 0;
+}
+
+void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&rbuf->lock, flags);
+	dvb_ringbuffer_flush(rbuf);
+	spin_unlock_irqrestore(&rbuf->lock, flags);
+
+	wake_up(&rbuf->queue);
+}
+
+ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf, u8 __user *buf, size_t len)
+{
+	size_t todo = len;
+	size_t split;
+
+	split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
+	if (split > 0) {
+		if (copy_to_user(buf, rbuf->data+rbuf->pread, split))
+			return -EFAULT;
+		buf += split;
+		todo -= split;
+		/* smp_store_release() for read pointer update to ensure
+		 * that buf is not overwritten until read is complete,
+		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()
+		 */
+		smp_store_release(&rbuf->pread, 0);
+	}
+	if (copy_to_user(buf, rbuf->data+rbuf->pread, todo))
+		return -EFAULT;
+
+	/* smp_store_release() to update read pointer, see above */
+	smp_store_release(&rbuf->pread, (rbuf->pread + todo) % rbuf->size);
+
+	return len;
+}
+
+void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len)
+{
+	size_t todo = len;
+	size_t split;
+
+	split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
+	if (split > 0) {
+		memcpy(buf, rbuf->data+rbuf->pread, split);
+		buf += split;
+		todo -= split;
+		/* smp_store_release() for read pointer update to ensure
+		 * that buf is not overwritten until read is complete,
+		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()
+		 */
+		smp_store_release(&rbuf->pread, 0);
+	}
+	memcpy(buf, rbuf->data+rbuf->pread, todo);
+
+	/* smp_store_release() to update read pointer, see above */
+	smp_store_release(&rbuf->pread, (rbuf->pread + todo) % rbuf->size);
+}
+
+
+ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t len)
+{
+	size_t todo = len;
+	size_t split;
+
+	split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
+
+	if (split > 0) {
+		memcpy(rbuf->data+rbuf->pwrite, buf, split);
+		buf += split;
+		todo -= split;
+		/* smp_store_release() for write pointer update to ensure that
+		 * written data is visible on other cpu cores before the pointer
+		 * update, this pairs with smp_load_acquire() in
+		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()
+		 */
+		smp_store_release(&rbuf->pwrite, 0);
+	}
+	memcpy(rbuf->data+rbuf->pwrite, buf, todo);
+	/* smp_store_release() for write pointer update, see above */
+	smp_store_release(&rbuf->pwrite, (rbuf->pwrite + todo) % rbuf->size);
+
+	return len;
+}
+
+ssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,
+				  const u8 __user *buf, size_t len)
+{
+	int status;
+	size_t todo = len;
+	size_t split;
+
+	split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
+
+	if (split > 0) {
+		status = copy_from_user(rbuf->data+rbuf->pwrite, buf, split);
+		if (status)
+			return len - todo;
+		buf += split;
+		todo -= split;
+		/* smp_store_release() for write pointer update to ensure that
+		 * written data is visible on other cpu cores before the pointer
+		 * update, this pairs with smp_load_acquire() in
+		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()
+		 */
+		smp_store_release(&rbuf->pwrite, 0);
+	}
+	status = copy_from_user(rbuf->data+rbuf->pwrite, buf, todo);
+	if (status)
+		return len - todo;
+	/* smp_store_release() for write pointer update, see above */
+	smp_store_release(&rbuf->pwrite, (rbuf->pwrite + todo) % rbuf->size);
+
+	return len;
+}
+
+ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8* buf, size_t len)
+{
+	int status;
+	ssize_t oldpwrite = rbuf->pwrite;
+
+	DVB_RINGBUFFER_WRITE_BYTE(rbuf, len >> 8);
+	DVB_RINGBUFFER_WRITE_BYTE(rbuf, len & 0xff);
+	DVB_RINGBUFFER_WRITE_BYTE(rbuf, PKT_READY);
+	status = dvb_ringbuffer_write(rbuf, buf, len);
+
+	if (status < 0) rbuf->pwrite = oldpwrite;
+	return status;
+}
+
+ssize_t dvb_ringbuffer_pkt_read_user(struct dvb_ringbuffer *rbuf, size_t idx,
+				int offset, u8 __user *buf, size_t len)
+{
+	size_t todo;
+	size_t split;
+	size_t pktlen;
+
+	pktlen = rbuf->data[idx] << 8;
+	pktlen |= rbuf->data[(idx + 1) % rbuf->size];
+	if (offset > pktlen) return -EINVAL;
+	if ((offset + len) > pktlen) len = pktlen - offset;
+
+	idx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;
+	todo = len;
+	split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
+	if (split > 0) {
+		if (copy_to_user(buf, rbuf->data+idx, split))
+			return -EFAULT;
+		buf += split;
+		todo -= split;
+		idx = 0;
+	}
+	if (copy_to_user(buf, rbuf->data+idx, todo))
+		return -EFAULT;
+
+	return len;
+}
+
+ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
+				int offset, u8* buf, size_t len)
+{
+	size_t todo;
+	size_t split;
+	size_t pktlen;
+
+	pktlen = rbuf->data[idx] << 8;
+	pktlen |= rbuf->data[(idx + 1) % rbuf->size];
+	if (offset > pktlen) return -EINVAL;
+	if ((offset + len) > pktlen) len = pktlen - offset;
+
+	idx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;
+	todo = len;
+	split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
+	if (split > 0) {
+		memcpy(buf, rbuf->data+idx, split);
+		buf += split;
+		todo -= split;
+		idx = 0;
+	}
+	memcpy(buf, rbuf->data+idx, todo);
+	return len;
+}
+
+void dvb_ringbuffer_pkt_dispose(struct dvb_ringbuffer *rbuf, size_t idx)
+{
+	size_t pktlen;
+
+	rbuf->data[(idx + 2) % rbuf->size] = PKT_DISPOSED;
+
+	// clean up disposed packets
+	while(dvb_ringbuffer_avail(rbuf) > DVB_RINGBUFFER_PKTHDRSIZE) {
+		if (DVB_RINGBUFFER_PEEK(rbuf, 2) == PKT_DISPOSED) {
+			pktlen = DVB_RINGBUFFER_PEEK(rbuf, 0) << 8;
+			pktlen |= DVB_RINGBUFFER_PEEK(rbuf, 1);
+			DVB_RINGBUFFER_SKIP(rbuf, pktlen + DVB_RINGBUFFER_PKTHDRSIZE);
+		} else {
+			// first packet is not disposed, so we stop cleaning now
+			break;
+		}
+	}
+}
+
+ssize_t dvb_ringbuffer_pkt_next(struct dvb_ringbuffer *rbuf, size_t idx, size_t* pktlen)
+{
+	int consumed;
+	int curpktlen;
+	int curpktstatus;
+
+	if (idx == -1) {
+	       idx = rbuf->pread;
+	} else {
+		curpktlen = rbuf->data[idx] << 8;
+		curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
+		idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
+	}
+
+	consumed = (idx - rbuf->pread) % rbuf->size;
+
+	while((dvb_ringbuffer_avail(rbuf) - consumed) > DVB_RINGBUFFER_PKTHDRSIZE) {
+
+		curpktlen = rbuf->data[idx] << 8;
+		curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
+		curpktstatus = rbuf->data[(idx + 2) % rbuf->size];
+
+		if (curpktstatus == PKT_READY) {
+			*pktlen = curpktlen;
+			return idx;
+		}
+
+		consumed += curpktlen + DVB_RINGBUFFER_PKTHDRSIZE;
+		idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
+	}
+
+	// no packets available
+	return -1;
+}
+
+
+#if 0
+EXPORT_SYMBOL(dvb_ringbuffer_init);
+EXPORT_SYMBOL(dvb_ringbuffer_empty);
+EXPORT_SYMBOL(dvb_ringbuffer_free);
+EXPORT_SYMBOL(dvb_ringbuffer_avail);
+EXPORT_SYMBOL(dvb_ringbuffer_flush_spinlock_wakeup);
+EXPORT_SYMBOL(dvb_ringbuffer_read_user);
+EXPORT_SYMBOL(dvb_ringbuffer_read);
+EXPORT_SYMBOL(dvb_ringbuffer_write);
+EXPORT_SYMBOL(dvb_ringbuffer_write_user);
+#endif
+EXPORT_SYMBOL(dvb_ringbuffer_pkt_read);
+EXPORT_SYMBOL(dvb_ringbuffer_pkt_write);
+EXPORT_SYMBOL(dvb_ringbuffer_pkt_next);
+EXPORT_SYMBOL(dvb_ringbuffer_pkt_dispose);
+EXPORT_SYMBOL(dvb_ringbuffer_pkt_read_user);
+
+
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/dvb_ringbuffer.h b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ringbuffer.h
new file mode 100644
index 0000000..bbe9487
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ringbuffer.h
@@ -0,0 +1,280 @@
+/*
+ *
+ * dvb_ringbuffer.h: ring buffer implementation for the dvb driver
+ *
+ * Copyright (C) 2003 Oliver Endriss
+ * Copyright (C) 2004 Andrew de Quincey
+ *
+ * based on code originally found in av7110.c & dvb_ci.c:
+ * Copyright (C) 1999-2003 Ralph Metzler & Marcus Metzler
+ *                         for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ */
+
+#ifndef _DVB_RINGBUFFER_H_
+#define _DVB_RINGBUFFER_H_
+
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+
+/**
+ * struct dvb_ringbuffer - Describes a ring buffer used at DVB framework
+ *
+ * @data: Area were the ringbuffer data is written
+ * @size: size of the ringbuffer
+ * @pread: next position to read
+ * @pwrite: next position to write
+ * @error: used by ringbuffer clients to indicate that an error happened.
+ * @queue: Wait queue used by ringbuffer clients to indicate when buffer
+ *         was filled
+ * @lock: Spinlock used to protect the ringbuffer
+ */
+struct dvb_ringbuffer {
+	u8               *data;
+	ssize_t           size;
+	ssize_t           pread;
+	ssize_t           pwrite;
+	int               error;
+
+	wait_queue_head_t queue;
+	spinlock_t        lock;
+};
+
+#define DVB_RINGBUFFER_PKTHDRSIZE 3
+
+/**
+ * dvb_ringbuffer_init - initialize ring buffer, lock and queue
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ * @data: pointer to the buffer where the data will be stored
+ * @len: bytes from ring buffer into @buf
+ */
+extern void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data,
+				size_t len);
+
+/**
+ * dvb_ringbuffer_empty - test whether buffer is empty
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ */
+extern int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf);
+
+/**
+ * dvb_ringbuffer_free - returns the number of free bytes in the buffer
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ *
+ * Return: number of free bytes in the buffer
+ */
+extern ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf);
+
+/**
+ * dvb_ringbuffer_avail - returns the number of bytes waiting in the buffer
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ *
+ * Return: number of bytes waiting in the buffer
+ */
+extern ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf);
+
+/**
+ * dvb_ringbuffer_reset - resets the ringbuffer to initial state
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ *
+ * Resets the read and write pointers to zero and flush the buffer.
+ *
+ * This counts as a read and write operation
+ */
+extern void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf);
+
+/*
+ * read routines & macros
+ */
+
+/**
+ * dvb_ringbuffer_flush - flush buffer
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ */
+extern void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf);
+
+/**
+ * dvb_ringbuffer_flush_spinlock_wakeup- flush buffer protected by spinlock
+ *      and wake-up waiting task(s)
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ */
+extern void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf);
+
+/**
+ * DVB_RINGBUFFER_PEEK - peek at byte @offs in the buffer
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ * @offs: offset inside the ringbuffer
+ */
+#define DVB_RINGBUFFER_PEEK(rbuf, offs)	\
+			((rbuf)->data[((rbuf)->pread + (offs)) % (rbuf)->size])
+
+/**
+ * DVB_RINGBUFFER_SKIP - advance read ptr by @num bytes
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ * @num: number of bytes to advance
+ */
+#define DVB_RINGBUFFER_SKIP(rbuf, num)	{\
+			(rbuf)->pread = ((rbuf)->pread + (num)) % (rbuf)->size;\
+}
+
+/**
+ * dvb_ringbuffer_read_user - Reads a buffer into an user pointer
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ * @buf: pointer to the buffer where the data will be stored
+ * @len: bytes from ring buffer into @buf
+ *
+ * This variant assumes that the buffer is a memory at the userspace. So,
+ * it will internally call copy_to_user().
+ *
+ * Return: number of bytes transferred or -EFAULT
+ */
+extern ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf,
+				   u8 __user *buf, size_t len);
+
+/**
+ * dvb_ringbuffer_read - Reads a buffer into a pointer
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ * @buf: pointer to the buffer where the data will be stored
+ * @len: bytes from ring buffer into @buf
+ *
+ * This variant assumes that the buffer is a memory at the Kernel space
+ *
+ * Return: number of bytes transferred or -EFAULT
+ */
+extern void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf,
+				   u8 *buf, size_t len);
+
+/*
+ * write routines & macros
+ */
+
+/**
+ * DVB_RINGBUFFER_WRITE_BYTE - write single byte to ring buffer
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ * @byte: byte to write
+ */
+#define DVB_RINGBUFFER_WRITE_BYTE(rbuf, byte)	\
+			{ (rbuf)->data[(rbuf)->pwrite] = (byte); \
+			(rbuf)->pwrite = ((rbuf)->pwrite + 1) % (rbuf)->size; }
+
+/**
+ * dvb_ringbuffer_write - Writes a buffer into the ringbuffer
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ * @buf: pointer to the buffer where the data will be read
+ * @len: bytes from ring buffer into @buf
+ *
+ * This variant assumes that the buffer is a memory at the Kernel space
+ *
+ * return: number of bytes transferred or -EFAULT
+ */
+extern ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf,
+				    size_t len);
+
+/**
+ * dvb_ringbuffer_write_user - Writes a buffer received via an user pointer
+ *
+ * @rbuf: pointer to struct dvb_ringbuffer
+ * @buf: pointer to the buffer where the data will be read
+ * @len: bytes from ring buffer into @buf
+ *
+ * This variant assumes that the buffer is a memory at the userspace. So,
+ * it will internally call copy_from_user().
+ *
+ * Return: number of bytes transferred or -EFAULT
+ */
+extern ssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,
+					 const u8 __user *buf, size_t len);
+
+/**
+ * dvb_ringbuffer_pkt_write - Write a packet into the ringbuffer.
+ *
+ * @rbuf: Ringbuffer to write to.
+ * @buf: Buffer to write.
+ * @len: Length of buffer (currently limited to 65535 bytes max).
+ *
+ * Return: Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.
+ */
+extern ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8 *buf,
+					size_t len);
+
+/**
+ * dvb_ringbuffer_pkt_read_user - Read from a packet in the ringbuffer.
+ *
+ * @rbuf: Ringbuffer concerned.
+ * @idx: Packet index as returned by dvb_ringbuffer_pkt_next().
+ * @offset: Offset into packet to read from.
+ * @buf: Destination buffer for data.
+ * @len: Size of destination buffer.
+ *
+ * Return: Number of bytes read, or -EFAULT.
+ *
+ * .. note::
+ *
+ *    unlike dvb_ringbuffer_read(), this does **NOT** update the read pointer
+ *    in the ringbuffer. You must use dvb_ringbuffer_pkt_dispose() to mark a
+ *    packet as no longer required.
+ */
+extern ssize_t dvb_ringbuffer_pkt_read_user(struct dvb_ringbuffer *rbuf,
+					    size_t idx,
+					    int offset, u8 __user *buf,
+					    size_t len);
+
+/**
+ * dvb_ringbuffer_pkt_read - Read from a packet in the ringbuffer.
+ * Note: unlike dvb_ringbuffer_read_user(), this DOES update the read pointer
+ * in the ringbuffer.
+ *
+ * @rbuf: Ringbuffer concerned.
+ * @idx: Packet index as returned by dvb_ringbuffer_pkt_next().
+ * @offset: Offset into packet to read from.
+ * @buf: Destination buffer for data.
+ * @len: Size of destination buffer.
+ *
+ * Return: Number of bytes read, or -EFAULT.
+ */
+extern ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
+				       int offset, u8 *buf, size_t len);
+
+/**
+ * dvb_ringbuffer_pkt_dispose - Dispose of a packet in the ring buffer.
+ *
+ * @rbuf: Ring buffer concerned.
+ * @idx: Packet index as returned by dvb_ringbuffer_pkt_next().
+ */
+extern void dvb_ringbuffer_pkt_dispose(struct dvb_ringbuffer *rbuf, size_t idx);
+
+/**
+ * dvb_ringbuffer_pkt_next - Get the index of the next packet in a ringbuffer.
+ *
+ * @rbuf: Ringbuffer concerned.
+ * @idx: Previous packet index, or -1 to return the first packet index.
+ * @pktlen: On success, will be updated to contain the length of the packet
+ *          in bytes.
+ * returns Packet index (if >=0), or -1 if no packets available.
+ */
+extern ssize_t dvb_ringbuffer_pkt_next(struct dvb_ringbuffer *rbuf,
+				       size_t idx, size_t *pktlen);
+
+#endif /* _DVB_RINGBUFFER_H_ */
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/dvbdev.c b/drivers/stream_input/parser/dvb_ci/cimax/dvbdev.c
new file mode 100644
index 0000000..0e9599b
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/dvbdev.c
@@ -0,0 +1,968 @@
+/*
+ * dvbdev.c
+ *
+ * Copyright (C) 2000 Ralph  Metzler <ralph@convergence.de>
+ *                  & Marcus Metzler <marcus@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/mutex.h>
+#include "dvbdev.h"
+
+/* Due to enum tuner_pad_index */
+#include <media/tuner.h>
+
+static DEFINE_MUTEX(dvbdev_mutex);
+static int dvbdev_debug;
+
+module_param(dvbdev_debug, int, 0644);
+MODULE_PARM_DESC(dvbdev_debug, "Turn on/off device debugging (default:off).");
+
+#define dprintk if (dvbdev_debug) printk
+
+static LIST_HEAD(dvb_adapter_list);
+static DEFINE_MUTEX(dvbdev_register_lock);
+
+static const char * const dnames[] = {
+	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
+	"net", "osd"
+};
+
+#ifdef CONFIG_DVB_DYNAMIC_MINORS
+#define MAX_DVB_MINORS		256
+#define DVB_MAX_IDS		MAX_DVB_MINORS
+#else
+#define DVB_MAX_IDS		4
+#define nums2minor(num, type, id)	((num << 6) | (id << 4) | type)
+#define MAX_DVB_MINORS		(DVB_MAX_ADAPTERS*64)
+#endif
+
+static struct class *dvb_class;
+
+static struct dvb_device *dvb_minors[MAX_DVB_MINORS];
+static DECLARE_RWSEM(minor_rwsem);
+
+static int dvb_device_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev;
+
+	mutex_lock(&dvbdev_mutex);
+	down_read(&minor_rwsem);
+	dvbdev = dvb_minors[iminor(inode)];
+
+	if (dvbdev && dvbdev->fops) {
+		int err = 0;
+		const struct file_operations *new_fops;
+
+		new_fops = fops_get(dvbdev->fops);
+		if (!new_fops)
+			goto fail;
+		file->private_data = dvbdev;
+		replace_fops(file, new_fops);
+		if (file->f_op->open)
+			err = file->f_op->open(inode, file);
+		up_read(&minor_rwsem);
+		mutex_unlock(&dvbdev_mutex);
+		return err;
+	}
+fail:
+	up_read(&minor_rwsem);
+	mutex_unlock(&dvbdev_mutex);
+	return -ENODEV;
+}
+
+
+static const struct file_operations dvb_device_fops =
+{
+	.owner =	THIS_MODULE,
+	.open =		dvb_device_open,
+	.llseek =	noop_llseek,
+};
+
+static struct cdev dvb_device_cdev;
+
+int dvb_generic_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+
+	if (!dvbdev)
+		return -ENODEV;
+
+	if (!dvbdev->users)
+		return -EBUSY;
+
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
+		if (!dvbdev->readers)
+			return -EBUSY;
+		dvbdev->readers--;
+	} else {
+		if (!dvbdev->writers)
+			return -EBUSY;
+		dvbdev->writers--;
+	}
+
+	dvbdev->users--;
+	return 0;
+}
+EXPORT_SYMBOL(dvb_generic_open);
+
+
+int dvb_generic_release(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+
+	if (!dvbdev)
+		return -ENODEV;
+
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
+		dvbdev->readers++;
+	} else {
+		dvbdev->writers++;
+	}
+
+	dvbdev->users++;
+	return 0;
+}
+EXPORT_SYMBOL(dvb_generic_release);
+
+
+long dvb_generic_ioctl(struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+
+	if (!dvbdev)
+		return -ENODEV;
+
+	if (!dvbdev->kernel_ioctl)
+		return -EINVAL;
+
+	return dvb_usercopy(file, cmd, arg, dvbdev->kernel_ioctl);
+}
+EXPORT_SYMBOL(dvb_generic_ioctl);
+
+
+static int dvbdev_get_free_id (struct dvb_adapter *adap, int type)
+{
+	u32 id = 0;
+
+	while (id < DVB_MAX_IDS) {
+		struct dvb_device *dev;
+		list_for_each_entry(dev, &adap->device_list, list_head)
+			if (dev->type == type && dev->id == id)
+				goto skip;
+		return id;
+skip:
+		id++;
+	}
+	return -ENFILE;
+}
+
+static void dvb_media_device_free(struct dvb_device *dvbdev)
+{
+#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
+	if (dvbdev->entity) {
+		media_device_unregister_entity(dvbdev->entity);
+		kfree(dvbdev->entity);
+		kfree(dvbdev->pads);
+		dvbdev->entity = NULL;
+		dvbdev->pads = NULL;
+	}
+
+	if (dvbdev->tsout_entity) {
+		int i;
+
+		for (i = 0; i < dvbdev->tsout_num_entities; i++) {
+			media_device_unregister_entity(&dvbdev->tsout_entity[i]);
+			kfree(dvbdev->tsout_entity[i].name);
+		}
+		kfree(dvbdev->tsout_entity);
+		kfree(dvbdev->tsout_pads);
+		dvbdev->tsout_entity = NULL;
+		dvbdev->tsout_pads = NULL;
+
+		dvbdev->tsout_num_entities = 0;
+	}
+
+	if (dvbdev->intf_devnode) {
+		media_devnode_remove(dvbdev->intf_devnode);
+		dvbdev->intf_devnode = NULL;
+	}
+
+	if (dvbdev->adapter->conn) {
+		media_device_unregister_entity(dvbdev->adapter->conn);
+		dvbdev->adapter->conn = NULL;
+		kfree(dvbdev->adapter->conn_pads);
+		dvbdev->adapter->conn_pads = NULL;
+	}
+#endif
+}
+
+#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
+static int dvb_create_tsout_entity(struct dvb_device *dvbdev,
+				    const char *name, int npads)
+{
+	int i, ret = 0;
+
+	dvbdev->tsout_pads = kcalloc(npads, sizeof(*dvbdev->tsout_pads),
+				     GFP_KERNEL);
+	if (!dvbdev->tsout_pads)
+		return -ENOMEM;
+
+	dvbdev->tsout_entity = kcalloc(npads, sizeof(*dvbdev->tsout_entity),
+				       GFP_KERNEL);
+	if (!dvbdev->tsout_entity)
+		return -ENOMEM;
+
+	dvbdev->tsout_num_entities = npads;
+
+	for (i = 0; i < npads; i++) {
+		struct media_pad *pads = &dvbdev->tsout_pads[i];
+		struct media_entity *entity = &dvbdev->tsout_entity[i];
+
+		entity->name = kasprintf(GFP_KERNEL, "%s #%d", name, i);
+		if (!entity->name)
+			return -ENOMEM;
+
+		entity->function = MEDIA_ENT_F_IO_DTV;
+		pads->flags = MEDIA_PAD_FL_SINK;
+
+		ret = media_entity_pads_init(entity, 1, pads);
+		if (ret < 0)
+			return ret;
+
+		ret = media_device_register_entity(dvbdev->adapter->mdev,
+						   entity);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+#define DEMUX_TSOUT	"demux-tsout"
+#define DVR_TSOUT	"dvr-tsout"
+
+static int dvb_create_media_entity(struct dvb_device *dvbdev,
+				   int type, int demux_sink_pads)
+{
+	int i, ret, npads;
+
+	switch (type) {
+	case DVB_DEVICE_FRONTEND:
+		npads = 2;
+		break;
+	case DVB_DEVICE_DVR:
+		ret = dvb_create_tsout_entity(dvbdev, DVR_TSOUT,
+					      demux_sink_pads);
+		return ret;
+	case DVB_DEVICE_DEMUX:
+		npads = 1 + demux_sink_pads;
+		ret = dvb_create_tsout_entity(dvbdev, DEMUX_TSOUT,
+					      demux_sink_pads);
+		if (ret < 0)
+			return ret;
+		break;
+	case DVB_DEVICE_CA:
+		npads = 2;
+		break;
+	case DVB_DEVICE_NET:
+		/*
+		 * We should be creating entities for the MPE/ULE
+		 * decapsulation hardware (or software implementation).
+		 *
+		 * However, the number of for the MPE/ULE decaps may not be
+		 * fixed. As we don't have yet dynamic support for PADs at
+		 * the Media Controller, let's not create the decap
+		 * entities yet.
+		 */
+		return 0;
+	default:
+		return 0;
+	}
+
+	dvbdev->entity = kzalloc(sizeof(*dvbdev->entity), GFP_KERNEL);
+	if (!dvbdev->entity)
+		return -ENOMEM;
+
+	dvbdev->entity->name = dvbdev->name;
+
+	if (npads) {
+		dvbdev->pads = kcalloc(npads, sizeof(*dvbdev->pads),
+				       GFP_KERNEL);
+		if (!dvbdev->pads)
+			return -ENOMEM;
+	}
+
+	switch (type) {
+	case DVB_DEVICE_FRONTEND:
+		dvbdev->entity->function = MEDIA_ENT_F_DTV_DEMOD;
+		dvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;
+		dvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;
+		break;
+	case DVB_DEVICE_DEMUX:
+		dvbdev->entity->function = MEDIA_ENT_F_TS_DEMUX;
+		dvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;
+		for (i = 1; i < npads; i++)
+			dvbdev->pads[i].flags = MEDIA_PAD_FL_SOURCE;
+		break;
+	case DVB_DEVICE_CA:
+		dvbdev->entity->function = MEDIA_ENT_F_DTV_CA;
+		dvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;
+		dvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;
+		break;
+	default:
+		/* Should never happen, as the first switch prevents it */
+		kfree(dvbdev->entity);
+		kfree(dvbdev->pads);
+		dvbdev->entity = NULL;
+		dvbdev->pads = NULL;
+		return 0;
+	}
+
+	if (npads) {
+		ret = media_entity_pads_init(dvbdev->entity, npads, dvbdev->pads);
+		if (ret)
+			return ret;
+	}
+	ret = media_device_register_entity(dvbdev->adapter->mdev,
+					   dvbdev->entity);
+	if (ret)
+		return ret;
+
+	printk(KERN_DEBUG "%s: media entity '%s' registered.\n",
+		__func__, dvbdev->entity->name);
+
+	return 0;
+}
+#endif
+
+static int dvb_register_media_device(struct dvb_device *dvbdev,
+				     int type, int minor,
+				     unsigned demux_sink_pads)
+{
+#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
+	struct media_link *link;
+	u32 intf_type;
+	int ret;
+
+	if (!dvbdev->adapter->mdev)
+		return 0;
+
+	ret = dvb_create_media_entity(dvbdev, type, demux_sink_pads);
+	if (ret)
+		return ret;
+
+	switch (type) {
+	case DVB_DEVICE_FRONTEND:
+		intf_type = MEDIA_INTF_T_DVB_FE;
+		break;
+	case DVB_DEVICE_DEMUX:
+		intf_type = MEDIA_INTF_T_DVB_DEMUX;
+		break;
+	case DVB_DEVICE_DVR:
+		intf_type = MEDIA_INTF_T_DVB_DVR;
+		break;
+	case DVB_DEVICE_CA:
+		intf_type = MEDIA_INTF_T_DVB_CA;
+		break;
+	case DVB_DEVICE_NET:
+		intf_type = MEDIA_INTF_T_DVB_NET;
+		break;
+	default:
+		return 0;
+	}
+
+	dvbdev->intf_devnode = media_devnode_create(dvbdev->adapter->mdev,
+						    intf_type, 0,
+						    DVB_MAJOR, minor);
+
+	if (!dvbdev->intf_devnode)
+		return -ENOMEM;
+
+	/*
+	 * Create the "obvious" link, e. g. the ones that represent
+	 * a direct association between an interface and an entity.
+	 * Other links should be created elsewhere, like:
+	 *		DVB FE intf    -> tuner
+	 *		DVB demux intf -> dvr
+	 */
+
+	if (!dvbdev->entity)
+		return 0;
+
+	link = media_create_intf_link(dvbdev->entity, &dvbdev->intf_devnode->intf,
+				      MEDIA_LNK_FL_ENABLED);
+	if (!link)
+		return -ENOMEM;
+#endif
+	return 0;
+}
+
+int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
+			const struct dvb_device *template, void *priv, int type,
+			int demux_sink_pads)
+{
+	struct dvb_device *dvbdev;
+	struct file_operations *dvbdevfops;
+	struct device *clsdev;
+	int minor;
+	int id, ret;
+
+	mutex_lock(&dvbdev_register_lock);
+
+	if ((id = dvbdev_get_free_id (adap, type)) < 0){
+		mutex_unlock(&dvbdev_register_lock);
+		*pdvbdev = NULL;
+		printk(KERN_ERR "%s: couldn't find free device id\n", __func__);
+		return -ENFILE;
+	}
+
+	*pdvbdev = dvbdev = kzalloc(sizeof(*dvbdev), GFP_KERNEL);
+
+	if (!dvbdev){
+		mutex_unlock(&dvbdev_register_lock);
+		return -ENOMEM;
+	}
+
+	dvbdevfops = kzalloc(sizeof(struct file_operations), GFP_KERNEL);
+
+	if (!dvbdevfops){
+		kfree (dvbdev);
+		mutex_unlock(&dvbdev_register_lock);
+		return -ENOMEM;
+	}
+
+	memcpy(dvbdev, template, sizeof(struct dvb_device));
+	dvbdev->type = type;
+	dvbdev->id = id;
+	dvbdev->adapter = adap;
+	dvbdev->priv = priv;
+	dvbdev->fops = dvbdevfops;
+	init_waitqueue_head (&dvbdev->wait_queue);
+
+	memcpy(dvbdevfops, template->fops, sizeof(struct file_operations));
+	dvbdevfops->owner = adap->module;
+
+	list_add_tail (&dvbdev->list_head, &adap->device_list);
+
+	down_write(&minor_rwsem);
+#ifdef CONFIG_DVB_DYNAMIC_MINORS
+	for (minor = 0; minor < MAX_DVB_MINORS; minor++)
+		if (dvb_minors[minor] == NULL)
+			break;
+
+	if (minor == MAX_DVB_MINORS) {
+		kfree(dvbdevfops);
+		kfree(dvbdev);
+		up_write(&minor_rwsem);
+		mutex_unlock(&dvbdev_register_lock);
+		return -EINVAL;
+	}
+#else
+	minor = nums2minor(adap->num, type, id);
+#endif
+
+	dvbdev->minor = minor;
+	dvb_minors[minor] = dvbdev;
+	up_write(&minor_rwsem);
+
+	ret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);
+	if (ret) {
+		printk(KERN_ERR
+		      "%s: dvb_register_media_device failed to create the mediagraph\n",
+		      __func__);
+
+		dvb_media_device_free(dvbdev);
+		kfree(dvbdevfops);
+		kfree(dvbdev);
+		up_write(&minor_rwsem);
+		mutex_unlock(&dvbdev_register_lock);
+		return ret;
+	}
+
+	mutex_unlock(&dvbdev_register_lock);
+
+	clsdev = device_create(dvb_class, adap->device,
+			       MKDEV(DVB_MAJOR, minor),
+			       dvbdev, "dvb%d.%s%d", adap->num, dnames[type], id);
+	if (IS_ERR(clsdev)) {
+		printk(KERN_ERR "%s: failed to create device dvb%d.%s%d (%ld)\n",
+		       __func__, adap->num, dnames[type], id, PTR_ERR(clsdev));
+		return PTR_ERR(clsdev);
+	}
+	dprintk(KERN_DEBUG "DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
+		adap->num, dnames[type], id, minor, minor);
+
+	return 0;
+}
+EXPORT_SYMBOL(dvb_register_device);
+
+
+void dvb_unregister_device(struct dvb_device *dvbdev)
+{
+	if (!dvbdev)
+		return;
+
+	down_write(&minor_rwsem);
+	dvb_minors[dvbdev->minor] = NULL;
+	up_write(&minor_rwsem);
+
+	dvb_media_device_free(dvbdev);
+
+	device_destroy(dvb_class, MKDEV(DVB_MAJOR, dvbdev->minor));
+
+	list_del (&dvbdev->list_head);
+	kfree (dvbdev->fops);
+	kfree (dvbdev);
+}
+EXPORT_SYMBOL(dvb_unregister_device);
+
+
+#ifdef CONFIG_MEDIA_CONTROLLER_DVB
+
+static int dvb_create_io_intf_links(struct dvb_adapter *adap,
+				    struct media_interface *intf,
+				    char *name)
+{
+	struct media_device *mdev = adap->mdev;
+	struct media_entity *entity;
+	struct media_link *link;
+
+	media_device_for_each_entity(entity, mdev) {
+		if (entity->function == MEDIA_ENT_F_IO_DTV) {
+			if (strncmp(entity->name, name, strlen(name)))
+				continue;
+			link = media_create_intf_link(entity, intf,
+						      MEDIA_LNK_FL_ENABLED);
+			if (!link)
+				return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+int dvb_create_media_graph(struct dvb_adapter *adap,
+			   bool create_rf_connector)
+{
+	struct media_device *mdev = adap->mdev;
+	struct media_entity *entity, *tuner = NULL, *demod = NULL, *conn;
+	struct media_entity *demux = NULL, *ca = NULL;
+	struct media_link *link;
+	struct media_interface *intf;
+	unsigned demux_pad = 0;
+	unsigned dvr_pad = 0;
+	unsigned ntuner = 0, ndemod = 0;
+	int ret;
+	static const char *connector_name = "Television";
+
+	if (!mdev)
+		return 0;
+
+	media_device_for_each_entity(entity, mdev) {
+		switch (entity->function) {
+		case MEDIA_ENT_F_TUNER:
+			tuner = entity;
+			ntuner++;
+			break;
+		case MEDIA_ENT_F_DTV_DEMOD:
+			demod = entity;
+			ndemod++;
+			break;
+		case MEDIA_ENT_F_TS_DEMUX:
+			demux = entity;
+			break;
+		case MEDIA_ENT_F_DTV_CA:
+			ca = entity;
+			break;
+		}
+	}
+
+	/*
+	 * Prepare to signalize to media_create_pad_links() that multiple
+	 * entities of the same type exists and a 1:n or n:1 links need to be
+	 * created.
+	 * NOTE: if both tuner and demod have multiple instances, it is up
+	 * to the caller driver to create such links.
+	 */
+	if (ntuner > 1)
+		tuner = NULL;
+	if (ndemod > 1)
+		demod = NULL;
+
+	if (create_rf_connector) {
+		conn = kzalloc(sizeof(*conn), GFP_KERNEL);
+		if (!conn)
+			return -ENOMEM;
+		adap->conn = conn;
+
+		adap->conn_pads = kzalloc(sizeof(*adap->conn_pads), GFP_KERNEL);
+		if (!adap->conn_pads)
+			return -ENOMEM;
+
+		conn->flags = MEDIA_ENT_FL_CONNECTOR;
+		conn->function = MEDIA_ENT_F_CONN_RF;
+		conn->name = connector_name;
+		adap->conn_pads->flags = MEDIA_PAD_FL_SOURCE;
+
+		ret = media_entity_pads_init(conn, 1, adap->conn_pads);
+		if (ret)
+			return ret;
+
+		ret = media_device_register_entity(mdev, conn);
+		if (ret)
+			return ret;
+
+		if (!ntuner)
+			ret = media_create_pad_links(mdev,
+						     MEDIA_ENT_F_CONN_RF,
+						     conn, 0,
+						     MEDIA_ENT_F_DTV_DEMOD,
+						     demod, 0,
+						     MEDIA_LNK_FL_ENABLED,
+						     false);
+		else
+			ret = media_create_pad_links(mdev,
+						     MEDIA_ENT_F_CONN_RF,
+						     conn, 0,
+						     MEDIA_ENT_F_TUNER,
+						     tuner, TUNER_PAD_RF_INPUT,
+						     MEDIA_LNK_FL_ENABLED,
+						     false);
+		if (ret)
+			return ret;
+	}
+
+	if (ntuner && ndemod) {
+		ret = media_create_pad_links(mdev,
+					     MEDIA_ENT_F_TUNER,
+					     tuner, TUNER_PAD_OUTPUT,
+					     MEDIA_ENT_F_DTV_DEMOD,
+					     demod, 0, MEDIA_LNK_FL_ENABLED,
+					     false);
+		if (ret)
+			return ret;
+	}
+
+	if (ndemod && demux) {
+		ret = media_create_pad_links(mdev,
+					     MEDIA_ENT_F_DTV_DEMOD,
+					     demod, 1,
+					     MEDIA_ENT_F_TS_DEMUX,
+					     demux, 0, MEDIA_LNK_FL_ENABLED,
+					     false);
+		if (ret)
+			return ret;
+	}
+	if (demux && ca) {
+		ret = media_create_pad_link(demux, 1, ca,
+					    0, MEDIA_LNK_FL_ENABLED);
+		if (ret)
+			return ret;
+	}
+
+	/* Create demux links for each ringbuffer/pad */
+	if (demux) {
+		media_device_for_each_entity(entity, mdev) {
+			if (entity->function == MEDIA_ENT_F_IO_DTV) {
+				if (!strncmp(entity->name, DVR_TSOUT,
+				    strlen(DVR_TSOUT))) {
+					ret = media_create_pad_link(demux,
+								++dvr_pad,
+							    entity, 0, 0);
+					if (ret)
+						return ret;
+				}
+				if (!strncmp(entity->name, DEMUX_TSOUT,
+				    strlen(DEMUX_TSOUT))) {
+					ret = media_create_pad_link(demux,
+							      ++demux_pad,
+							    entity, 0, 0);
+					if (ret)
+						return ret;
+				}
+			}
+		}
+	}
+
+	/* Create interface links for FE->tuner, DVR->demux and CA->ca */
+	media_device_for_each_intf(intf, mdev) {
+		if (intf->type == MEDIA_INTF_T_DVB_CA && ca) {
+			link = media_create_intf_link(ca, intf,
+						      MEDIA_LNK_FL_ENABLED);
+			if (!link)
+				return -ENOMEM;
+		}
+
+		if (intf->type == MEDIA_INTF_T_DVB_FE && tuner) {
+			link = media_create_intf_link(tuner, intf,
+						      MEDIA_LNK_FL_ENABLED);
+			if (!link)
+				return -ENOMEM;
+		}
+#if 0
+		/*
+		 * Indirect link - let's not create yet, as we don't know how
+		 *		   to handle indirect links, nor if this will
+		 *		   actually be needed.
+		 */
+		if (intf->type == MEDIA_INTF_T_DVB_DVR && demux) {
+			link = media_create_intf_link(demux, intf,
+						      MEDIA_LNK_FL_ENABLED);
+			if (!link)
+				return -ENOMEM;
+		}
+#endif
+		if (intf->type == MEDIA_INTF_T_DVB_DVR) {
+			ret = dvb_create_io_intf_links(adap, intf, DVR_TSOUT);
+			if (ret)
+				return ret;
+		}
+		if (intf->type == MEDIA_INTF_T_DVB_DEMUX) {
+			ret = dvb_create_io_intf_links(adap, intf, DEMUX_TSOUT);
+			if (ret)
+				return ret;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dvb_create_media_graph);
+#endif
+
+static int dvbdev_check_free_adapter_num(int num)
+{
+	struct list_head *entry;
+	list_for_each(entry, &dvb_adapter_list) {
+		struct dvb_adapter *adap;
+		adap = list_entry(entry, struct dvb_adapter, list_head);
+		if (adap->num == num)
+			return 0;
+	}
+	return 1;
+}
+
+static int dvbdev_get_free_adapter_num (void)
+{
+	int num = 0;
+
+	while (num < DVB_MAX_ADAPTERS) {
+		if (dvbdev_check_free_adapter_num(num))
+			return num;
+		num++;
+	}
+
+	return -ENFILE;
+}
+
+
+int dvb_register_adapter(struct dvb_adapter *adap, const char *name,
+			 struct module *module, struct device *device,
+			 short *adapter_nums)
+{
+	int i, num;
+
+	mutex_lock(&dvbdev_register_lock);
+
+	for (i = 0; i < DVB_MAX_ADAPTERS; ++i) {
+		num = adapter_nums[i];
+		if (num >= 0  &&  num < DVB_MAX_ADAPTERS) {
+		/* use the one the driver asked for */
+			if (dvbdev_check_free_adapter_num(num))
+				break;
+		} else {
+			num = dvbdev_get_free_adapter_num();
+			break;
+		}
+		num = -1;
+	}
+
+	if (num < 0) {
+		mutex_unlock(&dvbdev_register_lock);
+		return -ENFILE;
+	}
+
+	memset (adap, 0, sizeof(struct dvb_adapter));
+	INIT_LIST_HEAD (&adap->device_list);
+
+	printk(KERN_INFO "DVB: registering new adapter (%s)\n", name);
+
+	adap->num = num;
+	adap->name = name;
+	adap->module = module;
+	adap->device = device;
+	adap->mfe_shared = 0;
+	adap->mfe_dvbdev = NULL;
+	mutex_init (&adap->mfe_lock);
+
+	list_add_tail (&adap->list_head, &dvb_adapter_list);
+
+	mutex_unlock(&dvbdev_register_lock);
+
+	return num;
+}
+EXPORT_SYMBOL(dvb_register_adapter);
+
+
+int dvb_unregister_adapter(struct dvb_adapter *adap)
+{
+	mutex_lock(&dvbdev_register_lock);
+	list_del (&adap->list_head);
+	mutex_unlock(&dvbdev_register_lock);
+	return 0;
+}
+EXPORT_SYMBOL(dvb_unregister_adapter);
+
+/* if the miracle happens and "generic_usercopy()" is included into
+   the kernel, then this can vanish. please don't make the mistake and
+   define this as video_usercopy(). this will introduce a dependecy
+   to the v4l "videodev.o" module, which is unnecessary for some
+   cards (ie. the budget dvb-cards don't need the v4l module...) */
+int dvb_usercopy(struct file *file,
+		     unsigned int cmd, unsigned long arg,
+		     int (*func)(struct file *file,
+		     unsigned int cmd, void *arg))
+{
+	char    sbuf[128];
+	void    *mbuf = NULL;
+	void    *parg = NULL;
+	int     err  = -EINVAL;
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		/*
+		 * For this command, the pointer is actually an integer
+		 * argument.
+		 */
+		parg = (void *) arg;
+		break;
+	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		err = -EFAULT;
+		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+			goto out;
+		break;
+	}
+
+	/* call driver */
+	if ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)
+		err = -ENOTTY;
+
+	if (err < 0)
+		goto out;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd))
+	{
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			err = -EFAULT;
+		break;
+	}
+
+out:
+	kfree(mbuf);
+	return err;
+}
+EXPORT_SYMBOL(dvb_usercopy);
+static int dvb_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct dvb_device *dvbdev = dev_get_drvdata(dev);
+
+	add_uevent_var(env, "DVB_ADAPTER_NUM=%d", dvbdev->adapter->num);
+	add_uevent_var(env, "DVB_DEVICE_TYPE=%s", dnames[dvbdev->type]);
+	add_uevent_var(env, "DVB_DEVICE_NUM=%d", dvbdev->id);
+	return 0;
+}
+
+static char *dvb_devnode(struct device *dev, umode_t *mode)
+{
+	struct dvb_device *dvbdev = dev_get_drvdata(dev);
+
+	return kasprintf(GFP_KERNEL, "dvb/adapter%d/%s%d",
+		dvbdev->adapter->num, dnames[dvbdev->type], dvbdev->id);
+}
+
+
+static int __init init_dvbdev(void)
+{
+	int retval;
+	dev_t dev = MKDEV(DVB_MAJOR, 0);
+
+	if ((retval = register_chrdev_region(dev, MAX_DVB_MINORS, "DVB")) != 0) {
+		printk(KERN_ERR "dvb-core: unable to get major %d\n", DVB_MAJOR);
+		return retval;
+	}
+
+	cdev_init(&dvb_device_cdev, &dvb_device_fops);
+	if ((retval = cdev_add(&dvb_device_cdev, dev, MAX_DVB_MINORS)) != 0) {
+		printk(KERN_ERR "dvb-core: unable register character device\n");
+		goto error;
+	}
+
+	dvb_class = class_create(THIS_MODULE, "dvb");
+	if (IS_ERR(dvb_class)) {
+		retval = PTR_ERR(dvb_class);
+		goto error;
+	}
+	dvb_class->dev_uevent = dvb_uevent;
+	dvb_class->devnode = dvb_devnode;
+	return 0;
+
+error:
+	cdev_del(&dvb_device_cdev);
+	unregister_chrdev_region(dev, MAX_DVB_MINORS);
+	return retval;
+}
+
+
+static void __exit exit_dvbdev(void)
+{
+	class_destroy(dvb_class);
+	cdev_del(&dvb_device_cdev);
+	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
+}
+#if 0
+subsys_initcall(init_dvbdev);
+module_exit(exit_dvbdev);
+
+MODULE_DESCRIPTION("DVB Core Driver");
+MODULE_AUTHOR("Marcus Metzler, Ralph Metzler, Holger Waechtler");
+MODULE_LICENSE("GPL");
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/dvbdev.h b/drivers/stream_input/parser/dvb_ci/cimax/dvbdev.h
new file mode 100644
index 0000000..4aff7bd
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/dvbdev.h
@@ -0,0 +1,299 @@
+/*
+ * dvbdev.h
+ *
+ * Copyright (C) 2000 Ralph Metzler & Marcus Metzler
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Lesser Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBDEV_H_
+#define _DVBDEV_H_
+
+#include <linux/types.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/list.h>
+#include <media/media-device.h>
+
+#define DVB_MAJOR 212
+
+#if defined(CONFIG_DVB_MAX_ADAPTERS) && CONFIG_DVB_MAX_ADAPTERS > 0
+  #define DVB_MAX_ADAPTERS CONFIG_DVB_MAX_ADAPTERS
+#else
+  #define DVB_MAX_ADAPTERS 8
+#endif
+
+#define DVB_UNSET (-1)
+
+#define DVB_DEVICE_VIDEO      0
+#define DVB_DEVICE_AUDIO      1
+#define DVB_DEVICE_SEC        2
+#define DVB_DEVICE_FRONTEND   3
+#define DVB_DEVICE_DEMUX      4
+#define DVB_DEVICE_DVR        5
+#define DVB_DEVICE_CA         6
+#define DVB_DEVICE_NET        7
+#define DVB_DEVICE_OSD        8
+
+#define DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr) \
+	static short adapter_nr[] = \
+		{[0 ... (DVB_MAX_ADAPTERS - 1)] = DVB_UNSET }; \
+	module_param_array(adapter_nr, short, NULL, 0444); \
+	MODULE_PARM_DESC(adapter_nr, "DVB adapter numbers")
+
+struct dvb_frontend;
+
+/**
+ * struct dvb_adapter - represents a Digital TV adapter using Linux DVB API
+ *
+ * @num:		Number of the adapter
+ * @list_head:		List with the DVB adapters
+ * @device_list:	List with the DVB devices
+ * @name:		Name of the adapter
+ * @proposed_mac:	proposed MAC address for the adapter
+ * @priv:		private data
+ * @device:		pointer to struct device
+ * @module:		pointer to struct module
+ * @mfe_shared:		mfe shared: indicates mutually exclusive frontends
+ *			Thie usage of this flag is currently deprecated
+ * @mfe_dvbdev:		Frontend device in use, in the case of MFE
+ * @mfe_lock:		Lock to prevent using the other frontends when MFE is
+ *			used.
+ * @mdev:		pointer to struct media_device, used when the media
+ *			controller is used.
+ * @conn:		RF connector. Used only if the device has no separate
+ *			tuner.
+ * @conn_pads:		pointer to struct media_pad associated with @conn;
+ */
+struct dvb_adapter {
+	int num;
+	struct list_head list_head;
+	struct list_head device_list;
+	const char *name;
+	u8 proposed_mac [6];
+	void* priv;
+
+	struct device *device;
+
+	struct module *module;
+
+	int mfe_shared;			/* indicates mutually exclusive frontends */
+	struct dvb_device *mfe_dvbdev;	/* frontend device in use */
+	struct mutex mfe_lock;		/* access lock for thread creation */
+
+#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
+	struct media_device *mdev;
+	struct media_entity *conn;
+	struct media_pad *conn_pads;
+#endif
+};
+
+/**
+ * struct dvb_device - represents a DVB device node
+ *
+ * @list_head:	List head with all DVB devices
+ * @fops:	pointer to struct file_operations
+ * @adapter:	pointer to the adapter that holds this device node
+ * @type:	type of the device: DVB_DEVICE_SEC, DVB_DEVICE_FRONTEND,
+ *		DVB_DEVICE_DEMUX, DVB_DEVICE_DVR, DVB_DEVICE_CA, DVB_DEVICE_NET
+ * @minor:	devnode minor number. Major number is always DVB_MAJOR.
+ * @id:		device ID number, inside the adapter
+ * @readers:	Initialized by the caller. Each call to open() in Read Only mode
+ *		decreases this counter by one.
+ * @writers:	Initialized by the caller. Each call to open() in Read/Write
+ *		mode decreases this counter by one.
+ * @users:	Initialized by the caller. Each call to open() in any mode
+ *		decreases this counter by one.
+ * @wait_queue:	wait queue, used to wait for certain events inside one of
+ *		the DVB API callers
+ * @kernel_ioctl: callback function used to handle ioctl calls from userspace.
+ * @name:	Name to be used for the device at the Media Controller
+ * @entity:	pointer to struct media_entity associated with the device node
+ * @pads:	pointer to struct media_pad associated with @entity;
+ * @priv:	private data
+ * @intf_devnode: Pointer to media_intf_devnode. Used by the dvbdev core to
+ *		store the MC device node interface
+ * @tsout_num_entities: Number of Transport Stream output entities
+ * @tsout_entity: array with MC entities associated to each TS output node
+ * @tsout_pads: array with the source pads for each @tsout_entity
+ *
+ * This structure is used by the DVB core (frontend, CA, net, demux) in
+ * order to create the device nodes. Usually, driver should not initialize
+ * this struct diretly.
+ */
+struct dvb_device {
+	struct list_head list_head;
+	const struct file_operations *fops;
+	struct dvb_adapter *adapter;
+	int type;
+	int minor;
+	u32 id;
+
+	/* in theory, 'users' can vanish now,
+	   but I don't want to change too much now... */
+	int readers;
+	int writers;
+	int users;
+
+	wait_queue_head_t	  wait_queue;
+	/* don't really need those !? -- FIXME: use video_usercopy  */
+	int (*kernel_ioctl)(struct file *file, unsigned int cmd, void *arg);
+
+	/* Needed for media controller register/unregister */
+#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
+	const char *name;
+
+	/* Allocated and filled inside dvbdev.c */
+	struct media_intf_devnode *intf_devnode;
+
+	unsigned tsout_num_entities;
+	struct media_entity *entity, *tsout_entity;
+	struct media_pad *pads, *tsout_pads;
+#endif
+
+	void *priv;
+};
+
+/**
+ * dvb_register_adapter - Registers a new DVB adapter
+ *
+ * @adap:	pointer to struct dvb_adapter
+ * @name:	Adapter's name
+ * @module:	initialized with THIS_MODULE at the caller
+ * @device:	pointer to struct device that corresponds to the device driver
+ * @adapter_nums: Array with a list of the numbers for @dvb_register_adapter;
+ * 		to select among them. Typically, initialized with:
+ *		DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nums)
+ */
+int dvb_register_adapter(struct dvb_adapter *adap, const char *name,
+			 struct module *module, struct device *device,
+			 short *adapter_nums);
+
+/**
+ * dvb_unregister_adapter - Unregisters a DVB adapter
+ *
+ * @adap:	pointer to struct dvb_adapter
+ */
+int dvb_unregister_adapter(struct dvb_adapter *adap);
+
+/**
+ * dvb_register_device - Registers a new DVB device
+ *
+ * @adap:	pointer to struct dvb_adapter
+ * @pdvbdev:	pointer to the place where the new struct dvb_device will be
+ *		stored
+ * @template:	Template used to create &pdvbdev;
+ * @priv:	private data
+ * @type:	type of the device: %DVB_DEVICE_SEC, %DVB_DEVICE_FRONTEND,
+ *		%DVB_DEVICE_DEMUX, %DVB_DEVICE_DVR, %DVB_DEVICE_CA,
+ *		%DVB_DEVICE_NET
+ * @demux_sink_pads: Number of demux outputs, to be used to create the TS
+ *		outputs via the Media Controller.
+ */
+int dvb_register_device(struct dvb_adapter *adap,
+			struct dvb_device **pdvbdev,
+			const struct dvb_device *template,
+			void *priv,
+			int type,
+			int demux_sink_pads);
+
+/**
+ * dvb_unregister_device - Unregisters a DVB device
+ *
+ * @dvbdev:	pointer to struct dvb_device
+ */
+void dvb_unregister_device(struct dvb_device *dvbdev);
+
+#ifdef CONFIG_MEDIA_CONTROLLER_DVB
+/**
+ * dvb_create_media_graph - Creates media graph for the Digital TV part of the
+ * 				device.
+ *
+ * @adap:			pointer to struct dvb_adapter
+ * @create_rf_connector:	if true, it creates the RF connector too
+ *
+ * This function checks all DVB-related functions at the media controller
+ * entities and creates the needed links for the media graph. It is
+ * capable of working with multiple tuners or multiple frontends, but it
+ * won't create links if the device has multiple tuners and multiple frontends
+ * or if the device has multiple muxes. In such case, the caller driver should
+ * manually create the remaining links.
+ */
+__must_check int dvb_create_media_graph(struct dvb_adapter *adap,
+					bool create_rf_connector);
+
+static inline void dvb_register_media_controller(struct dvb_adapter *adap,
+						 struct media_device *mdev)
+{
+	adap->mdev = mdev;
+}
+
+static inline struct media_device
+*dvb_get_media_controller(struct dvb_adapter *adap)
+{
+	return adap->mdev;
+}
+#else
+static inline
+int dvb_create_media_graph(struct dvb_adapter *adap,
+			   bool create_rf_connector)
+{
+	return 0;
+};
+#define dvb_register_media_controller(a, b) {}
+#define dvb_get_media_controller(a) NULL
+#endif
+
+int dvb_generic_open (struct inode *inode, struct file *file);
+int dvb_generic_release (struct inode *inode, struct file *file);
+long dvb_generic_ioctl (struct file *file,
+			      unsigned int cmd, unsigned long arg);
+
+/* we don't mess with video_usercopy() any more,
+we simply define out own dvb_usercopy(), which will hopefully become
+generic_usercopy()  someday... */
+
+int dvb_usercopy(struct file *file, unsigned int cmd, unsigned long arg,
+		 int (*func)(struct file *file, unsigned int cmd, void *arg));
+
+/** generic DVB attach function. */
+#ifdef CONFIG_MEDIA_ATTACH
+#define dvb_attach(FUNCTION, ARGS...) ({ \
+	void *__r = NULL; \
+	typeof(&FUNCTION) __a = symbol_request(FUNCTION); \
+	if (__a) { \
+		__r = (void *) __a(ARGS); \
+		if (__r == NULL) \
+			symbol_put(FUNCTION); \
+	} else { \
+		printk(KERN_ERR "DVB: Unable to find symbol "#FUNCTION"()\n"); \
+	} \
+	__r; \
+})
+
+#define dvb_detach(FUNC)	symbol_put_addr(FUNC)
+
+#else
+#define dvb_attach(FUNCTION, ARGS...) ({ \
+	FUNCTION(ARGS); \
+})
+
+#define dvb_detach(FUNC)	{}
+
+#endif
+
+#endif /* #ifndef _DVBDEV_H_ */
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/COPYING.LESSER b/drivers/stream_input/parser/dvb_ci/cimax/usb/COPYING.LESSER
new file mode 100644
index 0000000..8f4a860
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/COPYING.LESSER
@@ -0,0 +1,499 @@
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.
+We sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/README.txt b/drivers/stream_input/parser/dvb_ci/cimax/usb/README.txt
new file mode 100644
index 0000000..1d6a01c
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/README.txt
@@ -0,0 +1,61 @@
+April 28, 2011
+
+Linux CIMaX+ Kernel driver.
+Release Code version:
+
+DISCLAIMER
+----------
+
+This is a Smardtv' Linux Kernel driver for use with
+the CIMaX+ USB reference board hardware.
+
+IMPORTANT NOTE
+--------------
+
+This packages contains a Linux Kernel driver to be installed in the
+/lib/modules target directory in order to be loaded automaticaly.
+
+1. High level driver: cimax+usb_driver.ko
+  This driver provide the high level interface to control the CIMaX+ USB interface.
+
+2. Firmware
+  To have a functional hardware, the firmware must be uploaded to the device.
+
+  The firmwares is delivered in 2 files for dedicated usage and must be
+  installed in the Linux firmware directory on the target board:
+
+    - /lib/firmware
+
+  A) CIMaX+ firmware binary file
+    Copy the following firmware file to the /lib/firmware directory:
+      - firmware/cimax+_usbdvb.bin
+
+  B) CIMaX+ configuration file
+    Copy the following firmware file to the /lib/firmware directory:
+      - firmware/cimax+usb.cfg
+
+
+BUILD AND INSTALLATION INSTRUCTIONS
+-----------------------------------
+
+2. Building LINUX USB DVB driver
+  On the target machine performs the following commands:
+
+  1. cd src
+  2. make
+  3. make install
+
+3. Installing firmware files
+  On the target machine performs the following command:
+
+  1. cp firmware/*.* /lib/firmware/
+
+4. Installing rules file
+  1. cp src/99-cimax+usb.rules /etc/udev/rules.d/
+  2. udevadm control --reload-rules
+
+5. Build modules dependencies
+  On the target machine performs the following command:
+
+  1. depmod -a
+
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/99-cimax+usb.rules b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/99-cimax+usb.rules
new file mode 100644
index 0000000..82af370
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/99-cimax+usb.rules
@@ -0,0 +1,4 @@
+BUS=="usb", ACTION=="add", SYSFS{idProduct}=="2F00", SYSFS{idVendor}=="1B0D"
+KERNEL=="cimaxusb[0-9]", GROUP="users"
+
+
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/HOWTO.txt b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/HOWTO.txt
new file mode 100644
index 0000000..23de038
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/HOWTO.txt
@@ -0,0 +1,85 @@
+The following examples shows how to use the cimax+usb driver.
+All structures and macro are defined in file cimax+usb-driver.h.
+
+
+1.Open the device cimax+usb
+===========================
+/* open device */
+dev = open("/dev/cimaxusb0", O_RDWR);
+/* select USB alt_setting */
+ioctl(dev, DEVICE_IOC_SELECT_INTF, alt_setting);
+
+
+2.Close the device cimax+usb
+============================
+/* unlock read queue */
+ioctl(dev, DEVICE_IOC_UNLOCK_READ, 0);
+/* close device */
+close(dev);
+
+
+3.Send a CI message to a CAM through the device
+===============================================
+/* Send CAM A Reset command */
+uint8 command[5] = {0x01,    /* Command       */
+										0x01,    /* Counter       */
+										0x00,    /* MSB data size */
+										0x01,    /* LSB data size */
+										0x00};   /* data          */
+uint8 response[4100];
+struct ioctl_data_s stData;
+stData.txData = command;
+stData.txSize = 5;
+stData.rxData = response;
+stData.rxSize = 4100;
+ioctl(dev, DEVICE_IOC_CI_WRITE, &stData);
+
+/* Send CAM B Get CIS command */
+uint8 command[5] = {0x82,    /* Command       */
+										0x01,    /* Counter       */
+										0x00,    /* MSB data size */
+										0x00};   /* LSB data size */
+uint8 response[4100];
+struct ioctl_data_s stData;
+stData.txData = command;
+stData.txSize = 4;
+stData.rxData = response;
+stData.rxSize = 4100;
+ioctl(dev, DEVICE_IOC_CI_WRITE, &stData);
+
+
+4.Send a Transport Stream to a CAM through the device
+=====================================================
+/* Send to CAM A */
+struct rw_data_s rwData;
+rwData.type = DEVICE_TYPE_TS_WRITE;
+rwData.moduleId = 0; /* CAM A */
+rwData.data = stream;
+rwData.size = size;
+rwData.copiedSize = 0;
+write(dev, &rwData, sizeof(struct rw_data_s));
+
+
+5.Read a Transport Stream from a CAM through the device
+=======================================================
+/* Read from CAM B */
+struct rw_data_s rwData;
+rwData.type = DEVICE_TYPE_TS_READ;
+rwData.moduleId = 1; /* CAM B */
+rwData.data = stream;
+rwData.size = size;
+rwData.copiedSize = 0;
+read(dev, &rwData, sizeof(struct rw_data_s));
+
+
+6.Read a CI message from a CAM through the device
+=================================================
+/* Read from CAM A */
+uint8 response[4096];
+struct rw_data_s rwData;
+rwData.type = DEVICE_TYPE_CI_READ;
+rwData.moduleId = 0; /* CAM A */
+rwData.data = response;
+rwData.size = 4096;
+rwData.copiedSize = 0;
+read(dev, &rwData, sizeof(struct rw_data_s));
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/Makefile b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/Makefile
new file mode 100644
index 0000000..bc79945
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/Makefile
@@ -0,0 +1,35 @@
+TARGET = cimax+usb_driver
+OBJS = cimax+usb_driver.o
+MDIR = drivers/misc
+
+ccflags-y = -DEXPORT_SYMTAB
+#ccflags-y = -DEXPORT_SYMTAB -DDEBUG
+CURRENT = $(shell uname -r)
+KDIR = /lib/modules/$(CURRENT)/build
+PWD = $(shell pwd)
+DEST = /lib/modules/$(CURRENT)/kernel/$(MDIR)
+
+obj-m := $(TARGET).o
+cimax+usb_driver-y :=  cimax+usb-driver.o cimax+usb_fw.o
+cimax+usb_driver-y +=  cimax+usb_config.o
+cimax+usb_driver-y +=  cimax+usb_time.o
+
+default:
+	make -C /usr/src/linux SUBDIRS=$(PWD) modules
+#	make -C /lib/modules/`uname -r`/build M=$(PWD) modules
+
+$(TARGET).o: $(OBJS)
+	$(LD) $(LD_RFLAG) -r -o $@ $(OBJS)
+
+ifneq (,$(findstring 2.4.,$(CURRENT)))
+install:
+	su -c "cp -v $(TARGET).o $(DEST) && /sbin/depmod -a"
+else
+install:
+	su -c "cp -v $(TARGET).ko $(DEST) && /sbin/depmod -a"
+endif
+
+clean:
+	-rm -f *.o *.ko .*.cmd .*.flags *.mod.c
+
+-include $(KDIR)/Rules.make
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/bodydef.h b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/bodydef.h
new file mode 100644
index 0000000..f93fef5
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/bodydef.h
@@ -0,0 +1,424 @@
+/**************************************************************************//**
+ * @file    bodydef.h
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ ******************************************************************************/
+
+#ifndef __BODYDEF_H
+#define __BODYDEF_H
+
+struct reg_s {
+	__u8     RegisterName[50];
+	__u16    RegAddr;
+};
+
+/*=======================================================================
+ Input/Output Ports and Data Direction Registers
+=======================================================================*/
+struct reg_s cimax_reg_map[] = {
+	{"BUFFIN_CFG"                      , 0x0000},
+	{"BUFFIN_ADDR_LSB"                 , 0x0001},
+	{"BUFFIN_ADDR_MSB"                 , 0x0002},
+	{"BUFFIN_DATA"                     , 0x0003},
+	{"BUFFOUT_CFG"                     , 0x0004},
+	{"BUFFOUT_ADDR_LSB"                , 0x0005},
+	{"BUFFOUT_ADDR_MSB"                , 0x0006},
+	{"BUFFOUT_DATA"                    , 0x0007},
+	{"BOOT_Key"                        , 0x0008},
+	{"BOOT_Status"                     , 0x0009},
+	{"BOOT_Test "                      , 0x000A},
+	{"RxDMA_Ctrl"                      , 0x0010},
+	{"RxDMA_Status"                    , 0x0011},
+	{"RxDMA_DbgL"                      , 0x0012},
+	{"RxDMA_DbgH"                      , 0x0013},
+	{"SPI_Slave_Ctrl"                  , 0x0018},
+	{"SPI_Slave_Status"                , 0x0019},
+	{"SPI_Slave_Rx"                    , 0x001A},
+	{"SPI_Slave_Tx"                    , 0x001B},
+	{"SPI_Slave_Mask"                  , 0x001C},
+	{"UCSG_Ctrl"                       , 0x0020},
+	{"UCSG_Status"                     , 0x0021},
+	{"UCSG_RxData"                     , 0x0022},
+	{"UCSG_TxData"                     , 0x0023},
+	{"PCtrl_Ctrl"                      , 0x0028},
+	{"PCtrl_Status"                    , 0x0029},
+	{"PCtrl_NbByte_LSB"                , 0x002A},
+	{"PCtrl_NbByte_MSB"                , 0x002B},
+	{"SPI_Master_Ctl"                  , 0x0030},
+	{"SPI_Master_NCS"                  , 0x0031},
+	{"SPI_Master_Status"               , 0x0032},
+	{"SPI_Master_TxBuf"                , 0x0033},
+	{"SPI_Master_RxBuf"                , 0x0034},
+	{"BISTRAM_Ctl"                     , 0x0038},
+	{"BISTRAM_Bank"                    , 0x0039},
+	{"BISTRAM_Pat"                     , 0x003A},
+	{"BISTRAM_SM"                      , 0x003B},
+	{"BISTRAM_AddrLSB"                 , 0x003C},
+	{"BISTROM_Config"                  , 0x0040},
+	{"BISTROM_SignatureLSB"            , 0x0041},
+	{"BISTROM_SignatureMSB"            , 0x0042},
+	{"BISTROM_StartAddrLSB"            , 0x0043},
+	{"BISTROM_StartAddrMSB"            , 0x0044},
+	{"BISTROM_StopAddrLSB"             , 0x0045},
+	{"BISTROM_StopAddrMSB"             , 0x0046},
+	{"CkMan_Config"                    , 0x0048},
+	{"CkMan_Select"                    , 0x0049},
+	{"CkMan_Test"                      , 0x004A},
+	{"Revision_Number"                 , 0x004B},
+	{"CkMan_PD_Key"                    , 0x004C},
+	{"USB_Power_Mode"                  , 0x004D},
+	{"ResMan_Config"                   , 0x0050},
+	{"ResMan_Status"                   , 0x0051},
+	{"ResMan_WD"                      , 0x0052},
+	{"ResMan_WD_MSB"                   , 0x0053},
+	{"TxDMA_Ctrl"                      , 0x0058},
+	{"TxDMA_Status"                    , 0x0059},
+	{"TxDMA_StartAddrL"                , 0x005A},
+	{"TxDMA_StartAddrH"                , 0x005B},
+	{"TxDMA_StopAddrL"                 , 0x005C},
+	{"TxDMA_StopAddrH"                 , 0x005D},
+	{"CPU_Test"                      , 0x0060},
+	{"IrqMan_Config0"                  , 0x0068},
+	{"IrqMan_Config1"                  , 0x0069},
+	{"IrqMan_Irq0"                     , 0x006A},
+	{"IrqMan_NMI"                      , 0x006B},
+	{"IrqMan_SleepKey"                 , 0x006C},
+	{"Tim_Config"                      , 0x0070},
+	{"Tim_Value_LSB"                   , 0x0071},
+	{"Tim_Value_MSB"                   , 0x0072},
+	{"Tim_Comp_LSB"                    , 0x0073},
+	{"Tim_Comp_MSB"                    , 0x0074},
+	{"TI_Config"                       , 0x0076},
+	{"TI_Data"                      , 0x0077},
+	{"TI_Reg0"                      , 0x0078},
+	{"TI_Reg1"                      , 0x0079},
+	{"TI_Reg2"                      , 0x007A},
+	{"TI_Reg3"                      , 0x007B},
+	{"TI_Reg4"                      , 0x007C},
+	{"TI_ROM1"                      , 0x007D},
+	{"TI_ROM2"                      , 0x007E},
+	{"TI_ROM3"                      , 0x007F},
+	{"DVBCI_START_ADDR"                , 0x0100},
+	{"DVBCI_END_ADDR"                  , 0x017F},
+	{"DATA"                      , 0x0180},
+	{"CTRL"                      , 0x0181},
+	{"QB_HOST"                      , 0x0182},
+	{"LEN_HOST_LSB"                    , 0x0183},
+	{"LEN_HOST_MSB"                    , 0x0184},
+	{"FIFO_TX_TH_LSB"                  , 0x0185},
+	{"FIFO_TX_TH_MSB"                  , 0x0186},
+	{"FIFO_TX_D_NB_LSB"                , 0x0187},
+	{"FIFO_TX_D_NB_MSB"                , 0x0188},
+	{"QB_MOD_CURR"                     , 0x0189},
+	{"LEN_MOD_CURR_LSB"                , 0x018A},
+	{"LEN_MOD_CURR_MSB"                , 0x018B},
+	{"QB_MOD"                      , 0x018C},
+	{"LEN_MOD_LSB"                     , 0x018D},
+	{"LEN_MOD_MSB"                     , 0x018E},
+	{"FIFO_RX_TH_LSB"                  , 0x018F},
+	{"FIFO_RX_TH_MSB"                  , 0x0190},
+	{"FIFO_RX_D_NB_LSB"                , 0x0191},
+	{"FIFO_RX_D_NB_MSB"                , 0x0192},
+	{"IT_STATUS_0"                     , 0x0193},
+	{"IT_STATUS_1"                     , 0x0194},
+	{"IT_MASK_0"                      , 0x0195},
+	{"IT_MASK_1"                      , 0x0196},
+	{"IT_HOST_PIN_CFG"                 , 0x0200},
+	{"CFG_0"                      , 0x0201},
+	{"CFG_1"                      , 0x0202},
+	{"CFG_2"                      , 0x0203},
+	{"IT_HOST"                      , 0x0204},
+	{"MOD_IT_STATUS"                   , 0x0205},
+	{"MOD_IT_MASK"                     , 0x0206},
+	{"MOD_CTRL_A"                      , 0x0207},
+	{"MOD_CTRL_B"                      , 0x0208},
+	{"DEST_SEL"                      , 0x0209},
+	{"CAM_MSB_ADD"                     , 0x020A},
+	{"GPIO0_DIR"                      , 0x020B},
+	{"GPIO0_DATA_IN"                   , 0x020C},
+	{"GPIO0_DATA_OUT"                  , 0x020D},
+	{"GPIO0_STATUS"                    , 0x020E},
+	{"GPIO0_IT_MASK"                   , 0x020F},
+	{"GPIO0_DFT"                      , 0x0210},
+	{"GPIO0_MASK_DATA"                 , 0x0211},
+	{"GPIO1_DIR"                      , 0x0212},
+	{"GPIO1_DATA_IN"                   , 0x0213},
+	{"GPIO1_DATA_OUT"                  , 0x0214},
+	{"GPIO1_STATUS"                    , 0x0215},
+	{"GPIO1_IT_MASK"                   , 0x0216},
+	{"MEM_ACC_TIME_A"                  , 0x0217},
+	{"MEM_ACC_TIME_B"                  , 0x0218},
+	{"IO_ACC_TIME_A"                   , 0x0219},
+	{"IO_ACC_TIME_B"                   , 0x021A},
+	{"EXT_CH_ACC_TIME_A"               , 0x021B},
+	{"EXT_CH_ACC_TIME_B"               , 0x021C},
+	{"PAR_IF_0"                      , 0x021D},
+	{"PAR_IF_1"                      , 0x021E},
+	{"PAR_IF_CTRL"                     , 0x021F},
+	{"PCK_LENGTH"                      , 0x0220},
+	{"USB2TS_CTRL"                     , 0x0221},
+	{"USB2TS0_RDL"                    , 0x0222},
+	{"USB2TS1_RDL"                     , 0x0223},
+	{"TS2USB_CTRL"                     , 0x0224},
+	{"TSOUT_PAR_CTRL"                  , 0x0225},
+	{"TSOUT_PAR_CLK_SEL"               , 0x0226},
+	{"S2P_CH0_CTRL"                    , 0x0227},
+	{"S2P_CH1_CTRL"                    , 0x0228},
+	{"P2S_CH0_CTRL"                    , 0x0229},
+	{"P2S_CH1_CTRL"                    , 0x022A},
+	{"TS_IT_STATUS"                    , 0x022B},
+	{"TS_IT_MASK"                      , 0x022C},
+	{"IN_SEL"                      , 0x022D},
+	{"OUT_SEL"                      , 0x022E},
+	{"ROUTER_CAM_CH"                   , 0x022F},
+	{"ROUTER_CAM_MOD"                  , 0x0230},
+	{"FIFO_CTRL"                      , 0x0231},
+	{"FIFO1_2_STATUS"                  , 0x0232},
+	{"FIFO3_4_STATUS"                  , 0x0233},
+	{"GAP_REMOVER_CH0_CTRL"            , 0x0234},
+	{"GAP_REMOVER_CH1_CTRL"            , 0x0235},
+	{"SYNC_RTV_CTRL"                   , 0x0236},
+	{"SYNC_RTV_CH0_SYNC_NB"            , 0x0237},
+	{"SYNC_RTV_CH0_PATTERN"            , 0x0238},
+	{"SYNC_RTV_CH1_SYNC_NB"            , 0x0239},
+	{"SYNC_RTV_CH1_PATTERN"            , 0x023A},
+	{"SYNC_RTV_OFFSET_PATT"            , 0x023B},
+	{"CTRL_FILTER"                     , 0x023D},
+	{"PID_EN_FILTER_CH0"               , 0x023E},
+	{"PID_EN_FILTER_CH1"               , 0x023F},
+	{"PID_LSB_FILTER_CH0_0"            , 0x0240},
+	{"PID_MSB_FILTER_CH0_0"            , 0x0241},
+	{"PID_LSB_FILTER_CH0_1"            , 0x0242},
+	{"PID_MSB_FILTER_CH0_1"            , 0x0243},
+	{"PID_LSB_FILTER_CH0_2"            , 0x0244},
+	{"PID_MSB_FILTER_CH0_2"            , 0x0245},
+	{"PID_LSB_FILTER_CH0_3"            , 0x0246},
+	{"PID_MSB_FILTER_CH0_3"            , 0x0247},
+	{"PID_LSB_FILTER_CH0_4"            , 0x0248},
+	{"PID_MSB_FILTER_CH0_4"            , 0x0249},
+	{"PID_LSB_FILTER_CH0_5"            , 0x024A},
+	{"PID_MSB_FILTER_CH0_5"            , 0x024B},
+	{"PID_LSB_FILTER_CH0_6"            , 0x024C},
+	{"PID_MSB_FILTER_CH0_6"            , 0x024D},
+	{"PID_LSB_FILTER_CH0_7"            , 0x024E},
+	{"PID_MSB_FILTER_CH0_7"            , 0x024F},
+	{"PID_LSB_FILTER_CH1_0"            , 0x0260},
+	{"PID_MSB_FILTER_CH1_0"            , 0x0261},
+	{"PID_LSB_FILTER_CH1_1"            , 0x0262},
+	{"PID_MSB_FILTER_CH1_1"            , 0x0263},
+	{"PID_LSB_FILTER_CH1_2"            , 0x0264},
+	{"PID_MSB_FILTER_CH1_2"            , 0x0265},
+	{"PID_LSB_FILTER_CH1_3"            , 0x0266},
+	{"PID_MSB_FILTER_CH1_3"            , 0x0267},
+	{"PID_LSB_FILTER_CH1_4"            , 0x0268},
+	{"PID_MSB_FILTER_CH1_4"            , 0x0269},
+	{"PID_LSB_FILTER_CH1_5"            , 0x026A},
+	{"PID_MSB_FILTER_CH1_5"            , 0x026B},
+	{"PID_LSB_FILTER_CH1_6"            , 0x026C},
+	{"PID_MSB_FILTER_CH1_6"            , 0x026D},
+	{"PID_LSB_FILTER_CH1_7"            , 0x026E},
+	{"PID_MSB_FILTER_CH1_7"            , 0x026F},
+	{"PID_OLD_LSB_REMAPPER_0"          , 0x0280},
+	{"PID_OLD_MSB_REMAPPER_0"          , 0x0281},
+	{"PID_OLD_LSB_REMAPPER_1"          , 0x0282},
+	{"PID_OLD_MSB_REMAPPER_1"          , 0x0283},
+	{"PID_OLD_LSB_REMAPPER_2"          , 0x0284},
+	{"PID_OLD_MSB_REMAPPER_2"          , 0x0285},
+	{"PID_OLD_LSB_REMAPPER_3"          , 0x0286},
+	{"PID_OLD_MSB_REMAPPER_3"          , 0x0287},
+	{"PID_OLD_LSB_REMAPPER_4"          , 0x0288},
+	{"PID_OLD_MSB_REMAPPER_4"          , 0x0289},
+	{"PID_OLD_LSB_REMAPPER_5"          , 0x028A},
+	{"PID_OLD_MSB_REMAPPER_5"          , 0x028B},
+	{"PID_OLD_LSB_REMAPPER_6"          , 0x028C},
+	{"PID_OLD_MSB_REMAPPER_6"          , 0x028D},
+	{"PID_OLD_LSB_REMAPPER_7"          , 0x028E},
+	{"PID_OLD_MSB_REMAPPER_7"          , 0x028F},
+	{"PID_NEW_LSB_REMAPPER_0"          , 0x02A0},
+	{"PID_NEW_MSB_REMAPPER_0"          , 0x02A1},
+	{"PID_NEW_LSB_REMAPPER_1"          , 0x02A2},
+	{"PID_NEW_MSB_REMAPPER_1"          , 0x02A3},
+	{"PID_NEW_LSB_REMAPPER_2"          , 0x02A4},
+	{"PID_NEW_MSB_REMAPPER_2"          , 0x02A5},
+	{"PID_NEW_LSB_REMAPPER_3"          , 0x02A6},
+	{"PID_NEW_MSB_REMAPPER_3"          , 0x02A7},
+	{"PID_NEW_LSB_REMAPPER_4"          , 0x02A8},
+	{"PID_NEW_MSB_REMAPPER_4"          , 0x02A9},
+	{"PID_NEW_LSB_REMAPPER_5"         , 0x02AA},
+	{"PID_NEW_MSB_REMAPPER_5"          , 0x02AB},
+	{"PID_NEW_LSB_REMAPPER_6"          , 0x02AC},
+	{"PID_NEW_MSB_REMAPPER_6"          , 0x02AD},
+	{"PID_NEW_LSB_REMAPPER_7"          , 0x02AE},
+	{"PID_NEW_MSB_REMAPPER_7"          , 0x02AF},
+	{"MERGER_DIV_MICLK"                , 0x02C0},
+	{"PID_AND_SYNC_REMAPPER_CTRL"      , 0x02C1},
+	{"PID_EN_REMAPPER"                 , 0x02C2},
+	{"SYNC_SYMBOL"                     , 0x02C3},
+	{"PID_AND_SYNC_REMAPPER_INV_CTRL"  , 0x02C4},
+	{"BITRATE_CH0_LSB"                 , 0x02C5},
+	{"BITRATE_CH0_MSB"                 , 0x02C6},
+	{"BITRATE_CH1_LSB"                 , 0x02C7},
+	{"BITRATE_CH1_MSB"                 , 0x02C8},
+	{"STATUS_CLK_SWITCH_0"             , 0x02C9},
+	{"STATUS_CLK_SWITCH_1"             , 0x02CA},
+	{"RESET_CLK_SWITCH_0"              , 0x02CB},
+	{"RESET_CLK_SWITCH_1"              , 0x02CC},
+	{"PAD_DRVSTR_CTRL"                 , 0x02CD},
+	{"PAD_PUPD_CTRL"                   , 0x02CE},
+	{"PRE_HEADER_ADDER_CH0_0"          , 0x02D0},
+	{"PRE_HEADER_ADDER_CH0_1"          , 0x02D1},
+	{"PRE_HEADER_ADDER_CH0_2"          , 0x02D2},
+	{"PRE_HEADER_ADDER_CH0_3"          , 0x02D3},
+	{"PRE_HEADER_ADDER_CH0_4"          , 0x02D4},
+	{"PRE_HEADER_ADDER_CH0_5"          , 0x02D5},
+	{"PRE_HEADER_ADDER_CH0_6"          , 0x02D6},
+	{"PRE_HEADER_ADDER_CH0_7"          , 0x02D7},
+	{"PRE_HEADER_ADDER_CH0_8"          , 0x02D8},
+	{"PRE_HEADER_ADDER_CH0_9"          , 0x02D9},
+	{"PRE_HEADER_ADDER_CH0_10"         , 0x02DA},
+	{"PRE_HEADER_ADDER_CH0_11"         , 0x02DB},
+	{"PRE_HEADER_ADDER_CH1_0"          , 0x02E0},
+	{"PRE_HEADER_ADDER_CH1_1"          , 0x02E1},
+	{"PRE_HEADER_ADDER_CH1_2"          , 0x02E2},
+	{"PRE_HEADER_ADDER_CH1_3"          , 0x02E3},
+	{"PRE_HEADER_ADDER_CH1_4"          , 0x02E4},
+	{"PRE_HEADER_ADDER_CH1_5"          , 0x02E5},
+	{"PRE_HEADER_ADDER_CH1_6"          , 0x02E6},
+	{"PRE_HEADER_ADDER_CH1_7"          , 0x02E7},
+	{"PRE_HEADER_ADDER_CH1_8"          , 0x02E8},
+	{"PRE_HEADER_ADDER_CH1_9"          , 0x02E9},
+	{"PRE_HEADER_ADDER_CH1_10"         , 0x02EA},
+	{"PRE_HEADER_ADDER_CH1_11"         , 0x02EB},
+	{"PRE_HEADER_ADDER_CTRL"           , 0x02EC},
+	{"PRE_HEADER_ADDER_LEN"            , 0x02ED},
+	{"PRE_HEADER_REMOVER_CTRL"         , 0x02EE},
+	{"FSM_DVB"                      , 0x02F0},
+	{"TS2USB_FSM_DEBUG"                , 0x02F2},
+	{"TSOUT_PAR_FSM_DEBUG"             , 0x02F3},
+	{"GAP_REMOVER_FSM_DEBUG"           , 0x02F4},
+	{"PID_AND_SYNC_REMAPPER_FSM_DEBUG" , 0x02F5},
+	{"PRE_HEADER_ADDER_FSM_DEBUG"      , 0x02F6},
+	{"SYNC_RTV_FSM_DEBUG"              , 0x02F7},
+	{"CHECK_PHY_CLK"                   , 0x0E00},
+	{"CONTROL1"                      , 0x0E01},
+	{"WAKE_UP"                      , 0x0E02},
+	{"CONTROL2"                      , 0x0E03},
+	{"PHY_RELATED"                     , 0x0E04},
+	{"EP_CFG"                      , 0x0E05},
+	{"MAX_PKT_EP1L"                    , 0x0E06},
+	{"MAX_PKT_EP1H"                    , 0x0E07},
+	{"MAX_PKT_EP2L"                    , 0x0E08},
+	{"MAX_PKT_EP2H"                    , 0x0E09},
+	{"MAX_PKT_EP3L"                    , 0x0E0A},
+	{"MAX_PKT_EP3H"                    , 0x0E0B},
+	{"MAX_PKT_EP4L"                    , 0x0E0C},
+	{"MAX_PKT_EP4H"                    , 0x0E0D},
+	{"EPS_STALL_SET"                   , 0x0E10},
+	{"EPS_STALL_CLR"                   , 0x0E11},
+	{"EPS_ENABLE"                      , 0x0E12},
+	{"DMA_ACC_EPS"                     , 0x0E13},
+	{"CPU_ACC_EPS_EN"                  , 0x0E14},
+	{"SETUP_BYTE0"                     , 0x0E15},
+	{"SETUP_BYTE1"                     , 0x0E16},
+	{"SETUP_BYTE2"                     , 0x0E17},
+	{"SETUP_BYTE3"                     , 0x0E18},
+	{"SETUP_BYTE4"                     , 0x0E19},
+	{"SETUP_BYTE5"                     , 0x0E1A},
+	{"SETUP_BYTE6"                     , 0x0E1B},
+	{"SETUP_BYTE7"                     , 0x0E1C},
+	{"SETUP_DT_VLD"                    , 0x0E1D},
+	{"CLR_EPS_TOG"                     , 0x0E1E},
+	{"EP0_CTRL"                      , 0x0E20},
+	{"EP0_DATA_CNT"                    , 0x0E21},
+	{"EP0_DATA"                      , 0x0E22},
+	{"EP1_CTRL"                      , 0x0E30},
+	{"EP1_DATA_CNTL"                   , 0x0E31},
+	{"EP1_DATA_CNTH"                   , 0x0E32},
+	{"EP1_DATA"                      , 0x0E33},
+	{"EP1_HEADER"                      , 0x0E34},
+	{"EP2_CTRL"                      , 0x0E40},
+	{"EP2_DATA_CNTL"                   , 0x0E41},
+	{"EP2_DATA_CNTH"                   , 0x0E42},
+	{"EP2_DATA"                      , 0x0E43},
+	{"EP2_HEADER"                      , 0x0E44},
+	{"EP3_DATA_CNTL"                   , 0x0E50},
+	{"EP3_DATA_CNTH"                   , 0x0E51},
+	{"EP3_DATA"                      , 0x0E52},
+	{"EP3_HEADER"                      , 0x0E53},
+	{"EP3_HEADER_CNT"                  , 0x0E54},
+	{"EP3_HEADER_DATA"                 , 0x0E55},
+	{"EP4_DATA_CNTL"                   , 0x0E60},
+	{"EP4_DATA_CNTH"                   , 0x0E61},
+	{"EP4_DATA"                      , 0x0E62},
+	{"EP4_HEADER"                      , 0x0E63},
+	{"EP4_HEADER_CNT"                  , 0x0E64},
+	{"EP4_HEADER_DATA"                 , 0x0E65},
+	{"EP5_CTRL"                      , 0x0E70},
+	{"EP5_DATA_CNTL"                   , 0x0E71},
+	{"EP5_DATA_CNTH"                   , 0x0E72},
+	{"EP5_DATA"                      , 0x0E73},
+	{"MAX_PKT_EP5L"                    , 0x0E74},
+	{"MAX_PKT_EP5H"                    , 0x0E75},
+	{"EP6_DATA_CNTL"                   , 0x0E80},
+	{"EP6_DATA_CNTH"                   , 0x0E81},
+	{"EP6_DATA"                      , 0x0E82},
+	{"MAX_PKT_EP6L"                    , 0x0E83},
+	{"MAX_PKT_EP6H"                    , 0x0E84},
+	{"FRAME_NUML"                      , 0x0E90},
+	{"FRAME_NUMH"                      , 0x0E91},
+	{"FRAME_TIMEL"                     , 0x0E92},
+	{"FRAME_TIMEH"                     , 0x0E93},
+	{"STC_DIVL"                      , 0x0E94},
+	{"STC_DIVM"                      , 0x0E95},
+	{"STC_DIVH"                      , 0x0E96},
+	{"USB_STATUS"                      , 0x0E97},
+	{"DEV_STATE1"                      , 0x0E98},
+	{"DEV_STATE2"                      , 0x0E99},
+	{"DEV_STATE3"                      , 0x0E9A},
+	{"DEV_STATE4"                      , 0x0E9B},
+	{"INTR_EN1"                      , 0x0EA0},
+	{"INTR_EN2"                      , 0x0EA1},
+	{"INTR_EN3"                      , 0x0EA2},
+	{"INTR_EN4"                      , 0x0EA3},
+	{"INTR_SRC1"                      , 0x0EB0},
+	{"INTR_SRC2"                      , 0x0EB1},
+	{"INTR_SRC3"                      , 0x0EB2},
+	{"INTR_SRC4"                      , 0x0EB3},
+	{"INTR_FLAG1"                      , 0x0EC0},
+	{"INTR_FLAG2"                      , 0x0EC1},
+	{"INTR_FLAG3"                      , 0x0EC2},
+	{"INTR_FLAG4"                      , 0x0EC3},
+	{"EP0_INAK_CNT"                    , 0x0ED0},
+	{"EP0_ONAK_CNT"                    , 0x0ED1},
+	{"EP1_NAK_CNT"                     , 0x0ED2},
+	{"EP2_NAK_CNT"                     , 0x0ED3},
+	{"EP3_NAK_CNT"                     , 0x0ED4},
+	{"EP4_NAK_CNT"                     , 0x0ED5},
+	{"EP5_NAK_CNT"                     , 0x0ED6},
+	{"EP6_NAK_CNT"                     , 0x0ED7},
+	{"NAK_CNT_LEVEL"                   , 0x0ED8},
+	{"CC2_Buffer_out"                  , 0x2000},
+	{"CC2_Buffer_in"                   , 0x4000},
+	{"nmb_vector_address_lsb"          , 0xFFFA},
+	{"nmb_vector_address_msb"          , 0xFFFB},
+	{"reset_vector_address_lsb"        , 0xFFFC},
+	{"reset_vector_address_msb"        , 0xFFFD},
+	{"irb_vector_address_lsb"          , 0xFFFE},
+	{"irb_vector_address_msb"          , 0xFFFF}
+};
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb-driver.c b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb-driver.c
new file mode 100644
index 0000000..43cdcde
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb-driver.c
@@ -0,0 +1,2535 @@
+/**************************************************************************//**
+ * @file    cimax+usb-driver.c
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ ******************************************************************************/
+
+#define FRBIT
+/*#define DEBUG*/
+/*#define DEBUG_BITRATE*/
+/*#define DEBUG_ISOC_IN*/
+/*#define DEBUG_ISOC_OUT*/
+/*#define DEBUG_CONTINUITY*/
+
+/******************************************************************************
+ * Include
+ ******************************************************************************/
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/usb.h>
+#include <linux/uaccess.h>
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/dvb/ca.h>
+
+#include "cimax+usb-driver.h"
+#include "cimax+usb_fw.h"
+#include "cimax+usb_config.h"
+#ifdef TIMESTAMP
+#include "cimax+usb_time.h"
+#endif
+#include "../../aml_cimax_usb_priv.h"
+
+/******************************************************************************
+ * Defines
+ *****************************************************************************/
+#define DRIVER_VERSION "v1.1.2"
+#define DRIVER_AUTHOR "Bruno Tonelli, tonelli@smardtv.com"
+#define DRIVER_DESC "CIMaX+ USB Driver for Linux (c)2009-2011"
+
+#define DRIVER_MAX_NUMBER   1
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+
+/******************************************************************************
+ * Structures
+ ******************************************************************************/
+/******************************************************************************
+ * Globals
+ ******************************************************************************/
+#ifdef FRBIT
+int CimaxCfg = 1;
+module_param_named(CimaxCfg, CimaxCfg, int, 0644);
+MODULE_PARM_DESC(CimaxCfg, "Turn on/off configuration of CIMaX+ (default: on)");
+int CimaxDwnl = 1;
+module_param_named(CimaxDwnl, CimaxDwnl, int, 0644);
+MODULE_PARM_DESC(CimaxDwnl, "Enable upload of FW in CIMaX+ chip (default: on)");
+#endif
+
+static struct device_s *gdevice;
+static unsigned int gdeviceNumber;
+
+static struct usb_driver device_driver;
+static struct timespec gStart;
+
+static __u8 nullHeader[] = {
+	0x47, 0x1F, 0xFF, 0x1F, 0xFA, 0xDE, 0xBA, 0xBE
+};
+
+static struct bulk_timer_s gbulk_timer[DEVICE_NUM_CAM];
+int (*cimax_usb_dev_add)(struct device_s *device, int id);
+int (*cimax_usb_dev_remove)(struct device_s *device, int id);
+
+#ifdef TIMESTAMP
+static int bSetTimestamps;
+#endif
+
+/******************************************************************************
+ * Functions
+ ******************************************************************************/
+#ifdef DEBUG_CONTINUITY
+#define TS_MAXPIDS 8192                  /* max value of a PID */
+unsigned char    tab_cc[TS_MAXPIDS];
+
+__u16 get_ts_pid(unsigned char *pid)
+{
+	__u16 pp = 0;
+
+	pp = (pid[0] & 0X1f)<<8;
+	pp |= pid[1];
+
+	return pp;
+}
+
+static void init_tab_cc(void)
+{
+	memset(tab_cc, 0xff, TS_MAXPIDS);
+}
+
+static int dbg_cc(unsigned char *buf)
+{
+	int pid;
+	unsigned char cc;
+
+	if (buf[0] != DEVICE_MPEG2_SYNC_BYTE) {
+		err("Out Of Sync: ");
+		return -1;
+	}
+
+	pid = get_ts_pid(buf + 1);
+
+	if (!(buf[3] & 0x10))   /* no payload?*/
+		return 0;
+
+	if (buf[1] & 0x80)
+		err("Error in TS for PID: %d\n", pid);
+
+	/* Check continuity count*/
+	cc = tab_cc[pid];
+	if (cc == 255)
+		cc = (buf[3] & 15);
+	else {
+		cc = ((cc) + 1) & 15;
+		if (cc != (buf[3] & 15)) {
+			/* Otherwise, this is a real corruption */
+			err("pid %d cc %d expected cc %d actual\n",
+					pid, cc, buf[3] & 15);
+			cc = (buf[3] & 15);
+		}
+	}
+	return 0;
+}
+#endif
+
+/*-------------------------------------------------------------------*/
+#ifdef DEBUG
+static void dbg_dump(char *hdr, unsigned char *data, int size)
+{
+	int i;
+	char line[40];
+	char str[9];
+	line[0] = 0;
+	for (i = 0; i < size; i++) {
+		sprintf(line, "%s%.2x ", line, data[i]);
+		if ((data[i] >= 32) && (data[i] <= 126))
+			str[i%8] = data[i];
+		else
+			str[i%8] = '.';
+		if (!((i+1)%8)) {
+			str[i%8 + 1] = 0;
+			dbg_s("%s %s %s", hdr, line, str);
+			line[0] = 0;
+		} /* if */
+	} /* for */
+	if (i%8) {
+		int j;
+		str[i%8 + 1] = 0;
+		for (j = (i%8); j < 8; j++)
+			sprintf(line, "%s   ", line);
+		dbg_s("%s %s %s", hdr, line, str);
+		line[0] = 0;
+	} /* if */
+} /* dbg_dump */
+#else
+#define dbg_dump(format, arg...) do {} while (0)
+#endif /* DEBUG */
+
+static unsigned long copyDataFrom(int us,
+		void *to, const void *from, unsigned long n)
+{
+	if (us)
+		return copy_from_user(to, from, n);
+	memcpy(to, from, n);
+	return 0;
+}
+
+static unsigned long copyDataTo(int us,
+		void *to, const void *from, unsigned long n)
+{
+	if (us)
+		return copy_to_user(to, from, n);
+	memcpy(to, from, n);
+	return 0;
+}
+
+static void vb_init(struct video_buf_s *buf)
+{
+	buf->readOffset = 0;
+	buf->writeOffset = 0;
+	buf->isEmpty = 1;
+} /* vb_init */
+
+static int vb_get_write_size(struct video_buf_s *buf)
+{
+	int writeSize = 0;
+
+	if (buf->writeOffset == buf->readOffset) {
+		if (buf->isEmpty)
+			writeSize = DEVICE_VB_LENGTH;
+	} else if (buf->writeOffset > buf->readOffset)
+		writeSize =
+			DEVICE_VB_LENGTH - (buf->writeOffset - buf->readOffset);
+	else
+		writeSize = buf->readOffset - buf->writeOffset;
+	return writeSize;
+} /* vb_get_write_size */
+
+static int vb_write(struct video_buf_s *buf, __u8 *data, int size)
+{
+	int writeSize = vb_get_write_size(buf);
+	int firstPart = DEVICE_VB_LENGTH - buf->writeOffset;
+	if (size > writeSize)
+		size = writeSize;
+
+	if (size < firstPart) {
+		memcpy(&buf->data[buf->writeOffset], data, size);
+		buf->writeOffset += size;
+	} /* if */ else {
+		memcpy(&buf->data[buf->writeOffset], data, firstPart);
+		memcpy(buf->data, &data[firstPart], size - firstPart);
+		buf->writeOffset = size - firstPart;
+	} /* else */
+
+	if (size > 0)
+		buf->isEmpty = 0;
+	return size;
+} /* vb_write */
+
+static int vb_read_next(struct video_buf_s *buf, __u8 *data)
+{
+	int readSize;
+	int firstPart;
+	int nextOffset;
+	int isStuffing;
+	int ret;
+
+	readSize = DEVICE_VB_LENGTH - vb_get_write_size(buf);
+	nextOffset = buf->readOffset + DEVICE_MPEG2_PACKET_SIZE;
+	if (nextOffset >= DEVICE_VB_LENGTH)
+		nextOffset -= DEVICE_VB_LENGTH;
+	while (readSize > DEVICE_MPEG2_PACKET_SIZE) {
+		if ((buf->data[buf->readOffset] == DEVICE_MPEG2_SYNC_BYTE) &&
+			(buf->data[nextOffset] == DEVICE_MPEG2_SYNC_BYTE)) {
+			/* packet in sync */
+			break;
+		} /* if */
+		buf->readOffset++;
+		if (buf->readOffset == DEVICE_VB_LENGTH)
+			buf->readOffset = 0;
+		nextOffset++;
+		if (nextOffset == DEVICE_VB_LENGTH)
+			nextOffset = 0;
+		readSize--;
+	} /* while */
+	if (readSize <= DEVICE_MPEG2_PACKET_SIZE) {
+		buf->isEmpty = 1;
+		return 0;
+	} /* if */
+
+	/* packet is in sync, check if it is a stuffing packet */
+	isStuffing = 0;
+	firstPart = DEVICE_VB_LENGTH - buf->readOffset;
+	if (firstPart < DEVICE_NULL_HEADER_SIZE) {
+		if ((memcmp(nullHeader, &buf->data[buf->readOffset], firstPart)
+				== 0) &&
+				(memcmp(&nullHeader[firstPart], buf->data,
+					    DEVICE_NULL_HEADER_SIZE - firstPart)
+					== 0)) {
+			isStuffing = 1;
+		} /* if */
+	} /* if */
+	else {
+		if (memcmp(nullHeader, &buf->data[buf->readOffset],
+					DEVICE_NULL_HEADER_SIZE) == 0) {
+			isStuffing = 1;
+		} /* if */
+	} /* else */
+	readSize -= DEVICE_MPEG2_PACKET_SIZE;
+	if (readSize <= DEVICE_MPEG2_PACKET_SIZE)
+		buf->isEmpty = 1;
+
+	/* skip stuffing packet */
+	if (isStuffing) {
+		buf->readOffset = nextOffset;
+		return 0;
+	} /* if */
+
+	/* copy packet to user space */
+	if (firstPart >= DEVICE_MPEG2_PACKET_SIZE) {
+		ret = copy_to_user(data,
+			&buf->data[buf->readOffset], DEVICE_MPEG2_PACKET_SIZE);
+	} /* if */ else {
+		ret = copy_to_user(data,
+			&buf->data[buf->readOffset], firstPart);
+		ret = copy_to_user(&data[firstPart],
+			buf->data, DEVICE_MPEG2_PACKET_SIZE - firstPart);
+	} /* else */
+	buf->readOffset = nextOffset;
+	return DEVICE_MPEG2_PACKET_SIZE;
+} /* vb_read_next */
+
+/*-------------------------------------------------------------------*/
+#ifdef DEBUG_BITRATE
+static void print_bitrate(struct ts_channel_s *channel, __u8 channel_number)
+{
+	int     readSize;
+	ktime_t  currentTime;
+	int  diffTime_us;
+	int bitrate;
+
+	currentTime = ktime_get_real();
+	if (!(channel->bitrateTime.tv64)) {
+		channel->bitrateTime = currentTime;
+	} else {
+		readSize = DEVICE_VB_LENGTH - vb_get_write_size(&channel->inVb);
+		dbg("%d bytes received\n", readSize);
+		diffTime_us = (int)(ktime_us_delta(currentTime,
+					channel->bitrateTime));
+		if (diffTime_us) {
+			bitrate = (int)((readSize * 8 * USEC_PER_SEC)
+					/ diffTime_us);
+		}
+		channel->bitrateTime = currentTime;
+		dbg("received bitrate for channel[%d] = %dbps\n",
+			channel_number, bitrate);
+	}
+}
+#endif /* DEBUG_BITRATE */
+/*-------------------------------------------------------------------*/
+
+static void device_cibulk_complete(struct urb *urb)
+{
+	dbg("start");
+	kfree(urb->transfer_buffer);
+	usb_free_urb(urb);
+	dbg("end");
+} /* device_cibulk_complete */
+
+static int device_cibulk_send(struct device_s *device,
+		struct ioctl_data_s *data,
+		int user_space)
+{
+	int         res;
+	struct urb *urb;
+	int         size;
+	int         index = -1;
+	__u8        *ptr;
+	__u32       todo = data->txSize;
+	__u8        *userData = data->txData;
+
+	dbg("start");
+
+	do {
+		/* get a free bulk message */
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			err("alloc urb");
+			return -ENOMEM;
+		} /* if */
+		urb->dev = device->usbdev;
+
+		/* allocate bulk data */
+		size = device->ciBulk.outMaxPacketSize;
+		if (todo < size)
+			size = todo;
+		urb->transfer_buffer = kmalloc(size, GFP_KERNEL);
+		if (!urb->transfer_buffer) {
+			err("alloc transfer buffer");
+			usb_free_urb(urb);
+			return -ENOMEM;
+		} /* if */
+
+		/* copy data */
+		ptr = urb->transfer_buffer;
+		res = copyDataFrom(user_space, ptr, userData, size);
+
+#ifdef TIMESTAMP
+		if (bSetTimestamps) {
+			if (index == -1) {
+				SetTimestamp("urb %x, toSend %d, send %d",
+					    urb, todo, size);
+				SetTimestamp("cmd 0x%02x", ptr[0]);
+			} else {
+				SetTimestamp("urb %x, toSend %d, send %d",
+					    urb, todo, size);
+			}
+		}
+#endif
+
+		/* first packet, get index */
+		if (index == -1) {
+			if ((ptr[DEVICE_COMMAND_OFFSET] == DEVICE_CMD_INIT) ||
+				(ptr[DEVICE_COMMAND_OFFSET]
+					== DEVICE_CMD_WRITE_REG) ||
+				(ptr[DEVICE_COMMAND_OFFSET]
+					== DEVICE_CMD_READ_REG)) {
+				index = 0; /* register command, no module */
+			} else if (ptr[DEVICE_COMMAND_OFFSET]
+					& DEVICE_SEL_MASK) {
+				index = 1; /* module B */
+			} else {
+				index = 0; /* module A */
+			} /* else */
+			device->ciBulk.ciData[index].syncDataSize = 0;
+			device->ciBulk.ciData[index].syncSignal = 0;
+		} /* if */
+
+		/* submit bulk */
+		urb->pipe = usb_sndbulkpipe(device->usbdev,
+				DEVICE_BULK_OUT_PIPE);
+		urb->transfer_buffer_length = size;
+		urb->complete = device_cibulk_complete;
+		urb->context  = NULL;
+		dbg_dump("txBuf", urb->transfer_buffer,
+				urb->transfer_buffer_length);
+		res = usb_submit_urb(urb, GFP_KERNEL);
+		if (res < 0) {
+			err("submit urb res = %d", res);
+			kfree(urb->transfer_buffer);
+			usb_free_urb(urb);
+			return -ENOMEM;
+		} /* if */
+		todo -= size;
+		userData += size;
+	} while (todo);
+
+	device->ciBulk.ciData[index].bPendingSend = 1;
+	dbg("end");
+	return index;
+} /* device_cibulk_send */
+
+static void device_int_complete(struct urb *urb)
+{
+	unsigned long   flags;
+	struct device_s *device = urb->context;
+	__u8            *dataToCopy;
+	int             sizeToCopy, SizeReceived;
+	__u8            isFirstPacket = 0;
+	__u8            isLastPacket = 0;
+	__u8            index, i;
+	__u8            status;
+	struct message_node_s *message;
+
+	dbg("start");
+
+	if (urb->status) {
+		dbg("urb status %d, not submitted again", urb->status);
+		kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+		for (i = 0; i < DEVICE_NUM_INT_IN_URBS; i++) {
+			if (device->ciBulk.intUrb[i] == urb)
+				device->ciBulk.intUrb[i] = NULL;
+		}
+		return;
+	} /* if */
+
+	spin_lock_irqsave(&device->ciBulk.intUrbLock, flags);
+	dbg("urb status %d, transfer_buffer_length %d actual_length %d",
+			urb->status,
+			urb->transfer_buffer_length,
+			urb->actual_length);
+	dataToCopy = urb->transfer_buffer;
+	SizeReceived =  urb->actual_length;
+	dbg_dump("total rxBuf", dataToCopy, SizeReceived);
+
+
+	do {
+		if (device->ciBulk.intSizeToReceive == 0) {
+			if (!dataToCopy[DEVICE_STATUS_OFFSET] &&
+					!dataToCopy[DEVICE_LENGTH_MSB_OFFSET] &&
+					!dataToCopy[DEVICE_LENGTH_LSB_OFFSET] &&
+					!dataToCopy[DEVICE_COUNTER_OFFSET]){
+				dbg("no data receive");
+				memset(urb->transfer_buffer,
+						0, urb->transfer_buffer_length);
+				usb_submit_urb(urb, GFP_ATOMIC);
+				return;
+			}
+			/* first packet, read header */
+			isFirstPacket = 1;
+			device->ciBulk.intCurrStatus =
+				dataToCopy[DEVICE_STATUS_OFFSET] &
+				DEVICE_CMD_MASK;
+			if (dataToCopy[DEVICE_STATUS_OFFSET]
+				& DEVICE_SEL_MASK) {
+				device->ciBulk.intCurrIndex = 1; /* module B */
+			} else {
+				device->ciBulk.intCurrIndex = 0; /* module A */
+			}
+			if ((device->ciBulk.intCurrStatus == DEVICE_READ_REGOK)
+				|| (device->ciBulk.intCurrStatus
+					== DEVICE_WRITE_REGOK)) {
+				device->ciBulk.intSizeToReceive =
+					dataToCopy[DEVICE_LENGTH_LSB_OFFSET] +
+					DEVICE_DATA_OFFSET;
+			} else {
+				device->ciBulk.intSizeToReceive =
+				dataToCopy[DEVICE_LENGTH_MSB_OFFSET] * 256
+					+ dataToCopy[DEVICE_LENGTH_LSB_OFFSET]
+					+ DEVICE_DATA_OFFSET;
+			}
+		} /* if */
+
+		/* get last packet state */
+		status     = device->ciBulk.intCurrStatus;
+		index      = device->ciBulk.intCurrIndex;
+		sizeToCopy = device->ciBulk.intSizeToReceive;
+		if (sizeToCopy > urb->actual_length) {
+			/* limit size to received buffer size */
+			sizeToCopy = urb->actual_length;
+		} /* if */ else
+			isLastPacket = 1;
+		dbg_dump("rxBuf", dataToCopy, sizeToCopy);
+
+#ifndef FRBIT
+		if (status == DEVICE_DATAREADY) {
+			if (device->ciBulk.ciData[index].bPendingSend)
+				status = DEVICE_DATAREADY_SYNC;
+		}
+#endif
+
+#ifdef TIMESTAMP
+		if (device->ciBulk.intSizeToReceive > 2000)
+			bSetTimestamps = 1;
+		if (bSetTimestamps) {
+			SetTimestamp("urb %x,toReceive %d,received %d,toCopy%d",
+				urb,
+				device->ciBulk.intSizeToReceive,
+				SizeReceived,
+				sizeToCopy);
+			SetTimestamp("status 0x%02x, camIndex %d, isLast %d",
+				status, index, isLastPacket);
+		}
+#endif
+
+		switch (status) {
+		case DEVICE_INITOK:
+		case DEVICE_READ_REGOK:
+		case DEVICE_WRITE_REGOK:
+			index = 0;
+		case DEVICE_CAMRESETOK:
+			/*only for debug*/
+			if (!dataToCopy[DEVICE_STATUS_OFFSET] &&
+				!dataToCopy[DEVICE_LENGTH_MSB_OFFSET] &&
+				!dataToCopy[DEVICE_LENGTH_LSB_OFFSET] &&
+				!dataToCopy[DEVICE_COUNTER_OFFSET]){
+				break;
+			}
+		case DEVICE_CISOK:
+		case DEVICE_WRITECOROK:
+		case DEVICE_NEGOTIATEOK:
+		case DEVICE_WRITELPDUOK:
+		case DEVICE_WRITELPDUBUSY:
+		case DEVICE_READLPDUOK:
+		case DEVICE_WRITEEXTOK:
+		case DEVICE_READEXTOK:
+		case DEVICE_NO_CAM:
+		case DEVICE_NOK:
+		case DEVICE_MCARD_WRITEOK:
+		case DEVICE_CAMPARSE_ERROR:
+		case DEVICE_CMDPENDING:
+		case DEVICE_REGSTATUSOK:
+		case DEVICE_DATAREADY_SYNC:
+			/* copy partial message */
+			spin_lock_irqsave(&device->ciBulk.intLock,
+				flags);
+			memcpy(&device->ciBulk.ciData[index].
+				syncData[device->ciBulk.ciData[index].
+				syncDataSize],
+				dataToCopy, sizeToCopy);
+			device->ciBulk.intSizeToReceive -= sizeToCopy;
+			device->ciBulk.ciData[index].syncDataSize +=
+				sizeToCopy;
+			spin_unlock_irqrestore(&device->ciBulk.intLock,
+				flags);
+			dbg("copied %d bytes at offset %d", sizeToCopy,
+				device->ciBulk.ciData[index].
+				syncDataSize - sizeToCopy);
+
+			if (isLastPacket) {
+				/* last packet received, sync message */
+				device->ciBulk.ciData[index].syncSignal = 1;
+				wake_up_interruptible(&device->ciBulk.
+					ciData[index].syncWait);
+				device->ciBulk.ciData[index].bPendingSend = 0;
+				dbg("sync signal return %d %d ",
+					device->ciBulk.ciData[index].
+						syncDataSize, index);
+			} /* if */
+			break;
+		case DEVICE_CAMDET:
+		case DEVICE_DATAREADY:
+		case DEVICE_MCARD_READ:
+		case DEVICE_FRBit:
+			if (isFirstPacket) {
+				/* create new async message */
+				message = kmalloc(sizeof(struct message_node_s),
+					GFP_ATOMIC);
+				if (!message) {
+					err("cannot allocate async message");
+					break;
+				}
+				memset(message,
+					0, sizeof(struct message_node_s));
+				list_add_tail(&message->node,
+					&device->ciBulk.ciData[index].
+						asyncDataList);
+			} /* if */
+			else {
+				/* get tail message */
+				message = list_entry((device->ciBulk.
+					ciData[index].asyncDataList.prev),
+					struct message_node_s, node);
+			} /* else */
+
+			/* copy partial message */
+			spin_lock_irqsave(&device->ciBulk.intLock, flags);
+			memcpy(&message->data[message->size],
+					dataToCopy, sizeToCopy);
+			device->ciBulk.intSizeToReceive -= sizeToCopy;
+			message->size += sizeToCopy;
+			spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
+			dbg("async copied %d bytes at offset %d", sizeToCopy,
+				message->size - sizeToCopy);
+
+			if (isLastPacket) {
+				/* last packet received, signal async message */
+				wake_up_interruptible(&device->ciBulk.
+					ciData[index].asyncWait);
+				dbg("async signal %d", index);
+			} /* if */
+			break;
+		case DEVICE_GPIOCHANGE:
+			info("GPIO change %x %x %x",
+				status, dataToCopy[4], dataToCopy[5]);
+			device->ciBulk.intSizeToReceive -= sizeToCopy;
+			break;
+		default:
+			err("unknown status 0x%2x", status);
+			break;
+		} /* switch */
+		dataToCopy += sizeToCopy;
+		SizeReceived -= sizeToCopy;
+
+	} while (SizeReceived > 0);
+
+	memset(urb->transfer_buffer, 0, urb->transfer_buffer_length);
+	usb_submit_urb(urb, GFP_ATOMIC);
+
+#ifdef TIMESTAMP
+	/*if (bSetTimestamps) {
+		SetTimestamp("urb %x submitted", urb);
+	}*/
+#endif
+
+	spin_unlock_irqrestore(&device->ciBulk.intUrbLock, flags);
+
+	dbg("end");
+} /* device_int_complete */
+
+static int device_wait_sync_data(struct device_s *device,
+		__u8          index,
+		struct ioctl_data_s *data,
+		int user_space)
+{
+	unsigned long flags;
+	int ret;
+
+	dbg("start %d", index);
+
+	spin_lock_irqsave(&device->ciBulk.intLock, flags);
+	while (device->ciBulk.ciData[index].syncSignal == 0) {
+		/* nothing to copy */
+		spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
+		if (wait_event_interruptible(device->ciBulk.
+				ciData[index].syncWait,
+				device->ciBulk.ciData[index].syncSignal)) {
+			device->ciBulk.ciData[index].bPendingSend = 0;
+			err("interrupt");
+			return -ERESTARTSYS;
+			/* signal: tell the fs layer to handle it */
+		} /* if */
+		/* otherwise loop, but first reacquire the lock */
+		spin_lock_irqsave(&device->ciBulk.intLock, flags);
+	} /* while */
+
+	/* copy packet to user space buffer */
+	if (device->ciBulk.ciData[index].syncDataSize < data->rxSize)
+		/* truncate returned message against user buffer size */
+		data->rxSize = device->ciBulk.ciData[index].syncDataSize;
+	spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
+	/* release the lock */
+	ret = copyDataTo(user_space,
+			data->rxData,
+			device->ciBulk.ciData[index].syncData, data->rxSize);
+	dbg_dump("userMsg",
+		device->ciBulk.ciData[index].syncData, data->rxSize);
+	dbg("userRet %d", data->rxSize);
+	device->ciBulk.ciData[index].syncDataSize = 0;
+	device->ciBulk.ciData[index].syncSignal = 0;
+
+	dbg("end");
+	return 0;
+} /* device_wait_sync_data */
+
+static int device_wait_async_data(struct device_s *device,
+		__u8       index,
+		struct rw_data_s *data,
+		int user_space)
+{
+	struct list_head *item;
+	struct message_node_s *message;
+	unsigned long     flags;
+	int ret;
+
+	dbg("start %d", index);
+
+	if ((device->askToRelease) || (device->askToSuspend)) {
+		err("ask to release or ask to suspend");
+		return -EINTR; /* device close interrupt */
+	} /* if */
+
+	if (index >= DEVICE_NUM_CAM) {
+		err("bad index(%d)", index);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&device->ciBulk.intLock, flags);
+	while (list_empty(&device->ciBulk.ciData[index].asyncDataList)) {
+		/* nothing to copy */
+		spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
+		/* release the lock */
+		if (wait_event_interruptible(device->ciBulk.
+				ciData[index].asyncWait,
+			device->askToRelease ||
+			device->askToSuspend ||
+			(!list_empty(&device->ciBulk.
+				ciData[index].asyncDataList)))) {
+			err("interrupt");
+			return -ERESTARTSYS;
+			/* signal: tell the fs layer to handle it */
+		} /* if */
+		if ((device->askToRelease) || (device->askToSuspend)) {
+			err("ask to release or ask to suspend");
+			return -EINTR; /* device close interrupt */
+		} /* if */
+		/* otherwise loop, but first reacquire the lock */
+		spin_lock_irqsave(&device->ciBulk.intLock, flags);
+	} /* while */
+
+	/* ok, data is there, return first item */
+	item = device->ciBulk.ciData[index].asyncDataList.next;
+	message = list_entry(item, struct message_node_s, node);
+	if (message->size < data->size) {
+		/* truncate returned message against user buffer size */
+		data->size = message->size;
+	} /* if */
+	spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
+	/* release the lock */
+	ret = copyDataTo(user_space, data->data, message->data, data->size);
+	dbg_dump("userMsg", message->data, data->size);
+	dbg("userRet %d", data->size);
+	list_del(item);
+	kfree(message);
+
+	dbg("end");
+	return 0;
+} /* device_wait_async_data */
+
+static int device_start_intr(struct device_s *device)
+{
+	__u8        i, j;
+	struct urb *urb;
+
+	dbg("start");
+
+	for (i = 0; i < DEVICE_NUM_INT_IN_URBS; i++) {
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			err("alloc urb");
+			return -ENOMEM;
+		} /* if */
+		urb->transfer_buffer =
+			kmalloc(device->ciBulk.inMaxPacketSize, GFP_KERNEL);
+		if (!urb->transfer_buffer) {
+			err("alloc transfer buffer");
+			usb_free_urb(urb);
+			urb = NULL;
+			return -ENOMEM;
+		} /* if */
+
+		urb->dev  = device->usbdev;
+		urb->pipe = usb_rcvintpipe(device->usbdev, DEVICE_INT_IN_PIPE);
+		urb->transfer_buffer_length = device->ciBulk.inMaxPacketSize;
+		urb->complete = device_int_complete;
+		urb->context  = device;
+		urb->interval = 1;
+		device->ciBulk.intUrb[i] = urb;
+		for (j = 0; j < DEVICE_NUM_CAM; j++) {
+			init_waitqueue_head(&device->ciBulk.ciData[j].syncWait);
+			init_waitqueue_head(&device->ciBulk.
+				ciData[j].asyncWait);
+		} /* for */
+		usb_submit_urb(device->ciBulk.intUrb[i], GFP_KERNEL);
+	}
+
+	dbg("end");
+	return 0;
+} /* device_start_intr */
+
+static void device_stop_intr(struct device_s *device)
+{
+	struct list_head *item;
+	struct list_head *tmp;
+	struct message_node_s *message;
+	int               i, j;
+
+	dbg("start");
+
+	for (i = 0; i < DEVICE_NUM_INT_IN_URBS; i++) {
+		if (!device->ciBulk.intUrb[i])
+			break;
+		usb_unlink_urb(device->ciBulk.intUrb[i]);
+		device->ciBulk.intUrb[i] = NULL;
+		for (j = 0; j < DEVICE_NUM_CAM; j++) {
+			for (item = device->ciBulk.ciData[j].asyncDataList.next;
+				item != &device->ciBulk.ciData[j].asyncDataList;
+				) {
+				message = list_entry(item,
+						struct message_node_s, node);
+				tmp = item->next;
+				list_del(item);
+				kfree(item);
+				item = tmp;
+			} /* for */
+		} /* for */
+		dbg("unlink urb");
+	}
+
+	dbg("end");
+} /* device_stop_intr */
+
+static void device_iso_in_complete(struct urb *urb)
+{
+	unsigned long flags;
+	struct ts_channel_s *channel = urb->context;
+	__u8          i;
+	__u8          *data;
+
+	/*dbg("start");*/
+
+	if (urb->status) {
+		dbg("urb status %d, not submitted again", urb->status);
+		kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+		return;
+	} /* if */
+
+	spin_lock_irqsave(&channel->inLock, flags);
+	for (i = 0; i < urb->number_of_packets; i++) {
+		data = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
+		if (!urb->iso_frame_desc[i].status &&
+				(urb->iso_frame_desc[i].actual_length > 0)) {
+			if (vb_get_write_size(&channel->inVb)
+				>= urb->iso_frame_desc[i].actual_length) {
+				vb_write(&channel->inVb, data,
+					urb->iso_frame_desc[i].actual_length);
+			} /* if */
+			else {
+				err("video buffer is full, packet loss %d",
+					urb->iso_frame_desc[i].actual_length);
+			} /* else */
+		} /* if */
+		else {
+			err("frame rejected, status %x, actual_length %d bytes",
+				urb->iso_frame_desc[i].status,
+				urb->iso_frame_desc[i].actual_length);
+		}
+	} /* for */
+	spin_unlock_irqrestore(&channel->inLock, flags);
+
+	if (!channel->inVb.isEmpty)
+		wake_up_interruptible(&channel->inWait);
+
+	memset(urb->transfer_buffer,
+		0, DEVICE_ISOC_LENGTH(channel->maxPacketSize));
+	urb->transfer_buffer_length =
+		DEVICE_ISOC_LENGTH(channel->maxPacketSize);
+	urb->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
+	urb->complete = device_iso_in_complete;
+	urb->context = channel;
+	urb->transfer_flags = URB_ISO_ASAP;
+	urb->interval = 1;
+	for (i = 0; i < DEVICE_NUM_FRAMES_PER_URB; i++) {
+		urb->iso_frame_desc[i].offset = i * channel->maxPacketSize;
+		urb->iso_frame_desc[i].length = channel->maxPacketSize;
+	} /* for */
+	usb_submit_urb(urb, GFP_ATOMIC);
+
+	/*dbg("end");*/
+} /* device_iso_in_complete */
+
+static void device_tsbulk_in_complete(struct urb *urb)
+{
+	unsigned long flags;
+	struct ts_channel_s *channel = urb->context;
+	__u8          *data;
+#ifdef DEBUG_CONTINUITY
+	unsigned int i;
+#endif
+
+	/*dbg("start");*/
+
+	if (urb->status) {
+		err("urb status %d(%x), not submitted again",
+			urb->status, urb->status);
+		kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+		return;
+	} /* if */
+
+	spin_lock_irqsave(&channel->inLock, flags);
+	data = urb->transfer_buffer;
+
+#ifdef DEBUG_CONTINUITY
+	i = 0;
+	/* check synchro byte*/
+	while (i < urb->actual_length) {
+		if (!((data[i] == DEVICE_MPEG2_SYNC_BYTE) &&
+			(data[i+DEVICE_MPEG2_PACKET_SIZE]
+				== DEVICE_MPEG2_SYNC_BYTE))) {
+			i++;
+		} else {
+			/* Synchro find*/
+			break;
+		}
+	}
+
+	/* Synchro Ok, check discontinuity*/
+	while (i < urb->actual_length) {
+		if (dbg_cc(&data[i]) < 0) {
+			dbg("(actual_length= %d i=%d pkt=%d)",
+				urb->actual_length,
+				i,
+				i/DEVICE_MPEG2_PACKET_SIZE);
+			dbg("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				data[i-4], data[i-3], data[i-2], data[i-1],
+				data[i], data[i+1], data[i+2], data[i+3]);
+		}
+		i += DEVICE_MPEG2_PACKET_SIZE;
+	}
+#endif
+
+	if (urb->actual_length) {
+		channel->nbByteRead += urb->actual_length;
+		if (vb_get_write_size(&channel->inVb) >= urb->actual_length)
+			vb_write(&channel->inVb, data, urb->actual_length);
+		else
+			err("video buffer is full, packet loss %d",
+				urb->actual_length);
+	} else {
+		/*warn("receive size of 0\n");*/
+	}
+
+	spin_unlock_irqrestore(&channel->inLock, flags);
+	/*  dbg("urb->actual_length=%d",urb->actual_length);*/
+	/*  info("urb->actual_length=%d\n",urb->actual_length);*/
+
+	if (!channel->inVb.isEmpty)
+		wake_up_interruptible(&channel->inWait);
+	kfree(urb->transfer_buffer);
+	usb_free_urb(urb);
+	/*dbg("end");*/
+} /* device_tsbulk_in_complete */
+
+static int device_fill_ts(struct device_s *device,
+		__u8       index,
+		struct rw_data_s *data)
+{
+	unsigned long flags;
+	__u32         copiedSize;
+	struct ts_channel_s *channel = &device->channel[index];
+
+	/*dbg("start");*/
+
+	spin_lock_irqsave(&channel->inLock, flags);
+	do {
+		while (channel->inVb.isEmpty) {
+			/* nothing to copy */
+			spin_unlock_irqrestore(&channel->inLock, flags);
+			/* release the lock */
+			if (wait_event_interruptible(channel->inWait,
+					    device->askToRelease ||
+					    device->askToSuspend ||
+					    (!channel->inVb.isEmpty))) {
+				err("interrupt");
+				return -ERESTARTSYS;
+				/* signal: tell the fs layer to handle it */
+			} /* if */
+			if ((device->askToRelease) || (device->askToSuspend)) {
+				err("ask to release or ask to suspend");
+				return -EINTR; /* device close interrupt */
+			} /* if */
+			/* otherwise loop, but first reacquire the lock */
+			spin_lock_irqsave(&channel->inLock, flags);
+		} /* while */
+
+		spin_unlock_irqrestore(&channel->inLock, flags);
+
+		copiedSize = vb_read_next(&channel->inVb,
+			&data->data[data->copiedSize]);
+		if (copiedSize) {
+			/*dbg("copied %d bytes in buffer 0x%p, offset %d",
+			  copiedSize, data->data, data->copiedSize);*/
+			data->copiedSize += copiedSize;
+		} /* if */
+		spin_lock_irqsave(&channel->inLock, flags);
+	} while ((data->copiedSize+DEVICE_MPEG2_PACKET_SIZE) <= data->size);
+	/* buffer not full */
+
+	spin_unlock_irqrestore(&channel->inLock, flags);
+
+#ifdef DEBUG_BITRATE
+	print_bitrate(channel, index);
+#endif
+
+	/*dbg("end, buffer 0x%p", data->data);*/
+	return 0;
+} /* device_fill_ts */
+
+static int device_start_iso_in(struct device_s *device, __u8 index)
+{
+	int         i, j;
+	int         ret = 0;
+	struct urb *urb;
+
+	/*dbg("start");*/
+
+#ifdef DEBUG_BITRATE
+	device->channel[index].bitrateTime = ktime_set(0, 0);
+#endif
+	for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++) {
+		urb = usb_alloc_urb(DEVICE_NUM_FRAMES_PER_URB, GFP_KERNEL);
+		device->channel[index].isocInUrb[i] = urb;
+		if (urb) {
+			/*urb->transfer_buffer =
+				kmalloc(DEVICE_ISOC_LENGTH, GFP_KERNEL);*/
+			urb->transfer_buffer =
+				kmalloc(DEVICE_ISOC_LENGTH(
+					device->channel[index].maxPacketSize),
+					GFP_KERNEL);
+			if (!urb->transfer_buffer) {
+				ret = -ENOMEM;
+				err("transfer_buffer allocation failed %d", i);
+				break;
+			} /* if */
+		} /* if */ else {
+			ret = -ENOMEM;
+			err("usb_alloc_urb failed %d", i);
+			break;
+		} /* if */
+	} /* for */
+
+	if (ret) {
+		/* Allocation error, must free already allocated data */
+		for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++) {
+			urb = device->channel[index].isocInUrb[i];
+			if (urb) {
+				kfree(urb->transfer_buffer);
+				if (urb->transfer_buffer)
+					urb->transfer_buffer = NULL;
+				usb_free_urb(urb);
+				device->channel[index].isocInUrb[i] = NULL;
+			} /* if */
+		} /* for */
+		return ret;
+	} /* if */
+
+	for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++) {
+		urb = device->channel[index].isocInUrb[i];
+		memset(urb->transfer_buffer,
+			0,
+			DEVICE_ISOC_LENGTH(
+				device->channel[index].maxPacketSize));
+		urb->transfer_buffer_length =
+			DEVICE_ISOC_LENGTH(
+				device->channel[index].maxPacketSize);
+		urb->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
+		urb->complete = device_iso_in_complete;
+		urb->context = &device->channel[index];
+		urb->dev = device->usbdev;
+		urb->pipe = usb_rcvisocpipe(
+			device->usbdev, DEVICE_TS_IN_PIPE + index);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->interval = 1;
+		for (j = 0; j < DEVICE_NUM_FRAMES_PER_URB; j++) {
+			urb->iso_frame_desc[j].offset =
+				j * device->channel[index].maxPacketSize;
+			urb->iso_frame_desc[j].length =
+				device->channel[index].maxPacketSize;
+		} /* for */
+	} /* for */
+	for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++)
+		usb_submit_urb(device->channel[index].isocInUrb[i], GFP_KERNEL);
+
+	/*dbg("end");*/
+	return 0;
+} /* device_start_iso_in */
+
+static void device_stop_iso_in(struct device_s *device, __u8 index)
+{
+	int i;
+
+	/*dbg("start");*/
+
+	for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++) {
+		if (device->channel[index].isocInUrb[i]) {
+			usb_unlink_urb(device->channel[index].isocInUrb[i]);
+			device->channel[index].isocInUrb[i] = NULL;
+			dbg("unlink urb %i", i);
+		} /* if */
+	} /* for */
+
+	/*dbg("end");*/
+} /* device_stop_iso_in */
+
+static int device_start_tsbulk_in(struct device_s *device, __u8 index)
+{
+	struct urb *urb;
+
+	dbg("start");
+
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (urb) {
+		urb->transfer_buffer  = kmalloc(3072, GFP_KERNEL);
+		if (!urb->transfer_buffer) {
+			err("transfer_buffer allocation failed");
+			usb_free_urb(urb);
+			return -ENOMEM;
+		} /* if */
+	} /* if */ else {
+		err("usb_alloc_urb failed");
+		return -ENOMEM;
+	} /* if */
+	device->channel[index].bulkInUrb = urb;
+	memset(urb->transfer_buffer, 0, 3072);
+	urb->transfer_buffer_length = 3072;
+
+	urb->complete = device_tsbulk_in_complete;
+	urb->context = &device->channel[index];
+	urb->dev = device->usbdev;
+	urb->pipe = usb_rcvbulkpipe(device->usbdev, DEVICE_TS_IN_PIPE + index);
+	usb_submit_urb(device->channel[index].bulkInUrb, GFP_KERNEL);
+
+	dbg("end");
+	return 0;
+} /* device_start_tsbulk_in */
+
+static void device_stop_tsbulk_in(struct device_s *device, __u8 index)
+{
+	dbg("start");
+
+	if (device->channel[index].bulkInUrb) {
+		usb_unlink_urb(device->channel[index].bulkInUrb);
+		device->channel[index].bulkInUrb = NULL;
+		dbg("unlink urb");
+	} /* if */
+
+	dbg("end");
+} /* device_stop_tsbulk_in */
+
+static void device_iso_out_complete(struct urb *urb)
+{
+	struct ts_channel_s *channel = urb->context;
+	struct urb    *tmpUrb;
+	int           i;
+	int ret = 0;
+
+	/*dbg("start");*/
+
+/*dbg_dump("txBuf", urb->transfer_buffer, urb->transfer_buffer_length);*/
+
+	if (urb->status || channel->outStop) {
+		/* error, free all coming urbs */
+		err("free urb");
+		channel->outStop = 1;
+		atomic_dec(&channel->numOutUrbs);
+		kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+		return;
+	} /* if */
+
+	for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS; i++) {
+		if (urb == channel->isocOutUrb[i])
+			break;
+	} /* for */
+	if (i == DEVICE_NUM_ISOC_OUT_URBS) {
+		/* urb must be deleted */
+		kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+	} /* if */
+
+	if (atomic_dec_and_test(&channel->numOutUrbs)) {
+		/* get next free urb */
+		tmpUrb = channel->isocOutUrb[channel->nextFreeOutUrbIndex++];
+		if (channel->nextFreeOutUrbIndex == DEVICE_NUM_ISOC_OUT_URBS)
+			channel->nextFreeOutUrbIndex = 0;
+
+		/* reinitialize urb with null packets */
+		memset(tmpUrb->transfer_buffer,
+			0xCD, DEVICE_ISOC_LENGTH(channel->maxPacketSize));
+		for (i = 0;
+			i < DEVICE_ISOC_LENGTH(channel->maxPacketSize);
+			i += DEVICE_MPEG2_PACKET_SIZE) {
+			memcpy(tmpUrb->transfer_buffer+i,
+				nullHeader, sizeof(nullHeader));
+		} /* for */
+		tmpUrb->transfer_buffer_length =
+			DEVICE_ISOC_LENGTH(channel->maxPacketSize);
+		tmpUrb->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
+		tmpUrb->complete = device_iso_out_complete;
+		tmpUrb->context = channel;
+		tmpUrb->transfer_flags = URB_ISO_ASAP;
+		tmpUrb->interval = 1;
+		for (i = 0; i < DEVICE_NUM_FRAMES_PER_URB; i++) {
+			tmpUrb->iso_frame_desc[i].offset =
+				i * channel->maxPacketSize;
+			tmpUrb->iso_frame_desc[i].length =
+				channel->maxPacketSize;
+		} /* for */
+
+		/* submit urb */
+		ret = usb_submit_urb(tmpUrb, GFP_ATOMIC);
+		if (ret)
+			err("usb_submit_urb failed %d", ret);
+
+		atomic_inc(&channel->numOutUrbs);
+	} /* if */
+
+	/*dbg("end");*/
+} /* device_iso_out_complete */
+
+static int device_tsiso_send(struct device_s *device,
+	__u8 index, __u8 *data, int size)
+{
+	int          i, j;
+	struct urb   **urb;
+	__u32        numUrbs;
+	int          ret = 0;
+
+	/*  dbg("start");*/
+
+	numUrbs =
+		size / DEVICE_ISOC_LENGTH(device->channel[index].maxPacketSize);
+	urb = kmalloc(numUrbs * sizeof(struct urb *), GFP_KERNEL);
+	if (!urb) {
+		err("urb array allocation failed %d", numUrbs);
+		return -ENOMEM;
+
+	} /* if */
+	memset(urb, 0, numUrbs * sizeof(struct urb *));
+
+	for (i = 0; i < numUrbs; i++) {
+		urb[i] = usb_alloc_urb(DEVICE_NUM_FRAMES_PER_URB, GFP_KERNEL);
+		if (urb[i]) {
+			urb[i]->transfer_buffer =
+				kmalloc(DEVICE_ISOC_LENGTH(
+					device->channel[index].maxPacketSize),
+						GFP_KERNEL);
+			if (!urb[i]->transfer_buffer) {
+				ret = -ENOMEM;
+				err("transfer_buffer allocation failed %d", i);
+				break;
+			} /* if */
+		} /* if */
+		else {
+			ret = -ENOMEM;
+			err("usb_alloc_urb failed %d", i);
+			break;
+		} /* if */
+	} /* for */
+	if (ret) {
+		/* Allocation error, must free already allocated data */
+		for (i = 0; i < numUrbs; i++) {
+			if (urb[i]) {
+				kfree(urb[i]->transfer_buffer);
+				urb[i]->transfer_buffer = NULL;
+				usb_free_urb(urb[i]);
+				urb[i] = NULL;
+			} /* if */
+		} /* for */
+		kfree(urb);
+		return ret;
+	} /* if */
+
+	for (i = 0; i < numUrbs; i++) {
+		ret = copy_from_user(urb[i]->transfer_buffer,
+			&data[i*DEVICE_ISOC_LENGTH(
+					device->channel[index].maxPacketSize)],
+				DEVICE_ISOC_LENGTH(
+					device->channel[index].maxPacketSize));
+		urb[i]->transfer_buffer_length = DEVICE_ISOC_LENGTH(
+			device->channel[index].maxPacketSize);
+		urb[i]->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
+		urb[i]->complete = device_iso_out_complete;
+		urb[i]->context = &device->channel[index];
+		urb[i]->dev = device->usbdev;
+		urb[i]->pipe = usb_sndisocpipe(device->usbdev,
+			DEVICE_TS_OUT_PIPE + index);
+		urb[i]->transfer_flags = URB_ISO_ASAP;
+		urb[i]->interval = 1;
+		for (j = 0; j < DEVICE_NUM_FRAMES_PER_URB; j++) {
+			urb[i]->iso_frame_desc[j].offset =
+				j * device->channel[index].maxPacketSize;
+			urb[i]->iso_frame_desc[j].length =
+				device->channel[index].maxPacketSize;
+		} /* for */
+	} /* for */
+
+	atomic_add(numUrbs, &device->channel[index].numOutUrbs);
+	for (i = 0; i < numUrbs; i++) {
+		ret = usb_submit_urb(urb[i], GFP_ATOMIC);
+		if (ret)
+			err("usb_submit_urb failed %d", ret);
+	} /* for */
+
+	kfree(urb);
+
+	/*  dbg("end");*/
+	return size;
+} /* device_tsiso_send */
+
+static int device_start_iso_out(struct device_s *device, __u8 index)
+{
+	int         i, j;
+	int         ret = 0;
+	struct urb  *urb;
+
+	/*dbg("start");*/
+
+	device->channel[index].outStop = 0;
+	for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS; i++) {
+		urb = usb_alloc_urb(DEVICE_NUM_FRAMES_PER_URB, GFP_KERNEL);
+		device->channel[index].isocOutUrb[i] = urb;
+		if (urb) {
+			urb->transfer_buffer = kmalloc(DEVICE_ISOC_LENGTH(
+				device->channel[index].maxPacketSize),
+				GFP_KERNEL);
+			if (!urb->transfer_buffer) {
+				ret = -ENOMEM;
+				err("transfer_buffer allocation failed %d", i);
+				break;
+			} /* if */
+		} /* if */ else {
+			ret = -ENOMEM;
+			err("usb_alloc_urb failed %d", i);
+			break;
+		} /* if */
+	} /* for */
+
+	if (ret) {
+		/* Allocation error, must free already allocated data */
+		for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS; i++) {
+			urb = device->channel[index].isocOutUrb[i];
+			if (urb) {
+				kfree(urb->transfer_buffer);
+				urb->transfer_buffer = NULL;
+				usb_free_urb(urb);
+				device->channel[index].isocOutUrb[i] = NULL;
+			} /* if */
+		} /* for */
+		return ret;
+	} /* if */
+
+	for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS; i++) {
+		urb = device->channel[index].isocOutUrb[i];
+		memset(urb->transfer_buffer, 0, DEVICE_ISOC_LENGTH(
+			device->channel[index].maxPacketSize));
+		for (j = 0;
+			j < DEVICE_ISOC_LENGTH(
+				device->channel[index].maxPacketSize);
+			j += DEVICE_MPEG2_PACKET_SIZE) {
+			memcpy(urb->transfer_buffer+j,
+				nullHeader, sizeof(nullHeader));
+		} /* for */
+		urb->transfer_buffer_length = DEVICE_ISOC_LENGTH(
+			device->channel[index].maxPacketSize);
+		urb->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
+		urb->complete = device_iso_out_complete;
+		urb->context = &device->channel[index];
+		urb->dev = device->usbdev;
+		urb->pipe = usb_sndisocpipe(device->usbdev,
+			DEVICE_TS_OUT_PIPE + index);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->interval = 1;
+		for (j = 0; j < DEVICE_NUM_FRAMES_PER_URB; j++) {
+			urb->iso_frame_desc[j].offset =
+				j * device->channel[index].maxPacketSize;
+			urb->iso_frame_desc[j].length =
+				device->channel[index].maxPacketSize;
+		} /* for */
+	} /* for */
+	device->channel[index].nextFreeOutUrbIndex = DEVICE_NUM_ISOC_OUT_URBS-1;
+	atomic_set(&device->channel[index].numOutUrbs, 1);
+	for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS-1; i++) {
+		ret = usb_submit_urb(
+			device->channel[index].isocOutUrb[i], GFP_KERNEL);
+		if (ret)
+			err("usb_submit_urb failed %d", ret);
+	} /* for */
+
+	/*dbg("end");*/
+	return 0;
+} /* device_start_iso_out */
+
+static void device_stop_iso_out(struct device_s *device, __u8 index)
+{
+	dbg("start");
+
+	device->channel[index].outStop = 1;
+
+	dbg("end");
+} /* device_stop_iso_out */
+
+static void device_tsbulk_complete(struct urb *urb)
+{
+	struct device_s *device = urb->context;
+	__u8 index = 0;
+
+	/*dbg("start");*/
+	if (!urb->status) {
+		if (usb_endpoint_num(&(urb->ep->desc)) != DEVICE_TS_OUT_PIPE)
+			index = 1;
+		device->channel[index].nbByteSend += urb->actual_length;
+	}
+	kfree(urb->transfer_buffer);
+	usb_free_urb(urb);
+	/*dbg("end");*/
+} /* device_tsbulk_complete */
+
+static int device_tsbulk_send(struct device_s *device,
+	__u8 index, __u8 *data, int size)
+{
+	struct urb *urb;
+	/*  int         todo = size;*/
+	int ret = 0;
+
+	dbg("start");
+
+	/* get a free bulk message */
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!urb) {
+		err("alloc urb");
+		return -ENOMEM;
+	} /* if */
+	urb->dev = device->usbdev;
+
+	/* allocate bulk data */
+	urb->transfer_buffer = kmalloc(size, GFP_KERNEL);
+	if (!urb->transfer_buffer) {
+		err("alloc transfer buffer");
+		usb_free_urb(urb);
+		return -ENOMEM;
+	} /* if */
+
+	/* copy data */
+	ret = copy_from_user(urb->transfer_buffer, data, size);
+
+	/* submit bulk */
+	urb->pipe = usb_sndbulkpipe(device->usbdev, DEVICE_TS_OUT_PIPE + index);
+	urb->transfer_buffer_length = size;
+	urb->complete = device_tsbulk_complete;
+	urb->context  = device;
+	/*dbg("Transmit %d bytes\n",urb->transfer_buffer_length);*/
+	/*dbg_dump("txBuf",
+		urb->transfer_buffer, urb->transfer_buffer_length);*/
+	mod_timer(&(device->channel[index].StartBulkReadTimer),
+		usecs_to_jiffies(50));
+
+	if (usb_submit_urb(urb, GFP_KERNEL) < 0) {
+		err("submit urb");
+		kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+		return -ENOMEM;
+	} /* if */
+
+	dbg("end");
+	return 0;
+} /* device_tsbulk_send */
+
+/* ---------------------------------------------------------- */
+static void StartBulkRead_func(unsigned long context)
+{
+	struct bulk_timer_s *bulk_time = (struct bulk_timer_s *) context;
+
+	device_start_tsbulk_in(bulk_time->device, bulk_time->index);
+}
+
+static int device_drv_open(struct device_s *device)
+{
+	int index;
+	mutex_lock(&device->lock);
+
+	if (!device->usbdev) {
+		err("no dev, can not start dev");
+		mutex_unlock(&device->lock);
+		return -ENODEV;
+	}
+
+	if (device->opened) {
+		mutex_unlock(&device->lock);
+		device->opened++;
+		info("udev=%p opened=%d", (device->usbdev), device->opened);
+		return 0;
+	} /* while */
+
+	info("set interface 0");
+	if (usb_set_interface(device->usbdev, 0, 0) < 0) {
+		mutex_unlock(&device->lock);
+		err("set_interface fail");
+		return -EINVAL;
+	} /* if */
+
+	device->opened++;
+	device->askToRelease = 0;
+	mutex_unlock(&device->lock);
+
+	for (index = 0; index < DEVICE_NUM_CAM; index++) {
+		device->channel[index].nbByteSend = -376;
+		device->channel[index].nbByteRead = 0;
+		device->channel[index].FirstTransfer = true;
+		gbulk_timer[index].device = device;
+		gbulk_timer[index].index = index;
+		setup_timer(&device->channel[index].StartBulkReadTimer,
+			StartBulkRead_func,
+			(unsigned long)&(gbulk_timer[index]));
+	}
+#ifdef DEBUG_CONTINUITY
+	init_tab_cc();
+#endif
+	info("udev=%p opened=%d", (device->usbdev), device->opened);
+	return 0;
+}
+
+static int device_ci_unlock_read(struct device_s *device)
+{
+	if (device->opened) {
+		/* release blocking functions */
+		device->askToRelease = 1;
+		wake_up_interruptible(&device->ciBulk.ciData[0].asyncWait);
+		wake_up_interruptible(&device->ciBulk.ciData[1].asyncWait);
+		wake_up_interruptible(&device->channel[0].inWait);
+		wake_up_interruptible(&device->channel[1].inWait);
+	}
+	return 0;
+}
+
+static int device_drv_close(struct device_s *device)
+{
+	int i;
+	mutex_lock(&device->lock);
+	if (device->opened && ((--device->opened) == 0)) {
+		device->askToRelease = 1;
+		device_stop_intr(device);
+		for (i = 0; i < DEVICE_NUM_CAM; i++) {
+			if (device->useIsoc) {
+				device_stop_iso_out(device, i);
+				device_stop_iso_in(device, i);
+			} else
+				device_stop_tsbulk_in(device, i);
+		} /* for */
+		device->opened = 0;
+	} /* if */
+	mutex_unlock(&device->lock);
+	return 0;
+}
+
+static int device_open(struct inode *inode, struct file *file)
+{
+	int       devnum = iminor(inode);
+#ifdef DEBUG
+	int        type = (MINOR(inode->i_rdev) >> 4);
+	int        num = (MINOR(inode->i_rdev) & 0xf);
+#endif
+	int   ret = 0;
+
+	struct device_s *device;
+
+	dbg("start, devnum = %d type = %d num = %d", devnum, type, num);
+
+	if (gdeviceNumber >= DRIVER_MAX_NUMBER) {
+		dbg("only support one device open");
+		return -EINVAL;
+	}
+	device = &gdevice[gdeviceNumber];
+	/*gdeviceNumber++;*/
+
+	ktime_get_ts(&gStart);
+
+	ret = device_drv_open(device);
+	if (ret < 0)
+		return ret;
+
+	file->f_pos = 0;
+	file->private_data = device;
+
+	dbg("end");
+	return nonseekable_open(inode, file);
+} /* device_open */
+
+static int device_release(struct inode *inode, struct file *file)
+{
+	struct device_s *device = (struct device_s *)file->private_data;
+
+	dbg("start");
+	device_drv_close(device);
+	dbg("end");
+	return 0;
+} /* device_release */
+
+int cimax_usb_select_interface(struct device_s *device, unsigned long intf)
+{
+	int          max    =  0;
+	int          mult    =  0;
+	int          ret    =  0;
+
+	info("set interface %ld", intf);
+	if (usb_set_interface(device->usbdev, 0, intf) < 0) {
+		err("set_interface failed interface 0, altSetting %ld", intf);
+		return -EINVAL;
+	} /* if */
+
+	/* check endpoints */
+	/* CI bulk out */
+	if (!usb_endpoint_is_bulk_out(
+			&device->usbdev->ep_out[DEVICE_BULK_OUT_PIPE]->desc)) {
+		err("unexpected endpoint %d", DEVICE_BULK_OUT_PIPE);
+		return -EINVAL;
+	} /* if */
+	device->ciBulk.outMaxPacketSize = DEVICE_BULK_OUT_MAXPACKET;
+	dbg("CI bulk out (endpoint %d), packet size %d", DEVICE_BULK_OUT_PIPE,
+			device->ciBulk.outMaxPacketSize);
+	/* CI int in */
+	if (!usb_endpoint_is_int_in(
+			&device->usbdev->ep_in[DEVICE_INT_IN_PIPE]->desc)) {
+		err("unexpected endpoint %d", DEVICE_INT_IN_PIPE);
+		return -EINVAL;
+	} /* if */
+	device->ciBulk.inMaxPacketSize =
+		device->usbdev->ep_in[DEVICE_INT_IN_PIPE]->desc.wMaxPacketSize;
+	dbg("CI int in (endpoint %d), packet size %d", DEVICE_INT_IN_PIPE,
+			device->ciBulk.inMaxPacketSize);
+	/* TS out */
+	if (device->usbdev->ep_out[DEVICE_TS_OUT_PIPE] == NULL)
+		dbg("no TS endpoint");
+	else {
+		if (usb_endpoint_is_bulk_out(
+			&device->usbdev->ep_out[DEVICE_TS_OUT_PIPE]->desc)) {
+			device->useIsoc = 0;
+			dbg("TS is configured as bulk");
+		} else if (usb_endpoint_is_isoc_out(
+			&device->usbdev->ep_out[DEVICE_TS_OUT_PIPE]->desc)) {
+			device->useIsoc = 1;
+			dbg("TS is configured as isochronous");
+		} else {
+			err("unexpected endpoint %d", DEVICE_TS_OUT_PIPE);
+			return -EINVAL;
+		} /* if */
+		max = device->usbdev->
+			ep_out[DEVICE_TS_OUT_PIPE]->desc.wMaxPacketSize;
+		mult = 1 + ((max >> 11) & 0x03);
+		max &= 0x7ff;
+		device->channel[0].maxPacketSize = max * mult;
+		dbg("TS out (endpoint %d), packet size %d", DEVICE_TS_OUT_PIPE,
+				device->channel[0].maxPacketSize);
+
+		max = device->usbdev->
+			ep_out[DEVICE_TS_OUT_PIPE+1]->desc.wMaxPacketSize;
+		mult = 1 + ((max >> 11) & 0x03);
+		max &= 0x7ff;
+		device->channel[1].maxPacketSize = max * mult;
+		dbg("TS out (endpoint %d), packet size %d",
+				DEVICE_TS_OUT_PIPE + 1,
+				device->channel[1].maxPacketSize);
+	}
+
+	/* start intr urb */
+	if (device->ciBulk.intUrb[0] == NULL) {
+		ret = device_start_intr(device);
+		if (ret < 0) {
+			err("cannot start int urb");
+			return ret;
+		} /* if */
+	} /* if */
+
+	return ret;
+}
+EXPORT_SYMBOL(cimax_usb_select_interface);
+
+static int device_ci_write(struct device_s *device,
+		struct ioctl_data_s *data, int isIoctl)
+{
+	int ret = 0;
+	if (!device)
+		return -ENODEV;
+	ret = device_cibulk_send(device, data, isIoctl);
+	if (ret < 0)
+		return ret;
+	return device_wait_sync_data(device, ret, data, isIoctl);
+}
+
+static int device_ci_write_ioctl(struct device_s *device,
+		struct ioctl_data_s *data)
+{
+	return device_ci_write(device, data, 1);
+}
+
+int cimax_usb_ci_write(struct device_s *device,
+		u8 *txData, int txSize, u8 *rxData, int rxSize)
+{
+	struct ioctl_data_s data;
+	if (!device)
+		return -ENODEV;
+	memset(&data, 0, sizeof(data));
+	data.txData = txData;
+	data.txSize = txSize;
+	data.rxData = rxData;
+	data.rxSize = rxSize;
+	return device_ci_write(device, &data, 0);
+}
+EXPORT_SYMBOL(cimax_usb_ci_write);
+
+int cimax_usb_ci_read_evt(struct device_s *device,
+		int moduleId, u8 *buf, int size)
+{
+	int ret = 0;
+	struct rw_data_s data;
+	if (!device || !device->opened)
+		return -ENODEV;
+	memset(&data, 0, sizeof(data));
+	data.moduleId = moduleId;
+	data.data = buf;
+	data.size = size;
+	ret = device_wait_async_data(device, data.moduleId, &data, 0);
+	if (ret < 0) {
+		err("wait ci read failed");
+		return ret;
+	} /* if */
+	dbg("return CI, moduleId %d, data 0x%p, size %d",
+			data.moduleId, data.data, data.size);
+	return ret;
+}
+EXPORT_SYMBOL(cimax_usb_ci_read_evt);
+
+int cimax_usb_device_open(struct device_s *device)
+{
+	return device_drv_open(device);
+}
+EXPORT_SYMBOL(cimax_usb_device_open);
+
+int cimax_usb_device_unlock_read(struct device_s *device)
+{
+	int ret = 0;
+	if (!device)
+		return 0;
+	mutex_lock(&device->lock);
+	ret = device_ci_unlock_read(device);
+	mutex_unlock(&device->lock);
+	return ret;
+}
+EXPORT_SYMBOL(cimax_usb_device_unlock_read);
+
+int cimax_usb_device_close(struct device_s *device)
+{
+	if (!device)
+		return 0;
+	cimax_usb_device_unlock_read(device);
+	if (cimax_usb_dev_remove)
+		cimax_usb_dev_remove(device, gdeviceNumber);
+	return device_drv_close(device);
+}
+EXPORT_SYMBOL(cimax_usb_device_close);
+
+static long device_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	struct device_s *device = (struct device_s *)file->private_data;
+	int          err    = 0;
+	int          ret    = 0;
+	struct ioctl_data_s data;
+	void         *transfer_buffer = NULL;
+
+	dbg("start");
+
+	/* Don't decode wrong cmds: return ENOTTY (inappropriate ioctl) */
+	if (_IOC_TYPE(cmd) != DEVICE_IOC_MAGIC)
+		return -ENOTTY;
+	if (_IOC_NR(cmd) > DEVICE_IOC_MAXNR)
+		return -ENOTTY;
+
+	/* Verify direction (read/write) */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+	if (err)
+		return -EFAULT;
+
+	if (mutex_lock_interruptible(&device->lock))
+		return -ERESTARTSYS;
+
+	switch (cmd) {
+	case DEVICE_IOC_SELECT_INTF:
+		dbg("DEVICE_IOC_SELECT_INTF start");
+		ret = cimax_usb_select_interface(device, arg);
+		dbg("DEVICE_IOC_SELECT_INTF end");
+		break;
+
+	case DEVICE_IOC_CI_WRITE:
+		dbg("DEVICE_IOC_CI_WRITE start");
+
+		/* send CI message */
+		ret = copy_from_user(&data,
+			(void __user *)arg, sizeof(struct ioctl_data_s));
+		dbg("inMsg, rx 0x%p, rxSize %d, tx 0x%p, txSize %d",
+			data.rxData,
+			data.rxSize,
+			data.txData,
+			data.txSize);
+		ret = device_ci_write_ioctl(device, &data);
+		if (ret < 0)
+			break;
+		ret = copy_to_user((void __user *)arg,
+			&data, sizeof(struct ioctl_data_s));
+
+		dbg("DEVICE_IOC_CI_WRITE end");
+		break;
+
+	case DEVICE_IOC_UNLOCK_READ:
+		dbg("DEVICE_IOC_UNLOCK_READ start");
+
+		ret = device_ci_unlock_read(device);
+
+		dbg("DEVICE_IOC_UNLOCK_READ end");
+		break;
+
+	case DEVICE_IOC_SET_CONFIG:
+		dbg("DEVICE_IOC_SET_CONFIG start");
+
+		/* send CI message */
+		ret = copy_from_user(&data,
+			(void __user *)arg, sizeof(struct ioctl_data_s));
+		dbg("inMsg, rx 0x%p, rxSize %d, tx 0x%p, txSize %d",
+			data.rxData, data.rxSize,
+			data.txData, data.txSize);
+		transfer_buffer = kmalloc(data.txSize, GFP_KERNEL);
+		memcpy(transfer_buffer, data.txData, data.txSize);
+		dbg_dump("New config", transfer_buffer, data.txSize);
+		err = usb_control_msg(device->usbdev,
+			usb_sndctrlpipe(device->usbdev, 0),
+			USB_REQ_SET_DESCRIPTOR,
+			USB_TYPE_STANDARD,
+			(USB_DT_CONFIG << 8),
+			0,
+			transfer_buffer,
+			data.txSize,
+			5000);
+		if (err < 0) {
+			err("set_config failed %d", err);
+			ret = -EINVAL;
+		}
+		kfree(transfer_buffer);
+		dbg("DEVICE_IOC_SET_CONFIG end");
+		break;
+
+	default:
+		ret = -ENOIOCTLCMD;
+		break;
+	} /* switch */
+	mutex_unlock(&device->lock);
+
+	dbg("end, ret %d", ret);
+	return ret;
+} /* device_ioctl */
+
+static ssize_t device_write(struct file *file, const char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	int       ret;
+	struct rw_data_s data;
+	struct device_s *device = (struct device_s *)file->private_data;
+
+	dbg("start");
+
+	/* get transmission buffer */
+	ret = copy_from_user(&data, buf, sizeof(struct rw_data_s));
+	dbg("txBuffer, moduleId %u, data 0x%p, size %d",
+			data.moduleId, data.data, data.size);
+	if (data.moduleId >= DEVICE_NUM_CAM) {
+		err("bad moduleId");
+		return 0;
+	}
+
+	if (device->useIsoc) {
+		if (!data.size || (data.size % DEVICE_ISOC_LENGTH(
+			device->channel[data.moduleId].maxPacketSize))) {
+			err("transmission buffer size must be a multiple of %d",
+				DEVICE_ISOC_LENGTH(
+				device->channel[data.moduleId].maxPacketSize));
+			return -EINVAL;
+		} /* if */
+	}
+
+	if (device->useIsoc) {
+		if (device->channel[data.moduleId].isocInUrb[0] == NULL) {
+			ret = device_start_iso_in(device, data.moduleId);
+			if (ret < 0)
+				return ret;
+		} /* if */
+
+		if (device->channel[data.moduleId].isocOutUrb[0] == NULL) {
+			ret = device_start_iso_out(device, data.moduleId);
+			if (ret < 0)
+				return ret;
+		} /* if */
+
+		dbg("call device_tsiso_send moduleId %d, data 0x%p, size %d",
+			data.moduleId, data.data, data.size);
+		ret = device_tsiso_send(device,
+			data.moduleId, data.data, data.size);
+	} /* if */
+	else {
+		ret = device_tsbulk_send(device,
+			data.moduleId, data.data, data.size);
+	} /* else */
+
+	dbg("end, moduleId %d return %d", data.moduleId, ret);
+	return ret;
+} /* device_write */
+
+static ssize_t device_read(struct file *file, char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	int       res;
+	struct rw_data_s data;
+	struct device_s *device = (struct device_s *)file->private_data;
+
+	dbg("start");
+
+	if (count != sizeof(struct rw_data_s)) {
+		err("try to read uncorrect size %zd", count);
+		return -EFAULT;
+	} /* if */
+	res = copy_from_user(&data, buf, sizeof(struct rw_data_s));
+	data.copiedSize = 0;
+	if (data.type == DEVICE_TYPE_TS_READ) {
+		res = device_fill_ts(device, data.moduleId, &data);
+		if (res < 0) {
+			err("fill ts buffer failed");
+			return res;
+		} /* if */
+		dbg("return TS, moduleId %d, data 0x%p, size %d, copiedSize %d",
+			data.moduleId, data.data, data.size, data.copiedSize);
+		/*res = count;*/
+		res = data.copiedSize;
+	} /* if */
+	else if (data.type == DEVICE_TYPE_CI_READ) {
+		res = device_wait_async_data(device, data.moduleId, &data, 1);
+		if (res < 0) {
+			err("wait ci read failed");
+			return res;
+		} /* if */
+		dbg("return CI, moduleId %d, data 0x%p, size %d",
+				data.moduleId, data.data, data.size);
+		res = data.size;
+	} /* else if */
+	else {
+		err("unknown data type %d", data.type);
+		res = -EFAULT;
+	} /* else */
+
+	dbg("end, return %d", res);
+	return res;
+} /* device_read */
+
+/******************************************************************************
+ * @brief
+ *   write data on Control endpoint.
+ *
+
+ * @param   dev
+ *   Pointer to usb device.
+ *
+ * @param   addr
+
+ *   register address to write.
+ *
+ * @param   data
+ *   data to write.
+ *
+
+ * @param   size
+ *   size to write.
+ *
+ * @return
+
+ *   data writen or ENODEV error
+ ******************************************************************************/
+int write_ctrl_message(struct usb_device *dev, int addr, void *data, int size)
+{
+	int ret;
+	void *ptr = NULL;
+#ifdef DEBUG
+	/*   int i;*/
+	/*   unsigned char dump[500];*/
+#endif
+
+	/*   info("%s: . addr = %04x size=%d",DRIVER_NAME,addr,size);*/
+
+	if (size <= 0)
+		return 0;
+
+	ptr = kmemdup(data, size, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	ret = usb_control_msg
+			(dev, usb_sndctrlpipe(dev, 0), 0xA0, 0x40, addr, 0x0001,
+			ptr, size, 300);
+	if (ret != size) {
+		err("Failed to write CIMaX+ register 0x%04x", addr);
+		ret = -ENODEV;
+	}
+
+#ifdef DEBUG
+	/*   dump[0] =0;
+		 for(i=0;i<size;i++) {
+		 if((i !=0) && ((i%16) == 0)) {
+		 dbg("cimax+usb: %s",dump);
+		 dump[0] =0;
+		 }
+		 sprintf(dump,"%s%02x ",dump,((unsigned char *)ptr)[i]);
+		 }
+		 dbg("cimax+usb: %s",dump);
+	 */
+#endif
+	kfree(ptr);
+
+	return ret;
+}
+
+/******************************************************************************
+ * @brief
+ *   read data from Control endpoint.
+ *
+
+ * @param   dev
+ *   Pointer to usb device.
+ *
+ * @param   addr
+ *   firmware address to read.
+
+ *
+ * @param   data
+ *   pointer to buffer to fill with register data.
+ *
+
+ * @param   size
+ *   size to read.
+ *
+ * @return
+ *   data writen or ENODEV error
+
+ ******************************************************************************/
+int read_ctrl_message(struct usb_device *dev, int addr, void *data, int size)
+{
+	int ret;
+	ret = usb_control_msg
+			(dev, usb_rcvctrlpipe(dev, 0), 0xA0, 0xC0, addr, 0x0001,
+			(void *)data, size, 300);
+	if (ret != size) {
+		err("Failed to read CIMaX+ register 0x%04x return %d",
+			addr, ret);
+		ret = -ENODEV;
+	}
+	return ret;
+}
+
+/******************************************************************************
+ * @brief
+ *   Start new Firmware.
+ *
+ * @param   dev
+ *   Pointer to usb device.
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+int init_fw(struct usb_device *dev)
+{
+	int len;
+	char *bootStatus = NULL;
+	bootStatus = kmalloc(sizeof(char), GFP_KERNEL);
+	if (!bootStatus) {
+		pr_err("%s: init_fw kmalloc failed\n",
+				DRIVER_NAME);
+		return 0;
+	}
+
+	info("%s: .", DRIVER_NAME);
+	len = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+		0xA0, 0xC0, 0x0000, 0x0000, bootStatus, 1, 100);
+	if (len == 1) {
+		info("--> Init Status = %02X", *bootStatus);
+		if (bootStatus)
+			kfree(bootStatus);
+		return 0;
+	}
+	if (bootStatus)
+		kfree(bootStatus);
+
+	return len;
+}
+
+/******************************************************************************
+ * @brief
+ *   Start new Firmware.
+ *
+ * @param   dev
+ *   Pointer to usb device.
+
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+int write_ep6_message(struct usb_device *dev, void *data, int size)
+{
+	int ret;
+	void * ptr = NULL;
+	ptr = kmemdup(data, size, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	if (usb_bulk_msg(dev, usb_sndbulkpipe(dev, 6),
+			ptr, size, &ret, 200) < 0) {
+		err("Failed to write cmd 0x%02x", ((unsigned char *)data)[0]);
+		ret = -ENODEV;
+	}
+	kfree(ptr);
+	return ret;
+}
+
+/******************************************************************************
+ * @brief
+ *   Start new Firmware.
+ *
+ * @param   dev
+ *   Pointer to usb device.
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+int read_ep5_message(struct usb_device *dev, void *data, int size)
+{
+	int ret;
+
+	if (usb_interrupt_msg(dev, usb_rcvintpipe(dev, 5),
+			data, size, &ret, 200) < 0) {
+		err("Failed read interrupt endpoint");
+		ret = -ENODEV;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long device_compat_ioctl(struct file *filp,
+		unsigned int cmd, unsigned long args)
+{
+	unsigned long ret;
+
+	args = (unsigned long)compat_ptr(args);
+	ret = device_ioctl(filp, cmd, args);
+	return ret;
+}
+#endif
+
+static const struct file_operations device_fops = {
+	.owner   = THIS_MODULE,
+	.open    = device_open,
+	.release = device_release,
+	.unlocked_ioctl = device_ioctl,
+	.write   = device_write,
+	.read    = device_read,
+	/*
+	.poll    = device_poll,
+	*/
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = device_compat_ioctl,
+#endif
+};
+
+struct cimaxusb_priv_ops_t cimaxusb_priv_ops = {
+	.write_ctrl_message  = write_ctrl_message,
+	.read_ctrl_message   = read_ctrl_message,
+	.init_fw             = init_fw,
+	.write_ep6_message   = write_ep6_message,
+	.read_ep5_message    = read_ep5_message
+};
+
+static struct usb_class_driver device_class = {
+	.name = "cimaxusb%d",
+	.fops = &device_fops,
+	.minor_base = DEVICE_MINOR,
+};
+
+/* ---------------------------------------------------------- */
+
+
+void cimax_usb_set_cb(void *cb1, void *cb2)
+{
+	cimax_usb_dev_add = cb1;
+	cimax_usb_dev_remove = cb2;
+}
+EXPORT_SYMBOL(cimax_usb_set_cb);
+
+static int device_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	struct usb_device *usbdev = interface_to_usbdev(intf);
+	struct device_s *device;
+	char cmd[] = { 0x0C, 0x01, 0x00, 0x00 };
+	char *rsp;
+
+	dbg("start vendor id 0x%x, product id 0x%x, Device id 0x%x minor 0x%x",
+			le16_to_cpu(usbdev->descriptor.idVendor),
+			le16_to_cpu(usbdev->descriptor.idProduct),
+			le16_to_cpu(usbdev->descriptor.bcdDevice),
+			intf->minor);
+
+	/*  device = &gdevice[intf->minor];*/
+	device = &gdevice[gdeviceNumber];
+
+	mutex_lock(&device->lock);
+	/*  device->usbdev = usbdev;*/
+	device->usbdev = usb_get_dev(usbdev);
+	dbg("device->usbdev 0x%p", (device->usbdev));
+
+	/* set private callback functions */
+	device->ops = &cimaxusb_priv_ops;
+
+	device->askToSuspend = 0;
+
+	usb_set_intfdata(intf, device);
+	mutex_unlock(&device->lock);
+
+	if (usb_register_dev(intf, &device_class)) {
+		err("usb_register_dev");
+		usb_set_intfdata(intf, NULL);
+		return -ENOMEM;
+	} /* if */
+
+	/* test if firmware loafing is needed */
+#ifdef FRBIT
+	if ((le16_to_cpu(usbdev->descriptor.bcdDevice) != 0) &&
+			(CimaxDwnl == 1)) {
+#else
+	if (le16_to_cpu(usbdev->descriptor.bcdDevice) != 0) {
+#endif
+		info("start firmware download");
+		/* load firmware*/
+		cimaxusb_fw_upload(device);
+		info("end firmware download");
+	} else {
+		info("set alternate setting 1");
+		if (usb_set_interface(device->usbdev, 0, 1) < 0) {
+			err("set_interface failed intf 0, alt 1");
+		} else {
+			info("check FW version");
+			/* Get BOOT version */
+			if (write_ep6_message(device->usbdev,
+				cmd, sizeof(cmd)) == sizeof(cmd)) {
+				rsp = kcalloc(256,
+					sizeof(unsigned char),
+					GFP_KERNEL);
+				if (!rsp) {
+					err("out of memory");
+					return -ENOMEM;
+				}
+				if (read_ep5_message(device->usbdev,
+						rsp, 256) >= 0) {
+					info("=> ---- F.W. Version -------");
+					info("=>= %02X.%02X.%02X.%02X.%02X%c",
+						rsp[4], rsp[5], rsp[6],
+						rsp[7], rsp[8], rsp[9]);
+					info("=> Boot Version = %d.%d",
+						rsp[10], rsp[11]);
+					info("=> --------------------");
+				}
+				kfree(rsp);
+			}
+		}
+		info("start cfg download");
+		if (cimaxusb_configuration_setting(device) < 0)
+			err(" Error : set CIMaX+ configuration");
+		info("end cfg download");
+
+		if (cimax_usb_dev_add)
+			cimax_usb_dev_add(device, gdeviceNumber);
+	}
+
+	dbg("end");
+	return 0;
+} /* device_probe */
+
+static void device_disconnect(struct usb_interface *intf)
+{
+	struct device_s *device = usb_get_intfdata(intf);
+	int       i;
+
+	dbg("start");
+
+	if (!device)
+		return;
+
+	mutex_lock(&device->lock);
+	if (device->opened) {
+		/* release blocking functions */
+		device->askToRelease = 1;
+		wake_up_interruptible(&device->ciBulk.ciData[0].asyncWait);
+		wake_up_interruptible(&device->ciBulk.ciData[1].asyncWait);
+		wake_up_interruptible(&device->channel[0].inWait);
+		wake_up_interruptible(&device->channel[1].inWait);
+		device_stop_intr(device);
+		for (i = 0; i < DEVICE_NUM_CAM; i++) {
+			if (device->useIsoc) {
+				device_stop_iso_out(device, i);
+				device_stop_iso_in(device, i);
+			} /* if */
+			else
+				device_stop_tsbulk_in(device, i);
+		} /* for */
+		device->opened = 0;
+
+		if (cimax_usb_dev_remove)
+			cimax_usb_dev_remove(device, gdeviceNumber);
+	} /* if */
+	mutex_unlock(&device->lock);
+	usb_set_intfdata(intf, NULL);
+	if (device) {
+		usb_deregister_dev(intf, &device_class);
+		device->usbdev = NULL;
+	} /* if */
+	dbg("end");
+} /* device_disconnect */
+
+static int cimaxusb_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct device_s *device = usb_get_intfdata(intf);
+	int       i;
+
+	dbg("start");
+
+	if (!device)
+		return 0;
+
+	mutex_lock(&device->lock);
+	if (device->opened) {
+		/* release blocking functions */
+		device->askToSuspend = 1;
+		wake_up_interruptible(&device->ciBulk.ciData[0].asyncWait);
+		wake_up_interruptible(&device->ciBulk.ciData[1].asyncWait);
+		wake_up_interruptible(&device->channel[0].inWait);
+		wake_up_interruptible(&device->channel[1].inWait);
+		device_stop_intr(device);
+		for (i = 0; i < DEVICE_NUM_CAM; i++) {
+			if (device->useIsoc) {
+				device_stop_iso_out(device, i);
+				device_stop_iso_in(device, i);
+			} /* if */
+			else
+				device_stop_tsbulk_in(device, i);
+		} /* for */
+		device->opened = 0;
+	} /* if */
+	mutex_unlock(&device->lock);
+	dbg("end");
+
+	return 0;
+}
+
+static int cimaxusb_resume(struct usb_interface *intf)
+{
+	struct device_s *device = usb_get_intfdata(intf);
+
+	dbg("start");
+
+	if (!device)
+		return 0;
+
+	device->askToSuspend = 0;
+	dbg("end");
+	return 0;
+}
+
+static struct usb_device_id device_ids[] = {
+	{ USB_DEVICE(0x1b0d, 0x2f00) },
+	{ USB_DEVICE(0x1b0d, 0x2f01) },
+	{ USB_DEVICE(0x1b0d, 0x2f02) },
+	{ USB_DEVICE(0x1b0d, 0x2f03) },
+	{ USB_DEVICE(0x1b0d, 0x2f04) },
+	{ }           /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, device_ids);
+
+
+static struct usb_driver device_driver = {
+	.name = "cimaxusb",
+	.probe = device_probe,
+	.disconnect = device_disconnect,
+	.suspend =  cimaxusb_suspend,
+	.resume = cimaxusb_resume,
+	.id_table = device_ids,
+};
+
+/* ---------------------------------------------------------- */
+
+static int device_init_module(void)
+{
+	int ret = 0;
+	int i, j;
+	struct device_s *device;
+
+	info("start");
+
+	if (!gdevice)
+		gdevice = kcalloc(DRIVER_MAX_NUMBER,
+			sizeof(struct device_s), GFP_KERNEL);
+	if (!gdevice) {
+		err("not enough memory");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < DRIVER_MAX_NUMBER; i++) {
+		device = &gdevice[i];
+		/* initialize struct */
+		memset(device, 0, sizeof(struct device_s));
+		mutex_init(&device->lock);
+
+		/* initialize ci bulk struct */
+		device->ciBulk.counter = 1;
+		spin_lock_init(&device->ciBulk.intLock);
+		spin_lock_init(&device->ciBulk.intUrbLock);
+		for (j = 0; j < DEVICE_NUM_CAM; j++) {
+			init_waitqueue_head(&device->ciBulk.ciData[j].syncWait);
+			init_waitqueue_head(
+				&device->ciBulk.ciData[j].asyncWait);
+			INIT_LIST_HEAD(&device->ciBulk.ciData[j].asyncDataList);
+		} /* for */
+
+		/* initialize channels */
+		for (j = 0; j < DEVICE_NUM_CAM; j++) {
+			spin_lock_init(&device->channel[j].inLock);
+			init_waitqueue_head(&device->channel[j].inWait);
+			vb_init(&device->channel[j].inVb);
+			device->channel[j].syncOffset = -1;
+			spin_lock_init(&device->channel[j].outLock);
+		} /* for */
+	} /* for */
+
+	/* register misc device */
+	ret = usb_register(&device_driver);
+
+#ifdef TIMESTAMP
+	InitTimestamp();
+#endif
+
+	if (ret)
+		info("end driver register failed");
+	else
+		info("end driver registered");
+
+	info(DRIVER_VERSION ":" DRIVER_DESC);
+
+	return ret;
+} /* device_init_module */
+
+static void device_exit_module(void)
+{
+	int i;
+	struct device_s *device;
+
+	info("start");
+
+#ifdef TIMESTAMP
+	ShowTimestamp();
+#endif
+
+	for (i = 0; i < DRIVER_MAX_NUMBER; i++) {
+		device = &gdevice[i];
+		device->askToRelease = 1;
+		/* destroy struct */
+		mutex_destroy(&device->lock);
+	} /* for */
+	usb_deregister(&device_driver);
+	gdeviceNumber = 0;
+
+	kfree(gdevice);
+	gdevice = NULL;
+	info("end");
+} /* device_exit_module */
+
+module_init(device_init_module);
+module_exit(device_exit_module);
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb-driver.h b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb-driver.h
new file mode 100644
index 0000000..e4656e0
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb-driver.h
@@ -0,0 +1,362 @@
+/**************************************************************************//**
+ * @file    cimax+usb-driver.h
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+
+#ifndef CIMAXPLUS_USB_DRIVER_H
+#define CIMAXPLUS_USB_DRIVER_H
+
+/******************************************************************************
+ * Includes
+ *****************************************************************************/
+/******************************************************************************
+ * Defines
+ *****************************************************************************/
+/**
+ *  @brief
+ *    Driver Name
+ */
+#define DRIVER_NAME        "cimax+usb"
+/**
+ *  @brief
+ *    An unassigned USB minor.
+ */
+#define DEVICE_MINOR                          240
+
+/**
+ *  @brief
+ *    Driver version.
+ */
+#define DEVICE_VERSION                     0x1000
+
+/**
+ *  @brief
+ *    Number of CA module supported by the driver.
+ */
+#define DEVICE_NUM_CAM                          2
+
+/**
+ *  @brief
+ *    Buffer length.
+ */
+#define DEVICE_MESSAGE_LENGTH                4100
+
+/* Offset */
+#define DEVICE_COMMAND_OFFSET                   0
+#define DEVICE_STATUS_OFFSET                    0
+#define DEVICE_COUNTER_OFFSET                   1
+#define DEVICE_LENGTH_MSB_OFFSET                2
+#define DEVICE_LENGTH_LSB_OFFSET                3
+#define DEVICE_DATA_OFFSET                      4
+
+/* Mask */
+#define DEVICE_SEL_MASK                      0x80
+#define DEVICE_TYP_MASK                      0x40
+#define DEVICE_CMD_MASK                      0x3F
+
+/* Command tag */
+#define DEVICE_CMD_INIT                      0x00
+#define DEVICE_CMD_WRITE_REG                 0x7F
+#define DEVICE_CMD_READ_REG                  0xFF
+#define DEVICE_CMD_CAMRESET                  0x01
+#define DEVICE_CMD_GETCIS                    0x02
+#define DEVICE_CMD_WRITECOR                  0x03
+#define DEVICE_CMD_NEGOTIATE                 0x04
+#define DEVICE_CMD_WRITELPDU                 0x05
+#define DEVICE_CMD_READLPDU                  0x06
+#define DEVICE_CMD_WRITEEXT                  0x07
+#define DEVICE_CMD_READEXT                   0x08
+#define DEVICE_CMD_CC1RESET                  0x09
+#define DEVICE_CMD_MCARD_WRITE               0x0a
+
+/* Status field */
+#define DEVICE_CAMRESETOK                    0x00
+#define DEVICE_CISOK                         0x01
+#define DEVICE_WRITECOROK                    0x02
+#define DEVICE_NEGOTIATEOK                   0x03
+#define DEVICE_WRITELPDUOK                   0x04
+#define DEVICE_CAMDET                        0x05
+#define DEVICE_READLPDUOK                    0x06
+#define DEVICE_WRITEEXTOK                    0x07
+#define DEVICE_READEXTOK                     0x08
+#define DEVICE_NO_CAM                        0x09
+#define DEVICE_NOK                           0x0a
+#define DEVICE_INITOK                        0x0b
+#define DEVICE_READ_REGOK                    0x0c
+#define DEVICE_WRITE_REGOK                   0x0d
+#define DEVICE_DATAREADY                     0x0e
+#define DEVICE_MCARD_WRITEOK                 0x0f
+#define DEVICE_MCARD_READ                    0x10
+#define DEVICE_CAMPARSE_ERROR                0x11
+#define DEVICE_WRITELPDUBUSY                 0x14
+#define DEVICE_CMDPENDING                    0x16
+#define DEVICE_REGSTATUSOK                   0x17
+#define DEVICE_GPIOCHANGE                    0x18
+#define DEVICE_FRBit                         0x1A
+
+
+#define DEVICE_DATAREADY_SYNC                0x3e
+
+/**
+ *  @brief
+ *    MPEG2 transport size,.isochronous size and number of frames per URB.
+ */
+#define DEVICE_MPEG2_PACKET_SIZE             188
+#define DEVICE_MPEG2_SYNC_BYTE               0x47
+#define DEVICE_NULL_HEADER_SIZE              8
+#define DEVICE_NUM_FRAMES_PER_URB            8
+#define DEVICE_ISOC_LENGTH(x)                (DEVICE_NUM_FRAMES_PER_URB*x)
+#define DEVICE_VB_LENGTH                     902400
+
+/**
+ *  @brief
+ *    Endpoint address.
+ */
+#define DEVICE_TS_IN_PIPE                      1 /* and 2 */
+#define DEVICE_TS_OUT_PIPE                     3 /* and 4 */
+#define DEVICE_INT_IN_PIPE                     5
+#define DEVICE_BULK_OUT_PIPE                   6
+#define DEVICE_BULK_OUT_MAXPACKET            256
+
+/**
+ *  @brief
+ *    Number of isochronous/int URBs in the driver.
+ */
+#define DEVICE_NUM_ISOC_OUT_URBS                3
+#define DEVICE_NUM_ISOC_IN_URBS                 2
+#define DEVICE_NUM_INT_IN_URBS                  2
+
+/**
+ *  @brief
+ *    ioctl() calls definition.
+ */
+#define DEVICE_IOC_MAGIC        'a'
+#define DEVICE_IOC_SELECT_INTF  _IOWR(DEVICE_IOC_MAGIC,  0, signed long)
+#define DEVICE_IOC_CI_WRITE     _IOWR(DEVICE_IOC_MAGIC,  1, struct ioctl_data_s)
+#define DEVICE_IOC_UNLOCK_READ  _IOWR(DEVICE_IOC_MAGIC,  2, signed long)
+#define DEVICE_IOC_SET_CONFIG   _IOWR(DEVICE_IOC_MAGIC,  3, struct ioctl_data_s)
+#define DEVICE_IOC_MAXNR        4
+
+/******************************************************************************
+ * Types
+ *****************************************************************************/
+#ifdef __KERNEL__
+#include <linux/list.h>
+#include <linux/atomic.h>
+#include <linux/printk.h>
+
+#undef dbg
+#undef dbg_isoc_in
+#undef dbg_isoc_out
+
+#undef err
+#undef info
+#undef warn
+
+#define DEBUG
+
+#ifdef DEBUG
+#define dbg(format, arg...) pr_debug("cimax+usb: %s> " format "\n" , \
+		__func__, ## arg)
+#define dbg_s(format, arg...)\
+	pr_debug("cimax+usb: " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#define dbg_s(format, arg...) do {} while (0)
+#endif
+
+#ifdef DEBUG_ISOC_IN
+#define dbg_isoc_in(format, arg...)\
+	pr_debug("cimax+usb: %s> " format "\n" , \
+			__func__, ## arg)
+#else
+#define dbg_isoc_in(format, arg...) do {} while (0)
+#endif
+
+#ifdef DEBUG_ISOC_OUT
+#define dbg_isoc_out(format, arg...)\
+	pr_debug("cimax+usb: %s> " format "\n" , \
+			__func__, ## arg)
+#else
+#define dbg_isoc_out(format, arg...) do {} while (0)
+#endif
+
+#define err(format, arg...)\
+	pr_err("cimax+usb: %s> ERROR " format "\n" , \
+			__func__, ## arg)
+#define info(format, arg...)\
+	pr_info("cimax+usb: %s> " format "\n" , \
+			__func__, ## arg)
+#define warn(format, arg...)\
+	pr_warn("cimax+usb: %s> WARN" format "\n" , \
+			__func__, ## arg)
+
+/**
+ *  @brief
+ *    Video buffer structure.
+ */
+struct video_buf_s {
+	__u8 data[DEVICE_VB_LENGTH];
+	int  readOffset;
+	int  writeOffset;
+	int  isEmpty;
+};
+#endif
+
+/**
+ *  @brief
+ *    Io control data structure exchanged between user and kernel space.
+ */
+struct ioctl_data_s {
+	__u8  *txData;
+	__u32 txSize;
+	__u8  *rxData;
+	__u32 rxSize;
+};
+
+/**
+ *  @brief
+ *    Read/write type exchanged between user and kernel space.
+ */
+enum rw_type_e {
+	DEVICE_TYPE_CI_READ,
+	DEVICE_TYPE_TS_WRITE,
+	DEVICE_TYPE_TS_READ
+};
+
+/**
+ *  @brief
+ *    Read/write data structure exchanged between user and kernel space.
+ */
+struct rw_data_s {
+	enum rw_type_e type;
+	__u8      moduleId;
+	__u8      *data;
+	__u32     size;
+	__u32     copiedSize;
+};
+#ifdef __KERNEL__
+/**
+ *  @brief
+ *    Message node structure. Can be inserted in a list.
+ */
+struct message_node_s {
+	__u8              data[DEVICE_MESSAGE_LENGTH];
+	__u32             size;
+	struct list_head  node;
+};
+
+/**
+ *  @brief
+ *    Received CI data.
+ */
+struct ci_rx_data_s {
+	wait_queue_head_t  syncWait;
+	__u8               syncSignal;
+	__u8               syncData[DEVICE_MESSAGE_LENGTH];
+	__u32              syncDataSize;
+	wait_queue_head_t  asyncWait;
+	struct list_head   asyncDataList;
+	__u8               bPendingSend;
+};
+
+/**
+ *  @brief
+ *    CI bulk channel.
+ */
+struct ci_bulk_s {
+	__u8               counter;
+	__u16              inMaxPacketSize;
+	__u16              outMaxPacketSize;
+	struct urb         *intUrb[DEVICE_NUM_INT_IN_URBS];
+	spinlock_t         intLock;
+	spinlock_t         intUrbLock;
+	__u8               intCurrStatus;
+	__u8               intCurrIndex;
+	__u16              intSizeToReceive;
+	struct ci_rx_data_s       ciData[DEVICE_NUM_CAM];
+};
+
+/**
+ *  @brief
+ *    TS channel (can use isoc or bulk interface).
+ */
+struct ts_channel_s {
+	spinlock_t        inLock;
+	wait_queue_head_t inWait;
+	struct video_buf_s       inVb;
+	int               syncOffset;
+	int               prevOffset;
+	__u8              lastPacket[DEVICE_MPEG2_PACKET_SIZE];
+	__u8              lastPacketSize;
+	spinlock_t        outLock;
+	__u8              nextFreeOutUrbIndex;
+	atomic_t          numOutUrbs;
+	__u8              outStop;
+	__u16             maxPacketSize;
+	/* isochronous urbs */
+	struct urb        *isocInUrb[DEVICE_NUM_ISOC_IN_URBS];
+	struct urb        *isocOutUrb[DEVICE_NUM_ISOC_OUT_URBS];
+	/* bulk urbs */
+	struct urb       *bulkInUrb;
+	int              nbByteSend;
+	int              nbByteRead;
+	__u8             FirstTransfer;
+	struct timer_list StartBulkReadTimer;
+
+#ifdef DEBUG_BITRATE
+	ktime_t bitrateTime
+#endif
+};
+
+struct device_s {
+	struct mutex       lock;
+	struct usb_device  *usbdev;
+	__u8               opened;
+	__u8               askToRelease;
+	__u8               askToSuspend;
+	struct ci_bulk_s          ciBulk;
+	__u8               useIsoc;
+	struct ts_channel_s       channel[DEVICE_NUM_CAM];
+	/* bus adapter private ops callback */
+	struct cimaxusb_priv_ops_t *ops;
+	int                ref;
+};
+
+struct bulk_timer_s {
+	struct device_s *device;
+	__u8      index;
+};
+
+int cimax_usb_select_interface(struct device_s *device, unsigned long intf);
+int cimax_usb_ci_write(struct device_s *device,
+		u8 *txData, int txSize, u8 *rxData, int rxSize);
+int cimax_usb_ci_read_evt(struct device_s *device,
+		int moduleId, u8 *buf, int size);
+
+int cimax_usb_device_unlock_read(struct device_s *device);
+int cimax_usb_device_open(struct device_s *device);
+int cimax_usb_device_close(struct device_s *device);
+void cimax_usb_set_cb(void *cb1, void *cb2);
+
+
+#endif
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_config.c b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_config.c
new file mode 100644
index 0000000..4469b87
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_config.c
@@ -0,0 +1,684 @@
+/**************************************************************************//**
+ * @file    cimax+usb_config.c
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ ******************************************************************************/
+/******************************************************************************
+ * Include
+ ******************************************************************************/
+
+
+#include <linux/slab.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/usb.h>
+
+#include <linux/errno.h>
+#include <linux/firmware.h>
+
+#include <linux/uaccess.h>
+#include <linux/mutex.h>
+
+#include "cimax+usb-driver.h"
+#include "cimax+usb_config.h"
+#include "bodydef.h"
+
+#include <linux/ctype.h>
+
+#define DEBUG
+#include <linux/printk.h>
+
+/******************************************************************************
+ * Structures
+ ******************************************************************************/
+/******************************************************************************
+ * Globals
+ ******************************************************************************/
+char *cimax_config_file[4] = {
+	"cimax+usb.cfg",
+	"cimax+usb_vcc0.cfg",
+	"cimax+usb_vcc3.cfg",
+	"cimax+usb_vcc5.cfg"
+};
+
+/******************************************************************************
+ * Functions
+ ******************************************************************************/
+/******************************************************************************
+ * @brief
+ *   set CIMaX+ register value.
+ *
+ * @param   bus_adap
+ *   Pointer to CIMaX+ usb adapter.
+ *
+ * @param   addr
+ *   Addr of CIMaX+ register.
+ *
+ * @param   val
+ *   CIMaX+ register value to set.
+ *
+ * @return
+ *   0 if OK otherwise -1.
+ ******************************************************************************/
+int usb_setbyte(struct device_s *bus_adap, unsigned int addr, unsigned char val)
+{
+	unsigned char cmd[5];
+	unsigned char *buf;
+	int len;
+	struct usb_device *dev = bus_adap->usbdev;
+
+	cmd[0] = 0x7F;
+	cmd[1] = (unsigned char)((addr>>8)&0xff);
+	cmd[2] = (unsigned char)(addr&0xff);
+	cmd[3] = 0x01;
+	cmd[4] = val;
+	if (bus_adap->ops->write_ep6_message(dev, cmd, sizeof(cmd))
+		== sizeof(cmd)) {
+		/*pr_debug("%s-%s: cmd=0x%x\n",
+			DRIVER_NAME, __func__,cmd[0]);*/
+		buf = kcalloc(256, sizeof(unsigned char), GFP_KERNEL);
+		if (!buf) {
+			pr_err("%s-%s: out of memory.\n",
+				DRIVER_NAME, __func__);
+			return -ENOMEM;
+		}
+
+		while ((len = bus_adap->ops->read_ep5_message(dev, buf, 256))
+				>= 0) {
+			if (len == 0)
+				continue;
+			if ((len == 5) && ((buf[0] & 0x7f) == 0x45))
+				continue;
+			if (len < 4) {
+				pr_err("%s-%s: failed to read addr 0x%x\n",
+					DRIVER_NAME, __func__, addr);
+				kfree(buf);
+				return -1;
+			} else {
+				break;
+			}
+		}
+	} else {
+		pr_err("%s-%s: failed to write addr 0x%x\n",
+			DRIVER_NAME, __func__, addr);
+		return -1;
+	}
+	kfree(buf);
+	return 0;
+}
+
+/******************************************************************************
+ * @brief
+ *   get CIMaX+ register value.
+ *
+ * @param   bus_adap
+ *   Pointer to CIMaX+ usb adapter.
+ *
+ * @param   addr
+ *   Addr of CIMaX+ register.
+ *
+ * @param   val
+ *   pointer to buffer to store CIMaX+ register value.
+ *
+ * @return
+ *   0 if OK otherwise -1.
+ ******************************************************************************/
+int usb_getbyte(struct device_s *bus_adap,
+	unsigned int addr, unsigned char *val)
+{
+	unsigned char cmd[4];
+	unsigned char *buf;
+	int len;
+	struct usb_device *dev = bus_adap->usbdev;
+
+	cmd[0] = 0xFF;
+	cmd[1] = (unsigned char)((addr>>8)&0xff);
+	cmd[2] = (unsigned char)(addr&0xff);
+	cmd[3] = 0x01;
+	if (bus_adap->ops->write_ep6_message(dev, cmd, sizeof(cmd))
+			== sizeof(cmd)) {
+		/*pr_debug("%s-%s: cmd=0x%x\n",
+			DRIVER_NAME, __func__,cmd[0]);*/
+		buf = kcalloc(256, sizeof(unsigned char), GFP_KERNEL);
+		if (!buf) {
+			pr_err("%s-%s: out of memory.\n",
+				DRIVER_NAME, __func__);
+			return -ENOMEM;
+		}
+
+		while ((len = bus_adap->ops->read_ep5_message(dev, buf, 256))
+				>= 0) {
+			if (len == 0)
+				continue;
+			/*pr_debug("%s-%s: 0x%x\n",
+				DRIVER_NAME, __func__,buf[0]);*/
+			if ((len == 5) && ((buf[0] & 0x7f) == 0x45))
+				continue;
+			if (len >= 5) {
+				*val = buf[4];
+				break;
+			} else {
+				pr_err("%s-%s: failed to read addr 0x%x\n",
+					DRIVER_NAME, __func__, addr);
+				kfree(buf);
+				return -1;
+			}
+		}
+	} else {
+		pr_err("%s-%s: failed to read addr 0x%x\n",
+			DRIVER_NAME, __func__, addr);
+		return -1;
+	}
+	kfree(buf);
+	return 0;
+}
+
+/******************************************************************************
+ * @brief
+ *   compute a logical Or between CIMaX+ register value and a param value.
+ *
+ * @param   bus_adap
+ *   Pointer to CIMaX+ usb adapter.
+ *
+ * @param   addr
+ *   Addr of CIMaX+ register.
+ *
+ * @param   val
+ *   value to compute.
+ *
+ * @param   pval
+ *   pointer to buffer to store CIMaX+ register value.
+ *
+ * @return
+ *   0 if OK otherwise -1.
+ ******************************************************************************/
+int setLogicalOr(struct device_s *bus_adap,
+		unsigned int addr, unsigned char val, unsigned char *pval)
+{
+	*pval |= val;
+
+	if (usb_setbyte(bus_adap, addr, *pval) < 0)
+		return -1;
+
+	if (usb_getbyte(bus_adap, addr, pval) < 0)
+		return -1;
+
+	dbg("=> Logical OR [%02X] => %02X\n", val, *pval);
+
+	return 0;
+}
+
+/******************************************************************************
+ * @brief
+ *   compute a logical And between CIMaX+ register value and a param value.
+ *
+ * @param   bus_adap
+ *   Pointer to CIMaX+ usb adapter.
+ *
+ * @param   addr
+ *   Addr of CIMaX+ register.
+ *
+ * @param   val
+ *   value to compute.
+ *
+ * @param   pval
+ *   pointer to buffer to store CIMaX+ register value.
+ *
+ * @return
+ *   0 if OK otherwise -1.
+ ******************************************************************************/
+int setLogicalAnd(struct device_s *bus_adap,
+		unsigned int addr, unsigned char val, unsigned char *pval)
+{
+	*pval &= val;
+
+	if (usb_setbyte(bus_adap, addr, *pval) < 0)
+		return -1;
+
+	if (usb_getbyte(bus_adap, addr, pval) < 0)
+		return -1;
+
+	dbg("=> Logical AND [%02X] => %02X\n", val, *pval);
+
+	return 0;
+}
+
+/******************************************************************************
+ * @brief
+ *   wait CIMaX+ register value match a param value.
+ *
+ * @param   bus_adap
+ *   Pointer to CIMaX+ usb adapter.
+ *
+ * @param   addr
+ *   Addr of CIMaX+ register.
+ *
+ * @param   val
+ *   value to match.
+ *
+ * @param   pval
+ *   pointer to buffer to store CIMaX+ register value.
+ *
+ * @return
+ *   0 if OK otherwise -1.
+ ******************************************************************************/
+int waitForValue(struct device_s *bus_adap,
+		unsigned int addr, unsigned char val, unsigned char *pval)
+{
+	dbg("=> Wait for Value [%02X]\n", val);
+	if (*pval == val)
+		return 0;
+
+	while (1) {
+		if (usb_getbyte(bus_adap, addr, pval) < 0)
+			return -1;
+
+		dbg("\r => %02X", *pval);
+
+		if (*pval == val)
+			break;
+	}
+
+	dbg("\n");
+
+	return 0;
+}
+
+/******************************************************************************
+ * @brief
+ *   wait CIMaX+ register bits match a param value.
+ *
+ * @param   bus_adap
+ *   Pointer to CIMaX+ usb adapter.
+ *
+ * @param   addr
+ *   Addr of CIMaX+ register.
+ *
+ * @param   val
+ *   value to match.
+ *
+ * @param   pval
+ *   pointer to buffer to store CIMaX+ register value.
+ *
+ * @return
+ *   0 if OK otherwise -1.
+ ******************************************************************************/
+int waitForBitsSet(struct device_s *bus_adap,
+		unsigned int addr, unsigned char val, unsigned char *pval)
+{
+	dbg("=> Wait for Bits set [%02X]\n", val);
+	if ((*pval & val) == val)
+		return 0;
+
+	while (1) {
+		if (usb_getbyte(bus_adap, addr, pval) < 0)
+			return -1;
+
+		dbg("\r => %02X", *pval);
+
+		if ((*pval & val) == val)
+			break;
+	}
+
+	dbg("\n");
+
+	return 0;
+}
+
+/******************************************************************************
+ * @brief
+ *   wait CIMaX+ register bits cleared.
+ *
+ * @param   bus_adap
+ *   Pointer to CIMaX+ usb adapter.
+ *
+ * @param   addr
+ *   Addr of CIMaX+ register.
+ *
+ * @param   val
+ *   bits to check.
+ *
+ * @param   pval
+ *   pointer to buffer to store CIMaX+ register value.
+ *
+ * @return
+ *   0 if OK otherwise -1.
+ ******************************************************************************/
+int waitForBitsCleared(struct device_s *bus_adap,
+		unsigned int addr, unsigned char val, unsigned char *pval)
+{
+	dbg("=> Wait for Bits cleared [%02X]\n", val);
+	if ((*pval & val) == 0x00)
+		return 0;
+
+	while (1) {
+		if (usb_getbyte(bus_adap, addr, pval) < 0)
+			return -1;
+
+		dbg("\r => %02X", *pval);
+
+		if ((*pval & val) == 0x00)
+			break;
+	}
+
+	dbg("\n");
+
+	return 0;
+}
+
+/******************************************************************************
+ * @brief
+ *   retreive addr of CIMaX+ register.
+ *
+ * @param   dev
+ *   Pointer to CIMaX+ register Name.
+ *
+ * @return
+ *   Address of CIMaX+ register.
+ *****************************************************************************/
+int cimaxusb_rtr_reg_addr(char *str_addr)
+{
+	int i32NbItem = sizeof(cimax_reg_map) / sizeof(struct reg_s);
+	int i32index;
+	int i32ValAddr = -1;
+
+	for (i32index = 0; i32index < i32NbItem; i32index++) {
+		if (strcmp(str_addr, cimax_reg_map[i32index].RegisterName)
+				== 0) {
+			i32ValAddr = cimax_reg_map[i32index].RegAddr;
+			break;
+		}
+	}
+	return i32ValAddr;
+}
+
+static int cimaxusb_parse_cfg_ops(struct device_s *bus_adap,
+		unsigned char **pptr, size_t *plen)
+{
+	unsigned char op;
+	int ret;
+	char param1[256], param2[256];
+	char line[256], *ptr_line;
+	int val;
+	unsigned char val2;
+	unsigned int  addr;
+	unsigned char *ptr = *pptr;
+	size_t len = *plen;
+
+	ptr_line = line;
+	op = *ptr;
+	ret = sscanf(ptr, "%s %s", param1, param2);
+	ptr++;
+	len++;
+	if (sscanf(ptr, "%s %X", param1, &val) != 2)
+		return -EFAULT;
+	/*pr_debug("%s: param1=%s,param2=%s, val=%x\n",
+		DRIVER_NAME, param1, param2, val);*/
+	strcpy(ptr_line, param1);
+	len += strlen(param1);
+	ptr += strlen(param1);
+	strncat(ptr_line, ptr, 1);
+	len++;
+	ptr++;
+	strcat(ptr_line, param2);
+	len += strlen(param2);
+	ptr += strlen(param2);
+	/*pr_debug("%s: len = %08d line: %s\n",
+		DRIVER_NAME, len, line);*/
+	addr = cimaxusb_rtr_reg_addr(param1);
+	if (((signed)addr) < 0) {
+		pr_err("%s: unknown register name: %s\n",
+			DRIVER_NAME, param1);
+		return -ENODEV;
+	}
+	if (usb_getbyte(bus_adap, addr, &val2) < 0) {
+		pr_err("%s: CIMaX+ register reading problem: %s\n",
+		DRIVER_NAME, param1);
+		return -ENODEV;
+	}
+
+	switch (op) {
+	case '=':
+		if (waitForValue(bus_adap, addr, val, &val2) == -1) {
+			pr_err("%s : waitForValue failed on : %s\n",
+				DRIVER_NAME, param1);
+			return -ENODEV;
+		}
+		pr_info("%s : wait for value ([%x] = %x = %x)\n",
+			line, addr, val, val2);
+	break;
+	case '?':
+		if (waitForBitsSet(bus_adap, addr, val, &val2) == -1) {
+			pr_err("%s : waitForBitsSet failed on : %s\n",
+				DRIVER_NAME, param1);
+			return -ENODEV;
+		}
+		pr_info("%s : wait for bitsset ([%x] = %x = %x)\n",
+			line, addr, val, val2);
+	break;
+	case '!':
+		if (waitForBitsCleared(bus_adap, addr, val, &val2)
+				== -1) {
+			pr_err("%s : waitForBitsCleared failed on : %s\n",
+				DRIVER_NAME, param1);
+			return -ENODEV;
+		}
+		pr_info("%s : wait for bits cleared ([%x] = %x = %x)\n",
+			line, addr, val, val2);
+	break;
+	case '|':
+		if (setLogicalOr(bus_adap, addr, val, &val2) == -1) {
+			pr_err("%s : setLogicalOr failed on : %s\n",
+				DRIVER_NAME, param1);
+			return -ENODEV;
+		}
+		pr_info("%s : setOr ([%x] = %x = %x)\n",
+			line, addr, val, val2);
+	break;
+	case '&':
+		if (setLogicalAnd(bus_adap, addr, val, &val2) == -1) {
+			pr_err("%s : setLogicalAnd failed on : %s\n",
+				DRIVER_NAME, param1);
+			return -ENODEV;
+		}
+		pr_info("%s : setAnd ([%x] = %x = %x)\n",
+			line, addr, val, val2);
+	break;
+	default:
+		pr_err("Error: Marker Unknown <%c> !!!\n", op);
+		return -ENODEV;
+	}
+	*pptr = ptr;
+	*plen = len;
+	return 0;
+}
+
+static int cimaxusb_parse_cfg_default(struct device_s *bus_adap,
+		unsigned char **pptr, size_t *plen)
+{
+	unsigned char *ptr = *pptr;
+	size_t len = *plen;
+	int ret;
+	char param1[256], param2[256];
+	char line[256], *ptr_line;
+	int val;
+	unsigned char val2;
+	unsigned int  addr;
+
+	ptr_line = line;
+
+	ret = sscanf(ptr, "%s %s", param1, param2);
+	ret = sscanf(param2, "%X", &val);
+	/*pr_debug("%s: param1=%s,param2=%s,val=%x\n",
+		DRIVER_NAME,param1,param2,val);*/
+	strcpy(ptr_line, param1);
+	len += strlen(param1);
+	ptr += strlen(param1);
+	strncat(ptr_line, ptr, 1);
+	len++;
+	ptr++;
+	strcat(ptr_line, param2);
+	len += strlen(param2);
+	ptr += strlen(param2);
+	/*pr_debug("%s: len = %08d line: %s\n",
+		DRIVER_NAME, len, line);*/
+	addr = cimaxusb_rtr_reg_addr(param1);
+	if (((signed)addr) < 0) {
+		pr_err("%s: unknown register name: %s\n",
+			DRIVER_NAME, param1);
+		return -ENODEV;
+	}
+	if (usb_getbyte(bus_adap, addr, &val2) < 0) {
+		pr_err("%s: CIMaX+ register reading problem: %s\n",
+			DRIVER_NAME, param1);
+		return -ENODEV;
+	}
+	if (usb_setbyte(bus_adap, addr, val) < 0) {
+		pr_err("%s: CIMaX+ register writing problem: %s\n",
+			DRIVER_NAME, param1);
+		return -ENODEV;
+	}
+	if (usb_getbyte(bus_adap, addr, &val2) < 0) {
+		pr_err("%s: CIMaX+ register checking problem: %s\n",
+			DRIVER_NAME, param1);
+		return -ENODEV;
+	}
+	pr_info("set: %s(0x%04x) : 0x%02x\n", param1, addr, val);
+
+	*pptr = ptr;
+	*plen = len;
+	return 0;
+}
+
+/******************************************************************************
+ * @brief
+ *   parse CIMaX+ config file.
+ *
+ * @param   dev
+ *   Pointer to usb device.
+ *
+ * @param   fw_data
+ *   Pointer to buffer with firmware data.
+ *
+ * @return
+ *   O if no error otherwise errno.
+ *****************************************************************************/
+int cimaxusb_parse_cfg(struct device_s *bus_adap,
+		const unsigned char *cfg_data, size_t size)
+{
+	char line[256], *ptr_line;
+	size_t len = 0;
+	unsigned char *ptr = (unsigned char *)cfg_data;
+	int ret = -EFAULT;
+
+	dbg("%s: %s size = %zd\n", DRIVER_NAME, __func__, size);
+	do {
+		ptr_line = line;
+		switch (*ptr) {
+		case ';':
+			/* continue up to find \r character */
+			while (*ptr != 0x0A) {
+				*ptr_line++ = *ptr;
+				ptr++;
+				len++;
+			}
+			*ptr_line = 0;
+			/*pr_debug("%s: len = %08d line: %s\n",
+				DRIVER_NAME, len, line);*/
+		break;
+		case 0x0A:
+		case 0x0D:
+			ptr++;
+			len++;
+		break;
+		case '=':
+		case '?':
+		case '!':
+		case '|':
+		case '&':
+			ret = cimaxusb_parse_cfg_ops(bus_adap, &ptr, &len);
+			if (ret < 0)
+				return ret;
+		break;
+		default:
+			ret = cimaxusb_parse_cfg_default(bus_adap, &ptr, &len);
+			if (ret < 0)
+				return ret;
+		break;
+		}
+	} while (len < size);
+
+	return (ret == -EFAULT) ? 0 : ret;
+}
+
+/******************************************************************************
+ * @brief
+ *   read configuration file ( CIMAX_CONFIG_NAME) and set in CIMaX+ chip.
+ *
+ * @param   bus_adap
+ *   Pointer to usb device.
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+/*
+opt: 0: init, 1: off, 2: Vcc3.3 3: Vcc5
+*/
+int cimaxusb_configuration_setting_opt(struct device_s *bus_adap, int opt)
+{
+	int errno = -EFAULT;
+	const struct firmware *config;
+	char *cfg = cimax_config_file[opt];
+
+	struct usb_device *dev = bus_adap->usbdev;
+
+	dbg("request configuration file");
+	/* request kernel to locate firmware file */
+	errno = request_firmware(&config, cfg, &dev->dev);
+	if (errno < 0) {
+		pr_err("%s: unable to locate configuration file: %s\n",
+			 DRIVER_NAME, cfg);
+		goto error;
+	}
+
+	dbg("parse configuration file");
+	errno = cimaxusb_parse_cfg(bus_adap, config->data, config->size);
+	if (errno < 0) {
+		pr_err("%s: unable to parse config file: %s\n",
+			 DRIVER_NAME, cfg);
+		goto error;
+	}
+
+error:
+	/* release firmware if needed */
+	if (config != NULL)
+		release_firmware(config);
+	return errno;
+}
+
+int cimaxusb_configuration_setting(struct device_s *bus_adap)
+{
+	return cimaxusb_configuration_setting_opt(bus_adap, 0);
+}
+
+int cimaxusb_configuration_setting_vcc(struct device_s *bus_adap, int vcc)
+{
+	return cimaxusb_configuration_setting_opt(bus_adap, vcc);
+}
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_config.h b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_config.h
new file mode 100644
index 0000000..5c55204
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_config.h
@@ -0,0 +1,58 @@
+/**************************************************************************//**
+ * @file    cimax+usb_config.h
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ ******************************************************************************/
+
+#ifndef __CIMAXPLUS_USB_CFG_H
+#define __CIMAXPLUS_USB_CFG_H
+
+/******************************************************************************
+ * Include
+ ******************************************************************************/
+#include "cimax+usb_handle.h"
+
+/******************************************************************************
+ * Defines
+ ******************************************************************************/
+#define CIMAX_CONFIG_NAME   "cimax+usb.cfg"
+
+/******************************************************************************
+ * Enums
+ ******************************************************************************/
+/******************************************************************************
+ * Structures
+ ******************************************************************************/
+
+/******************************************************************************
+ * Functions
+ ******************************************************************************/
+
+/******************************************************************************
+ * @brief
+ *   read configuration file ( CIMAX_CONFIG_NAME) and set in CIMaX+ chip.
+ *
+ * @param   bus_adap
+ *   Pointer to usb device.
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+int cimaxusb_configuration_setting(struct device_s *bus_adap);
+
+#endif
+
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_fw.c b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_fw.c
new file mode 100644
index 0000000..6bccf4b
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_fw.c
@@ -0,0 +1,325 @@
+/**************************************************************************//**
+ * @file    cimax+usb_fw.c
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ ******************************************************************************/
+/******************************************************************************
+ * Include
+ ******************************************************************************/
+#include <linux/slab.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/usb.h>
+
+#include <linux/errno.h>
+#include <linux/firmware.h>
+
+#include <linux/uaccess.h>
+#include <linux/mutex.h>
+
+#include <linux/printk.h>
+
+#include "cimax+usb-driver.h"
+#include "cimax+usb_fw.h"
+
+/******************************************************************************
+ * Structures
+ ******************************************************************************/
+/******************************************************************************
+ * Globals
+ ******************************************************************************/
+char cimax_fw[] = CIMAX_FIRMWARE_NAME;
+
+/******************************************************************************
+ * Functions
+ ******************************************************************************/
+/******************************************************************************
+ * @brief
+ *   Start & check Bistrom.
+ *
+ * @param   dev
+ *   Pointer to usb device.
+ *
+ * @param   startAddr
+ *   start address of firmware to compute
+ *
+ * @param   endAddr
+ *   stop address of firmware to compute
+ *
+ * @param   FWSign
+ *   Current signature to check
+ *
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+int checkBistRom(struct device_s *bus_adap,
+	int startAddr, int endAddr, int signature)
+{
+	unsigned char *Val;
+	int rv;
+
+	struct usb_device *dev = bus_adap->usbdev;
+
+	Val = kcalloc(2, sizeof(unsigned char), GFP_KERNEL);
+	if (!Val) {
+		pr_err("%s-%s: out of memory.\n", DRIVER_NAME, __func__);
+		return -ENOMEM;
+	}
+
+	/* Write "Flash" Size
+	   (!) BistRom is computed since D000-flashSize to D0000-6
+	*/
+	Val[0] = (0xD000-startAddr)&0x00ff;
+	Val[1] = (0xD000-startAddr)>>8;
+	if (bus_adap->ops->write_ctrl_message(dev, 0x008D, Val, 2) != 2) {
+		kfree(Val);
+		return -1;
+	}
+
+	/* Write Signature*/
+	Val[0] = signature&0x00ff;
+	Val[1] = signature>>8;
+	if (bus_adap->ops->write_ctrl_message(dev, 0x0080, Val, 2) != 2) {
+		kfree(Val);
+		return -1;
+	}
+
+	/* Launch BistRom [(D000-flashSize)..CFF9]+[FFFA..FFFF] computation*/
+	Val[0] = 0x0F;
+	if (bus_adap->ops->write_ctrl_message(dev, 0x0082, Val, 1) != 1) {
+		kfree(Val);
+		return -1;
+	}
+
+	pr_info("\n>>Read Signature\n");
+
+	/* Read Signature*/
+	if (bus_adap->ops->read_ctrl_message(dev, 0x0041, Val, 2) != 2) {
+		kfree(Val);
+		return -1;
+	}
+
+	pr_info("\n>> Bistrom computed = %04X\n",  Val[0]|Val[1]<<8);
+
+	/* Read Boot status*/
+	if (bus_adap->ops->read_ctrl_message(dev, 0x0009, Val, 1) != 1) {
+		kfree(Val);
+		return -1;
+	}
+
+	pr_info("\n>> BootRom Status = %02X\n",  Val[0]);
+	rv = Val[0];
+	kfree(Val);
+
+	return rv;
+}
+
+/******************************************************************************
+ * @brief
+ *   Compute BistRom.
+ *
+ * @param   ptr
+ *   Pointer to buffer with register data
+ *
+ * @param   size
+ *   Number of register to process
+ *
+ * @param   FWSign
+ *   Current signature
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+unsigned int MISR(const unsigned char *ptr, int size, unsigned int FWSign)
+{
+	int k, i;
+
+	unsigned short mySign;
+
+	for (k = 0; k < size; k++) {
+		mySign = ptr[k]&0x01;
+
+		for (i = 0; i < 16; i++) {
+			if (0x88B7 & (1<<i))
+				mySign ^= (FWSign>>i) & 0x01;
+		}
+
+		mySign |= ((FWSign<<1)^(ptr[k])) & 0x00FE;
+		mySign |= (FWSign<<1) & 0x00FF00;
+
+		FWSign = mySign;
+	}
+
+	return FWSign;
+}
+
+
+/******************************************************************************
+ * @brief
+ *   upload firmware in CIMaX+ chip.
+ *
+ * @param   dev
+ *   Pointer to usb device.
+ *
+ * @param   fw_data
+ *   Pointer to buffer with firmware data.
+ *
+ * @param   FWSign
+ *   Pointer to store computed signature.
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+int cimaxusb_firmware_upload(struct device_s *bus_adap,
+	const unsigned char *fw_data, unsigned int *FWSign)
+{
+	int errno = -EFAULT;
+	const unsigned char *ptr;
+	int startAddr = START_FW_ADDR;
+	unsigned char *recv;
+	int size;
+
+	struct usb_device *dev = bus_adap->usbdev;
+
+	/* data firmware */
+	ptr = fw_data;
+	ptr += START_FW_ADDR;
+
+	recv = kcalloc(300, sizeof(unsigned char), GFP_KERNEL);
+	if (!recv) {
+		pr_err("%s-%s: out of memory.\n", DRIVER_NAME, __func__);
+		return -ENOMEM;
+	}
+
+	do {
+		/* compute the size to send to CIMaX+ */
+		size = (startAddr <= (STOP_FW_ADDR + 1 - MAX_FW_PKT_SIZE)) ?
+			(MAX_FW_PKT_SIZE) : (STOP_FW_ADDR + 1 - startAddr);
+		/* compute Signature */
+		*FWSign = MISR(ptr, size, *FWSign);
+
+		pr_info("%s: firmware start address %08x size %d\n",
+			DRIVER_NAME, startAddr, size);
+
+		/* upload data firmware */
+		if (bus_adap->ops->write_ctrl_message(
+				dev, startAddr, (void *)ptr, size) != size) {
+			pr_err("Failed to load CIMaX+ firmware\n");
+			errno = -ENODEV;
+			break;
+		}
+		if (bus_adap->ops->read_ctrl_message(
+				dev, startAddr, (void *)recv, size) != size) {
+			pr_err("Failed to load CIMaX+ firmware\n");
+			errno = -ENODEV;
+			break;
+		}
+		if (memcmp(ptr, recv, size)) {
+			pr_err("Failed compare at Address 0x%04x\n",
+				startAddr);
+			errno = -ENODEV;
+			break;
+		}
+		/* update size sent to CIMaX+ */
+		startAddr += size;
+		ptr += size;
+		if (startAddr >= STOP_FW_ADDR)
+			break;
+	} while (1);
+
+	kfree(recv);
+
+	if (errno == -EFAULT) {
+		/* upload interrupt vector*/
+		ptr = fw_data;
+		ptr += START_INTVECT_ADDR;
+		startAddr =  START_INTVECT_ADDR;
+
+		/* continue to compute Signature */
+		*FWSign = MISR(ptr, 6, *FWSign);
+
+		/* upload interrupt vector data*/
+		if (bus_adap->ops->write_ctrl_message(
+				dev, startAddr, (void *)ptr, 6) != 6) {
+			pr_err("Failed to load CIMaX firmware(Int vector)\n");
+			errno = -ENODEV;
+		}
+	}
+	return (errno == -EFAULT) ? 0 : errno;
+}
+
+/******************************************************************************
+ * @brief
+ *   upload and start firmware in CIMaX+ chip.
+ *
+ * @param   bus_adap
+ *   Pointer to usb device.
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+int cimaxusb_fw_upload(struct device_s *bus_adap)
+{
+	int errno = -EFAULT;
+	const struct firmware *firmware;
+	char *fw = cimax_fw;
+	unsigned int FWSign = 0;
+	int ret;
+
+	struct usb_device *dev = bus_adap->usbdev;
+
+	/* request kernel to locate firmware file */
+	errno = request_firmware(&firmware, fw, &dev->dev);
+	if (errno < 0) {
+		pr_err("%s: unable to locate firmware file: %s\n",
+				DRIVER_NAME, fw);
+		goto error;
+	}
+
+	errno = cimaxusb_firmware_upload(bus_adap, firmware->data, &FWSign);
+	if (errno < 0) {
+		pr_err("%s: unable to upload firmware file: %s\n",
+				DRIVER_NAME, fw);
+		goto error;
+	}
+
+	pr_info("%s: firmware: %s loaded with success. Current Bistrom %04X\n",
+			DRIVER_NAME, fw, FWSign);
+
+	ret = checkBistRom(bus_adap, START_FW_ADDR, STOP_FW_ADDR, FWSign);
+	if (ret != 0x02) {
+		pr_err("\nError: Fail on compare BistRom (%02X) !\n", ret);
+		errno = -ENODEV;
+		goto error;
+	}
+
+	if (bus_adap->ops->init_fw(dev) != 0) {
+		pr_err("\nError: Fail on INIT command !\n");
+		errno = -ENODEV;
+		goto error;
+	}
+
+error:
+	/* release firmware if needed */
+	if (firmware != NULL)
+		release_firmware(firmware);
+	return errno;
+}
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_fw.h b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_fw.h
new file mode 100644
index 0000000..bf3f64c
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_fw.h
@@ -0,0 +1,61 @@
+/**************************************************************************//**
+ * @file    cimax+usb_fw.h
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ ******************************************************************************/
+
+#ifndef __CIMAXPLUS_USB_FW_H
+#define __CIMAXPLUS_USB_FW_H
+
+/******************************************************************************
+ * Include
+ ******************************************************************************/
+#include "cimax+usb_handle.h"
+
+/******************************************************************************
+ * Defines
+ ******************************************************************************/
+#define CIMAX_FIRMWARE_NAME   "cimax+_usbdvb.bin"
+#define START_FW_ADDR	      0x8000
+#define STOP_FW_ADDR	         0xCFF9
+#define START_INTVECT_ADDR	   0xFFFA
+#define MAX_FW_PKT_SIZE	      256
+
+/******************************************************************************
+ * Enums
+ ******************************************************************************/
+/******************************************************************************
+ * Structures
+ ******************************************************************************/
+
+/******************************************************************************
+ * Functions
+ ******************************************************************************/
+/******************************************************************************
+ * @brief
+ *   upload firmware in CIMaX+ chip.
+ *
+ * @param   bus_adap
+ *   Pointer to usb device.
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+int cimaxusb_fw_upload(struct device_s *bus_adap);
+
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_handle.h b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_handle.h
new file mode 100644
index 0000000..936b9cf
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_handle.h
@@ -0,0 +1,46 @@
+/**************************************************************************//**
+ * @file    cimax+usb_handle.h
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ ******************************************************************************/
+
+#ifndef __CIMAXPLUS_USB_HDLE_H
+#define __CIMAXPLUS_USB_HDLE_H
+
+#ifdef __KERNEL__
+
+struct cimaxusb_priv_ops_t {
+	int (*write_ctrl_message)(
+		struct usb_device *dev, int addr, void *data, int size);
+
+	int (*read_ctrl_message)(
+		struct usb_device *dev, int addr, void *data, int size);
+
+	int (*init_fw)(
+		struct usb_device *dev);
+
+	int (*write_ep6_message)(
+		struct usb_device *dev, void *data, int size);
+
+	int (*read_ep5_message)(
+		struct usb_device *dev, void *data, int size);
+};
+
+#endif
+
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_time.c b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_time.c
new file mode 100644
index 0000000..ea80b5e
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_time.c
@@ -0,0 +1,130 @@
+/**************************************************************************//**
+ * @file    cimax+usb_fw.c
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ ******************************************************************************/
+
+/*#define TIMESTAMP*/
+
+/******************************************************************************
+ * Include
+ ******************************************************************************/
+#include <linux/delay.h>
+
+#include "cimax+usb_time.h"
+
+/******************************************************************************
+ * Structures
+ ******************************************************************************/
+#define err(format, arg...)\
+	pr_err("cimax+usb_time: %s> ERROR " format "\n" , \
+		__func__, ## arg)
+#define info(format, arg...) pr_info("time> " format "\n", ## arg)
+/******************************************************************************
+ * Globals
+ ******************************************************************************/
+#ifdef TIMESTAMP
+struct item_array_s gstArray;
+#endif
+/******************************************************************************
+ * Functions
+ ******************************************************************************/
+/******************************************************************************
+ * @brief
+ *   Init timestamp.
+ *
+ * @param
+ *   None
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+void InitTimestamp(void)
+{
+#ifdef TIMESTAMP
+	gstArray.count = 0;
+#endif
+	return;
+}
+
+/******************************************************************************
+ * @brief
+ *   Set timestamp.
+ *
+ * @param   pcFormat
+ *   Printf-like format
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+void SetTimestamp(const char *pcFormat, ...)
+{
+#ifdef TIMESTAMP
+	va_list stArgs;
+
+	if (gstArray.count >= MAX_ITEMS) {
+		if (gstArray.count++ == MAX_ITEMS)
+			ShowTimestamp();
+		return;
+	}
+	ktime_get_ts(&gstArray.stItem[gstArray.count].stTime);
+	va_start(stArgs, pcFormat);
+	vsprintf(gstArray.stItem[gstArray.count++].pcLine, pcFormat, stArgs);
+	va_end(stArgs);
+#endif
+	return;
+}
+
+/******************************************************************************
+ * @brief
+ *   Display all timestamps.
+ *
+ * @param
+ *   None
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+void ShowTimestamp(void)
+{
+#ifdef TIMESTAMP
+	int i;
+
+	if (gstArray.count == 0) {
+		err("No timestamps available");
+		return;
+	}
+
+	info("===============================================================");
+	info("                         TIMESTAMPS");
+	info("===============================================================");
+
+	for (i = 0; i < gstArray.count; i++) {
+		info("[%04d] [%03d.%09d] %s",
+				i,
+				gstArray.stItem[i].stTime.tv_sec,
+				gstArray.stItem[i].stTime.tv_nsec,
+				gstArray.stItem[i].pcLine);
+		if ((i % 100) == 0)
+			msleep(20);
+	}
+	info("===============================================================");
+	gstArray.count = 0;
+
+#endif
+	return;
+}
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_time.h b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_time.h
new file mode 100644
index 0000000..0012c64
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/SRC/cimax+usb_time.h
@@ -0,0 +1,92 @@
+/**************************************************************************//**
+ * @file    cimax+usb_time.h
+ *
+ * @brief   CIMaX+ USB Driver for linux based operating systems.
+ *
+ * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
+ *                          & Franck Descours <franck.descours@smardtv.com>
+ *                            for SmarDTV France, La Ciotat
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ ******************************************************************************/
+
+#ifndef __CIMAXPLUS_USB_TIME_H
+#define __CIMAXPLUS_USB_TIME_H
+
+/******************************************************************************
+ * Include
+ ******************************************************************************/
+#include <linux/ktime.h>
+
+/******************************************************************************
+ * Defines
+ ******************************************************************************/
+#define MAX_ITEMS     100000
+#define MAX_LINE_SIZE    128
+
+/******************************************************************************
+ * Enums
+ ******************************************************************************/
+/******************************************************************************
+ * Structures
+ ******************************************************************************/
+struct item_s {
+	struct timespec stTime;
+	char            pcLine[MAX_LINE_SIZE];
+};
+
+struct item_array_s {
+	int  count;
+	item_s stItem[MAX_ITEMS];
+};
+
+extern struct item_array_s gstArray;
+
+/******************************************************************************
+ * Functions
+ ******************************************************************************/
+/******************************************************************************
+ * @brief
+ *   Init timestamp.
+ *
+ * @param
+ *   None
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+void InitTimestamp(void);
+
+/******************************************************************************
+ * @brief
+ *   Set timestamp.
+ *
+ * @param   pcFormat
+ *   Printf-like format
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+void SetTimestamp(const char *pcFormat, ...);
+
+/******************************************************************************
+ * @brief
+ *   Display all timestamps.
+ *
+ * @param
+ *   None
+ *
+ * @return
+ *   None.
+ ******************************************************************************/
+void ShowTimestamp(void);
+
+#endif
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/firmware/cimax+_usbdvb.bin b/drivers/stream_input/parser/dvb_ci/cimax/usb/firmware/cimax+_usbdvb.bin
new file mode 100644
index 0000000..315fe5e
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/firmware/cimax+_usbdvb.bin
@@ -0,0 +1,81 @@
+                         @ /  
+ @ 	  	       	      	          	      	    	"S D T V   T B D                 "C I M A X   T B D               "S N 0 0 0   T B D                  
+
+  < L 
+  i i  	$ y| 
+7{    7{ B
+ ` `L`)8y|-y| %   `HHH9{1O{)&r!qp D{9{ O{)L 9{(  || KA_CSD.EyF4GMHIJLMNPPQRSVSWX1vf6 0  u  u  LL9L9 0  u  u  L$L9          8.m m  LL9          8.m m  LL9 K     i i  u  u  LXL9i i    L9 L9 L9 L9 L9L9L9         i i     8 7 iiLLL9         i i     8 7 iiLLSL9         i i     8 7 iiLJLL9L9L9 L9 L9 L9 L9 L9L9 0  u  u  LL9          8.m m  L6L9          8.m m  LL9L9L9 0  u  u  LL9L9K>NQS.* ||   i||i }|L        { i||i }|Lhhh`  @@.  Q  LF{b|ZSLE-=V|  	@  D{LG{g|_XQJ-B-	V|  	@  D{L K  8l8
+2&Ryj!, :L _L YL LJ{)J{ H{~|  LJ{)J{ I{~| L~|  L~| L~|      mLc      i i V-  ?- s|L8s|?-t|LX@-w|LXLXLXL  GL~|      mLf      i i V-  ?- u|L;u|?-v|L[@-x|L[L[L[L GL~|   |L~|  |L~|  L~| LH{~|   H{LI{~|  I{L~|  }L~| }L L /L
+	@ `y|)	-y|L$ 8{ [ Z}|]||\	XX	X8 ||}| 	 `  ):h	h 0)8y|0-y|	l | |)Ls |)L | | | 9{h)h|iX | |-y| 	)ts	)|WP)
+
+|h)hLS)|h)hLS) |h)h|
+|L|L.||)
+||L|UD{P-y|CK{L{|K{L{|| E 	@ ||=|8-y|0H{&H{    N   |L}|JD{E-y|8 K{ L{ || E 	@  ||LL|LL||)
+||L|P-y|CM{N{|M{N{||  	@ ||=|8-y|0I{&I{       |L|E-y|8 M{ N{ ||  	@  |7{-y|D{  7{-y|EO{)&r!qp9{ O{ D{)p)9{
+8{8{D{K<{={A:{ X  <{ <{h)h={ ={h)hL   `HHHHHHHxj)7{)||9{j)LB{q>{d>{gC{ p@{|)@{@{|)@{@{|)|L
+ | | F{) B{C{q?{d?{gB{ pA{|)A{A{|)A{A{|)|L | | G{) C{tsj)L|Ll)||#B{ p >{p@{pLB{ p >{|e>{p @{p))||#C{ p ?{pA{pLiC{ p ?{|e?{p A{p)L|
+|L)Li)gB{)|| p >{p@{pL p >{|e>{p @{)J{)J{p|o)gC{)|| p ?{pA{pLi p ?{|e?{p A{p)J{)J{))L)Lk)Lk|	))) -J{J{||Lf||	L||)	o|i p|i   -')||	|LX|	|)Lk|)7|2)*	)) -J{J{|k) sk):YO{-O{-	  Xrqp)9{ D{k) )7{j)@:{<{h	@hj);{={h	hjLrkLrXhhhhhhh@r      q    `|| | |p`   o '8||||||pLp` p o   L(p P  c @-|| `  c`}}	}} } }`}}	}}}}}}` 
+} } `  0 LL ,} )L` d  ) LVp 
+`)	 
+L
+`d  ) L" )Lp`) ! }`"}`HHH}} } }}m}}m}8}}}}Lu8}}}}  8V)L}@ L   }}L}m}}}m}}hhh`HHH L !	 L !) >"}}*}} }i}}i}}}LM@}}L)LLL}}L)Lhhh`  d  a )Ls)+)#	 )Ls)Ls Lp`6 })? }) 8}}}}	  `)L`)	 D)}Hh r) 	 L!L!L!3-} ! LX !	 )Lo !	`) 	)\))
+ 	L))L 		)	 )-9{ 8{	  8{-	)	)@	@)	)	a)   a`HHH	 L;  ou  {u  l{mL;  pu  {u     ]Hl{ hu mLhhh` -} 1|@Lm }	   L$
+}}}    LLL} }    , E }   _)    L)J   L)JJ   L)JJJ   L)JJJJ   L) Hh r   L)@Hh r   LLLL `}L L-}L} KQ8j	@	 i)iL	 	i)iYL		i)iL		i)iL		i)iL		i)iLLLL`} L-}L} KC*u\	@	 i)iL	 	i)iYL		i)iL		i)iL		i)iL		i)iLLLL`d  ) 	Lp 
+}L
+}`}}}P{} } } !}/"} #} $}} } `b}{}
+} } ` p)@ p)@s{s{-t{|	@|L p)@I-s{s{l}{}} } `}{}	} } `} }|}} }L;p) p
+| }|}"} }L;p) "p,| *}|}"} }L;p) BpN| L}|}"} }L	L `  } K1.F LN TLN r LN LNLN 	LNLN	 ~`  }l}{} L` 
+} L   `}
+}L}
+}L` 
+}}}	n| L
+ `HHH}  I[Rdmv HL L L L L bL L L L
+}L}}L}n|n| LLuLn|+  
+ 	 LUn|   pu  {u    qu  {u  1JJJi
+
+
+  qu  {u  1  wu  {u    xu  {u  1JJJi
+
+
+  xu  {u  1	  ~u  {u  
+  u  {u  1JJJi
+
+
+  u  {u  1  u  {u    u  {u  1JJJi
+
+
+  u  {u  1				 tu	 	@	 L	LLLhhh`E{ii&D{ E{`y!`HHH  
+    (|o|p|JIVL|q|r| i i   1LW
+ ii")L
+ Hh L<)L, Hh  Li/9{}}   L09{}}}   L0 V F{L G{h<{h)h={h)h9{      L0hhh`    K `HHH             /}}}L LQ ;  u  u H }hL}L h)hhhh`HHH         L  M h)hhhh`HHH  hx|O	|JI@h	   |)L    I LL o|I	|h	   |)L      L8L L:)L6 Hh  )L)Lp Hh  )-L
+ L  m83|L|     L.}}}  LP      F{La G{s|
+t|w|Lu|
+v|x|hhhh`   hxh	@hL`|||&	|JIAL]|+}}} J L>    I h<{h)h={h)hXLDL	L	|+|&	|L	|+}}}  L     h<{h)h={h)hXLD}L 
+  ii ii       
+) )  i i  ii Lfii       
+) )  i i ii L8 N}}}   
+h<{h)h={h)hXLDii       
+) )  i i  L- L ii  Vv    Hh r Vv    } L     L#}}}   
+h<{h)h={h)hXLHHHxF{
+G{hh	@hLx } } o|p||L3|L3)L3	|JIBF{Vs|t|	E}      }) )  i o|ip|o|p|Lu    I  F{h<{h)h={h)hXLLL } } q|r||LF|LF)LF	|G{u|v|	E}      }) )  i q|ir|q|r|L      G{h<{h)h={h)hXLL              
+) )  i i )@w
+ 	}
+LD	}
+
+ i i    i i    F{|LG{|Ui i  @ 1.9{}}  XLL0@ (XL F{LB G{      
+F{ G{h<{h)h={h)hXhhh`HHHh|=|8	|JIC}
+o|p|L    I  LLwe|=|8	|}
+q|r|Lw      Li i     ( Li i   i i          u u /}}}   L        mi i           u u8 L>  i i    @ ( L  8
+ i i   i i   @-L) i i   Li i   @-/}}}   Li i   i i    -Hh -Hh i i    i i    )@"  L)2--  L-- 
+hhh`HHHxs|I|D	|JIFw|}
+o|p|L9    I XLuLL|L||	|x|}
+q|r|)/}}  	XLuL     XLui i   -Li i   i i    $i i   Li i    J{L}}}  		L | 
+ A	||	Lt	||	Xhhh`HHH x       u ut|H|C	|JIDTw|}
+o|p|L9    I XLLq|H|C	|x|}
+q|r|L     XLi i   i i   1u8H{+H{ |    N L4 LlI{+I{ |     Ll L1i i   i i   @-Li i   i i     8 L$i i   Li i         L1$i i   Li i    "     L1      
+ C	||	L	||	Xhhh`HHHf|=|8	|JIW}
+o|p|L    I LLxc|=|8	|}
+q|r|Lx     Li i   }}   
+hhh`) ))|L|L	)|L|`HHHL       R    S L!     h)hhhh`}} Q h)h` VuLm` J`  ` 8  ` Vv uuL 
+6 `8vv `Vv `II`hh8 8
+eHhl L8hhiLZHhl hh iLHhl hhHHHHl hhhh`@%]
\ No newline at end of file
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/firmware/cimax+usb.cfg b/drivers/stream_input/parser/dvb_ci/cimax/usb/firmware/cimax+usb.cfg
new file mode 100644
index 0000000..7e792d8
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/firmware/cimax+usb.cfg
@@ -0,0 +1,97 @@
+;
+; ************************
+; *  INIT_TS.TXT SCRIPT  *
+; ************************
+;
+; *** CLOSE INPUT ***
+;
+IN_SEL 0x00
+;
+; *** CLOSE OUPUT ***
+;
+OUT_SEL 0x00
+;
+; *** RESET FIFO ***
+;
+FIFO_CTRL 0x0f
+SYNC_RTV_CTRL 0x0f
+;
+;
+; *************************
+; *  INIT_USB.TXT SCRIPT  *
+; *************************
+;
+; *** Endpoint Config ***
+;
+DMA_ACC_EPS	0x3f
+EPS_ENABLE 0x7f
+;
+; *** FIFO Control ***
+;
+USB2TS_CTRL	0x0f
+TS2USB_CTRL	0x0f
+;
+; *** FREQ Control ***
+;
+USB2TS0_RDL	0x80
+USB2TS1_RDL	0x80
+;
+;-----------------------------------------------------------------------------
+; Set CAM power
+;-----------------------------------------------------------------------------
+;
+GPIO0_DATA_OUT	0x00
+;
+; unlock CFG
+CFG_2	0x00
+;
+; 1) DVB/CI/CI+/SCARD 2slot
+CFG_1	0x00
+;
+; 2) Set the Default "power off" state such as VCC_MODA=VCC_MODB=VPPx_MODA=VPPx_MODB='Z'
+GPIO0_DFT 0x00
+;
+; 3) Set GPIO3 as external power switch driver
+GPIO0_MASK_DATA 0x07
+;
+; 4) Set "power on" state (VCC=VPP1=VPP2= 5V)
+GPIO0_DATA_OUT	0x01
+;
+; 5) Lock config
+CFG_2	0x01
+;
+; 6) Write in the GPIO0_DIR_REG: defines the GPIOs, which
+;    are used to drive the external power switch, in output mode.
+GPIO0_DIR 0x07
+;
+; 7) Check VCCENable
+?CFG_1 0x20
+;
+; 8) Set & wait for PcmciaOutputEnable
+|CFG_1 0x08
+?CFG_1 0x08
+;
+;---------------------------------------
+; Set Router CAM
+;---------------------------------------
+;
+;
+GAP_REMOVER_CH0_CTRL 0x0C
+GAP_REMOVER_CH1_CTRL 0x0C
+
+; 9) CH0 & CH1 from CAM A & B, CAM A & B from CH0 & CH1
+;
+ROUTER_CAM_MOD	0x21
+ROUTER_CAM_CH	0x00
+;
+;_Wait	200
+;---------------------------------------
+; ROUTER CAM
+;---------------------------------------
+OUT_SEL 0x03
+;
+USB2TS0_RDL	0x80
+USB2TS1_RDL	0x80
+;
+IN_SEL 0x22
+
diff --git a/drivers/stream_input/parser/dvb_ci/cimax/usb/firmware/cimax+usb_ms.cfg b/drivers/stream_input/parser/dvb_ci/cimax/usb/firmware/cimax+usb_ms.cfg
new file mode 100644
index 0000000..5c38429
--- /dev/null
+++ b/drivers/stream_input/parser/dvb_ci/cimax/usb/firmware/cimax+usb_ms.cfg
@@ -0,0 +1,136 @@
+;
+; ************************
+; *  INIT_TS.TXT SCRIPT  *
+; ************************
+;
+; *** CLOSE INPUT ***
+;
+IN_SEL 0x00
+;
+; *** CLOSE OUPUT ***
+;
+OUT_SEL 0x00
+;
+; *** RESET FIFO ***
+;
+FIFO_CTRL 0x0f
+SYNC_RTV_CTRL 0x0f
+;
+;
+; *************************
+; *  INIT_USB.TXT SCRIPT  *
+; *************************
+;
+; *** Endpoint Config ***
+;
+DMA_ACC_EPS	0x3f
+EPS_ENABLE 0x7f
+;
+; *** FIFO Control ***
+;
+USB2TS_CTRL	0x0f
+TS2USB_CTRL	0x0f
+;
+; *** FREQ Control ***
+;
+USB2TS0_RDL	0x80
+USB2TS1_RDL	0x80
+;
+;-----------------------------------------------------------------------------
+; Set CAM power
+;-----------------------------------------------------------------------------
+;
+GPIO0_DATA_OUT	0x00
+;
+; unlock CFG
+CFG_2	0x00
+;
+; 1) DVB/CI/CI+/SCARD 2slot
+CFG_1	0x00
+;
+; 2) Set the Default "power off" state such as VCC_MODA=VCC_MODB=VPPx_MODA=VPPx_MODB='Z'
+GPIO0_DFT 0x00
+;
+; 3) Set GPIO3 as external power switch driver
+GPIO0_MASK_DATA 0x07
+;
+; 4) Set "power on" state (VCC=VPP1=VPP2= 5V)
+GPIO0_DATA_OUT	0x01
+;
+; 5) Lock config
+CFG_2	0x01
+;
+; 6) Write in the GPIO0_DIR_REG: defines the GPIOs, which
+;    are used to drive the external power switch, in output mode.
+GPIO0_DIR 0x07
+;
+; 7) Check VCCENable
+?CFG_1 0x20
+;
+; 8) Set & wait for PcmciaOutputEnable
+|CFG_1 0x08
+?CFG_1 0x08
+;
+;---------------------------------------
+; Set Router CAM
+;---------------------------------------
+;
+;
+GAP_REMOVER_CH0_CTRL 0x0C
+GAP_REMOVER_CH1_CTRL 0x0C
+
+; 9) CH0 & CH1 from CAM A & B, CAM A & B from CH0 & CH1
+;
+ROUTER_CAM_MOD	0x21
+ROUTER_CAM_CH	0x00
+;
+;_Wait	200
+;---------------------------------------
+; ROUTER CAM
+;---------------------------------------
+OUT_SEL 0x03
+;
+USB2TS0_RDL	0x80
+USB2TS1_RDL	0x80
+;
+IN_SEL 0x22
+
+; ***************************
+; *  MuliStream.TXT SCRIPT  *
+; ***************************
+;
+; *** CLOSE INPUT ***
+;
+IN_SEL 0x00
+;
+; *** CLOSE OUPUT ***
+;
+OUT_SEL 0x00
+;
+; *** RESET FIFO ***
+;
+FIFO_CTRL 0x0f
+SYNC_RTV_CTRL 0x0f
+;
+; ***   ***
+;
+CkMan_Config 0x1f
+CkMan_Select 0x00
+MERGER_DIV_MICLK 0x02
+SYNC_SYMBOL 0x0d
+PID_AND_SYNC_REMAPPER_INV_CTRL 0x01
+
+FIFO_CTRL 0x0f
+ROUTER_CAM_MOD 0x03
+ROUTER_CAM_CH 0x80
+
+USB2TS_CTRL 0x0f
+TS2USB_CTRL 0x0f
+USB2TS0_RDL 0x20
+USB2TS1_RDL 0x20
+
+OUT_SEL 0x03
+IN_SEL 0x22
+;
+; ************************
+;
diff --git a/drivers/stream_input/parser/esparser.c b/drivers/stream_input/parser/esparser.c
index c3d8857..3d0eb2b 100644
--- a/drivers/stream_input/parser/esparser.c
+++ b/drivers/stream_input/parser/esparser.c
@@ -442,13 +442,15 @@ s32 esparser_init(struct stream_buf_s *buf, struct vdec_s *vdec)
 
 		/* reset PARSER with first esparser_init() call */
 		WRITE_RESET_REG(RESET1_REGISTER, RESET_PARSER);
-
-		/* TS data path */
+/* for recorded file and local play, this can't change the input source*/
+/* TS data path */
+/*
 #ifndef CONFIG_AM_DVB
 		WRITE_DEMUX_REG(FEC_INPUT_CONTROL, 0);
 #else
 		tsdemux_set_reset_flag();
-#endif
+#endif  */
+
 		CLEAR_DEMUX_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
 		CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
 		CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_3, 1 << USE_HI_BSF_INTERFACE);
diff --git a/drivers/stream_input/parser/hw_demux/Makefile b/drivers/stream_input/parser/hw_demux/Makefile
index 594f78f..e031594 100644
--- a/drivers/stream_input/parser/hw_demux/Makefile
+++ b/drivers/stream_input/parser/hw_demux/Makefile
@@ -5,4 +5,4 @@ ccflags-y += -I$(srctree)/drivers/media/dvb-core -I$(srctree)/drivers/gpio -I$(s
 aml_hardware_dmx-objs += aml_dvb.o
 aml_hardware_dmx-objs += aml_dmx.o
 
-obj-y += dvb_ci/
+#obj-y += dvb_ci/
diff --git a/drivers/stream_input/parser/hw_demux/aml_dvb.c b/drivers/stream_input/parser/hw_demux/aml_dvb.c
index f24ce60..67c11bb 100644
--- a/drivers/stream_input/parser/hw_demux/aml_dvb.c
+++ b/drivers/stream_input/parser/hw_demux/aml_dvb.c
@@ -392,6 +392,12 @@ struct aml_dvb *aml_get_dvb_device(void)
 }
 EXPORT_SYMBOL(aml_get_dvb_device);
 
+struct dvb_adapter *aml_get_dvb_adapter(void)
+{
+	return &aml_dvb_device.dvb_adapter;
+}
+EXPORT_SYMBOL(aml_get_dvb_adapter);
+
 static int dvb_dsc_open(struct inode *inode, struct file *file)
 {
 	int err;
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.h b/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.h
index 43d0d16..1b04caf 100644
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.h
+++ b/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.h
@@ -1,3 +1,22 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
 #ifndef __AML_SPI_H_
 #define __AML_SPI_H_
 
diff --git a/drivers/stream_input/parser/psparser.c b/drivers/stream_input/parser/psparser.c
index 3197976..771314a 100644
--- a/drivers/stream_input/parser/psparser.c
+++ b/drivers/stream_input/parser/psparser.c
@@ -893,12 +893,15 @@ s32 psparser_init(u32 vid, u32 aid, u32 sid, struct vdec_s *vdec)
 
 	WRITE_RESET_REG(RESET1_REGISTER, RESET_PARSER);
 
+/* for recorded file and local play, this can't change the input source*/
 	/* TS data path */
+/*
 #ifndef CONFIG_AM_DVB
 	WRITE_DEMUX_REG(FEC_INPUT_CONTROL, 0);
 #else
 	tsdemux_set_reset_flag();
-#endif
+#endif */
+
 	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
 	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
 	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_3, 1 << USE_HI_BSF_INTERFACE);
diff --git a/drivers/stream_input/parser/rmparser.c b/drivers/stream_input/parser/rmparser.c
index 1c4aa78..9f7a1b0 100644
--- a/drivers/stream_input/parser/rmparser.c
+++ b/drivers/stream_input/parser/rmparser.c
@@ -69,12 +69,15 @@ s32 rmparser_init(struct vdec_s *vdec)
 
 	WRITE_RESET_REG(RESET1_REGISTER, RESET_PARSER);
 
+/* for recorded file and local play, this can't change the input source*/
 	/* TS data path */
+/*
 #ifndef CONFIG_AM_DVB
 	WRITE_DEMUX_REG(FEC_INPUT_CONTROL, 0);
 #else
 	tsdemux_set_reset_flag();
-#endif
+#endif */
+
 	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
 	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
 	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_3, 1 << USE_HI_BSF_INTERFACE);
