commit e075d11901639619b30a83b0185acbdc99a7a109
Author: Chuangcheng Peng <chuangcheng.peng@amlogic.com>
Date:   Mon Jun 24 13:52:11 2019 +0800

    dvb: update CI & delete old CI [1/1]
    
    PD#SWPL-10195
    
    Problem:
    update ci & delete old CI
    
    Solution:
    update ci & delete old CI
    
    Verify:
    verify at R314
    
    Change-Id: I0b4b5da35809500a67a52e74ae77a38f33a84d4c
    Signed-off-by: Chuangcheng Peng <chuangcheng.peng@amlogic.com>

diff --git a/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.c b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.c
index e8fb0ee..0f09799 100644
--- a/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.c
+++ b/drivers/stream_input/parser/dvb_ci/cimax/dvb_ca_en50221_cimax.c
@@ -32,6 +32,8 @@
 #include "dvb_ca_en50221_cimax.h"
 #include "dvb_ringbuffer.h"
 
+#define READ_LPDU_PKT
+
 static int dvb_ca_en50221_debug = 1;
 
 module_param_named(cam_debug, dvb_ca_en50221_debug, int, 0644);
@@ -43,6 +45,9 @@ static int dvb_ca_en50221_link_size = HOST_LINK_BUF_SIZE;
 module_param_named(link_size, dvb_ca_en50221_link_size, int, 0644);
 MODULE_PARM_DESC(link_size, "debug only, no more than 0x1000");
 
+static int dvb_ca_en50221_buffer_free;
+module_param_named(buffer_free, dvb_ca_en50221_buffer_free, int, 0644);
+MODULE_PARM_DESC(buffer_free, "debug only");
 
 #define dprintk(args...)\
 	do {\
@@ -115,6 +120,12 @@ struct dvb_ca_slot {
 	/* if 1, the CAM supports DA IRQs */
 	u8 da_irq_supported:1;
 
+#ifdef READ_LPDU_PKT
+	/* Offset into current ringbuffer when user buffer was not big enough
+	   to return entire pkt */
+	int rx_offset;
+#endif
+
 	/* size of the buffer to use when talking to the CAM */
 	int link_buf_size;
 
@@ -269,7 +280,9 @@ static int dvb_ca_en50221_link_init(struct dvb_ca_private *ca, int slot)
 
 	/* we'll be determining these during this function */
 	ca->slot_info[slot].da_irq_supported = 0;
-
+#ifdef READ_LPDU_PKT
+	ca->slot_info[slot].rx_offset = 0;
+#endif
 	/* set the host link buffer size temporarily.
 	   it will be overwritten with the real negotiated size later. */
 	ca->slot_info[slot].link_buf_size = dvb_ca_en50221_link_size;
@@ -605,6 +618,7 @@ static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca,
 			goto exit;
 		}
 		buf_free = dvb_ringbuffer_free(&ca->slot_info[slot].rx_buffer);
+		dvb_ca_en50221_buffer_free = buf_free;
 
 		if (buf_free < (ca->slot_info[slot].link_buf_size
 				+ DVB_RINGBUFFER_PKTHDRSIZE)) {
@@ -681,8 +695,10 @@ static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca,
 		memcpy(ebuf, buf, bytes_read);
 	}
 
+#ifndef READ_LPDU_PKT
 	/* wake up readers when a last_fragment is received */
 	if ((buf[1] & 0x80) == 0x00)
+#endif
 		wake_up_interruptible(&ca->wait_queue);
 	status = bytes_read;
 
@@ -1487,7 +1503,12 @@ static int dvb_ca_en50221_io_read_condition(struct dvb_ca_private *ca,
 
 		if (ca->slot_info[slot].rx_buffer.data == NULL)
 			return 0;
-
+#ifdef READ_LPDU_PKT
+		if (ca->slot_info[slot].rx_offset != 0) {
+			*_slot = slot;
+			return 1;
+		}
+#endif
 		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer,
 				-1, &fraglen);
 		while (idx != -1) {
@@ -1496,7 +1517,10 @@ static int dvb_ca_en50221_io_read_condition(struct dvb_ca_private *ca,
 			if (connection_id == -1)
 				connection_id = hdr[0];
 			if ((hdr[0] == connection_id)
-				&& ((hdr[1] & 0x80) == 0)) {
+#ifndef READ_LPDU_PKT
+				&& ((hdr[1] & 0x80) == 0)
+#endif
+			) {
 				*_slot = slot;
 				found = 1;
 				break;
@@ -1544,6 +1568,11 @@ static ssize_t dvb_ca_en50221_io_read(struct file *file, char __user *buf,
 	int pktlen;
 	int dispose = 0;
 
+#ifdef READ_LPDU_PKT
+	int offset;
+	u8 flag = 0;
+#endif
+
 	/* dprintk("%s\n", __func__); */
 
 	/* Outgoing packet has a 2 byte header.
@@ -1581,11 +1610,46 @@ static ssize_t dvb_ca_en50221_io_read(struct file *file, char __user *buf,
 			status = -EIO;
 			goto exit;
 		}
-
+#ifdef READ_LPDU_PKT
+		offset = 2 + ca->slot_info[slot].rx_offset;
+#endif
 		dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer,
 				idx, 0, hdr, 2);
 		if (connection_id == -1)
 			connection_id = hdr[0];
+#ifdef READ_LPDU_PKT
+		flag = hdr[1];
+		if (hdr[0] == connection_id) {
+			if (pktlen < count) {
+				if ((pktlen + fraglen - offset) > (count - 2)) {
+					fraglen = (count - 2) - pktlen;
+					ca->slot_info[slot].rx_offset +=
+									fraglen;
+					/* more data for user,
+					   but cannot send,
+					   so force return to user,
+					   rather than dispose of it */
+					flag |= 0x80;
+				} else {
+					ca->slot_info[slot].rx_offset = 0;
+					fraglen -= offset;
+					dispose = 1;
+				}
+
+				status = dvb_ringbuffer_pkt_read_user(
+					&ca->slot_info[slot].rx_buffer,
+					idx,
+					offset,
+					buf + pktlen + 2,
+					fraglen);
+				if (status < 0)
+					goto exit;
+				pktlen += fraglen;
+			}
+
+			last_fragment = 1;
+		}
+#else
 		if (hdr[0] == connection_id) {
 			if (pktlen < count) {
 				if ((pktlen + fraglen - 2) > count)
@@ -1608,7 +1672,7 @@ static ssize_t dvb_ca_en50221_io_read(struct file *file, char __user *buf,
 				last_fragment = 1;
 			dispose = 1;
 		}
-
+#endif
 		idx2 = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer,
 				idx, &fraglen);
 		if (dispose)
@@ -1627,6 +1691,17 @@ static ssize_t dvb_ca_en50221_io_read(struct file *file, char __user *buf,
 	}
 	status = pktlen;
 
+#ifdef READ_LPDU_PKT
+	hdr[0] = flag;
+	hdr[1] = 0;
+
+	status = copy_to_user(buf + 2, hdr, 2);
+	if (status) {
+		status = -EFAULT;
+		goto exit;
+	}
+	status = pktlen + 2;
+#endif
 exit:
 	return status;
 }
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/Makefile b/drivers/stream_input/parser/hw_demux/dvb_ci/Makefile
deleted file mode 100644
index bbfbdd4..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/Makefile
+++ /dev/null
@@ -1,15 +0,0 @@
-obj-m += ci.o cimax-usb.o
-
-ci-objs = $(amlci-objs) $(cimax-objs)
-
-amlci-objs = aml_pcmcia.o  aml_ci.o
-cimax-objs = cimax/dvb_ca_en50221_cimax.o cimax/aml_cimax.o  cimax/dvb_ringbuffer.o
-cimax-usb-objs += cimax/usb/SRC/cimax+usb-driver.o cimax/usb/SRC/cimax+usb_fw.o
-cimax-usb-objs += cimax/usb/SRC/cimax+usb_config.o
-cimax-objs += cimax/aml_cimax_usb.o
-
-ccflags-y += -I$(srctree)/
-ccflags-y += -I$(srctree)/include
-ccflags-y += -I$(srctree)/drivers/gpio
-ccflags-y += -I$(srctree)/drivers/media/dvb-core
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_ci.c b/drivers/stream_input/parser/hw_demux/dvb_ci/aml_ci.c
deleted file mode 100644
index c28d2fc..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_ci.c
+++ /dev/null
@@ -1,754 +0,0 @@
-/*
-* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful, but WITHOUT
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-* more details.
-*
-* You should have received a copy of the GNU General Public License along
-* with this program; if not, write to the Free Software Foundation, Inc.,
-* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*
-* Description:
-*/
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include "aml_ci.h"
-#include "aml_spi.h"
-#include "cimax/aml_cimax.h"
-
-MODULE_PARM_DESC(aml_ci_debug, "\n\t\t dvb ci debug");
-static int aml_ci_debug = 1;
-module_param(aml_ci_debug, int, S_IRUGO);
-
-#define pr_dbg(args...)\
-	do {\
-		if (aml_ci_debug)\
-			printk(args);\
-	} while (0)
-#define pr_error(fmt, args...) printk("DVBCI: " fmt, ## args)
-/**\brief aml_ci_mem_read:mem read from cam
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param addr: read addr
- * \return
- *   - read value:ok
- *   - -EINVAL : error
- */
-static int aml_ci_mem_read(struct dvb_ca_en50221 *en50221, int slot, int addr)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_mem_read != NULL)
-		return ci->ci_mem_read(ci, slot, addr);
-
-	pr_error("ci_mem_read is null %s\r\n", __func__);
-	return -EINVAL;
-}
-/**\brief aml_ci_mem_write:mem write to cam
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param addr: write addr
- * \param addr: write value
- * \return
- *   - 0:ok
- *   - -EINVAL : error
- */
-static int aml_ci_mem_write(struct dvb_ca_en50221 *en50221,
-		int slot, int addr, u8 data)
-{
-
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot not 0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_mem_write != NULL)
-		return ci->ci_mem_write(ci, slot, addr, data);
-	pr_error("ci_mem_write is null %s\r\n", __func__);
-	return -EINVAL;
-}
-/**\brief aml_ci_io_read:io read from cam
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param addr: read addr
- * \return
- *   - read value:ok
- *   - -EINVAL : error
- */
-static int aml_ci_io_read(struct dvb_ca_en50221 *en50221, int slot, u8 addr)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_io_read != NULL)
-		return ci->ci_io_read(ci, slot, addr);
-
-	pr_error("ci_io_read is null %s\r\n", __func__);
-	return -EINVAL;
-}
-/**\brief aml_ci_io_write:io write to cam
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param addr: write addr
- * \param addr: write value
- * \return
- *   - 0:ok
- *   - -EINVAL : error
- */
-static int aml_ci_io_write(struct dvb_ca_en50221 *en50221,
-		int slot, u8 addr, u8 data)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_mem_write != NULL)
-		return ci->ci_io_write(ci, slot, addr, data);
-
-	pr_error("ci_io_write is null %s\r\n", __func__);
-	return -EINVAL;
-}
-/**\brief aml_ci_slot_reset:reset slot
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \return
- *   - 0:ok
- *   - -EINVAL : error
- */
-static int aml_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)
-{
-	struct aml_ci *ci = en50221->data;
-	pr_dbg("Slot(%d): Slot RESET\n", slot);
-	if (ci->ci_slot_reset != NULL) {
-		ci->ci_slot_reset(ci, slot);
-	} else {
-		pr_error("ci_slot_reset is null %s\r\n", __func__);
-		return -EINVAL;
-	}
-	return 0;
-}
-/**\brief aml_ci_slot_shutdown:show slot
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \return
- *   - 0:ok
- *   - -EINVAL : error
- */
-static int aml_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)
-{
-	struct aml_ci *ci = en50221->data;
-	pr_dbg("Slot(%d): Slot shutdown\n", slot);
-	if (ci->ci_slot_shutdown != NULL) {
-		ci->ci_slot_shutdown(ci, slot);
-	} else {
-		pr_error("aml_ci_slot_shutdown is null %s\r\n", __func__);
-		return -EINVAL;
-	}
-	return 0;
-}
-/**\brief aml_ci_ts_control:control slot ts
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \return
- *   - 0:ok
- *   - -EINVAL : error
- */
-static int aml_ci_ts_control(struct dvb_ca_en50221 *en50221, int slot)
-{
-
-		struct aml_ci *ci = en50221->data;
-		pr_dbg("Slot(%d): TS control\n", slot);
-		if (ci->ci_slot_ts_enable != NULL) {
-			ci->ci_slot_ts_enable(ci, slot);
-		} else {
-			pr_error("aml_ci_ts_control is null %s\r\n", __func__);
-			return -EINVAL;
-		}
-		return 0;
-}
-/**\brief aml_ci_slot_status:get slot status
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param open: no used
- * \return
- *   - cam status
- *   - -EINVAL : error
- */
-static int aml_ci_slot_status(struct dvb_ca_en50221 *en50221,
-		int slot, int open)
-{
-	struct aml_ci *ci = en50221->data;
-
-	pr_dbg("Slot(%d): Poll Slot status\n", slot);
-
-	if (ci->ci_poll_slot_status != NULL) {
-		return ci->ci_poll_slot_status(ci, slot, open);
-	} else {
-		pr_error("ci_poll_slot_status is null %s\r\n", __func__);
-		return -EINVAL;
-	}
-
-	return -EINVAL;
-}
-static int aml_ci_cimax_slot_reset(struct dvb_ca_en50221_cimax *en50221,
-		int slot)
-{
-	struct aml_ci *ci = en50221->data;
-	pr_dbg("Slot(%d): Slot RESET\n", slot);
-	if (ci->ci_slot_reset != NULL) {
-		ci->ci_slot_reset(ci, slot);
-	} else {
-		pr_error("ci_slot_reset is null %s\r\n", __func__);
-		return -EINVAL;
-	}
-	return 0;
-}
-/**\brief aml_ci_slot_shutdown:show slot
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \return
- *   - 0:ok
- *   - -EINVAL : error
- */
-static int aml_ci_cimax_slot_shutdown(struct dvb_ca_en50221_cimax *en50221,
-		int slot)
-{
-	struct aml_ci *ci = en50221->data;
-	pr_dbg("Slot(%d): Slot shutdown\n", slot);
-	if (ci->ci_slot_shutdown != NULL) {
-		ci->ci_slot_shutdown(ci, slot);
-	} else {
-		pr_error("aml_ci_slot_shutdown is null %s\r\n", __func__);
-		return -EINVAL;
-	}
-	return 0;
-}
-/**\brief aml_ci_ts_control:control slot ts
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \return
- *   - 0:ok
- *   - -EINVAL : error
- */
-static int aml_ci_cimax_ts_control(struct dvb_ca_en50221_cimax *en50221,
-		int slot)
-{
-
-	struct aml_ci *ci = en50221->data;
-	pr_dbg("Slot(%d): TS control\n", slot);
-	if (ci->ci_slot_ts_enable != NULL) {
-		ci->ci_slot_ts_enable(ci, slot);
-	} else {
-		pr_error("aml_ci_ts_control is null %s\r\n", __func__);
-		return -EINVAL;
-	}
-	return 0;
-}
-/**\brief aml_ci_slot_status:get slot status
- * \param en50221: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param open: no used
- * \return
- *   - cam status
- *   - -EINVAL : error
- */
-static int aml_ci_cimax_slot_status(
-	struct dvb_ca_en50221_cimax *en50221, int slot, int open)
-{
-	struct aml_ci *ci = en50221->data;
-
-	/*pr_dbg("Slot(%d): Poll Slot status\n", slot);*/
-
-	if (ci->ci_poll_slot_status != NULL) {
-		return ci->ci_poll_slot_status(ci, slot, open);
-	} else {
-		pr_error("ci_poll_slot_status is null %s\r\n", __func__);
-		return -EINVAL;
-	}
-
-	return -EINVAL;
-}
-
-/**\brief aml_ci_read_cis: read cis
- * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param buf: buf for cis data
- * \param size: buf size
- * \return
- *   --EINVAL : error
- *   -        : actual size read
- */
-static int aml_ci_read_cis(struct dvb_ca_en50221_cimax *en50221,
-		int slot, u8 *buf, int size)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_read_cis != NULL)
-		return ci->ci_read_cis(ci, slot, buf, size);
-
-	pr_error("ci_read_cis is null %s\r\n", __func__);
-	return -EINVAL;
-}
-/**\brief aml_ci_write_cor: write cor
- * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param addr:
- * \param buf:
- * \return
- *   --EINVAL : error
- *   -0       : ok
- */
-static int aml_ci_write_cor(struct dvb_ca_en50221_cimax *en50221,
-		int slot, int address, u8 *buf)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_write_cor != NULL)
-		return ci->ci_write_cor(ci, slot, address, buf);
-
-	pr_error("ci_write_cor is null %s\r\n", __func__);
-	return -EINVAL;
-}
-/**\brief aml_ci_negociate: negotiate
- * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param size: suggested size
- * \return
- *   --EINVAL : error
- *   -        : size negotiated
- */
-static int aml_ci_negotiate(struct dvb_ca_en50221_cimax *en50221,
-		int slot, int size)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_negotiate != NULL)
-		return ci->ci_negotiate(ci, slot, size);
-
-	pr_error("ci_negotiate is null %s\r\n", __func__);
-	return -EINVAL;
-}
-/**\brief aml_ci_read_lpdu: read lpdu
- * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param buf:  buf
- * \param size: buf size
- * \return
- *   --EINVAL : error
- *   -        : size read
- */
-static int aml_ci_read_lpdu(struct dvb_ca_en50221_cimax *en50221,
-		int slot, u8 *buf, int size)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_read_lpdu != NULL)
-		return ci->ci_read_lpdu(ci, slot, buf, size);
-
-	pr_error("ci_read_lpdu is null %s\r\n", __func__);
-	return -EINVAL;
-}
-
-/**\brief aml_ci_write_lpdu: write lpdu
- * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \param buf:  buf
- * \param size: write size
- * \return
- *   --EINVAL : error
- *   -        : size written
- */
-static int aml_ci_write_lpdu(struct dvb_ca_en50221_cimax *en50221,
-		int slot, u8 *buf, int size)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_write_lpdu != NULL)
-		return ci->ci_write_lpdu(ci, slot, buf, size);
-
-	pr_error("ci_write_lpdu is null %s\r\n", __func__);
-	return -EINVAL;
-}
-
-static int aml_ci_read_cam_status(struct dvb_ca_en50221_cimax *en50221,
-		int slot)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_read_cam_status != NULL)
-		return ci->ci_read_cam_status(ci, slot);
-
-	pr_error("ci_read_cam_status is null %s\r\n", __func__);
-	return -EINVAL;
-}
-
-static int aml_ci_cam_reset(struct dvb_ca_en50221_cimax *en50221, int slot)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_cam_reset != NULL)
-		return ci->ci_cam_reset(ci, slot);
-
-	pr_error("ci_cam_reset is null %s\r\n", __func__);
-	return -EINVAL;
-}
-
-/**\brief aml_ci_get_capbility
- * \param en50221_max: en50221 obj,used this data to get dvb_ci obj
- * \param slot: slot index
- * \return
- *   -        : capbilities
- */
-static int aml_ci_get_capbility(struct dvb_ca_en50221_cimax *en50221, int slot)
-{
-	struct aml_ci *ci = en50221->data;
-
-	if (slot != 0) {
-		pr_error("slot !=0 %s :%d\r\n", __func__, slot);
-		return -EINVAL;
-	}
-
-	if (ci->ci_get_capbility != NULL)
-		return ci->ci_get_capbility(ci, slot);
-
-	pr_error("ci_get_capbility is null %s\r\n", __func__);
-	return -EINVAL;
-}
-
-
-/**\brief get ci config from dts
- * \param np: device node
- * \return
- *   - 0 成功
- *   - 其他值 :
- */
-static int aml_ci_get_config_from_dts(struct platform_device *pdev,
-		struct aml_ci *ci)
-{
-	char buf[32];
-	int ret = 0;
-	int value;
-
-	snprintf(buf, sizeof(buf), "%s", "io_type");
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		pr_dbg("%s: 0x%x\n", buf, value);
-		ci->io_type = value;
-	}
-	return 0;
-}
-
-/**\brief aml_ci_init:ci dev init
- * \param pdev: platform_device device node,used to get dts info
- * \param dvb: aml_dvb obj,used to get dvb_adapter for en0211 to use
- * \param cip: ci_dev pp
- * \return
- *   - 0 成功
- *   - 其他值 :
- */
-int aml_ci_init(struct platform_device *pdev,
-	struct aml_dvb *dvb, struct aml_ci **cip)
-{
-	struct dvb_adapter *dvb_adapter	= &dvb->dvb_adapter;
-	struct aml_ci *ci = NULL;
-	int ca_flags = 0, result;
-
-	ci = kzalloc(sizeof(struct aml_ci), GFP_KERNEL);
-	if (!ci) {
-		pr_error("Out of memory!, exiting ..\n");
-		result = -ENOMEM;
-		goto err;
-	}
-	ci->id = 0;
-	aml_ci_get_config_from_dts(pdev, ci);
-
-	ci->priv		= dvb;
-	/* register CA interface */
-	if (ci->io_type == AML_DVB_IO_TYPE_CIMAX) {
-		ci->en50221_cimax.owner = THIS_MODULE;
-		ci->en50221_cimax.read_cis = aml_ci_read_cis;
-		ci->en50221_cimax.write_cor = aml_ci_write_cor;
-		ci->en50221_cimax.negotiate = aml_ci_negotiate;
-		ci->en50221_cimax.read_lpdu = aml_ci_read_lpdu;
-		ci->en50221_cimax.write_lpdu = aml_ci_write_lpdu;
-		ci->en50221_cimax.read_cam_status = aml_ci_read_cam_status;
-		ci->en50221_cimax.cam_reset = aml_ci_cam_reset;
-		ci->en50221_cimax.get_capbility = aml_ci_get_capbility;
-		ci->en50221_cimax.slot_reset = aml_ci_cimax_slot_reset;
-		ci->en50221_cimax.slot_shutdown = aml_ci_cimax_slot_shutdown;
-		ci->en50221_cimax.slot_ts_enable = aml_ci_cimax_ts_control;
-		ci->en50221_cimax.poll_slot_status = aml_ci_cimax_slot_status;
-		ci->en50221_cimax.data = ci;
-
-		pr_dbg("Registering EN50221 CIMAX device\n");
-		result = dvb_ca_en50221_cimax_init(dvb_adapter,
-			&ci->en50221_cimax, ca_flags, 1);
-		if (result != 0) {
-			pr_error("EN50221 CIMAX: Initialization failed <%d>\n",
-				result);
-			goto err;
-		}
-	} else {
-		ca_flags		= DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE;
-		ci->en50221.read_attribute_mem	= aml_ci_mem_read;
-		ci->en50221.write_attribute_mem	= aml_ci_mem_write;
-		ci->en50221.read_cam_control	= aml_ci_io_read;
-		ci->en50221.write_cam_control	= aml_ci_io_write;
-		ci->en50221.slot_reset		= aml_ci_slot_reset;
-		ci->en50221.slot_shutdown	= aml_ci_slot_shutdown;
-		ci->en50221.slot_ts_enable	= aml_ci_ts_control;
-		ci->en50221.poll_slot_status	= aml_ci_slot_status;
-		ci->en50221.data		= ci;
-
-
-		pr_dbg("Registering EN50221 device\n");
-		result = dvb_ca_en50221_init(dvb_adapter,
-			&ci->en50221, ca_flags, 1);
-		if (result != 0) {
-			pr_error("EN50221: Initialization failed <%d>\n",
-				result);
-			goto err;
-		}
-	}
-	*cip = ci;
-	pr_dbg("Registered EN50221 device\n");
-
-	if (ci->io_type == AML_DVB_IO_TYPE_SPI) {
-		/* spi init */
-		//ci->ci_init = aml_spi_init;
-		//ci->ci_exit = aml_spi_exit;
-	} else if (ci->io_type == AML_DVB_IO_TYPE_CIMAX) {
-		ci->ci_init = aml_cimax_init;
-		ci->ci_exit = aml_cimax_exit;
-	} else {
-		/* no io dev init,is error */
-		pr_dbg("unknown io type, please check io_type in dts file\r\n");
-	}
-
-	if (ci->ci_init)
-		result = ci->ci_init(pdev, ci);
-
-	if (result)
-		dvb_ca_en50221_cimax_release(&ci->en50221_cimax);
-
-	return result;
-err:
-	kfree(ci);
-	return result;
-}
-
-void aml_ci_exit(struct aml_ci *ci)
-{
-	pr_dbg("Unregistering EN50221 device\n");
-	if (ci) {
-		if (ci->io_type == AML_DVB_IO_TYPE_CIMAX)
-			dvb_ca_en50221_cimax_release(&ci->en50221_cimax);
-		else
-			dvb_ca_en50221_release(&ci->en50221);
-		if (ci->ci_exit)
-			ci->ci_exit(ci);
-		kfree(ci);
-	}
-}
-
-static struct aml_ci *ci_dev;
-
-static ssize_t aml_ci_ts_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-		int ret;
-		ret = sprintf(buf, "ts%d\n", 1);
-	return ret;
-}
-
-static struct class_attribute amlci_class_attrs[] = {
-	__ATTR(ts,  S_IRUGO | S_IWUSR, aml_ci_ts_show, NULL),
-	__ATTR_NULL
-};
-
-static int aml_ci_register_class(struct aml_ci *ci)
-{
-	#define CLASS_NAME_LEN 48
-	int ret;
-	struct class *clp;
-
-	clp = &(ci->class);
-
-	clp->name = kzalloc(CLASS_NAME_LEN, GFP_KERNEL);
-	if (!clp->name)
-		return -ENOMEM;
-
-	snprintf((char *)clp->name, CLASS_NAME_LEN, "amlci-%d", ci->id);
-	clp->owner = THIS_MODULE;
-	clp->class_attrs = amlci_class_attrs;
-	ret = class_register(clp);
-	if (ret)
-		kfree(clp->name);
-
-	return 0;
-}
-
-static int aml_ci_unregister_class(struct aml_ci *ci)
-{
-	class_unregister(&ci->class);
-	kzfree(ci->class.name);
-	return 0;
-}
-
-
-static int aml_ci_probe(struct platform_device *pdev)
-{
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	int err = 0;
-	pr_dbg("---Amlogic CI Init---\n");
-	err = aml_ci_init(pdev, dvb, &ci_dev);
-	if (err < 0)
-		return err;
-	platform_set_drvdata(pdev, ci_dev);
-	aml_ci_register_class(ci_dev);
-	return 0;
-}
-
-static int aml_ci_remove(struct platform_device *pdev)
-{
-	aml_ci_unregister_class(ci_dev);
-	platform_set_drvdata(pdev, NULL);
-	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI) {
-		//aml_spi_exit(ci_dev);
-		}
-	else if (ci_dev->io_type == AML_DVB_IO_TYPE_CIMAX)
-		aml_cimax_exit(ci_dev);
-	else
-		pr_dbg("---Amlogic CI remove unkown io type---\n");
-
-	aml_ci_exit(ci_dev);
-	return 0;
-}
-
-static int aml_ci_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	pr_dbg("Amlogic CI Suspend!\n");
-	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI) {
-		//aml_spi_exit(ci_dev);
-		}
-	else if (ci_dev->io_type == AML_DVB_IO_TYPE_CIMAX)
-		aml_cimax_exit(ci_dev);
-	else
-		pr_dbg("---Amlogic CI remove unkown io type---\n");
-
-	return 0;
-}
-
-static int aml_ci_resume(struct platform_device *pdev)
-{
-	int err = 0;
-	pr_dbg("Amlogic CI Resume!\n");
-	if (ci_dev->io_type == AML_DVB_IO_TYPE_SPI) {
-		//aml_spi_init(pdev, ci_dev);
-		}
-	else if (ci_dev->io_type == AML_DVB_IO_TYPE_CIMAX)
-		aml_cimax_init(pdev, ci_dev);
-	else
-		pr_dbg("---Amlogic CI remove unkown io type---\n");
-	return err;
-}
-
-static const struct of_device_id dvbci_dev_dt_match[] = {
-	{
-		.compatible = "amlogic, dvbci",
-	},
-	{},
-};
-
-
-
-static struct platform_driver aml_ci_driver = {
-	.probe		= aml_ci_probe,
-	.remove		= aml_ci_remove,
-	.suspend        = aml_ci_suspend,
-	.resume         = aml_ci_resume,
-	.driver		= {
-		.name	= "dvbci",
-		.of_match_table = dvbci_dev_dt_match,
-		.owner	= THIS_MODULE,
-	}
-};
-
-static int  aml_ci_mod_init(void)
-{
-	pr_dbg("Amlogic CI mode init\n");
-	return platform_driver_register(&aml_ci_driver);
-}
-
-static void  aml_ci_mod_exit(void)
-{
-	pr_dbg("Amlogic CI mode Exit\n");
-	platform_driver_unregister(&aml_ci_driver);
-}
-
-module_init(aml_ci_mod_init);
-module_exit(aml_ci_mod_exit);
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_ci.h b/drivers/stream_input/parser/hw_demux/dvb_ci/aml_ci.h
deleted file mode 100644
index 3e34417..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_ci.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
-* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful, but WITHOUT
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-* more details.
-*
-* You should have received a copy of the GNU General Public License along
-* with this program; if not, write to the Free Software Foundation, Inc.,
-* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*
-* Description:
-*/
-
-#ifndef __AML_CI_H_
-#define __AML_CI_H_
-
-#include "drivers/media/dvb-core/dvb_ca_en50221.h"
-#include "cimax/dvb_ca_en50221_cimax.h"
-#include "../aml_dvb.h"
-
-enum aml_dvb_io_type_e {
-	AML_DVB_IO_TYPE_IOBUS = 0,
-	AML_DVB_IO_TYPE_SPI,
-	AML_DVB_IO_TYPE_CIMAX,
-	AML_DVB_IO_TYPE_MAX,
-};
-
-struct aml_ci {
-	struct dvb_ca_en50221		en50221;
-	struct mutex			ci_lock;
-	int				io_type;
-	void				*priv;
-	int				id;
-	struct class			class;
-
-	int (*ci_init)(struct platform_device *pdev, struct aml_ci *ci);
-	int (*ci_exit)(struct aml_ci *ci);
-
-	/* NOTE: the read_*, write_* and poll_slot_status functions will be
-	 * called for different slots concurrently and need to use locks where
-	 * and if appropriate. There will be no concurrent access to one slot.
-	 */
-
-	/* functions for accessing attribute memory on the CAM */
-	int (*ci_mem_read)(struct aml_ci *ca, int slot, int address);
-	int (*ci_mem_write)(struct aml_ci *ca, int slot, int address, u8 value);
-
-	/* functions for accessing the control interface on the CAM */
-	int (*ci_io_read)(struct aml_ci *ca, int slot, int address);
-	int (*ci_io_write)(struct aml_ci *ca, int slot, int address, u8 value);
-
-	/* Functions for controlling slots */
-	int (*ci_slot_reset)(struct aml_ci *ca, int slot);
-	int (*ci_slot_shutdown)(struct aml_ci *ca, int slot);
-	int (*ci_slot_ts_enable)(struct aml_ci *ca, int slot);
-
-	/*
-	* Poll slot status.
-	* Only necessary if DVB_CA_FLAG_EN50221_IRQ_CAMCHANGE is not set
-	*/
-	int (*ci_poll_slot_status)(struct aml_ci *ca, int slot, int open);
-
-
-	struct dvb_ca_en50221_cimax en50221_cimax;
-
-	int (*ci_read_cis)(struct aml_ci *ca, int slot, u8 *buf, int size);
-	int (*ci_write_cor)(struct aml_ci *ca, int slot, int address, u8 *buf);
-      /*return the final size or -1 for error*/
-	int (*ci_negotiate)(struct aml_ci *ca, int slot, int size);
-
-	/* functions for accessing the control interface on the CAM */
-	int (*ci_read_lpdu)(struct aml_ci *ca, int slot, u8 *buf, int size);
-	int (*ci_write_lpdu)(struct aml_ci *ca, int slot, u8 *buf, int size);
-
-	int (*ci_get_capbility)(struct aml_ci *ca, int slot);
-
-	int (*ci_cam_reset)(struct aml_ci *ca, int slot);
-	int (*ci_read_cam_status)(struct aml_ci *ca, int slot);
-
-	/* private data, used by caller */
-	void *data;
-};
-
-struct ci_dev_config_s {
-	char name[20];
-	unsigned char type;
-	int cs_hold_delay;
-	int cs_clk_delay;
-};
-extern int aml_ci_init(struct platform_device *pdev,
-		struct aml_dvb *dvb, struct aml_ci **cip);
-extern void aml_ci_exit(struct aml_ci *ci);
-
-#endif /* __AML_CI_H_ */
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_pcmcia.c b/drivers/stream_input/parser/hw_demux/dvb_ci/aml_pcmcia.c
deleted file mode 100644
index ac8c87d..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_pcmcia.c
+++ /dev/null
@@ -1,199 +0,0 @@
-
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-
-#include "aml_pcmcia.h"
-
-static int aml_pcmcia_debug = 1;
-
-module_param_named(pcmcia_debug, aml_pcmcia_debug, int, 0644);
-MODULE_PARM_DESC(pcmcia_debug, "enable verbose debug messages");
-
-#define pr_dbg(args...)\
-	do {\
-		if (aml_pcmcia_debug)\
-			printk(args);\
-	} while (0)
-#define pr_error(fmt, args...) printk("PCMCIA: " fmt, ## args)
-
-
-static int pcmcia_plugin(struct aml_pcmcia *pc)
-{
-	if (pc->slot_state == MODULE_XTRACTED) {
-		pr_dbg(" CAM Plugged IN: Adapter(%d) Slot(0)\n", 0);
-		udelay(50);
-		aml_pcmcia_reset(pc);
-		/*wait unplug*/
-		pc->init_irq(pc, IRQF_TRIGGER_RISING);
-		udelay(500);
-		pc->slot_state = MODULE_INSERTED;
-	} else {
-		pr_error("repeat into pcmcia insert \r\n");
-		aml_pcmcia_reset(pc);
-	}
-	udelay(100);
-	pc->pcmcia_plugin(pc, 1);
-
-	return 0;
-}
-
-static int pcmcia_unplug(struct aml_pcmcia *pc)
-{
-	if (pc->slot_state == MODULE_INSERTED) {
-		pr_dbg(" CAM Unplugged: Adapter(%d) Slot(0)\n", 0);
-		/*udelay(50);*/
-		/*aml_pcmcia_reset(pc);*/
-		/*wait plugin*/
-		pc->init_irq(pc, IRQF_TRIGGER_FALLING);
-		udelay(500);
-		pc->slot_state = MODULE_XTRACTED;
-	}
-	udelay(100);
-	pc->pcmcia_plugin(pc, 0);
-
-	return 0;
-}
-
-static irqreturn_t pcmcia_irq_handler(int irq, void *dev_id)
-{
-	struct aml_pcmcia *pc = (struct aml_pcmcia *)dev_id;
-	pr_dbg("pcmcia_irq_handler--into--\r\n");
-	disable_irq_nosync(pc->irq);
-	schedule_work(&pc->pcmcia_work);
-	enable_irq(pc->irq);
-	return IRQ_HANDLED;
-}
-
-static void aml_pcmcia_work(struct work_struct *work)
-{
-	int cd1, cd2;
-	struct aml_pcmcia *pc = container_of(
-		work, struct aml_pcmcia, pcmcia_work);
-
-	cd1 = pc->get_cd1(pc);
-	cd2 = pc->get_cd2(pc);
-
-	if (cd1 != cd2)
-		pr_error("CAM card not inerted.\n");
-	else {
-		if (!cd1) {
-			pr_error("Adapter(%d) Slot(0): CAM Plugin\n", 0);
-			pcmcia_plugin(pc);
-		} else {
-			pr_error("Adapter(%d) Slot(0): CAM Unplug\n", 0);
-			pcmcia_unplug(pc);
-		}
-	}
-}
-
-static struct aml_pcmcia *pc_cur;
-
-int aml_pcmcia_init(struct aml_pcmcia *pc)
-{
-	int err = 0;
-	pr_dbg("aml_pcmcia_init start pc->irq=%d\r\n", pc->irq);
-	pc->rst(pc, AML_L);
-	/*power on*/
-	pc->pwr(pc, AML_PWR_OPEN);/*hi is open power*/
-	/*assuming cam unpluged, config the INT to waiting-for-plugin mode*/
-	pc->init_irq(pc, IRQF_TRIGGER_LOW);
-
-	INIT_WORK(&pc->pcmcia_work, aml_pcmcia_work);
-
-	err = request_irq(pc->irq,
-	pcmcia_irq_handler,
-	IRQF_ONESHOT, "aml-pcmcia", pc);
-	if (err != 0) {
-		pr_error("ERROR: IRQ registration failed ! <%d>", err);
-		return -ENODEV;
-	}
-
-	pc_cur = pc;
-	pr_dbg("aml_pcmcia_init ok\r\n");
-	return 0;
-}
-EXPORT_SYMBOL(aml_pcmcia_init);
-
-int aml_pcmcia_exit(struct aml_pcmcia *pc)
-{
-	free_irq(pc->irq, pc);
-	return 0;
-}
-EXPORT_SYMBOL(aml_pcmcia_exit);
-
-int aml_pcmcia_reset(struct aml_pcmcia *pc)
-{
-		pr_dbg("CAM RESET-->\n");
-		/* viaccess neotion cam need delay 2000 and 3000 */
-		/* smit cam need delay 1000 and 1500 */
-		/* need change delay according cam vendor */
-		pc->rst(pc, AML_H);/*HI is reset*/
-		mdelay(1000);
-		pc->rst(pc, AML_L);/*defaule LOW*/
-		pr_dbg("CAM RESET--\n");
-		mdelay(1500);
-		pr_dbg("CAM RESET--end\n");
-	return 0;
-}
-EXPORT_SYMBOL(aml_pcmcia_reset);
-
-
-#if 0
-static ssize_t aml_pcmcia_test_cmd(struct class *class,
-struct class_attribute *attr, const char *buf, size_t size)
-{
-	pr_dbg("pcmcia cmd: %s\n", buf);
-	if (pc_cur) {
-		if (memcmp(buf, "reset", 5) == 0)
-			aml_pcmcia_reset(pc_cur);
-		else if (memcmp(buf, "on", 2) == 0)
-			pc_cur->pwr(pc_cur, AML_PWR_OPEN);
-		else if (memcmp(buf, "off", 3) == 0)
-			pc_cur->pwr(pc_cur, AML_PWR_CLOSE);
-		else if (memcmp(buf, "poll", 4) == 0)
-			schedule_work(&pc_cur->pcmcia_work);
-		else if (memcmp(buf, "intr", 4) == 0)
-			pc_cur->init_irq(pc_cur, IRQF_TRIGGER_RISING);
-		else if (memcmp(buf, "intf", 4) == 0)
-			pc_cur->init_irq(pc_cur, IRQF_TRIGGER_FALLING);
-	}
-	return size;
-}
-
-static struct class_attribute aml_pcmcia_class_attrs[] = {
-	__ATTR(cmd,  S_IRUGO | S_IWUSR, NULL, aml_pcmcia_test_cmd),
-	__ATTR_NULL
-};
-
-static struct class aml_pcmcia_class = {
-	.name = "aml_pcmcia_test",
-	.class_attrs = aml_pcmcia_class_attrs,
-};
-
-static int __init aml_pcmcia_mod_init(void)
-{
-	pr_dbg("Amlogic PCMCIA Init\n");
-
-	class_register(&aml_pcmcia_class);
-
-	return 0;
-}
-
-static void __exit aml_pcmcia_mod_exit(void)
-{
-	pr_dbg("Amlogic PCMCIA Exit\n");
-
-	class_unregister(&aml_pcmcia_class);
-}
-
-
-
-module_init(aml_pcmcia_mod_init);
-module_exit(aml_pcmcia_mod_exit);
-
-MODULE_LICENSE("GPL");
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_pcmcia.h b/drivers/stream_input/parser/hw_demux/dvb_ci/aml_pcmcia.h
deleted file mode 100644
index 612d577..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_pcmcia.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
-* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful, but WITHOUT
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-* more details.
-*
-* You should have received a copy of the GNU General Public License along
-* with this program; if not, write to the Free Software Foundation, Inc.,
-* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*
-* Description:
-*/
-
-#ifndef _AML_PCMCIA_
-#define _AML_PCMCIA_
-
-enum aml_slot_state {
-	MODULE_INSERTED			= 3,
-	MODULE_XTRACTED			= 4
-};
-
-enum aml_pwr_cmd {
-	AML_PWR_OPEN			= 0,
-	AML_PWR_CLOSE			= 1
-};
-enum aml_reset_cmd {
-	AML_L	    = 0,
-	AML_H		= 1
-};
-struct aml_pcmcia {
-	enum aml_slot_state		slot_state;
-	struct work_struct		pcmcia_work;
-	int run_type;/*0：irq;1:poll*/
-	int irq;
-	int (*init_irq)(struct aml_pcmcia *pc, int flag);
-	int (*get_cd1)(struct aml_pcmcia *pc);
-	int (*get_cd2)(struct aml_pcmcia *pc);
-	int (*pwr)(struct aml_pcmcia *pc, int enable);
-	int (*rst)(struct aml_pcmcia *pc, int enable);
-
-	int (*pcmcia_plugin)(struct aml_pcmcia *pc, int plugin);
-
-	void *priv;
-};
-
-int aml_pcmcia_init(struct aml_pcmcia *pc);
-int aml_pcmcia_exit(struct aml_pcmcia *pc);
-int aml_pcmcia_reset(struct aml_pcmcia *pc);
-
-
-#endif /*_AML_PCMCIA_*/
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.c b/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.c
deleted file mode 100644
index 62f4f53..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.c
+++ /dev/null
@@ -1,1666 +0,0 @@
-/*
-* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful, but WITHOUT
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-* more details.
-*
-* You should have received a copy of the GNU General Public License along
-* with this program; if not, write to the Free Software Foundation, Inc.,
-* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*
-* Description:
-*/
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/gpio/consumer.h>
-#include <linux/device.h>
-#include <linux/slab.h>
-#include <linux/amlogic/sd.h>
-#include <linux/of_irq.h>
-#include <linux/irq.h>
-#include "aml_spi.h"
-#include "aml_ci.h"
-
-#define AML_MODE_NAME       "aml_dvbci_spi"
-static int  AML_CI_GPIO_IRQ_BASE = 251;
-static struct aml_spi *g_spi_dev;
-static int aml_spi_debug = 1;
-static int G_rec_flag = AM_SPI_STEP_INIT;
-
-
-module_param_named(spi_debug, aml_spi_debug, int, 0644);
-MODULE_PARM_DESC(spi_debug, "enable verbose debug messages");
-
-
-#define pr_dbg(args...)\
-	do {\
-		if (aml_spi_debug)\
-			printk(args);\
-	} while (0)
-#define pr_error(fmt, args...) printk("AML_CI_SPI: " fmt, ## args)
-
-struct spi_board_info aml_ci_spi_bdinfo = {
-	.modalias = "ci_spi_dev",
-	.mode = SPI_MODE_0,
-	.max_speed_hz = 1000000, /* 1MHz */
-	.bus_num = 0, /* SPI bus No. */
-	.chip_select = 0, /* the device index on the spi bus */
-	.controller_data = NULL,
-};
-
-#define NORMAL_MSG      (0<<7)
-#define BROADCAST_MSG   (1<<7)
-#define BLOCK_DATA      (0<<6)
-#define SINGLE_DATA     (1<<6)
-#define CISPI_DEV_ADDR  1
-
-#define INPUT 0
-#define OUTPUT 1
-#define OUTLEVEL_LOW 0
-#define OUTLEVEL_HIGH 1
-#define PULLLOW 1
-#define PULLHIGH 0
-
-/*
-sendbuf data struct
-----------------------------------------------------
-|start flag| cmd   | data  |  addr   |end flag  |
-----------------------------------------------------
-| 2 byte   | 1byte | 1byte |   2 byte|   2 byte |
-----------------------------------------------------
-*/
-
-#define SENDBUFLEN  8
-static u8 sendbuf[SENDBUFLEN];/* send data */
-static u8 rbuf[SENDBUFLEN];/*save get data */
-/**\brief aml_init_send_buf:init spi send buf
-* \param cmd: ci cmd
-* \param data: write value
-* \param addr: read or write addr
-* \return
-*   - read value:ok
-*   - -EINVAL : error
-*/
-static int aml_init_send_buf(u8 cmd, u8 data, u16 addr)
-{
-	/* start flag */
-	sendbuf[0] = DATASTART;
-	sendbuf[1] = DATASTART;
-	/* cmd */
-	sendbuf[2] = cmd;
-	/* data */
-	sendbuf[3] = data;
-	/* addr senf low 8 bit first,and then send hi 8bit */
-	sendbuf[4] = addr & 0x00ff;
-	sendbuf[5] = (addr>>8) & 0xff;
-	/* end flag */
-	sendbuf[6] = DATAEND;
-	sendbuf[7] = DATAEND;
-	return 0;
-}
-/**\brief aml_ci_spi_reciver
-* \param[out] None
-* \param[in] value,get from spi
-* \return
-*   - 0:reciver end,-1:reciver
-*   -
-*/
-/*
-data strouct
-----------------------------------------------------
-|start flag| cmd   | data  |  addr   |end flag  |
-----------------------------------------------------
-| 2 byte   | 1byte | 1byte |   2 byte|   2 byte |
-----------------------------------------------------
-*/
-int aml_ci_spi_paser_bit(uint8_t value)
-{
-	/* read spi data from slave */
-	if (G_rec_flag == AM_SPI_STEP_INIT) {
-		/* start type first */
-		if (value == DATASTART) {
-			rbuf[0] = value;
-			G_rec_flag = AM_SPI_STEP_START1;
-		}
-	} else if (G_rec_flag == AM_SPI_STEP_START1) {
-		/* start2 type seccond */
-		if (value == DATASTART) {
-			rbuf[1] = value;
-			G_rec_flag = AM_SPI_STEP_START2;
-		}
-	} else if (G_rec_flag == AM_SPI_STEP_START2) {
-		/* cmd type */
-		/* pr_dbg("spi value=%d\r\n",value); */
-		rbuf[2] = value;
-		G_rec_flag = AM_SPI_STEP_CMD;
-	} else if (G_rec_flag == AM_SPI_STEP_CMD) {
-		/* data  */
-		rbuf[3] = value;
-		G_rec_flag = AM_SPI_STEP_DATA;
-	} else if (G_rec_flag == AM_SPI_STEP_DATA) {
-		/* ADDR1  */
-		rbuf[4] = value;
-		G_rec_flag = AM_SPI_STEP_ADDR1;
-	} else if (G_rec_flag == AM_SPI_STEP_ADDR1) {
-		/* ADDR2 type */
-		rbuf[5] = value;
-		G_rec_flag = AM_SPI_STEP_ADDR2;
-	} else if (G_rec_flag == AM_SPI_STEP_ADDR2) {
-		/*  END1 type */
-		if (value == DATAEND) {
-			rbuf[6] = value;
-			G_rec_flag = AM_SPI_STEP_END1;
-		}
-	} else if (G_rec_flag == AM_SPI_STEP_END1) {
-		/* END2 type */
-		if (value == DATAEND) {
-			rbuf[7] = value;
-			G_rec_flag = AM_SPI_STEP_END2;
-			/* pr_dbg("spi read value ok end\r\n"); */
-			return 0;
-		}
-	}
-	return -1;
-}
-
-/**\brief aml_spi_io_api:spi read or write api with mcu
-* \param spi_dev: aml_spi obj,used this data to get spi obj
-* \param val: write value
-* \param len: write value len
-* \param mode: read or write
-* \return
-*   - read value:ok
-*   - -EINVAL : error
-*/
-static int aml_spi_io_api(struct aml_spi *spi_dev, u8 *val, int len, int mode)
-{
-	u8 rb[32] = {0};
-	int ret = 0;
-	int i = 0;
-	u8 rd = 0;
-	if (spi_dev->spi == NULL) {
-		pr_error("%s spi is null\r\n", __func__);
-		return -EINVAL;
-	}
-	spin_lock(&spi_dev->spi_lock);
-	if (spi_dev->cs_hold_delay)
-		udelay(spi_dev->cs_hold_delay);
-	dirspi_start(spi_dev->spi);
-	if (spi_dev->cs_clk_delay)
-		udelay(spi_dev->cs_clk_delay);
-
-	dirspi_xfer(spi_dev->spi, val, rb, len);
-	/* wait mcu io */
-	udelay(1000);
-	/* init rec flag */
-	G_rec_flag = AM_SPI_STEP_INIT;
-	memset(rbuf, 0, 8);
-	for (i = 0; i < 4*len; i++) {
-		udelay(50);
-		ret = dirspi_read(spi_dev->spi, &rd, 1);
-		if (ret != 0)
-			pr_dbg("spi read value timeout:%x\r\n", rd);
-		ret = aml_ci_spi_paser_bit(rd);
-		if (ret == 0)
-			break;
-	}
-	if (ret == 0) {
-		rd = rbuf[3];/* data */
-	} else {
-		pr_dbg("spi read value error\r\n");
-		rd = 0;
-	}
-
-	if (spi_dev->cs_clk_delay)
-		udelay(spi_dev->cs_clk_delay);
-
-	/* pr_error("ci spi is stop in %s rd=%d\r\n",__func__,rd);*/
-	dirspi_stop(spi_dev->spi);
-
-	spin_unlock(&spi_dev->spi_lock);
-
-	return rd;
-}
-
-/********************************************************/
-/********************************************************/
-/*******             gpio api               *************/
-/********************************************************/
-/********************************************************/
-/**\brief aml_set_gpio_out:set gio out and set val value
-* \param gpio: gpio_desc obj,
-* \param val:  set val
-* \return
-*   - 0:ok
-*   - -EINVAL : error
-*/
-static int aml_set_gpio_out(struct gpio_desc *gpio, int val)
-{
-	int ret = 0;
-	if (val < 0) {
-		pr_dbg("gpio out val = -1.\n");
-		return -1;
-	}
-	if (val != 0)
-		val = 1;
-	ret = gpiod_direction_output(gpio, val);
-	pr_dbg("dvb ci gpio out ret %d set val:%d\n", ret, val);
-	return ret;
-}
-#if 0
-/**\brief aml_set_gpio_in:set gio in
-* \param gpio: gpio_desc obj,
-* \return
-*   - 0:ok
-*   - -EINVAL : error
-*/
-static int aml_set_gpio_in(struct gpio_desc *gpio)
-{
-	gpiod_direction_input(gpio);
-	return 0;
-}
-#endif
-
-/**\brief aml_get_gpio_value:get gio value
-* \param gpio: gpio_desc obj,
-* \return
-*   - gpio value:ok
-*   - -EINVAL : error
-*/
-static int aml_get_gpio_value(struct gpio_desc *gpio)
-{
-	int ret = 0;
-	ret = gpiod_get_value(gpio);
-	return ret;
-}
-/**\brief aml_gpio_free:free gio
-* \param gpio: gpio_desc obj,
-* \return
-*   - 0:ok
-*   - -EINVAL : error
-*/
-static int aml_gpio_free(struct gpio_desc *gpio)
-{
-	gpiod_put(gpio);
-	return 0;
-}
-/**\brief spi_get_gpio_by_name:get gpio desc from dts file
-* \param spi_dev: aml_spi obj
-* \param gpiod:   gpio_desc * obj
-* \param str: gpio name at dts file
-* \param input_output: gpio input or output type
-* \param output_value: gpio out put value
-* \return
-*   - 0:ok
-*   - -EINVAL : error
-*/
-static int spi_get_gpio_by_name(struct aml_spi *spi_dev,
-struct gpio_desc **gpiod, int *pin_value,
-char *str, int input_output, int output_level)
-{
-	int ret = 0;
-	struct device_node *child = NULL;
-	struct platform_device *pdev = spi_dev->pdev;
-	struct device_node *np = pdev->dev.of_node;
-
-	/*get spi and gpio config from dts*/
-	/* get device config for dvbci_io*/
-	child = of_get_child_by_name(np, "dvbci_io");
-	if (IS_ERR(*gpiod)) {
-		pr_dbg("dvb ci spi %s request failed\n", str);
-		return -1;
-	}
-
-	*pin_value = of_get_named_gpio_flags(child, str, 0, NULL);
-	*gpiod = gpio_to_desc(*pin_value);
-	if (IS_ERR(*gpiod)) {
-		pr_dbg("spi %s request failed\n", str);
-		return -1;
-	}
-	pr_dbg("spi get_gpio %s %p  %d\n", str, *gpiod, *pin_value);
-	gpio_request(*pin_value, AML_MODE_NAME);
-
-	if (input_output == OUTPUT) {
-		ret = gpiod_direction_output(*gpiod, output_level);
-	} else if (input_output == INPUT)	{
-		ret = gpiod_direction_input(*gpiod);
-		/*ret |= gpiod_set_pullup(*gpiod, 1);*/
-	} else {
-		pr_error("spi Request gpio direction invalid\n");
-	}
-	return ret;
-}
-/********************************************************/
-/********************************************************/
-/*******             gpio api end           *************/
-/********************************************************/
-/********************************************************/
-#if 0
-/**\brief aml_ci_cis_test_by_spi:test cis
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \param addr: read addr
-* \return
-*   - test :ok
-*   - -EINVAL : error
-*/
-/**\brief aml_ci_full_test_by_spi:ci full test
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \param addr: read addr
-* \return
-*   - read value:ok
-*   - -EINVAL : error
-*/
-static  int aml_ci_full_test_by_spi(
-	struct aml_ci *ci_dev, int slot, int addr)
-{
-	u8  data = 0;
-	u16 addres = addr;
-	int value = 0;
-	struct aml_spi *spi_dev = ci_dev->data;
-	aml_init_send_buf(AM_CI_CMD_FULLTEST, data, addres);
-	value = aml_spi_io_api(spi_dev,
-		sendbuf, SENDBUFLEN, AM_CI_CMD_FULLTEST);
-	pr_dbg("FULL : TEST END \r\n");
-	return value;
-}
-#endif
-/**\brief aml_ci_mem_read_by_spi:io read from cam
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \param addr: read addr
-* \return
-*   - read value:ok
-*   - -EINVAL : error
-*/
-static  int aml_ci_mem_read_by_spi(
-	struct aml_ci *ci_dev, int slot, int addr)
-{
-	u8  data = 0;
-	u16 addres = addr;
-	int value = 0;
-	struct aml_spi *spi_dev = ci_dev->data;
-	aml_init_send_buf(AM_CI_CMD_MEMR, data, addres);
-	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_MEMR);
-	/*pr_dbg("Read : mem[%d] = 0x%x\n", addr, value);*/
-	return value;
-}
-/**\brief aml_ci_mem_write_by_spi:io write to cam by spi api
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \param addr: write addr
-* \param addr: write value
-* \return
-*   - 0:ok
-*   - -EINVAL : error
-*/
-static int aml_ci_mem_write_by_spi(
-	struct aml_ci *ci_dev, int slot, int addr,  u8 val)
-{
-	u8  data = val;
-	u16 addres = addr;
-	int value = 0;
-	struct aml_spi *spi_dev = ci_dev->data;
-	aml_init_send_buf(AM_CI_CMD_MEMW, data, addres);
-	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_MEMW);
-	/*pr_dbg("write : mem[%d] = 0x%x\n", addr, data);*/
-return value;
-}
-/**\brief aml_ci_io_read_by_spi:io read from cam by spi api
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \param addr: read addr
-* \return
-*   - read value:ok
-*   - -EINVAL : error
-*/
-static int aml_ci_io_read_by_spi(
-	struct aml_ci *ci_dev, int slot, int addr)
-{
-	u8  data = 0;
-	u16 addres = addr;
-	int value = 0;
-	struct aml_spi *spi_dev = ci_dev->data;
-	aml_init_send_buf(AM_CI_CMD_IOR, data, addres);
-	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_IOR);
-	/*pr_dbg("read : io[%d] = 0x%x\n", addr, value);*/
-	return value;
-}
-/**\brief aml_ci_io_write_by_spi:io write to cam
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \param addr: write addr
-* \param addr: write value
-* \return
-*   - 0:ok
-*   - -EINVAL : error
-*/
-static int aml_ci_io_write_by_spi(
-	struct aml_ci *ci_dev, int slot, int addr, u8 val)
-{
-	u8  data = val;
-	u16 addres = addr;
-	int value = 0;
-	struct aml_spi *spi_dev = ci_dev->data;
-	/*add by chl,need add time delay*/
-	mdelay(10);
-	aml_init_send_buf(AM_CI_CMD_IOW, data, addres);
-	value = aml_spi_io_api(spi_dev, sendbuf, SENDBUFLEN, AM_CI_CMD_IOW);
-	/*pr_dbg("write : ATTR[%d] = 0x%x\n", addr, data);*/
-	return value;
-}
-
-
-/**\brief aml_ci_slot_reset:reset slot
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \return
-*   - 0:ok
-*   - -EINVAL : error
-*/
-static int aml_ci_slot_reset(struct aml_ci *ci_dev, int slot)
-{
-	struct aml_spi *spi_dev = ci_dev->data;
-	pr_dbg("Slot(%d): Slot RESET\n", slot);
-	aml_pcmcia_reset(&spi_dev->pc);
-	dvb_ca_en50221_camready_irq(&ci_dev->en50221, 0);
-	return 0;
-}
-/**\brief aml_ci_slot_shutdown:show slot
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \return
-*   - 0:ok
-*   - -EINVAL : error
-* readme:no use this api
-*/
-static int aml_ci_slot_shutdown(struct aml_ci *ci_dev, int slot)
-{
-	pr_dbg("Slot(%d): Slot shutdown\n", slot);
-	return 0;
-}
-/**\brief aml_ci_ts_control:control slot ts
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \return
-*   - 0:ok
-*   - -EINVAL : error
-* readme:no use this api
-*/
-static int aml_ci_ts_control(struct aml_ci *ci_dev, int slot)
-{
-	pr_dbg("Slot(%d): TS control\n", slot);
-	return 0;
-}
-/**\brief aml_ci_slot_status:get slot status
-* \param ci_dev: aml_ci obj,used this data to get spi_dev obj
-* \param slot: slot index
-* \param open: no used
-* \return
-*   - cam status
-*   - -EINVAL : error
-*/
-static int aml_ci_slot_status(struct aml_ci *ci_dev, int slot, int open)
-{
-	struct aml_spi *spi_dev = ci_dev->data;
-
-	pr_dbg("Slot(%d): Poll Slot status\n", slot);
-
-	if (spi_dev->pc.slot_state == MODULE_INSERTED) {
-		pr_dbg("CA Module present and ready\n");
-		return DVB_CA_EN50221_POLL_CAM_PRESENT |
-		DVB_CA_EN50221_POLL_CAM_READY;
-	} else {
-		pr_error("CA Module not present or not ready\n");
-	}
-	return -EINVAL;
-}
-#if 0
-/**\brief aml_ci_gio_get_irq:get gpio cam irq pin value
-* \return
-*   - irq pin value
-*   - -EINVAL : error
-*/
-static int aml_ci_gio_get_irq(void)
-{
-	int ret = 0;
-	ret = aml_get_gpio_value(g_spi_dev->irq_cam_pin);
-	return ret;
-}
-#endif
-
-/********************************************************/
-/********************************************************/
-/*******        for pcmcid api              *************/
-/********************************************************/
-/********************************************************/
-/**\brief aml_gio_power:set power gpio hi or low
-* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
-* \param enable: power pin hi or low
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-static int aml_gio_power(struct aml_pcmcia *pc, int enable)
-{
-	int ret = 0;
-	struct aml_spi *spi_dev = pc->priv;
-	if (spi_dev == NULL) {
-		pr_dbg("spi dev is null %s : %d\r\n", __func__, enable);
-		return -1;
-	}
-	pr_dbg("%s : %d\r\n", __func__, enable);
-	if (enable == AML_PWR_OPEN) {
-		/*hi level ,open power*/
-		ret = aml_set_gpio_out(spi_dev->pwr_pin, AML_GPIO_HIGH);
-	} else {
-		/*low level ,close power*/
-		ret = aml_set_gpio_out(spi_dev->pwr_pin, AML_GPIO_LOW);
-	}
-	return ret;
-}
-/**\brief aml_gio_reset:set reset gpio hi or low
-* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
-* \param enable: reset pin hi or low
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-static int aml_gio_reset(struct aml_pcmcia *pc, int enable)
-{
-	/*need set hi and sleep set low*/
-	int ret = 0;
-	struct aml_spi *spi_dev = pc->priv;
-	pr_dbg("%s : %d\r\n", __func__, enable);
-	if (enable == AML_L)
-		ret = aml_set_gpio_out(spi_dev->reset_pin, AML_GPIO_LOW);
-	else
-		ret = aml_set_gpio_out(spi_dev->reset_pin, AML_GPIO_HIGH);
-	return ret;
-}
-
-/**\brief aml_gio_init_irq:set gpio irq
-* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
-* \param flag: rising or falling or hi or low
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-/*need change*/
-static int aml_gio_init_irq(struct aml_pcmcia *pc, int flag)
-	{
-		struct aml_spi *spi_dev = (struct aml_spi *)pc->priv;
-	
-#if 0
-		int cd1_pin = desc_to_gpio(spi_dev->cd_pin1);
-	
-		int irq = pc->irq-AML_CI_GPIO_IRQ_BASE;
-	
-		printk("----cd1_pin=%d irq=%d\r\n", cd1_pin, irq);
-		aml_set_gpio_in(spi_dev->cd_pin1);
-	
-		if (flag == IRQF_TRIGGER_RISING)
-			gpio_for_irq(cd1_pin,
-				AML_GPIO_IRQ(irq, FILTER_NUM7, GPIO_IRQ_RISING));
-		else if (flag == IRQF_TRIGGER_FALLING)
-			gpio_for_irq(cd1_pin,
-				AML_GPIO_IRQ(irq, FILTER_NUM7, GPIO_IRQ_FALLING));
-		else if (flag == IRQF_TRIGGER_HIGH)
-			gpio_for_irq(cd1_pin,
-				AML_GPIO_IRQ(irq, FILTER_NUM7, GPIO_IRQ_HIGH));
-		else if (flag == IRQF_TRIGGER_LOW)
-			gpio_for_irq(cd1_pin,
-				AML_GPIO_IRQ(irq, FILTER_NUM7, GPIO_IRQ_LOW));
-		else
-			return -1;
-#endif
-		gpiod_to_irq(spi_dev->cd_pin1);
-	
-		return 0;
-	}
-
-/**\brief aml_gio_get_cd1:get gpio cd1 pin value
-* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
-* \return
-*   - cd1 pin value
-*   - -EINVAL : error
-*/
-static int aml_gio_get_cd1(struct aml_pcmcia *pc)
-{
-	int ret = 0;
-	struct aml_spi *spi_dev = pc->priv;
-	ret = aml_get_gpio_value(spi_dev->cd_pin1);
-	return ret;
-}
-/**\brief aml_gio_get_cd2:get gpio cd2 pin value
-* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
-* \return
-*   - cd2 pin value
-*   - -EINVAL : error
-*/
-static int aml_gio_get_cd2(struct aml_pcmcia *pc)
-{
-	int ret = 0;
-	struct aml_spi *spi_dev = pc->priv;
-	ret = aml_get_gpio_value(spi_dev->cd_pin2);
-	pr_dbg("%s : %d\r\n", __func__, ret);
-	return ret;
-}
-/**\brief aml_cam_plugin:notify en50221 cam card in or out
-* \param pc: aml_pcmcia obj,used this priv to get spi_dev obj
-* \plugin: 0:remove;1:in
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-static int aml_cam_plugin(struct aml_pcmcia *pc, int plugin)
-{
-	struct aml_ci *ci = (struct aml_ci *)
-	((struct aml_spi *)(pc->priv))->priv;
-	pr_dbg("%s : %d\r\n", __func__, plugin);
-	if (plugin) {
-		dvb_ca_en50221_camchange_irq(&ci->en50221,
-			0, DVB_CA_EN50221_CAMCHANGE_INSERTED);
-	} else {
-		dvb_ca_en50221_camchange_irq(&ci->en50221,
-			0, DVB_CA_EN50221_CAMCHANGE_REMOVED);
-	}
-	return 0;
-}
-/**\brief aml_pcmcia_alloc:alloc nad init pcmcia obj
-* \param spi_dev: aml_spi obj,
-* \param pcmcia: aml_pcmcia * obj,
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-static void aml_pcmcia_alloc(struct aml_spi *spi_dev,
-	struct aml_pcmcia **pcmcia)
-{
-	pr_dbg("aml_pcmcia_alloc----\n");
-	*pcmcia = &spi_dev->pc;
-	(*pcmcia)->irq = spi_dev->irq;
-	(*pcmcia)->init_irq = aml_gio_init_irq;
-	(*pcmcia)->get_cd1 = aml_gio_get_cd1;
-	(*pcmcia)->get_cd2 = aml_gio_get_cd2;
-	(*pcmcia)->pwr = aml_gio_power;
-	(*pcmcia)->rst = aml_gio_reset;
-	(*pcmcia)->pcmcia_plugin = aml_cam_plugin;
-	(*pcmcia)->slot_state = MODULE_XTRACTED;
-	(*pcmcia)->priv = spi_dev;
-	(*pcmcia)->run_type = 0;/*0:irq;1:poll*/
-}
-
-/**\brief aml_spi_get_config_from_dts:get spi config and gpio config from dts
-* \param spi_dev: aml_spi obj,
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-static int aml_spi_get_config_from_dts(struct aml_spi *spi_dev)
-{
-	struct device_node *child = NULL;
-	struct platform_device *pdev = spi_dev->pdev;
-	struct device_node *np = pdev->dev.of_node;
-	unsigned int temp[5], val;
-	int ret = 0;
-	pr_dbg("into get spi dts \r\n");
-
-	/*get spi and gpio config from dts*/
-	/* get device config for dvbci_io*/
-	child = of_get_child_by_name(np, "dvbci_io");
-	if (child == NULL) {
-		pr_error("failed to get dvbci_io\n");
-		return -1;
-	}
-	spi_dev->spi_bdinfo = &aml_ci_spi_bdinfo;
-	/* get spi config */
-	ret = of_property_read_u32_array(child, "spi_bus_num", temp, 1);
-	if (ret) {
-		pr_error("failed to get spi_bus_num\n");
-	} else {
-		aml_ci_spi_bdinfo.bus_num = temp[0];
-		pr_dbg("bus_num: %d\n", aml_ci_spi_bdinfo.bus_num);
-	}
-	ret = of_property_read_u32_array(child, "spi_chip_select",
-	temp, 1);
-	if (ret) {
-		pr_error("failed to get spi_chip_select\n");
-	} else {
-		aml_ci_spi_bdinfo.chip_select = temp[0];
-		pr_dbg("chip_select: %d\n", aml_ci_spi_bdinfo.chip_select);
-	}
-	ret = of_property_read_u32_array(child, "spi_max_frequency",
-	temp, 1);
-	if (ret) {
-		pr_error("failed to get spi_chip_select\n");
-	} else {
-		aml_ci_spi_bdinfo.max_speed_hz = temp[0];
-		pr_dbg("max_speed_hz: %d\n", aml_ci_spi_bdinfo.max_speed_hz);
-	}
-	ret = of_property_read_u32_array(child, "spi_mode", temp, 1);
-	if (ret) {
-		pr_error("failed to get spi_mode\n");
-	} else {
-		aml_ci_spi_bdinfo.mode = temp[0];
-		pr_dbg("mode: %d\n", aml_ci_spi_bdinfo.mode);
-	}
-	ret = of_property_read_u32_array(child, "spi_cs_delay",
-	&temp[0], 2);
-	if (ret) {
-		spi_dev->cs_hold_delay = 0;
-		spi_dev->cs_clk_delay = 0;
-	} else {
-		spi_dev->cs_hold_delay = temp[0];
-		spi_dev->cs_clk_delay = temp[1];
-	}
-	ret = of_property_read_u32(child, "spi_write_check", &val);
-	if (ret)
-		spi_dev->write_check = 0;
-	else
-		spi_dev->write_check = (unsigned char)val;
-	/*get  cd1 irq num*/
-	ret = of_property_read_u32(child, "irq_cd1", &val);
-	if (ret) {
-		spi_dev->irq = 5;
-	} else {
-		/*set irq value need add
-		AML_CI_GPIO_IRQ_BASE,but
-		we need minus
-		AML_CI_GPIO_IRQ_BASE
-		when gpio request irq */
-		spi_dev->irq = val+AML_CI_GPIO_IRQ_BASE;
-	}
-
-	spi_dev->irq = irq_of_parse_and_map(
-	pdev->dev.of_node, 0);
-	AML_CI_GPIO_IRQ_BASE = spi_dev->irq - val;
-	pr_dbg("get spi irq : %d  0:%d USEDBASE:%d val:%d\r\n",
-		spi_dev->irq, INT_GPIO_0, AML_CI_GPIO_IRQ_BASE, val);
-	/*get reset pwd cd1 cd2 gpio pin*/
-	spi_dev->reset_pin = NULL;
-	ret = spi_get_gpio_by_name(spi_dev, &spi_dev->reset_pin,
-	&spi_dev->reset_pin_value, "reset_pin",
-	OUTPUT, OUTLEVEL_HIGH);
-	if (ret) {
-		pr_error("dvb ci reset pin request failed\n");
-		return -1;
-	}
-	spi_dev->cd_pin1 = NULL;
-	ret = spi_get_gpio_by_name(spi_dev,
-		&spi_dev->cd_pin1,
-		&spi_dev->cd_pin1_value, "cd_pin1",
-		INPUT, OUTLEVEL_HIGH);
-	if (ret) {
-		pr_error("dvb ci cd_pin1 pin request failed\n");
-		return -1;
-	}
-	spi_dev->cd_pin2 = spi_dev->cd_pin1;
-	spi_dev->cd_pin2_value = spi_dev->cd_pin1_value;
-	spi_dev->pwr_pin = NULL;
-	pr_dbg("spi_dev->cd_pin1_value==%d\r\n", spi_dev->cd_pin1_value);
-	ret = spi_get_gpio_by_name(spi_dev,
-		&spi_dev->pwr_pin, &spi_dev->pwr_pin_value,
-		"pwr_pin", OUTPUT, OUTLEVEL_HIGH);
-	if (ret) {
-		pr_error("dvb ci pwr_pin pin request failed\n");
-		return -1;
-	}
-	spi_dev->irq_cam_pin = NULL;
-	ret = spi_get_gpio_by_name(spi_dev,
-		&spi_dev->irq_cam_pin, &spi_dev->irq_cam_pin_value,
-		"irq_cam_pin", INPUT, OUTLEVEL_HIGH);
-	if (ret) {
-		pr_error("dvbci  irq_cam_pin pin request failed\n");
-		return -1;
-	}
-
-	return 0;
-}
-/**\brief aml_ci_free_gpio:free ci gpio
-* \param spi_dev: aml_spi obj,
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-static void aml_ci_free_gpio(struct aml_spi *spi_dev)
-{
-	if (spi_dev == NULL) {
-		pr_error("spi_dev is NULL,no need free gpio res\r\n");
-		return;
-	}
-
-	if (spi_dev->pwr_pin) {
-		aml_gpio_free(spi_dev->pwr_pin);
-		spi_dev->pwr_pin = NULL;
-	}
-	if (spi_dev->cd_pin1) {
-		aml_gpio_free(spi_dev->cd_pin1);
-		spi_dev->cd_pin1 = NULL;
-		spi_dev->cd_pin2 = NULL;
-	}
-	if (spi_dev->reset_pin) {
-		aml_gpio_free(spi_dev->reset_pin);
-		spi_dev->reset_pin = NULL;
-	}
-	if (spi_dev->irq_cam_pin) {
-		aml_gpio_free(spi_dev->irq_cam_pin);
-		spi_dev->irq_cam_pin = NULL;
-	}
-	return;
-}
-
-
-/**\brief ci_spi_dev_remove:spi probe api
-* \param spi: spi obj,
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-static int ci_spi_dev_probe(struct spi_device *spi)
-{
-	int ret;
-	pr_dbg("spi Dev probe--\n");
-	if (g_spi_dev)
-		g_spi_dev->spi = spi;
-	 else
-		pr_dbg("spi Dev probe-error-\n");
-	spi->bits_per_word = 8;
-	ret = spi_setup(spi);
-	if (ret)
-		pr_dbg("spi setup failed\n");
-	return ret;
-}
-/**\brief ci_spi_dev_remove:spi remove api
-* \param spi: spi obj,
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-static int ci_spi_dev_remove(struct spi_device *spi)
-{
-	pr_dbg("spi Dev remove--\n");
-	if (g_spi_dev)
-		g_spi_dev->spi = NULL;
-
-	return 0;
-}
-
-static struct spi_driver ci_spi_dev_driver = {
-	.probe = ci_spi_dev_probe,
-	.remove = ci_spi_dev_remove,
-	.driver = {
-		.name = "ci_spi_dev",/*set same with board info modalias*/
-		.owner = THIS_MODULE,
-	},
-};
-/**\brief aml_spi_init:spi_dev init
-* \param ci_dev: aml_ci obj,
-* \param pdev: platform_device obj,used to get dts info
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-int aml_spi_init(struct platform_device *pdev, struct aml_ci *ci_dev)
-{
-	struct aml_spi *spi_dev = NULL;
-	struct aml_pcmcia *pc;
-	int result;
-
-	spi_dev = kmalloc(sizeof(struct aml_spi), GFP_KERNEL);
-	if (!spi_dev) {
-		pr_error("Out of memory!, exiting ..\n");
-		result = -ENOMEM;
-		goto err;
-	}
-	g_spi_dev = spi_dev;
-	spi_dev->pdev = pdev;
-	spi_dev->priv = ci_dev;
-	/*get config from dts*/
-	aml_spi_get_config_from_dts(spi_dev);
-	/*regist api dev*/
-	spi_register_board_info(spi_dev->spi_bdinfo, 1);
-	result = spi_register_driver(&ci_spi_dev_driver);
-	if (result) {
-		pr_error("register amlspi_dev spi driver failed\n");
-		goto fail1;
-	}
-	aml_pcmcia_alloc(spi_dev, &pc);
-	result = aml_pcmcia_init(pc);
-	if (result < 0) {
-		pr_error("aml_pcmcia_init failed\n");
-		goto fail2;
-	}
-
-	/*init ci_dev used api.*/
-	ci_dev->ci_mem_read  = aml_ci_mem_read_by_spi;
-	ci_dev->ci_mem_write = aml_ci_mem_write_by_spi;
-	ci_dev->ci_io_read = aml_ci_io_read_by_spi;
-	ci_dev->ci_io_write = aml_ci_io_write_by_spi;
-	ci_dev->ci_slot_reset = aml_ci_slot_reset;
-	ci_dev->ci_slot_shutdown = aml_ci_slot_shutdown;
-	ci_dev->ci_slot_ts_enable = aml_ci_ts_control;
-	ci_dev->ci_poll_slot_status = aml_ci_slot_status;
-	ci_dev->data = spi_dev;
-	/*init spi_lock*/
-	spin_lock_init(&(spi_dev->spi_lock));
-	return 0;
-fail2:
-	spi_unregister_driver(&ci_spi_dev_driver);
-fail1:
-	kfree(spi_dev);
-	spi_dev = NULL;
-err:
-	return -1;
-}
-EXPORT_SYMBOL(aml_spi_init);
-/**\brief aml_spi_exit:spi exit
-* \return
-*   - 0
-*   - -EINVAL : error
-*/
-int aml_spi_exit(struct aml_ci *ci)
-{
-	/*exit pc card*/
-	aml_pcmcia_exit(&g_spi_dev->pc);
-	/*un regist spi driver*/
-	spi_unregister_driver(&ci_spi_dev_driver);
-	/*free gpio*/
-	aml_ci_free_gpio(g_spi_dev);
-	/*free spi dev*/
-	kfree(g_spi_dev);
-	g_spi_dev = NULL;
-
-	return 0;
-}
-EXPORT_SYMBOL(aml_spi_exit);
-
-
-#if 0
-/********************************************************/
-/********************************************************/
-/*******        for spi test api            *************/
-/********************************************************/
-/********************************************************/
-
-/*cam difines*/
-#define DA	0x80
-#define FR	0x40
-#define WE	0x02
-#define RE	0x01
-
-#define RS	0x08
-#define SR	0x04
-#define SW	0x02
-#define HC	0x01
-#define DATA_REG	  0
-#define COM_STA_REG	1
-#define SIZE_REG_L	2
-#define SIZE_REG_M	3
-static void aml_spi_ca_full_test(struct aml_ci *ci_dev)
-{
-		unsigned int BUF_SIZE = 0;
-		unsigned int i = 0;
-		unsigned char cc = 0;
-		unsigned char reg;
-		unsigned int  bsize = 0;
-		int cnt = 0;
-		unsigned char buf[10];
-		int count = 1000;
-		mdelay(1000);
-		pr_dbg("READ CIS START\r\n");
-		for (i = 0; i < 267; i++) {
-			mdelay(100);
-			cc = aml_ci_mem_read_by_spi(ci_dev, 0, i);
-			pr_dbg("0x%x ", cc);
-			if ((i + 1) % 16 == 0)
-				pr_dbg(" \r\n");
-		}
-		pr_dbg("READ CIS OVER\r\n");
-		mdelay(1000);
-		pr_dbg("SW rst CAM...\r\n");
-		aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, RS);
-		pr_dbg("SW rst over.\r\n");
-		pr_dbg("-----------------------------------\r\n");
-		pr_dbg("TO delay 2000ms\r\n");
-		mdelay(2000);
-		pr_dbg("\r\n");
-		pr_dbg("--------------clear rs--!!!-YOU MUST CLEAR RS BIT--no sleep--------\r\n");
-		aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, 0);
-		pr_dbg("--------------sleep---------------------\r\n");
-		mdelay(2000);
-		pr_dbg("TO check sw-rst is OK\r\n");
-		pr_dbg("start read fr \r\n");
-		if (1) {
-			unsigned char reg;
-			unsigned char reg1;
-			int count1 = 4000;
-			while (1) {
-				mdelay(20);
-				count1--;
-				reg1 = aml_ci_io_read_by_spi(
-					ci_dev, 0, COM_STA_REG);
-				if (FR != (FR & reg1)) {
-						continue;
-					} else {
-						pr_dbg("CAM Reset Ok\r\n");
-						break;
-					}
-			}
-			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-			pr_dbg("STA_REG = 0x%2.2x\r\n", reg);
-			if (FR & reg) {
-				pr_dbg("SW-RST is OK!\r\n");
-			} else {
-				pr_dbg("SW-RST is ERR!\r\n");
-				goto end;
-			}
-		}
-end:
-		pr_dbg("TO check sw-rst over.\r\n");
-		pr_dbg("\r\n");
-		pr_dbg("-----------------------------------\r\n");
-		pr_dbg("TO buffer size negotiation protocol...\r\n");
-		pr_dbg("Get which buf size CAM can support\r\n");
-		aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, SR);
-		mdelay(1000);
-		while (1) {
-
-			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-			if ((reg & DA) == DA) {
-				pr_dbg("Buffer negotiate size date avalible.\r\n");
-				break;
-			} else {
-				/*pr_dbg("Buffer negotiate
-				size date NOT avalible\r\n");*/
-				continue;
-			}
-			mdelay(100);
-		}
-		cnt = (aml_ci_io_read_by_spi(ci_dev, 0, SIZE_REG_L)) +
-		((aml_ci_io_read_by_spi(ci_dev, 0, SIZE_REG_M)) * 256);
-		pr_dbg("Moudle have <%d> Bytes send to host.\r\n", cnt);
-		if (cnt != 2) {
-			pr_dbg("The Bytes will be tx is ERR!\r\n");
-			return;
-		}
-		for (i = 0; i < cnt; i++)
-			buf[i] = aml_ci_io_read_by_spi(ci_dev, 0, DATA_REG);
-
-		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-		if (RE == (RE & reg)) {
-			pr_dbg("(1)Read CAM buf size ERR!\r\n");
-			return;
-		}
-		aml_ci_io_write_by_spi(ci_dev, 0, (COM_STA_REG), 0);
-
-		mdelay(1000);
-
-		while (count--) {
-			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-			if (FR != (FR & reg)) {
-				pr_dbg("CAM is busy 2, waiting...\r\n");
-				continue;
-			} else {
-				pr_dbg("CAM is OK 2.\r\n");
-				break;
-			}
-		}
-		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-		if (FR != (FR & reg)) {
-			pr_dbg("(2)Read CAM buf size ERR!-\r\n");
-			return;
-		}
-		bsize = (buf[0] * 256) + buf[1];
-
-		pr_dbg("CAM can support buf size is: <%d>B\r\n", bsize);
-
-		pr_dbg("Tell CAM which size buf is be used\r\n");
-		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-		if (FR != (FR & reg))
-			pr_dbg("CAM is busy, waiting free\r\n");
-		while (1) {
-			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-			if (FR != (FR & reg)) {
-				pr_dbg("CAM is busy 3, waiting\r\n");
-				continue;
-			} else {
-				pr_dbg("CAM is OK 3\r\n");
-				break;
-			}
-		}
-
-		bsize = bsize - 0;
-		BUF_SIZE = bsize;
-		pr_dbg("We will use this  buf size: <%d>B\r\n", bsize);
-		aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, SW);
-		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-		if (FR != (FR & reg))
-			pr_dbg("CAM is busy, waiting\r\n");
-
-		while (1) {
-			reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-			if (FR != (FR & reg)) {
-				pr_dbg("CAM is busy 4, waiting\r\n");
-				continue;
-			} else {
-				pr_dbg("CAM is OK 4\r\n");
-				break;
-			}
-		}
-		/*SHOULD CHECK DA!!!!!*/
-		/*PLS ADD THIS CHECK CODE:*/
-		pr_dbg("PRIOR to check CAM'S DA\r\n");
-		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-		if ((reg & DA) == DA) {
-			pr_dbg("CAM have data send to HOST\r\n");
-			return;
-		}
-
-
-		buf[0] = (unsigned char)((bsize >> 8) & 0xff);
-		buf[1] = (unsigned char)(bsize & 0xff);
-
-		while (1) {
-			mdelay(10);
-			aml_ci_io_write_by_spi(ci_dev,
-			0, COM_STA_REG, HC | SW);
-			mdelay(100);
-			reg = aml_ci_io_read_by_spi(ci_dev,
-				0, COM_STA_REG);
-			if (FR != (FR & reg)) {
-				pr_dbg("CAM is busy 5, waiting\r\n");
-				aml_ci_io_write_by_spi(ci_dev,
-					0, COM_STA_REG, SW);
-				continue;
-			} else {
-				pr_dbg("CAM is OK 5\r\n");
-				break;
-			}
-		}
-		pr_dbg("<2> Bytes send to CAM\r\n");
-		aml_ci_io_write_by_spi(ci_dev, 0, SIZE_REG_M, 0);
-		aml_ci_io_write_by_spi(ci_dev, 0, SIZE_REG_L, 2);
-		for (i = 0; i < 2; i++)
-			aml_ci_io_write_by_spi(ci_dev, 0, DATA_REG, buf[i]);
-
-		reg = aml_ci_io_read_by_spi(ci_dev, 0, COM_STA_REG);
-		if (WE == (WE & reg)) {
-			pr_dbg("Write CAM ERR!\r\n");
-			return;
-		} else {
-			aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, SW);
-			mdelay(100);
-			aml_ci_io_write_by_spi(ci_dev, 0, COM_STA_REG, 0);
-			pr_dbg("Buffer size negotiation over!\r\n");
-			pr_dbg("NOW, HOST can communicates with CAM\r\n");
-			pr_dbg("NOW, TEST END\r\n");
-		}
-}
-
-/**
-* Read a tuple from attribute memory.
-*
-* @param ca CA instance.
-* @param slot Slot id.
-* @param address Address to read from. Updated.
-* @param tupleType Tuple id byte. Updated.
-* @param tupleLength Tuple length. Updated.
-* @param tuple Dest buffer for tuple (must be 256 bytes). Updated.
-*
-* @return 0 on success, nonzero on error.
-*/
-static int dvb_ca_en50221_read_tuple(
-int *address, int *tupleType, int *tupleLength, u8 *tuple)
-{
-	int i;
-	int _tupleType;
-	int _tupleLength;
-	int _address = *address;
-
-	/* grab the next tuple length and type */
-	_tupleType = aml_ci_mem_read_by_spi((struct aml_ci *)
-		g_spi_dev->priv, 0, _address);
-	if (_tupleType < 0)
-		return _tupleType;
-	if (_tupleType == 0xff) {
-		pr_dbg("END OF CHAIN TUPLE type:0x%x\n", _tupleType);
-		*address += 2;
-		*tupleType = _tupleType;
-		*tupleLength = 0;
-		return 0;
-	}
-	_tupleLength = aml_ci_mem_read_by_spi((struct aml_ci *)
-		g_spi_dev->priv, 0, _address + 2);
-	if (_tupleLength < 0)
-		return _tupleLength;
-	_address += 4;
-
-	pr_dbg("TUPLE type:0x%x length:%i\n", _tupleType, _tupleLength);
-
-	/* read in the whole tuple */
-	for (i = 0; i < _tupleLength; i++) {
-		tuple[i] = aml_ci_mem_read_by_spi((struct aml_ci *)
-			g_spi_dev->priv, 0, _address + (i * 2));
-		pr_dbg("  0x%02x: 0x%02x %c\n",
-		i, tuple[i] & 0xff,
-		((tuple[i] > 31) && (tuple[i] < 127)) ? tuple[i] : '.');
-	}
-	_address += (_tupleLength * 2);
-
-	/* success */
-	*tupleType = _tupleType;
-	*tupleLength = _tupleLength;
-	*address = _address;
-	return 0;
-}
-static char *findstr(char *haystack, int hlen, char *needle, int nlen)
-{
-	int i;
-
-	if (hlen < nlen)
-		return NULL;
-
-	for (i = 0; i <= hlen - nlen; i++) {
-		if (!strncmp(haystack + i, needle, nlen))
-			return haystack + i;
-	}
-
-	return NULL;
-}
-
-/**
-* Parse attribute memory of a CAM module, extracting Config register, and checking
-* it is a DVB CAM module.
-*
-* @param ca CA instance.
-* @param slot Slot id.
-*
-* @return 0 on success, <0 on failure.
-*/
-static int dvb_ca_en50221_parse_attributes(void)
-{
-	int address = 0;
-	int tupleLength;
-	int tupleType;
-	u8 tuple[257];
-	char *dvb_str;
-	int rasz;
-	int status;
-	int got_cftableentry = 0;
-	int end_chain = 0;
-	int i;
-	u16 manfid = 0;
-	u16 devid = 0;
-	int config_base = 0;
-	int config_option;
-
-	/* CISTPL_DEVICE_0A */
-	status = dvb_ca_en50221_read_tuple(&address,
-	&tupleType, &tupleLength, tuple);
-	if (status < 0) {
-		pr_error("read status error\r\n");
-		return status;
-	}
-	if (tupleType != 0x1D) {
-		pr_error("read tupleType error [0x%x]\r\n", tupleType);
-		return -EINVAL;
-	}
-
-
-
-	/* CISTPL_DEVICE_0C */
-	status = dvb_ca_en50221_read_tuple(&address,
-	&tupleType, &tupleLength, tuple);
-	if (status < 0) {
-		pr_error("read read cis  error\r\n");
-		return status;
-	}
-	if (tupleType != 0x1C) {
-		pr_error("read read cis type error\r\n");
-		return -EINVAL;
-	}
-
-
-
-	/* CISTPL_VERS_1 */
-	status = dvb_ca_en50221_read_tuple(&address,
-	&tupleType, &tupleLength, tuple);
-	if (status < 0) {
-		pr_error("read read cis  version error\r\n");
-		return status;
-	}
-	if (tupleType != 0x15) {
-		pr_error("read read cis version type error\r\n");
-		return -EINVAL;
-	}
-
-
-
-	/* CISTPL_MANFID */
-	status = dvb_ca_en50221_read_tuple(&address, &tupleType,
-	&tupleLength, tuple);
-	if (status < 0) {
-		pr_error("read read cis manfid error\r\n");
-		return status;
-	}
-	if (tupleType != 0x20) {
-		pr_error("read read cis manfid type error\r\n");
-		return -EINVAL;
-	}
-	if (tupleLength != 4) {
-		pr_error("read read cis manfid len error\r\n");
-		return -EINVAL;
-	}
-	manfid = (tuple[1] << 8) | tuple[0];
-	devid = (tuple[3] << 8) | tuple[2];
-
-
-
-	/* CISTPL_CONFIG */
-	status = dvb_ca_en50221_read_tuple(&address, &tupleType,
-	&tupleLength, tuple);
-	if (status < 0) {
-		pr_error("read read cis config error\r\n");
-		return status;
-	}
-	if (tupleType != 0x1A) {
-		pr_error("read read cis config type error\r\n");
-		return -EINVAL;
-	}
-	if (tupleLength < 3) {
-		pr_error("read read cis config len error\r\n");
-		return -EINVAL;
-	}
-
-	/* extract the configbase */
-	rasz = tuple[0] & 3;
-	if (tupleLength < (3 + rasz + 14)) {
-		pr_error("read extract the configbase  error\r\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < rasz + 1; i++)
-		config_base |= (tuple[2 + i] << (8 * i));
-
-
-	/* check it contains the correct DVB string */
-	dvb_str = findstr((char *)tuple, tupleLength, "DVB_CI_V", 8);
-	if (dvb_str == NULL) {
-		pr_error("find dvb str DVB_CI_V  error\r\n");
-		return -EINVAL;
-	}
-	if (tupleLength < ((dvb_str - (char *) tuple) + 12)) {
-		pr_error("find dvb str DVB_CI_V len error\r\n");
-		return -EINVAL;
-	}
-
-	/* is it a version we support? */
-	if (strncmp(dvb_str + 8, "1.00", 4)) {
-		pr_error(" Unsupported DVB CAM module version %c%c%c%c\n",
-		dvb_str[8], dvb_str[9], dvb_str[10], dvb_str[11]);
-		return -EINVAL;
-	}
-
-/* process the CFTABLE_ENTRY tuples, and any after those */
-while ((!end_chain) && (address < 0x1000)) {
-		status = dvb_ca_en50221_read_tuple(&address, &tupleType,
-	&tupleLength, tuple);
-	if (status < 0) {
-		pr_error("process the CFTABLE_ENTRY tuples error\r\n");
-		return status;
-	}
-
-	switch (tupleType) {
-	case 0x1B:	/* CISTPL_CFTABLE_ENTRY */
-			if (tupleLength < (2 + 11 + 17))
-				break;
-
-			/* if we've already parsed one, just use it */
-			if (got_cftableentry)
-				break;
-
-			/* get the config option */
-			config_option = tuple[0] & 0x3f;
-
-			/* OK, check it contains the correct strings */
-			if ((findstr((char *)tuple,
-				tupleLength, "DVB_HOST", 8) == NULL) ||
-			(findstr((char *)tuple,
-			tupleLength, "DVB_CI_MODULE", 13) == NULL))
-				break;
-
-
-			got_cftableentry = 1;
-			break;
-
-	case 0x14:	/* CISTPL_NO_LINK*/
-			break;
-
-	case 0xFF:	/* CISTPL_END */
-			end_chain = 1;
-			break;
-
-	default:
-		/* Unknown tuple type - just skip
-		*this tuple and move to the next one
-		*/
-pr_error("Skipping unknown tupletype:0x%x L:0x%x\n",
-				tupleType, tupleLength);
-			break;
-		}
-	}
-
-	if ((address > 0x1000) || (!got_cftableentry)) {
-		pr_error("got_cftableentry :%d\r\n", got_cftableentry);
-		return -EINVAL;
-	}
-
-	pr_error("----------ci cis ok-----\r\n");
-	return 0;
-}
-
-static ssize_t aml_spi_ci_reset_help(struct class *class,
-struct class_attribute *attr, char *buf)
-{
-	int ret;
-	ret = sprintf(buf, "echo 1 > %s\n\t", attr->attr.name);
-	return ret;
-}
-
-static ssize_t aml_spi_ci_reset(struct class *class,
-struct class_attribute *attr, const char *buf, size_t size)
-{
-	int ret;
-	struct aml_ci *ci = (struct aml_ci *)g_spi_dev->priv;
-	ret = aml_ci_slot_reset(ci, 0);
-	return size;
-}
-
-static ssize_t aml_spi_ci_pwr_help(struct class *class,
-struct class_attribute *attr, char *buf)
-{
-	int ret;
-	ret = sprintf(buf, "echo 1|0> %s\n\t", attr->attr.name);
-	return ret;
-}
-
-static ssize_t aml_spi_ci_pwr(struct class *class,
-struct class_attribute *attr, const char *buf, size_t size)
-{
-	int ret = 0;
-	int enable = 0;
-	long value;
-	if (kstrtol(buf, 0, &value) == 0)
-		enable = (int)value;
-	ret = aml_gio_power(&g_spi_dev->pc, enable);
-	return size;
-}
-static ssize_t aml_spi_ci_state_show(struct class *class,
-struct class_attribute *attr, char *buf)
-{
-	int ret;
-	struct aml_ci *ci = (struct aml_ci *)g_spi_dev->priv;
-	ret = aml_ci_slot_status(ci, 0, 0);
-	ret = sprintf(buf, "%s: %d;\n\t", attr->attr.name, ret);
-	return ret;
-}
-
-static ssize_t aml_spi_ci_irq_show(struct class *class,
-struct class_attribute *attr, char *buf)
-{
-	int ret;
-	ret = aml_ci_gio_get_irq();
-	ret = sprintf(buf, "%s irq: %d\n\t", attr->attr.name, ret);
-	return ret;
-}
-
-static ssize_t aml_spi_io_test_help(struct class *class,
-struct class_attribute *attr, char *buf)
-{
-	int ret;
-	ret = sprintf(buf, "echo (r|w|f|c)(i|a) addr data > %s\n",
-	attr->attr.name);
-	return ret;
-}
-
-static ssize_t aml_spi_io_test(struct class *class,
-struct class_attribute *attr, const char *buf, size_t size)
-{
-	int n = 0;
-	char *buf_orig, *ps, *token;
-	char *parm[3];
-	unsigned int addr = 0, val = 0, retval = 0;
-	long value = 0;
-	struct aml_ci *ci = (struct aml_ci *)g_spi_dev->priv;
-	buf_orig = kstrdup(buf, GFP_KERNEL);
-	ps = buf_orig;
-	while (1) {
-		/*need set '\n' to ' \n'*/
-		token = strsep(&ps, "\n");
-		if (token == NULL)
-			break;
-		if (*token == '\0')
-			continue;
-		parm[n++] = token;
-	}
-
-	if (!n || ((n > 0) && (strlen(parm[0]) != 2))) {
-		pr_err("invalid command\n");
-		kfree(buf_orig);
-		return size;
-	}
-
-	if ((parm[0][0] == 'r')) {
-		if (n != 2) {
-			pr_err("read: invalid parameter\n");
-			kfree(buf_orig);
-			return size;
-		}
-	if (kstrtol(parm[1], 0, &value) == 0)
-		addr = (int)value;
-		pr_err("%s 0x%x\n", parm[0], addr);
-	/*	switch ((char)parm[0][1]) {
-			case 'i':
-				retval = aml_ci_io_read_by_spi(ci, 0, addr);
-				break;
-			case 'a':
-				retval = aml_ci_mem_read_by_spi(ci, 0, addr);
-				break;
-			default:
-				break;
-		}*/
-		pr_dbg("%s: 0x%x --> 0x%x\n", parm[0], addr, retval);
-	} else if ((parm[0][0] == 'w')) {
-		if (n != 3) {
-			pr_err("write: invalid parameter\n");
-			kfree(buf_orig);
-			return size;
-		}
-		if (kstrtol(parm[1], 0, &value) == 0)
-				addr = (int)value;
-		if (kstrtol(parm[2], 0, &value) == 0)
-				val = (int)value;
-
-		pr_err("%s 0x%x 0x%x", parm[0], addr, val);
-		/*switch ((char)parm[0][1]) {
-			case 'i':
-retval = aml_ci_io_write_by_spi(ci, 0, addr, val);
-				break;
-			case 'a':
-retval = aml_ci_mem_write_by_spi(ci, 0, addr, val);
-				break;
-			default:
-				break;
-		}*/
-		pr_dbg("%s: 0x%x <-- 0x%x\n", parm[0], addr, retval);
-	} else if ((parm[0][0] == 'f')) {
-		pr_dbg("full test----\r\n");
-		aml_spi_ca_full_test(ci);
-	} else if ((parm[0][0] == 'c')) {
-		pr_dbg("cis test----\r\n");
-		aml_ci_full_test_by_spi(ci, 0, addr);
-	} else if ((parm[0][0] == 'p')) {
-		pr_dbg("cis dvb_ca_en50221_parse_attributes----\r\n");
-		dvb_ca_en50221_parse_attributes();
-	}
-
-	kfree(buf_orig);
-	return size;
-}
-
-static struct class_attribute aml_spi_class_attrs[] = {
-	__ATTR(reset,  S_IRUGO | S_IWUSR,
-		aml_spi_ci_reset_help, aml_spi_ci_reset),
-	__ATTR(pwr,  S_IRUGO | S_IWUSR,
-		aml_spi_ci_pwr_help, aml_spi_ci_pwr),
-	__ATTR(irq,  S_IRUGO | S_IWUSR,
-		aml_spi_ci_irq_show, NULL),
-	__ATTR(status,  S_IRUGO | S_IWUSR,
-		aml_spi_ci_state_show, NULL),
-	__ATTR(iotest,  S_IRUGO | S_IWUSR,
-		aml_spi_io_test_help, aml_spi_io_test),
-	__ATTR_NULL
-};
-
-static struct class aml_spi_class = {
-	.name = "aml_dvb_spi_test",
-	.class_attrs = aml_spi_class_attrs,
-};
-
-static int  aml_spi_mod_init(void)
-{
-	int ret;
-	pr_dbg("Amlogic DVB SPI Init\n");
-	ret = class_register(&aml_spi_class);
-	return 0;
-}
-
-static void  aml_spi_mod_exit(void)
-{
-	pr_dbg("Amlogic DVB SPI Exit\n");
-	class_unregister(&aml_spi_class);
-}
-
-module_init(aml_spi_mod_init);
-module_exit(aml_spi_mod_exit);
-
-MODULE_LICENSE("GPL");
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.h b/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.h
deleted file mode 100644
index 1b04caf..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/aml_spi.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
-* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful, but WITHOUT
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-* more details.
-*
-* You should have received a copy of the GNU General Public License along
-* with this program; if not, write to the Free Software Foundation, Inc.,
-* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*
-* Description:
-*/
-#ifndef __AML_SPI_H_
-#define __AML_SPI_H_
-
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/gpio/consumer.h>
-#include "aml_pcmcia.h"
-#include "aml_ci.h"
-#include "drivers/media/dvb-core/dvb_ca_en50221.h"
-
-/*
-aml spi dev
-*/
-struct aml_spi {
-		spinlock_t spi_lock;
-
-		/* add SPI DEV */
-		struct spi_board_info *spi_bdinfo;
-		struct spi_device *spi;
-		struct platform_device *pdev;
-		struct device *dev;
-
-		/* spi otherconfig */
-		int cs_hold_delay;
-		int cs_clk_delay;
-		int write_check;
-
-		/* add gpio pin */
-		struct gpio_desc *reset_pin;
-		int reset_pin_value;
-		struct gpio_desc *cd_pin1;
-		int cd_pin1_value;
-		struct gpio_desc *cd_pin2;
-		int cd_pin2_value;
-		struct gpio_desc *pwr_pin;
-		int pwr_pin_value;
-
-		/* cam and mcu irq */
-		struct gpio_desc *irq_cam_pin;
-		int irq_cam_pin_value;
-		int irq;
-		struct aml_pcmcia pc;
-		void *priv;
-};
-enum aml_gpio_level_e {
-		AML_GPIO_LOW = 0,
-		AML_GPIO_HIGH
-};
-
-/* used to mcu */
-#define DATASTART 0xef
-#define DATAEND   0xfe
-enum AM_CI_CMD {
-		AM_CI_CMD_IOR = 0,
-		AM_CI_CMD_IOW,
-		AM_CI_CMD_MEMR,
-		AM_CI_CMD_MEMW,
-		AM_CI_CMD_FULLTEST,
-		AM_CI_CMD_CISTEST
-};
-enum AM_SPI_RECIVERSTEP {
-		AM_SPI_STEP_INIT = 0,
-		AM_SPI_STEP_START1,
-		AM_SPI_STEP_START2,
-		AM_SPI_STEP_CMD,
-		AM_SPI_STEP_DATA,
-		AM_SPI_STEP_ADDR1,
-		AM_SPI_STEP_ADDR2,
-		AM_SPI_STEP_END1,
-		AM_SPI_STEP_END2
-};
-extern int dirspi_xfer(struct spi_device *spi, u8 *tx_buf, u8 *rx_buf,
-		       int len);
-extern int dirspi_write(struct spi_device *spi, u8 *buf, int len);
-extern int dirspi_read(struct spi_device *spi, u8 *buf, int len);
-extern void dirspi_start(struct spi_device *spi);
-extern void dirspi_stop(struct spi_device *spi);
-extern void dvb_ca_en50221_camready_irq(struct dvb_ca_en50221 *pubca, int slot);
-extern int aml_spi_init(struct platform_device *pdev, struct aml_ci *ci_dev);
-extern int aml_spi_exit(struct aml_ci *ci_dev);
-
-#endif				/* __AML_SPI_H_ */
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax.c
deleted file mode 100644
index 9346b8d..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax.c
+++ /dev/null
@@ -1,279 +0,0 @@
-
-/***************************************************************************
- * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
- *
- * This source code is subject to the terms and conditions defined in the
- * file 'LICENSE' which is part of this source code package.
- *
- * Description:
- *
-***************************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/device.h>
-#include <linux/slab.h>
-#include <linux/kthread.h>
-//#include <linux/switch.h>
-#include "../aml_ci.h"
-#include "aml_cimax.h"
-#include "aml_cimax_spi.h"
-#include "aml_cimax_usb.h"
-
-#define MODUDLE_NAME       "aml_cimax"
-
-MODULE_PARM_DESC(cimax_debug, "enable verbose debug messages");
-static int aml_cimax_debug = 1;
-module_param_named(cimax_debug, aml_cimax_debug, int, 0644);
-
-//static struct switch_dev slot_state = {
-//	.name = "ci_slot",
-//};
-
-#define pr_dbg(fmt...)\
-	do {\
-		if (aml_cimax_debug)\
-			pr_info("AML_CIMAX: " fmt);\
-	} while (0)
-#define pr_error(fmt...) pr_err("AML_CIMAX: " fmt)
-
-static int aml_cimax_slot_reset(struct aml_ci *ci, int slot)
-{
-	int ret = 0;
-	struct aml_cimax *cimax = ci->data;
-	pr_dbg("cimax: slot(%d) reset\n", slot);
-	if (cimax->ops.slot_reset)
-		ret = cimax->ops.slot_reset(cimax, slot);
-	return ret;
-}
-
-static int aml_cimax_slot_shutdown(struct aml_ci *ci, int slot)
-{
-	pr_dbg("slot(%d) shutdown\n", slot);
-	return 0;
-}
-
-static int aml_cimax_slot_ts_enable(struct aml_ci *ci, int slot)
-{
-	pr_dbg("slot(%d) ts control\n", slot);
-	return 0;
-}
-
-static int aml_cimax_slot_status(struct aml_ci *ci, int slot, int open)
-{
-	int ret = 0;
-	struct aml_cimax *cimax = ci->data;
-
-	/*pr_dbg("cimax: slot(%d) poll\n", slot);*/
-	if (cimax->ops.slot_status)
-		ret = cimax->ops.slot_status(cimax, slot);
-	return ret;
-}
-
-#define DEF_FUNC_WRAPPER3(_pre, _fn, _S, _P1, _P2, _P3) \
-static int _pre##_fn(_S s, _P1 p1, _P2 p2, _P3 p3)\
-{\
-	struct aml_cimax *cimax = s->data;\
-	/*pr_dbg("%s\n", #_fn);*/\
-	if (cimax->ops._fn)\
-		return cimax->ops._fn(cimax, p1, p2, p3);\
-	return 0;\
-}
-
-/*DEF_FUNC_WRAPPER3(aml_cimax_, read_reg, struct aml_ci*, int, u8*, int)*/
-/*DEF_FUNC_WRAPPER3(aml_cimax_, write_reg, struct aml_ci*, int, u8*, int)*/
-DEF_FUNC_WRAPPER3(aml_cimax_, read_cis, struct aml_ci*, int, u8*, int)
-DEF_FUNC_WRAPPER3(aml_cimax_, read_lpdu, struct aml_ci*, int, u8*, int)
-DEF_FUNC_WRAPPER3(aml_cimax_, write_lpdu, struct aml_ci*, int, u8*, int)
-
-static int aml_cimax_write_cor(struct aml_ci *ci, int slot, int addr, u8 *buf)
-{
-	struct aml_cimax *cimax = ci->data;
-	pr_dbg("write_cor\n");
-	if (cimax->ops.write_cor)
-		return cimax->ops.write_cor(cimax, slot, addr, buf);
-	return 0;
-}
-
-static int aml_cimax_negotiate(struct aml_ci *ci, int slot, int size)
-{
-	struct aml_cimax *cimax = ci->data;
-	pr_dbg("negotiate\n");
-	if (cimax->ops.negotiate)
-		return cimax->ops.negotiate(cimax, slot, size);
-	return 0;
-}
-
-static int aml_cimax_read_cam_status(struct aml_ci *ci, int slot)
-{
-	struct aml_cimax *cimax = ci->data;
-	if (cimax->ops.read_cam_status)
-		return cimax->ops.read_cam_status(cimax, slot);
-	return 0;
-}
-
-static int aml_cimax_cam_reset(struct aml_ci *ci, int slot)
-{
-	struct aml_cimax *cimax = ci->data;
-	if (cimax->ops.cam_reset)
-		return cimax->ops.cam_reset(cimax, slot);
-	return 0;
-}
-
-static int aml_cimax_get_capbility(struct aml_ci *ci, int slot)
-{
-	return 0;
-}
-
-int aml_cimax_camchanged(struct aml_cimax *cimax, int slot, int plugin)
-{
-	struct aml_ci *ci = cimax->ci;
-	if (plugin) {
-		dvb_ca_en50221_cimax_camchange_irq(&ci->en50221_cimax,
-			slot, DVB_CA_EN50221_CAMCHANGE_INSERTED);
-	} else {
-		dvb_ca_en50221_cimax_camchange_irq(&ci->en50221_cimax,
-			slot, DVB_CA_EN50221_CAMCHANGE_REMOVED);
-	}
-	return 0;
-}
-
-static int aml_cimax_start(struct aml_cimax *cimax)
-{
-	int ret = 0;
-	if (cimax->ops.start)
-		ret = cimax->ops.start(cimax);
-	return ret;
-}
-
-static int aml_cimax_stop(struct aml_cimax *cimax)
-{
-	int ret = 0;
-	if (cimax->ops.stop)
-		ret = cimax->ops.stop(cimax);
-	return ret;
-}
-
-static int aml_cimax_get_config_from_dts(struct aml_cimax *cimax)
-{
-	struct device_node *child = NULL;
-	struct platform_device *pdev = cimax->pdev;
-	struct device_node *np = pdev->dev.of_node;
-	unsigned int val;
-	int ret = 0;
-	pr_dbg("get cimax dts\n");
-
-	child = of_get_child_by_name(np, "cimax");
-	if (child == NULL) {
-		pr_error("failed to get cimax\n");
-		return -1;
-	}
-	ret = of_property_read_u32(child, "io_type", &val);
-	if (ret)
-		cimax->io_type = IO_TYPE_SPI;
-	else
-		cimax->io_type = val;
-
-	return 0;
-}
-
-int aml_cimax_init(struct platform_device *pdev, struct aml_ci *ci)
-{
-	struct aml_cimax *cimax = NULL;
-	int ret = 0;
-
-	cimax = kzalloc(sizeof(struct aml_cimax), GFP_KERNEL);
-	if (!cimax) {
-		pr_error("Out of memory!, exiting ..\n");
-		return -ENOMEM;
-	}
-	cimax->pdev = pdev;
-	cimax->ci = ci;
-
-	aml_cimax_get_config_from_dts(cimax);
-
-	if (cimax->io_type == IO_TYPE_SPI) {
-		//ret = aml_cimax_spi_init(pdev, cimax);
-	}
-	else {
-		ret = aml_cimax_usb_init(pdev, cimax);
-	}
-
-	if (ret != 0) {
-		kfree(cimax);
-		cimax = NULL;
-		return -EIO;
-	}
-
-	ret = aml_cimax_start(cimax);
-	if (ret != 0)
-		return ret;
-
-	ci->ci_read_cis = aml_cimax_read_cis;
-	ci->ci_write_cor = aml_cimax_write_cor;
-	ci->ci_negotiate = aml_cimax_negotiate;
-	ci->ci_read_lpdu = aml_cimax_read_lpdu;
-	ci->ci_write_lpdu = aml_cimax_write_lpdu;
-	ci->ci_read_cam_status = aml_cimax_read_cam_status;
-	ci->ci_cam_reset = aml_cimax_cam_reset;
-	ci->ci_get_capbility = aml_cimax_get_capbility;
-	ci->ci_slot_reset = aml_cimax_slot_reset;
-	ci->ci_slot_shutdown = aml_cimax_slot_shutdown;
-	ci->ci_slot_ts_enable = aml_cimax_slot_ts_enable;
-	ci->ci_poll_slot_status = aml_cimax_slot_status;
-
-	ci->data = cimax;
-	return 0;
-}
-EXPORT_SYMBOL(aml_cimax_init);
-
-int aml_cimax_exit(struct aml_ci *ci)
-{
-	struct aml_cimax *cimax = ci->data;
-
-	aml_cimax_stop(cimax);
-
-	if (cimax->io_type == IO_TYPE_SPI) {
-        //aml_cimax_spi_exit(cimax);
-	}
-	else {
-		aml_cimax_usb_exit(cimax);
-	}
-	kfree(cimax);
-	ci->data = NULL;
-
-	return 0;
-}
-EXPORT_SYMBOL(aml_cimax_exit);
-
-int aml_cimax_slot_state_changed(struct aml_cimax *cimax, int slot, int state)
-{
-	//if (slot == 0)
-	//	switch_set_state(&slot_state, state);
-	return 0;
-}
-EXPORT_SYMBOL(aml_cimax_slot_state_changed);
-#if 0
-static int __init aml_cimax_mod_init(void)
-{
-	pr_dbg("Amlogic DVB CIMAX Init\n");
-	//switch_dev_register(&slot_state);
-	//switch_set_state(&slot_state, 0);
-	return 0;
-}
-
-static void __exit aml_cimax_mod_exit(void)
-{
-	pr_dbg("Amlogic DVB CIMAX Exit\n");
-	//switch_dev_unregister(&slot_state);
-}
-
-module_init(aml_cimax_mod_init);
-module_exit(aml_cimax_mod_exit);
-
-MODULE_LICENSE("GPL");
-#endif
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax.h
deleted file mode 100644
index 17c62fa..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/***************************************************************************
- * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
- *
- * This source code is subject to the terms and conditions defined in the
- * file 'LICENSE' which is part of this source code package.
- *
- * Description:
- *
-***************************************************************************/
-
-#ifndef __AML_CIMAX_H_
-#define __AML_CIMAX_H_
-
-#include "../aml_ci.h"
-#include "dvb_ca_en50221_cimax.h"
-
-struct aml_cimax;
-
-struct aml_cimax_ops {
-	int (*read_cis)(struct aml_cimax *cimax, int slot, u8 *buf, int size);
-	int (*write_cor)(struct aml_cimax *cimax,
-			int slot, int address, u8 *buf);
-	int (*negotiate)(struct aml_cimax *cimax, int slot, int size);
-	int (*read_lpdu)(struct aml_cimax *cimax, int slot, u8 *buf, int size);
-	int (*write_lpdu)(struct aml_cimax *cimax, int slot, u8 *buf, int size);
-	int (*read_cam_status)(struct aml_cimax *cimax, int slot);
-	int (*cam_reset)(struct aml_cimax *cimax, int slot);
-	int (*get_capblility)(struct aml_cimax *cimax, int slot);
-
-	int (*slot_reset)(struct aml_cimax *cimax, int slot);
-	int (*slot_shutdown)(struct aml_cimax *cimax, int slot);
-	int (*slot_ts_enable)(struct aml_cimax *cimax, int slot);
-	int (*slot_status)(struct aml_cimax *cimax, int slot);
-
-	/*load fw etc.*/
-	int (*start)(struct aml_cimax *cimax);
-	int (*stop)(struct aml_cimax *cimax);
-
-	/*cimax reg*/
-	int (*read_reg)(struct aml_cimax *cimax, int addr, u8 *buf, int size);
-	int (*write_reg)(struct aml_cimax *cimax, int addr, u8 *buf, int size);
-};
-
-struct aml_cimax {
-	struct platform_device *pdev;
-	struct device *dev;
-	struct aml_ci *ci;
-
-	int io_type;
-#define IO_TYPE_SPI 0
-#define IO_TYPE_USB 1
-	struct aml_cimax_ops ops;
-	void *priv;
-};
-
-int aml_cimax_init(struct platform_device *pdev, struct aml_ci *ci_dev);
-int aml_cimax_exit(struct aml_ci *ci_dev);
-
-int aml_cimax_camchanged(struct aml_cimax *cimax, int slot, int plugin);
-int aml_cimax_slot_state_changed(struct aml_cimax *cimax, int slot, int state);
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_spi.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_spi.c
deleted file mode 100644
index a4aadda..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_spi.c
+++ /dev/null
@@ -1,2139 +0,0 @@
-/***************************************************************************
- * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
- *
- * This source code is subject to the terms and conditions defined in the
- * file 'LICENSE' which is part of this source code package.
- *
- * Description:
- *
-***************************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/gpio/consumer.h>
-#include <linux/device.h>
-#include <linux/slab.h>
-#include <linux/amlogic/sd.h>
-#include <linux/of_irq.h>
-#include <linux/irq.h>
-#include <linux/mutex.h>
-#include <linux/firmware.h>
-#include <linux/delay.h>
-
-#include "aml_cimax.h"
-
-#define MOD_NAME       "aml_cimax_spi"
-
-#define pr_dbg(fmt...)\
-	do {\
-		if (cimax_spi_debug)\
-			pr_info("cimax_spi: "fmt);\
-	} while (0)
-#define pr_error(fmt...) pr_err("AML_CIMAX_SPI: " fmt)
-
-#define BUFFIN_CFG                        0x0000
-#define BUFFIN_ADDR_LSB                   0x0001
-#define BUFFIN_ADDR_MSB                   0x0002
-#define BUFFIN_DATA                       0x0003
-#define BUFFOUT_CFG                       0x0004
-#define BUFFOUT_ADDR_LSB                  0x0005
-#define BUFFOUT_ADDR_MSB                  0x0006
-#define BUFFOUT_DATA                      0x0007
-#define BOOT_Key                          0x0008
-#define BOOT_Status                       0x0009
-#define BOOT_Test                         0x000A
-#define usb2_0_irq_mask                   0x0010
-#define usb2_0_status                     0x0011
-#define usb2_0_rx                         0x0012
-#define usb2_0_tx                         0x0013
-#define SPI_Slave_Ctrl                    0x0018
-#define SPI_Slave_Status                  0x0019
-#define SPI_Slave_Rx                      0x001A
-#define SPI_Slave_Tx                      0x001B
-#define SPI_Slave_Mask                    0x001C
-#define UCSG_Ctrl                         0x0020
-#define UCSG_Status                       0x0021
-#define UCSG_RxData                       0x0022
-#define UCSG_TxData                       0x0023
-#define PCtrl_Ctrl                        0x0028
-#define PCtrl_Status                      0x0029
-#define PCtrl_NbByte_LSB                  0x002A
-#define PCtrl_NbByte_MSB                  0x002B
-#define SPI_Master_Ctl                    0x0030
-#define SPI_Master_NCS                    0x0031
-#define SPI_Master_Status                 0x0032
-#define SPI_Master_TxBuf                  0x0033
-#define SPI_Master_RxBuf                  0x0034
-#define BISTRAM_Ctl                       0x0038
-#define BISTRAM_Bank                      0x0039
-#define BISTRAM_Pat                       0x003A
-#define BISTRAM_SM                        0x003B
-#define BISTRAM_AddrLSB                   0x003C
-#define BISTROM_Config                    0x0040
-#define BISTROM_SignatureLSB              0x0041
-#define BISTROM_SignatureMSB              0x0042
-#define BISTROM_StartAddrLSB              0x0043
-#define BISTROM_StartAddrMSB              0x0043
-#define BISTROM_StopAddrLSB               0x0043
-#define BISTROM_StopAddrMSB               0x0043
-#define CkMan_Config                      0x0048
-#define CkMan_Select                      0x0049
-#define CkMan_Test                        0x004A
-#define Revision_Number                   0x004B
-#define ResMan_Config                     0x0050
-#define ResMan_Status                     0x0051
-#define ResMan_WD                         0x0052
-#define ResMan_WD_MSB                     0x0053
-#define CPU_Test                          0x0060
-#define IrqMan_Config0                    0x0068
-#define IrqMan_Config1                    0x0069
-#define IrqMan_Irq0                       0x006A
-#define IrqMan_NMI                        0x006B
-#define IrqMan_SleepKey                   0x006C
-#define Tim_Config                        0x0070
-#define Tim_Value_LSB                     0x0071
-#define Tim_Value_MSB                     0x0072
-#define Tim_Comp_LSB                      0x0073
-#define Tim_Comp_MSB                      0x0074
-#define TI_Config                         0x0076
-#define TI_Data                           0x0077
-#define TI_Reg0                           0x0078
-#define TI_Reg1                           0x0079
-#define TI_Reg2                           0x007A
-#define TI_Reg3                           0x007B
-#define TI_Reg4                           0x007C
-#define TI_ROM1                           0x007D
-#define TI_ROM2                           0x007E
-#define TI_ROM3                           0x007F
-#define DVBCI_START_ADDR                  0x0100
-#define DVBCI_END_ADDR                    0x017F
-#define DATA                              0x0180
-/*#define CTRL                            0x0181*/
-#define QB_HOST                           0x0182
-#define LEN_HOST_LSB                      0x0183
-#define LEN_HOST_MSB                      0x0184
-#define FIFO_TX_TH_LSB                    0x0185
-#define FIFO_TX_TH_MSB                    0x0186
-#define FIFO_TX_D_NB_LSB                  0x0187
-#define FIFO_TX_D_NB_MSB                  0x0188
-#define QB_MOD_CURR                       0x0189
-#define LEN_MOD_CURR_LSB                  0x018A
-#define LEN_MOD_CURR_MSB                  0x018B
-#define QB_MOD                            0x018C
-#define LEN_MOD_LSB                       0x018D
-#define LEN_MOD_MSB                       0x018E
-#define FIFO_RX_TH_LSB                    0x018F
-#define FIFO_RX_TH_MSB                    0x0190
-#define FIFO_RX_D_NB_LSB                  0x0191
-#define FIFO_RX_D_NB_MSB                  0x0192
-#define IT_STATUS_0                       0x0193
-#define IT_STATUS_1                       0x0194
-#define IT_MASK_0                         0x0195
-#define IT_MASK_1                         0x0196
-#define IT_HOST_PIN_CFG                   0x0200
-#define CFG_0                             0x0201
-#define CFG_1                             0x0202
-#define CFG_2                             0x0203
-#define IT_HOST                           0x0204
-#define MOD_IT_STATUS                     0x0205
-#define MOD_IT_MASK                       0x0206
-#define MOD_CTRL_A                        0x0207
-#define MOD_CTRL_B                        0x0208
-#define DEST_SEL                          0x0209
-#define CAM_MSB_ADD                       0x020A
-#define GPIO0_DIR                         0x020B
-#define GPIO0_DATA_IN                     0x020C
-#define GPIO0_DATA_OUT                    0x020D
-#define GPIO0_STATUS                      0x020E
-#define GPIO0_IT_MASK                     0x020F
-#define GPIO0_DFT                         0x0210
-#define GPIO0_MASK_DATA                   0x0211
-#define GPIO1_DIR                         0x0212
-#define GPIO1_DATA_IN                     0x0213
-#define GPIO1_DATA_OUT                    0x0214
-#define GPIO1_STATUS                      0x0215
-#define GPIO1_IT_MASK                     0x0216
-#define MEM_ACC_TIME_A                    0x0217
-#define MEM_ACC_TIME_B                    0x0218
-#define IO_ACC_TIME_A                     0x0219
-#define IO_ACC_TIME_B                     0x021A
-#define EXT_CH_ACC_TIME_A                 0x021B
-#define EXT_CH_ACC_TIME_B                 0x021C
-#define PAR_IF_0                          0x021D
-#define PAR_IF_1                          0x021E
-#define PAR_IF_CTRL                       0x021F
-#define PCK_LENGTH                        0x0220
-#define USB2TS_CTRL                       0x0221
-#define USB2TS0_RDL                       0x0222
-#define USB2TS1_RDL                       0x0223
-#define TS2USB_CTRL                       0x0224
-#define TSOUT_PAR_CTRL                    0x0225
-#define TSOUT_PAR_CLK_SEL                 0x0226
-#define S2P_CH0_CTRL                      0x0227
-#define S2P_CH1_CTRL                      0x0228
-#define P2S_CH0_CTRL                      0x0229
-#define P2S_CH1_CTRL                      0x022A
-#define TS_IT_STATUS                      0x022B
-#define TS_IT_MASK                        0x022C
-#define IN_SEL                            0x022D
-#define OUT_SEL                           0x022E
-#define ROUTER_CAM_CH                     0x022F
-#define ROUTER_CAM_MOD                    0x0230
-#define FIFO_CTRL                         0x0231
-#define FIFO1_2_STATUS                    0x0232
-#define FIFO3_4_STATUS                    0x0233
-#define GAP_REMOVER_CH0_CTRL              0x0234
-#define GAP_REMOVER_CH1_CTRL              0x0235
-#define SYNC_RTV_CTRL                     0x0236
-#define SYNC_RTV_CH0_SYNC_NB              0x0237
-#define SYNC_RTV_CH0_PATTERN              0x0238
-#define SYNC_RTV_CH1_SYNC_NB              0x0239
-#define SYNC_RTV_CH1_PATTERN              0x023A
-#define SYNC_RTV_OFFSET_PATT              0x023B
-#define CTRL_FILTER                       0x023D
-#define PID_EN_FILTER_CH0                 0x023E
-#define PID_EN_FILTER_CH1                 0x023F
-#define PID_LSB_FILTER_CH0_0              0x0240
-#define PID_MSB_FILTER_CH0_0              0x0241
-#define PID_LSB_FILTER_CH0_1              0x0242
-#define PID_MSB_FILTER_CH0_1              0x0243
-#define PID_LSB_FILTER_CH0_2              0x0244
-#define PID_MSB_FILTER_CH0_2              0x0245
-#define PID_LSB_FILTER_CH0_3              0x0246
-#define PID_MSB_FILTER_CH0_3              0x0247
-#define PID_LSB_FILTER_CH0_4              0x0248
-#define PID_MSB_FILTER_CH0_4              0x0249
-#define PID_LSB_FILTER_CH0_5              0x024A
-#define PID_MSB_FILTER_CH0_5              0x024B
-#define PID_LSB_FILTER_CH0_6              0x024C
-#define PID_MSB_FILTER_CH0_6              0x024D
-#define PID_LSB_FILTER_CH0_7              0x024E
-#define PID_MSB_FILTER_CH0_7              0x024F
-#define PID_LSB_FILTER_CH1_0              0x0260
-#define PID_MSB_FILTER_CH1_0              0x0261
-#define PID_LSB_FILTER_CH1_1              0x0262
-#define PID_MSB_FILTER_CH1_1              0x0263
-#define PID_LSB_FILTER_CH1_2              0x0264
-#define PID_MSB_FILTER_CH1_2              0x0265
-#define PID_LSB_FILTER_CH1_3              0x0266
-#define PID_MSB_FILTER_CH1_3              0x0267
-#define PID_LSB_FILTER_CH1_4              0x0268
-#define PID_MSB_FILTER_CH1_4              0x0269
-#define PID_LSB_FILTER_CH1_5              0x026A
-#define PID_MSB_FILTER_CH1_5              0x026B
-#define PID_LSB_FILTER_CH1_6              0x026C
-#define PID_MSB_FILTER_CH1_6              0x026D
-#define PID_LSB_FILTER_CH1_7              0x026E
-#define PID_MSB_FILTER_CH1_7              0x026F
-#define PID_OLD_LSB_REMAPPER_0            0x0280
-#define PID_OLD_MSB_REMAPPER_0            0x0281
-#define PID_OLD_LSB_REMAPPER_1            0x0282
-#define PID_OLD_MSB_REMAPPER_1            0x0283
-#define PID_OLD_LSB_REMAPPER_2            0x0284
-#define PID_OLD_MSB_REMAPPER_2            0x0285
-#define PID_OLD_LSB_REMAPPER_3            0x0286
-#define PID_OLD_MSB_REMAPPER_3            0x0287
-#define PID_OLD_LSB_REMAPPER_4            0x0288
-#define PID_OLD_MSB_REMAPPER_4            0x0289
-#define PID_OLD_LSB_REMAPPER_5            0x028A
-#define PID_OLD_MSB_REMAPPER_5            0x028B
-#define PID_OLD_LSB_REMAPPER_6            0x028C
-#define PID_OLD_MSB_REMAPPER_6            0x028D
-#define PID_OLD_LSB_REMAPPER_7            0x028E
-#define PID_OLD_MSB_REMAPPER_7            0x028F
-#define PID_NEW_LSB_REMAPPER_0            0x02A0
-#define PID_NEW_MSB_REMAPPER_0            0x02A1
-#define PID_NEW_LSB_REMAPPER_1            0x02A2
-#define PID_NEW_MSB_REMAPPER_1            0x02A3
-#define PID_NEW_LSB_REMAPPER_2            0x02A4
-#define PID_NEW_MSB_REMAPPER_2            0x02A5
-#define PID_NEW_LSB_REMAPPER_3            0x02A6
-#define PID_NEW_MSB_REMAPPER_3            0x02A7
-#define PID_NEW_LSB_REMAPPER_4            0x02A8
-#define PID_NEW_MSB_REMAPPER_4            0x02A9
-#define PID_NEW_LSB_REMAPPER_5            0x02AA
-#define PID_NEW_MSB_REMAPPER_5            0x02AB
-#define PID_NEW_LSB_REMAPPER_6            0x02AC
-#define PID_NEW_MSB_REMAPPER_6            0x02AD
-#define PID_NEW_LSB_REMAPPER_7            0x02AE
-#define PID_NEW_MSB_REMAPPER_7            0x02AF
-#define MERGER_DIV_MICLK                  0x02C0
-#define PID_AND_SYNC_REMAPPER_CTRL        0x02C1
-#define PID_EN_REMAPPER                   0x02C2
-#define SYNC_SYMBOL                       0x02C3
-#define PID_AND_SYNC_REMAPPER_INV_CTRL    0x02C4
-#define BITRATE_CH0_LSB                   0x02C5
-#define BITRATE_CH0_MSB                   0x02C6
-#define BITRATE_CH1_LSB                   0x02C7
-#define BITRATE_CH1_MSB                   0x02C8
-#define STATUS_CLK_SWITCH_0               0x02C9
-#define STATUS_CLK_SWITCH_1               0x02CA
-#define RESET_CLK_SWITCH_0                0x02CB
-#define RESET_CLK_SWITCH_1                0x02CC
-#define PAD_DRVSTR_CTRL                   0x02CD
-#define PAD_PUPD_CTRL                     0x02CE
-#define PRE_HEADER_ADDER_CH0_0            0x02D0
-#define PRE_HEADER_ADDER_CH0_1            0x02D1
-#define PRE_HEADER_ADDER_CH0_2            0x02D2
-#define PRE_HEADER_ADDER_CH0_3            0x02D3
-#define PRE_HEADER_ADDER_CH0_4            0x02D4
-#define PRE_HEADER_ADDER_CH0_5            0x02D5
-#define PRE_HEADER_ADDER_CH0_6            0x02D6
-#define PRE_HEADER_ADDER_CH0_7            0x02D7
-#define PRE_HEADER_ADDER_CH0_8            0x02D8
-#define PRE_HEADER_ADDER_CH0_9            0x02D9
-#define PRE_HEADER_ADDER_CH0_10           0x02DA
-#define PRE_HEADER_ADDER_CH0_11           0x02DB
-#define PRE_HEADER_ADDER_CH1_0            0x02E0
-#define PRE_HEADER_ADDER_CH1_1            0x02E1
-#define PRE_HEADER_ADDER_CH1_2            0x02E2
-#define PRE_HEADER_ADDER_CH1_3            0x02E3
-#define PRE_HEADER_ADDER_CH1_4            0x02E4
-#define PRE_HEADER_ADDER_CH1_5            0x02E5
-#define PRE_HEADER_ADDER_CH1_6            0x02E6
-#define PRE_HEADER_ADDER_CH1_7            0x02E7
-#define PRE_HEADER_ADDER_CH1_8            0x02E8
-#define PRE_HEADER_ADDER_CH1_9            0x02E9
-#define PRE_HEADER_ADDER_CH1_10           0x02EA
-#define PRE_HEADER_ADDER_CH1_11           0x02EB
-#define PRE_HEADER_ADDER_CTRL             0x02EC
-#define PRE_HEADER_ADDER_LEN              0x02ED
-#define PRE_HEADER_REMOVER_CTRL           0x02EE
-#define FSM_DVB                           0x02F0
-#define TS2USB_FSM_DEBUG                  0x02F2
-#define TSOUT_PAR_FSM_DEBUG               0x02F3
-#define GAP_REMOVER_FSM_DEBUG             0x02F4
-#define PID_AND_SYNC_REMAPPER_FSM_DEBUG   0x02F5
-#define PRE_HEADER_ADDER_FSM_DEBUG        0x02F6
-#define SYNC_RTV_FSM_DEBUG                0x02F7
-#define CHECK_PHY_CLK                     0x0E00
-#define USB_CTRL1                         0x0E01
-#define USB_ISO2_out                      0x0800
-#define USB_ISO1_out                      0x1000
-#define USB_Interrupt_out                 0x1E00
-#define USB_Bulk_in                       0x1F00
-#define CC2_Buffer_out                    0x2000
-#define USB_EP0                           0x30C0
-#define CC2_Buffer_in                     0x4000
-#define USB_ISO2_in                       0x5800
-#define USB_ISO1_in                       0x6000
-#define nmb_vector_address_lsb            0xFFFA
-#define nmb_vector_address_msb            0xFFFB
-#define reset_vector_address_lsb          0xFFFC
-#define reset_vector_address_msb          0xFFFD
-#define irb_vector_address_lsb            0xFFFE
-#define irb_vector_address_msb            0xFFFF
-
-
-#define CIMAX_REG_HDR_SIZE 4
-#define CIMAX_REG_PLD_SIZE 255
-#define CIMAX_CAM_HDR_SIZE 4
-#define CIMAX_CAM_PLD_SIZE 65535
-
-#define DEF_LOCK(_l_) struct mutex _l_
-
-struct cimax_spi {
-	struct platform_device *pdev;
-	struct spi_device *dev;
-
-	struct aml_cimax *cimax;
-
-	u8 buf[CIMAX_REG_HDR_SIZE + CIMAX_CAM_HDR_SIZE + CIMAX_CAM_PLD_SIZE];
-
-	int cam_inserted[2];
-	int cam_data_ready[2];
-
-	int poll_mode;
-#define STOP_MODE 0
-#define POLL_MODE 1
-#define INT_MODE  2
-
-	int irq;
-	int irq_io;
-	int rst_io;
-
-	struct workqueue_struct *workq;
-	struct delayed_work work;
-	int work_cnt;
-
-	DEF_LOCK(lock);
-#define lock_init(_spi) mutex_init(&(_spi)->lock)
-#define lock_lock(_spi) do {\
-	int err = mutex_lock_interruptible(&(_spi)->lock);\
-	if (err)\
-		return err;\
-} while (0)
-#define lock_unlock(_spi) mutex_unlock(&(_spi)->lock)
-
-	u8 *cis;
-#define CIS_MAX 512
-};
-
-static struct cimax_spi *g_spi;
-
-MODULE_PARM_DESC(debug, "enable verbose debug messages");
-static int cimax_spi_debug = 1;
-module_param_named(debug, cimax_spi_debug, int, 0644);
-
-MODULE_PARM_DESC(poll_interval, "interval for spi poll");
-static int spi_poll_interval = 100;
-module_param_named(poll_interval, spi_poll_interval, int, 0644);
-
-MODULE_PARM_DESC(poll_mode, "set cimax poll mode, need reset");
-static int cimax_poll_mode = 1;
-module_param_named(poll_mode, cimax_poll_mode, int, 0644);
-
-MODULE_PARM_DESC(cam_irq_mode, "set cam irq mode, need reset");
-static int cam_irq_mode;
-module_param_named(cam_irq_mode, cam_irq_mode, int, 0644);
-
-#define CIMAX_REG_READ     0xff
-#define CIMAX_REG_READ_OK  0x4c
-#define CIMAX_REG_WRITE    0x7f
-#define CIMAX_REG_WRITE_OK 0x4d
-#define CIMAX_REG_INIT     0x00
-#define CIMAX_REG_INIT_OK  0x4b
-#define CIMAX_REG_CMD_ERROR 0x51
-
-#define CIMAX_CAM_RESET    0x01
-#define CIMAX_CAM_RESET_OK 0x40
-#define CIMAX_CAM_CIS      0x02
-#define CIMAX_CAM_CIS_OK   0x41
-#define CIMAX_CAM_COR      0x03
-#define CIMAX_CAM_COR_OK   0x42
-#define CIMAX_CAM_NEG      0x04
-#define CIMAX_CAM_NEG_OK   0x43
-#define CIMAX_CAM_WLPDU    0x05
-#define CIMAX_CAM_WLPDU_OK 0x44
-#define CIMAX_CAM_RLPDU    0x06
-#define CIMAX_CAM_RLPDU_OK 0x46
-#define CIMAX_CAM_EVT         0x0d
-#define CIMAX_CAM_DET_OK      0x45
-#define CIMAX_CAM_NOCAM       0x49
-#define CIMAX_CAM_ERROR       0x4a
-#define CIMAX_CAM_NOEVT       0x55
-#define CIMAX_CAM_DATA_READY  0x4e
-#define CIMAX_CAM_WBUSY       0x54
-#define CIMAX_CAM_PENDING     0x56
-#define CIMAX_CAM_REGSTAT     0x0e
-#define CIMAX_CAM_REGSTAT_OK  0x57
-
-
-#define CIMAX_CAM_PKT_CNT_VAL 1
-
-#define CIMAX_SLOT_A 0
-#define CIMAX_SLOT_B 1
-
-#define CIMAX_CMD_RESP_MASK 0x7f
-
-#define cimax_to_spi(_c) ((struct cimax_spi *)((_c)->priv))
-#define dev_to_spi(_d) ((struct cimax_spi *)spi_get_drvdata(_d))
-
-#define byte_to_u16(_b1, _b2)   (((_b1)<<8) | (_b2))
-
-#define hdr_cmd_resp(_s)     ((_s)->buf[0] & CIMAX_CMD_RESP_MASK)
-
-#define reg_hdr(_s)          ((_s)->buf)
-#define reg_addr(_s)         byte_to_u16((_s)->buf[1], (_s)->buf[2])
-#define reg_hdr_dat_size(_s) ((_s)->buf[3])
-#define reg_dat(_s)          (&((_s)->buf[CIMAX_REG_HDR_SIZE]))
-
-#define cam_hdr(_s)          ((_s)->buf)
-#define cam_hdr_slot(_s)     (((_s)->buf[0] & 0x80) ? 1 : 0)
-#define cam_hdr_pkt_cnt(_s)  ((_s)->buf[1])
-#define cam_hdr_dat_size(_s) byte_to_u16((_s)->buf[2], (_s)->buf[3])
-#define cam_dat(_s)          (&((_s)->buf[CIMAX_CAM_HDR_SIZE]))
-
-#define REG_TIMEOUT 500
-#define CAM_TIMEOUT 5000
-
-#define USE_INT_PIO
-
-static int aml_cimax_spi_mod_init(void);
-static void aml_cimax_spi_mod_exit(void);
-
-static void dump(char *title, u8 *buf, int size)
-{
-	int i;
-	pr_info("%s\n", title);
-	for (i = 0; i < size; i++) {
-		if (!(i & 0xf))
-			pr_info("\n\t");
-		pr_info("%02x ", *(buf+i));
-	}
-	pr_info("\n");
-}
-
-static void perr(char *err, struct cimax_spi *spi)
-{
-	pr_error("error: %s\n", err);
-	dump("dump:", spi->buf, 16);
-}
-
-static inline unsigned long get_jiffies(void)
-{
-	return (unsigned long)(sched_clock()/10000000);
-}
-
-static inline void set_spi_cam_ready(struct cimax_spi *spi, int slot)
-{
-	if (spi->cam_inserted[slot] == 1) {
-		spi->cam_inserted[slot] = 2;
-		aml_cimax_slot_state_changed(spi->cimax,
-			slot, spi->cam_inserted[slot]);
-	}
-}
-
-
-static int cimax_spi_get_resp(struct cimax_spi *spi, int timeout)
-{
-	struct spi_device *dev = spi->dev;
-	int ret = 0;
-	unsigned long start = get_jiffies();
-#ifndef USE_INT_PIO
-	u8 t = 0;
-
-	while (!t && jiffies_to_msecs(get_jiffies() - start) < timeout) {
-		ret = spi_read(dev, &t, 1);
-		if (ret)
-			return ret;
-		usleep_range(1000, 2000);
-	}
-	if (!t) {
-		pr_error("resp timeout: %dms\n", timeout);
-		return -EIO;
-	}
-	cam_hdr(spi)[0] = t;
-	ret = spi_read(dev, cam_hdr(spi)+1, CIMAX_CAM_HDR_SIZE-1);
-	if (ret)
-		return ret;
-#else
-	do {
-		if (jiffies_to_msecs(get_jiffies() - start) >= timeout) {
-			pr_error("resp timeout: %dms\n", timeout);
-			return -EIO;
-		}
-		usleep_range(1000, 2000);
-	} while (gpio_get_value(spi->irq_io));
-
-	ret = spi_read(dev, cam_hdr(spi), CIMAX_CAM_HDR_SIZE);
-	if (ret)
-		return ret;
-#endif
-	/*pr_dbg("rp: %02x:%02x:%02x:%02x\n",
-		cam_hdr(spi)[0], cam_hdr(spi)[1],
-		cam_hdr(spi)[2], cam_hdr(spi)[3]);*/
-	switch (hdr_cmd_resp(spi)) {
-	case CIMAX_REG_READ_OK:
-	case CIMAX_REG_WRITE_OK:
-	case CIMAX_REG_INIT_OK:
-	case CIMAX_REG_CMD_ERROR: {
-		int len = reg_hdr_dat_size(spi);
-		if (len) {
-			ret = spi_read(dev, reg_dat(spi), len);
-			if (ret != 0)
-				return ret;
-		}
-		} break;
-	case CIMAX_CAM_RESET_OK:
-	case CIMAX_CAM_CIS_OK:
-	case CIMAX_CAM_COR_OK:
-	case CIMAX_CAM_NEG_OK:
-	case CIMAX_CAM_WLPDU_OK:
-	case CIMAX_CAM_RLPDU_OK:
-	case CIMAX_CAM_NOCAM:
-	case CIMAX_CAM_ERROR:
-	case CIMAX_CAM_WBUSY:
-	case CIMAX_CAM_DET_OK:
-	case CIMAX_CAM_DATA_READY:
-	case CIMAX_CAM_PENDING:
-	case CIMAX_CAM_REGSTAT_OK:
-	case CIMAX_CAM_NOEVT: {
-		int len = cam_hdr_dat_size(spi);
-		if (len) {
-			ret = spi_read(dev, cam_dat(spi), len);
-			if (ret != 0)
-				return ret;
-			/*if (len)
-				dump("dat:", cam_dat(spi), len);*/
-		}
-		}
-		break;
-	default:
-		pr_error("unknown resp:0x%02x\n", hdr_cmd_resp(spi));
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int init_reg_hdr(u8 *hdr, u8 tag, int addr, int size)
-{
-	hdr[0] = tag;
-	hdr[1] = (addr>>8) & 0xff;
-	hdr[2] = addr & 0xff;
-	hdr[3] = size;
-	return 0;
-}
-
-static int check_reg_hdr(u8 *hdr, u8 tag, int addr, int size)
-{
-	return hdr[0] != tag
-		|| hdr[1] != ((addr>>8) & 0xff)
-		|| hdr[2] != (addr & 0xff)
-		|| hdr[3] != size;
-}
-
-static int aml_cimax_spi_read_reg(struct aml_cimax *cimax, int addr,
-		u8 *buf, int size)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	struct spi_device *dev = spi->dev;
-	int err = 0;
-
-	init_reg_hdr(spi->buf, CIMAX_REG_READ, addr, size);
-
-	lock_lock(spi);
-
-	pr_dbg("rd %02x:%02x:%02x:%02x\n",
-		reg_hdr(spi)[0], reg_hdr(spi)[1],
-		reg_hdr(spi)[2], reg_hdr(spi)[3]);
-	err = spi_write(dev, spi->buf, CIMAX_REG_HDR_SIZE);
-	if (err)
-		goto end;
-	err = cimax_spi_get_resp(spi, REG_TIMEOUT);
-	if (err)
-		goto end;
-	if (check_reg_hdr(reg_hdr(spi), CIMAX_REG_READ_OK, addr, size) != 0) {
-		perr("read reg fail.", spi);
-		err = -EINVAL;
-		goto end;
-	}
-	memcpy(buf, reg_dat(spi), size);
-end:
-	lock_unlock(spi);
-	return err;
-}
-
-static int aml_cimax_spi_write_reg(struct aml_cimax *cimax, int addr,
-		u8 *buf, int size)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	struct spi_device *dev = spi->dev;
-	int err = 0;
-
-	init_reg_hdr(spi->buf, CIMAX_REG_WRITE, addr, size);
-	memcpy(&spi->buf[CIMAX_REG_HDR_SIZE], buf, size);
-
-	lock_lock(spi);
-
-	pr_dbg("wr %02x:%02x:%02x:%02x\n",
-		reg_hdr(spi)[0], reg_hdr(spi)[1],
-		reg_hdr(spi)[2], reg_hdr(spi)[3]);
-	err = spi_write(dev, spi->buf, CIMAX_REG_HDR_SIZE + size);
-	if (err)
-		goto end;
-	err = cimax_spi_get_resp(spi, REG_TIMEOUT);
-	if (err)
-		goto end;
-	if (check_reg_hdr(reg_hdr(spi), CIMAX_REG_WRITE_OK, addr, 0) != 0) {
-		perr("write reg fail.", spi);
-		err = -EINVAL;
-		goto end;
-	}
-end:
-	lock_unlock(spi);
-	return err;
-}
-
-static inline int init_cam_hdr(u8 *hdr, int cmd, int size)
-{
-	hdr[0] = cmd;
-	hdr[1] = CIMAX_CAM_PKT_CNT_VAL;
-	hdr[2] = (size>>8) & 0xff;
-	hdr[3] = size & 0xff;
-	return 0;
-}
-
-static inline int cam_err(struct cimax_spi *spi)
-{
-	if (hdr_cmd_resp(spi) != CIMAX_CAM_ERROR
-		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(spi) != 2)
-		return 0;
-	return byte_to_u16(cam_dat(spi)[0], cam_dat(spi)[1]);
-}
-
-static inline char *cam_err_str(int err)
-{
-#define CAMERROR_RESET           0x0101
-#define CAMERROR_CIS_BUF         0x0201
-#define CAMERROR_CIS_SIZE        0x0202
-#define CAMERROR_CAM_NOT_ACT     0x0203
-#define CAMERROR_COR_NOT_READY   0x0301
-#define CAMERROR_COR_VAL_CHK     0x0302
-#define CAMERROR_NEG_NO_RESP     0x0401
-#define CAMERROR_NEG_BAD_SIZE    0x0402
-#define CAMERROR_NEG_NOT_READY   0x0403
-#define CAMERROR_LPDU_NOT_AVAIL  0x0601
-	struct { int err; char *str; } cam_err_strings[] = {
-		{CAMERROR_RESET, "reset error, not ready."},
-		{CAMERROR_CIS_BUF, "cis error, buffer not allocated."},
-		{CAMERROR_CIS_SIZE, "cis error, bad cis size."},
-		{CAMERROR_CAM_NOT_ACT, "cam not activated."},
-		{CAMERROR_COR_NOT_READY, "cam not ready during write COR."},
-		{CAMERROR_COR_VAL_CHK, "COR value check failed."},
-		{CAMERROR_NEG_NO_RESP, "cam not responding when negotiation."},
-		{CAMERROR_NEG_BAD_SIZE, "cam buf size length != 2."},
-		{CAMERROR_NEG_NOT_READY, "cam not ready during negotiation."},
-		{CAMERROR_LPDU_NOT_AVAIL, "lpdu not available."}
-	};
-	int i;
-	for (i = 0;
-		i < sizeof(cam_err_strings)/sizeof(cam_err_strings[0]); i++) {
-		if (cam_err_strings[i].err == err)
-			return cam_err_strings[i].str;
-	}
-	return "err unknown.";
-}
-
-static int cimax_spi_access_cam(struct cimax_spi *spi, int slot,
-		int cmd, u8 *buf, int size)
-{
-	struct spi_device *dev = spi->dev;
-	int err = 0;
-
-	cmd |= slot ? 0x80 : 0;
-	init_cam_hdr(cam_hdr(spi), cmd, size);
-	memcpy(cam_dat(spi), buf, size);
-	/*dump("access cam:", cam_hdr(spi), CIMAX_CAM_HDR_SIZE+size);*/
-	err = spi_write(dev, cam_hdr(spi), CIMAX_CAM_HDR_SIZE + size);
-	if (err)
-		return err;
-	err = cimax_spi_get_resp(spi, CAM_TIMEOUT);
-	if (err)
-		return err;
-	if (cam_hdr_slot(spi) != slot) {
-		pr_error("expect slot(%d), but slot(%d)\n",
-			slot, cam_hdr_slot(spi));
-		return -EINVAL;
-	}
-	switch (hdr_cmd_resp(spi)) {
-	case CIMAX_CAM_NOCAM:
-		pr_dbg("no cam\n");
-		err = -ENODEV;
-		break;
-	case CIMAX_CAM_ERROR:
-		pr_error("cam error\n");
-		pr_error("err code: 0x%04x(%s)\n", cam_err(spi),
-			cam_err_str(cam_err(spi)));
-		err = -ENODEV;
-		break;
-	case CIMAX_CAM_WBUSY:
-		pr_dbg("cam busy\n");
-		err = -EBUSY;
-		break;
-	case CIMAX_CAM_PENDING:
-		pr_dbg("cam pending\n");
-		err = -EAGAIN;
-		break;
-	}
-	return err;
-}
-
-static int aml_cimax_spi_read_cis(struct aml_cimax *cimax, int slot,
-		u8 *buf, int size)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	int err = 0;
-	int len;
-
-	lock_lock(spi);
-
-	err = cimax_spi_access_cam(spi, slot, CIMAX_CAM_CIS, NULL, 0);
-	if (err)
-		goto end;
-	if (hdr_cmd_resp(spi) != CIMAX_CAM_CIS_OK
-		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL) {
-		perr("read cis fail.", spi);
-		err = -EINVAL;
-		goto end;
-	}
-	len = cam_hdr_dat_size(spi);
-	if (size < len) {
-		pr_error("cis size too large, expect<%d, but:%d\n", size, len);
-		perr("cis fail.", spi);
-		err = -EINVAL;
-		goto end;
-	}
-	memcpy(buf, cam_dat(spi), len);
-
-	if (!spi->cis)
-		spi->cis = kzalloc((len < 512) ? 512 : len, GFP_KERNEL);
-	if (spi->cis)
-		memcpy(spi->cis, cam_dat(spi), len);
-
-end:
-	lock_unlock(spi);
-	return err;
-}
-#define CIMAX_CAM_COR_PLD_SIZE 5
-static int aml_cimax_spi_write_cor(struct aml_cimax *cimax, int slot,
-		int addr, u8 *buf)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	int err = 0;
-	u8 out[CIMAX_CAM_COR_PLD_SIZE + 8];
-	int sz = CIMAX_CAM_COR_PLD_SIZE;
-
-	out[0] = addr>>8 & 0xff;
-	out[1] = addr & 0xff;
-	out[2] = buf[0];
-	out[3] = 0;
-	out[4] = 0;
-
-	if (!cam_irq_mode) {
-		out[5] = 0x40;/*cam poll mode*/
-		sz++;
-	}
-
-	lock_lock(spi);
-
-	err = cimax_spi_access_cam(spi, slot, CIMAX_CAM_COR, out, sz);
-	if (err)
-		goto end;
-	if (hdr_cmd_resp(spi) != CIMAX_CAM_COR_OK
-		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(spi) != 0) {
-		perr("write cor fail.", spi);
-		err = -EINVAL;
-		goto end;
-	}
-end:
-	lock_unlock(spi);
-	return err;
-}
-#define CIMAX_CAM_NEG_PLD_SIZE 2
-static int aml_cimax_spi_negotiate(struct aml_cimax *cimax, int slot, int size)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	int ret = 0;
-	u8 out[CIMAX_CAM_NEG_PLD_SIZE];
-
-	out[0] = (size>>8) & 0xff;
-	out[1] = size & 0xff;
-
-	lock_lock(spi);
-
-	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_NEG,
-			out, CIMAX_CAM_NEG_PLD_SIZE);
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(spi) != CIMAX_CAM_NEG_OK
-		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(spi) != 2) {
-		perr("negotiate fail.", spi);
-		ret = -EINVAL;
-		goto end;
-	}
-	ret = byte_to_u16(cam_dat(spi)[0], cam_dat(spi)[1]);
-
-	set_spi_cam_ready(spi, slot);
-end:
-	lock_unlock(spi);
-	return ret;
-}
-
-static int aml_cimax_spi_write_lpdu(struct aml_cimax *cimax, int slot,
-		u8 *buf, int size)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	int ret = 0;
-
-	lock_lock(spi);
-
-	/*dump("lpdu ->", buf, size);*/
-	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_WLPDU, buf, size);
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(spi) != CIMAX_CAM_WLPDU_OK
-		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(spi) != 0) {
-		perr("write lpdu fail.", spi);
-		ret = -EINVAL;
-		goto end;
-	}
-	ret = size;
-end:
-	lock_unlock(spi);
-	return ret;
-}
-
-static int aml_cimax_spi_read_lpdu(struct aml_cimax *cimax, int slot,
-		u8 *buf, int size)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	int ret = 0;
-
-	lock_lock(spi);
-
-	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_RLPDU, NULL, 0);
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(spi) != CIMAX_CAM_RLPDU_OK
-		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL) {
-		perr("read lpdu fail.", spi);
-		ret = -EINVAL;
-		goto end;
-	}
-	ret = cam_hdr_dat_size(spi);
-	memcpy(buf, cam_dat(spi), ret);
-
-	/*dump("lpdu <-", buf, ret);*/
-
-	spi->cam_data_ready[slot] = 0;
-end:
-	lock_unlock(spi);
-	return ret;
-}
-
-static int aml_cimax_spi_read_cam_status(struct aml_cimax *cimax, int slot)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	int ret = 0;
-
-	if (cam_irq_mode && spi->cam_data_ready[slot])
-		return 0x80;
-
-	lock_lock(spi);
-
-	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_REGSTAT, NULL, 0);
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(spi) != CIMAX_CAM_REGSTAT_OK
-		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(spi) != 1) {
-		perr("read cam status fail.", spi);
-		ret = -EINVAL;
-		goto end;
-	}
-
-	ret = cam_dat(spi)[0];
-end:
-	lock_unlock(spi);
-	return ret;
-}
-
-static int aml_cimax_spi_slot_reset(struct aml_cimax *cimax, int slot)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	int ret = 0;
-
-	spi->cam_data_ready[slot] = 0;
-
-	lock_lock(spi);
-
-	ret = cimax_spi_access_cam(spi, slot, CIMAX_CAM_RESET, NULL, 0);
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(spi) != CIMAX_CAM_RESET_OK
-		|| cam_hdr_pkt_cnt(spi) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(spi) != 0) {
-		perr("slot reset fail.", spi);
-		ret = -EINVAL;
-		goto end;
-	}
-end:
-	lock_unlock(spi);
-	return ret;
-}
-
-static int aml_cimax_spi_cam_reset(struct aml_cimax *cimax, int slot)
-{
-	pr_dbg("Slot(%d): camreset\n", slot);
-	return 0;
-}
-
-static int aml_cimax_spi_slot_shutdown(struct aml_cimax *cimax, int slot)
-{
-	pr_dbg("Slot(%d): shutdown\n", slot);
-	return 0;
-}
-static int aml_cimax_spi_slot_ts_enable(struct aml_cimax *cimax, int slot)
-{
-	pr_dbg("Slot(%d): ts control\n", slot);
-	return 0;
-}
-static int aml_cimax_spi_slot_status(struct aml_cimax *cimax, int slot)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-	if (spi->cam_inserted[slot]) {
-		/*pr_dbg("CA Module present and ready\n");*/
-		return DVB_CA_EN50221_POLL_CAM_PRESENT |
-			DVB_CA_EN50221_POLL_CAM_READY;
-	} else {
-		/*pr_error("CA Module not present or not ready\n");*/
-	}
-	return 0;
-}
-
-static int cimax_spi_cam_plugin(struct cimax_spi *spi, int slot, int plugin)
-{
-	pr_dbg("cam plug: slot(%d) %s\n",
-		slot, plugin ? "plugged" : "unplugged");
-	return aml_cimax_camchanged(spi->cimax, slot, plugin);
-}
-
-static int cimax_spi_poll(struct cimax_spi *spi)
-{
-	struct spi_device *dev = spi->dev;
-	int err = 0;
-
-	lock_lock(spi);
-
-#ifdef USE_INT_PIO
-	if (gpio_get_value(spi->irq_io))
-		goto end;
-#endif
-
-	init_reg_hdr(spi->buf, CIMAX_CAM_EVT, 0x100, 0);
-	err = spi_write(dev, spi->buf, CIMAX_REG_HDR_SIZE);
-	if (err)
-		goto end;
-	err = cimax_spi_get_resp(spi, CAM_TIMEOUT);
-	if (err)
-		goto end;
-	switch (hdr_cmd_resp(spi)) {
-	case CIMAX_CAM_DET_OK: {
-		int slot = cam_hdr_slot(spi);
-		int insert = cam_dat(spi)[0];
-		if (!!spi->cam_inserted[slot] != insert) {
-			spi->cam_inserted[slot] = insert;
-			cimax_spi_cam_plugin(spi, slot, insert);
-			aml_cimax_slot_state_changed(spi->cimax, slot,
-				spi->cam_inserted[slot]);
-		}
-		} break;
-	case CIMAX_CAM_DATA_READY: {
-		int slot = cam_hdr_slot(spi);
-		spi->cam_data_ready[slot] = 1;
-		} break;
-	case CIMAX_CAM_NOEVT:
-		break;
-	default:
-		pr_error("unknown resp:%02x\n", hdr_cmd_resp(spi));
-		break;
-	}
-end:
-	queue_delayed_work(spi->workq, &spi->work, spi_poll_interval);
-	lock_unlock(spi);
-	return 0;
-}
-
-static void cimax_spi_poll_work(struct work_struct *work)
-{
-	struct cimax_spi *spi =
-		container_of(to_delayed_work(work), struct cimax_spi, work);
-	spi->work_cnt++;
-	cimax_spi_poll(spi);
-}
-
-static irqreturn_t cimax_irq_handler(int irq, void *para)
-{
-	return IRQ_HANDLED;
-}
-
-#define CTRL_DISABLE -1
-#define CTRL_STOP     0
-#define CTRL_START    1
-
-static inline int cimax_spi_poll_ctrl(struct cimax_spi *spi, int ctrl)
-{
-	if (ctrl == CTRL_START) {
-		spi->workq = create_singlethread_workqueue("cimax_spi");
-		INIT_DELAYED_WORK(&spi->work, &cimax_spi_poll_work);
-		queue_delayed_work(spi->workq,
-			&spi->work, spi_poll_interval);
-		pr_dbg("poll started\n");
-	} else {
-		if (!spi->workq)
-			return 0;
-		cancel_delayed_work_sync(&spi->work);
-		destroy_workqueue(spi->workq);
-		spi->workq = NULL;
-		pr_dbg("poll stopped\n");
-	}
-	return 0;
-}
-
-static inline int cimax_spi_intr_ctrl(struct cimax_spi *spi, int ctrl)
-{
-	if (ctrl == CTRL_START) {
-		int ret;
-		if (spi->irq == -1) {
-			pr_error("incorrect irq");
-			return -1;
-		}
-		ret = request_irq(spi->irq, cimax_irq_handler,
-			IRQF_SHARED|IRQF_TRIGGER_RISING,
-			"cimax irq", spi);
-		enable_irq(spi->irq);
-	} else {
-		if (spi->irq == -1)
-			return 0;
-		disable_irq(spi->irq);
-		free_irq(spi->irq, spi);
-	}
-	return 0;
-}
-
-static int cimax_spi_setup_poll(struct cimax_spi *spi, int poll_mode)
-{
-	if (poll_mode == spi->poll_mode)
-		return 0;
-	switch (poll_mode) {
-	case POLL_MODE:
-		if (spi->poll_mode == INT_MODE)
-			cimax_spi_intr_ctrl(spi, CTRL_DISABLE);
-		cimax_spi_poll_ctrl(spi, CTRL_START);
-		spi->poll_mode = POLL_MODE;
-		break;
-	case INT_MODE:
-		if (spi->poll_mode == POLL_MODE)
-			cimax_spi_poll_ctrl(spi, CTRL_DISABLE);
-		cimax_spi_intr_ctrl(spi, CTRL_START);
-		spi->poll_mode = INT_MODE;
-		break;
-	case STOP_MODE:
-		if (spi->poll_mode == POLL_MODE)
-			cimax_spi_poll_ctrl(spi, CTRL_DISABLE);
-		else if (spi->poll_mode == INT_MODE)
-			cimax_spi_intr_ctrl(spi, CTRL_DISABLE);
-		spi->poll_mode = STOP_MODE;
-		break;
-	default:
-		break;
-	}
-	return 0;
-}
-
-static int cimax_spi_hw_reset(struct cimax_spi *spi, int reset_val)
-{
-	/*trigger reset io*/
-	if (spi->rst_io) {
-		gpio_direction_output(spi->rst_io, reset_val ? 1 : 0);
-		msleep(50);
-		gpio_direction_output(spi->rst_io, reset_val ? 0 : 1);
-	}
-	return 0;
-}
-
-
-enum regOperation_e {
-	/** Read register. */
-	REG_OP_READ,
-	/** Write register. */
-	REG_OP_WRITE,
-	/** Read register until some bits are set. */
-	REG_OP_WAIT_TO_BE_SET,
-	/** Read register until some bits are cleared. */
-	REG_OP_WAIT_TO_BE_CLEARED,
-	/** Read register until it's value is not equal to defined. */
-	REG_OP_WAIT_EQUAL,
-	/** Perform logical AND over register. */
-	REG_OP_LOGICAL_AND,
-	/** Perform logical OR over register. */
-	REG_OP_LOGICAL_OR,
-	/** Wait timeout in miliseconds. */
-	REG_OP_WAIT
-};
-
-struct regSettings_s {
-	/** CIMaX+ register address. */
-	u16         reg;
-	/** CIMaX+ register value. */
-	u16         val;
-	/** CIMaX+ register operation. */
-	enum regOperation_e op;
-};
-
-static struct regSettings_s spiRegSettings[] = {
-	/** TS interface init. */
-	{IN_SEL,          0x00, REG_OP_WRITE},          /** Close TS input. */
-	{OUT_SEL,         0x00, REG_OP_WRITE},          /** Close TS output. */
-	{FIFO_CTRL,       0x0f, REG_OP_WRITE},          /** Reset TS FIFO.  */
-	{SYNC_RTV_CTRL,   0x0f, REG_OP_WRITE},
-
-	/** CAM power. */
-	{GPIO0_DATA_OUT,  0x00, REG_OP_WRITE},
-	/** Unlock CFG. */
-	{CFG_2,           0x00, REG_OP_WRITE},
-	/** 1) DVB/CI/CI+/SCARD 2slot. */
-	{CFG_1,           0x00, REG_OP_WRITE},
-	/** 2) Set the Default "power off" state
-	such as VCC_MODA=VCC_MODB=VPPx_MODA=VPPx_MODB='Z'. */
-	{GPIO0_DFT,       0x00, REG_OP_WRITE},
-	/** 3) Set GPIO3 as external power switch driver. */
-	{GPIO0_MASK_DATA, 0x07, REG_OP_WRITE},
-	/** 4) Set "power on" state (VCC=VPP1=VPP2= 5V). */
-	{GPIO0_DATA_OUT,  0x03, REG_OP_WRITE},
-	/** 5) Lock config. */
-	{CFG_2,           0x01, REG_OP_WRITE},
-	/** 6) Write in the GPIO0_DIR_REG: defines the GPIOs,
-	which are used to drive the external power switch, in output mode. */
-	{GPIO0_DIR,       0x07, REG_OP_WRITE},
-	/** 7) Check VCCENable. */
-	{CFG_1,           0x20, REG_OP_WAIT_TO_BE_SET},
-	/** 8) Set & wait for PcmciaOutputEnable. */
-	{CFG_1,           0x08, REG_OP_LOGICAL_OR},
-	{CFG_1,           0x08, REG_OP_WAIT_TO_BE_SET},
-
-	/** Set router CAM. */
-	/** CH0 & CH1 from CAM A & B, CAM A & B from CH0 & CH1. */
-	{ROUTER_CAM_MOD,  0x21, REG_OP_WRITE},
-	{ROUTER_CAM_CH,   0x00, REG_OP_WRITE},
-	/** Wait 200 miliseconds. */
-	{0x0000,          200,  REG_OP_WAIT},
-
-	/** Set In/Out. */
-	/** Route CAM Channel 0 to Channel 0, Channel 1 null. */
-	{ROUTER_CAM_CH,   0x80, REG_OP_WRITE},
-
-#ifdef PARALLEL_OUT
-#else
-#if 1
-	/*72M internal clock source*/
-	/*CLK Select SER0->72M*/
-	{CkMan_Select,    0x20, REG_OP_WRITE},
-	/*Enable SER0 clk source, Enable 72M clk source*/
-	{CkMan_Config,    0x44, REG_OP_LOGICAL_OR},
-#else
-	/*108M internal clock source*/
-	/*CLK Select SER0->108M*/
-	{CkMan_Select,    0x30, REG_OP_WRITE},
-	/*Enable SER0 clk source, Enable 108M clk source*/
-	{CkMan_Config,    0x48, REG_OP_LOGICAL_OR},
-#endif
-	{P2S_CH0_CTRL,    0x19, REG_OP_WRITE},           /*Enable p2s*/
-	{OUT_SEL,         0x02, REG_OP_WRITE},           /*Out1=p2s0*/
-#endif /*Parallel out*/
-
-	/** Input Ch0=Parallel, Ch1=null. */
-	{IN_SEL,          0x01, REG_OP_WRITE},
-};
-
-int downloadCfg(struct cimax_spi *spi)
-{
-	u32   cnt;
-	u8    buf[CIMAX_REG_PLD_SIZE];
-	struct aml_cimax *cimax = spi->cimax;
-
-	pr_info("Download CIMaX+ configuration(register settings):\n");
-
-	for (cnt = 0; cnt < sizeof(spiRegSettings)/sizeof(struct regSettings_s);
-			cnt++) {
-		pr_dbg("reg:%04x, val:%02x, op:%d\n",
-				spiRegSettings[cnt].reg,
-				spiRegSettings[cnt].val,
-				spiRegSettings[cnt].op);
-		switch (spiRegSettings[cnt].op) {
-		case REG_OP_READ:
-			/* Read register. */
-			if (aml_cimax_spi_read_reg(cimax,
-					spiRegSettings[cnt].reg, buf, 1) < 0) {
-				/* CIMaX+ read error. */
-				pr_error("FAILED at REG_OP_READ operation.\n");
-				return -1;
-			}
-			break;
-		case REG_OP_WRITE:
-			/* Write register. */
-			if (aml_cimax_spi_write_reg(cimax,
-					spiRegSettings[cnt].reg,
-					(u8 *)&spiRegSettings[cnt].val,
-					1) < 0) {
-				/* CIMaX+ write error. */
-				pr_error("FAILED at REG_OP_WRITE operation.\n");
-				return -1;
-			}
-			break;
-		case REG_OP_WAIT_TO_BE_SET:
-			do {
-				if (aml_cimax_spi_read_reg(cimax,
-					spiRegSettings[cnt].reg, buf, 1) < 0) {
-					/* CIMaX+ read error. */
-					pr_error("E REG_OP_WAIT_TO_BE_SET\n");
-					return -1;
-				}
-			} while ((buf[0] & spiRegSettings[cnt].val)
-					!= spiRegSettings[cnt].val);
-			break;
-		case REG_OP_WAIT_TO_BE_CLEARED:
-			do {
-				if (aml_cimax_spi_read_reg(cimax,
-					spiRegSettings[cnt].reg, buf, 1) < 0) {
-					/* CIMaX+ read error. */
-					pr_error("REG_OP_WAIT_TO_BE_CLEARED\n");
-					return -1;
-				}
-			} while ((buf[0] & spiRegSettings[cnt].val) != 0);
-			break;
-		case REG_OP_WAIT_EQUAL:
-			do {
-				if (aml_cimax_spi_read_reg(cimax,
-					spiRegSettings[cnt].reg, buf, 1) < 0) {
-					/* CIMaX+ read error. */
-					pr_error("REG_OP_WAIT_EQUAL.\n");
-					return -1;
-				}
-			} while (buf[0] != spiRegSettings[cnt].val);
-			break;
-		case REG_OP_LOGICAL_AND:
-			if (aml_cimax_spi_read_reg(cimax,
-				spiRegSettings[cnt].reg, buf, 1) < 0) {
-				/* CIMaX+ read error. */
-				pr_error("FAILED at REG_OP_LOGICAL_AND(r).\n");
-				return -1;
-			}
-			buf[0] &=  spiRegSettings[cnt].val;
-			if (aml_cimax_spi_write_reg(cimax,
-				spiRegSettings[cnt].reg, buf, 1) < 0) {
-				/* CIMaX+ write error. */
-				pr_error("FAILED at REG_OP_LOGICAL_AND(w).\n");
-				return -1;
-			}
-			break;
-		case REG_OP_LOGICAL_OR:
-			if (aml_cimax_spi_read_reg(cimax,
-				spiRegSettings[cnt].reg, buf, 1) < 0) {
-				/* CIMaX+ read error. */
-				pr_error("FAILED at REG_OP_LOGICAL_OR(r).\n");
-				return -1;
-			}
-			buf[0] |=  spiRegSettings[cnt].val;
-			if (aml_cimax_spi_write_reg(cimax,
-				spiRegSettings[cnt].reg, buf, 1) < 0) {
-				/* CIMaX+ write error. */
-				pr_error("FAILED at REG_OP_LOGICAL_AND(w).\n");
-				return -1;
-			}
-			break;
-		case REG_OP_WAIT:
-			msleep(spiRegSettings[cnt].val);
-			break;
-		default:
-			pr_error("\nInvalid operation 0x%02x!\n",
-				spiRegSettings[cnt].op);
-		}
-	}
-	pr_info("config OK.\n");
-	return 0;
-}
-
-
-#define CIMAX_FW_PKT_SIZE    128
-#define CIMAX_FW_START_ADDR  0x8000
-#define CIMAX_FW_STOP_ADDR   0xcff9
-#define CIMAX_FW_VECT_ADDR   0xfffa
-#define CIMAX_FW_VECT_SIZE   6
-
-static u32 compute_bistrom(const u8 *ptr, int size, u32 sign)
-{
-	int k, i;
-	u16 s;
-
-	for (k = 0; k < size; k++) {
-		s = ptr[k]&0x01;
-		for (i = 0; i < 16; i++)
-			if (0x88B7 & (1<<i))
-				s ^= (sign>>i) & 0x01;
-		s |= ((sign<<1) ^ (ptr[k])) & 0x00FE;
-		s |= (sign<<1) & 0x00FF00;
-		sign = s;
-	}
-	return sign;
-}
-
-static int cimax_spi_upload_firmware(struct cimax_spi *spi,
-		const u8 *fw_data, u32 *sign)
-{
-	struct aml_cimax *cimax = spi->cimax;
-	int err = 0;
-	int addr;
-	const u8 *ptr;
-	int size;
-	int debug = cimax_spi_debug;
-	u8 *ptmp = kzalloc(CIMAX_FW_PKT_SIZE + CIMAX_REG_HDR_SIZE, GFP_KERNEL);
-
-	if (!ptmp)
-		return -ENOMEM;
-
-	cimax_spi_debug = 0;
-
-	addr = CIMAX_FW_START_ADDR;
-	ptr = fw_data + addr;
-	while (addr < CIMAX_FW_STOP_ADDR) {
-		size = (addr <= (CIMAX_FW_STOP_ADDR+1-CIMAX_FW_PKT_SIZE)) ?
-			CIMAX_FW_PKT_SIZE : (CIMAX_FW_STOP_ADDR+1-addr);
-
-		*sign = compute_bistrom(ptr, size, *sign);
-
-		pr_dbg(">>%x@%x\n", size, addr);
-
-		/*dump("w:", (u8*)ptr, size);*/
-		err = aml_cimax_spi_write_reg(cimax, addr, (u8 *)ptr, size);
-		if (err)
-			break;
-		err = aml_cimax_spi_read_reg(cimax, addr, ptmp, size);
-		if (err)
-			break;
-		/*dump("r:", ptmp, size);*/
-		if (memcmp(ptr, ptmp, size)) {
-			pr_error("fw write error.\n");
-			err = -ENODEV;
-			break;
-		}
-
-		addr += size;
-		ptr += size;
-	}
-
-	if (!err) {
-		addr = CIMAX_FW_VECT_ADDR;
-		ptr = fw_data + addr;
-		size = CIMAX_FW_VECT_SIZE;
-
-		*sign = compute_bistrom(ptr, size, *sign);
-
-		err = aml_cimax_spi_write_reg(cimax, addr, (u8 *)ptr, size);
-		if (err)
-			goto end;
-		err = aml_cimax_spi_read_reg(cimax, addr, ptmp, size);
-		if (err)
-			goto end;
-		if (memcmp(ptr, ptmp, size)) {
-			pr_error("fw vect write error.\n");
-			err = -ENODEV;
-			goto end;
-		}
-	}
-end:
-	kfree(ptmp);
-
-	cimax_spi_debug = debug;
-	return err;
-}
-
-static int cimax_spi_check_bistrom(struct cimax_spi *spi,
-		int start, int end, u32 sign)
-{
-	struct aml_cimax *cimax = spi->cimax;
-	int err = 0;
-	u8 buf[2];
-
-	buf[0] = (0xd000-start) & 0xff;
-	buf[1] = (0xd000-start) >> 8;
-	err = aml_cimax_spi_write_reg(cimax, 0x8d, buf, 2);
-	if (err)
-		return err;
-	buf[0] = sign & 0xff;
-	buf[1] = sign >> 8;
-	err = aml_cimax_spi_write_reg(cimax, 0x80, buf, 2);
-	if (err)
-		return err;
-	buf[0] = 0xf;
-	err = aml_cimax_spi_write_reg(cimax, 0x82, buf, 1);
-	if (err)
-		return err;
-	err = aml_cimax_spi_read_reg(cimax, 0x41, buf, 2);
-	if (err)
-		return err;
-	pr_dbg("bist checked: 0x%04x\n", byte_to_u16(buf[0], buf[1]));
-	err = aml_cimax_spi_read_reg(cimax, 0x09, buf, 1);
-	if (err)
-		return err;
-	pr_dbg("rom status: 0x%02x\n", buf[0]);
-	return buf[0];
-}
-
-static int cimax_spi_init_firmware(struct cimax_spi *spi)
-{
-	struct spi_device *dev = spi->dev;
-	int err = 0;
-
-	init_reg_hdr(spi->buf, CIMAX_REG_INIT, 0, 0);
-	err = spi_write(dev, spi->buf, CIMAX_REG_HDR_SIZE);
-	if (err)
-		return err;
-	err = cimax_spi_get_resp(spi, REG_TIMEOUT);
-	if (err)
-		return err;
-	if (check_reg_hdr(spi->buf, CIMAX_REG_INIT_OK, 0, 0)) {
-		perr("init fw fail.", spi);
-		return -EINVAL;
-	}
-	return err;
-}
-
-static void request_fw_callback(const struct firmware *fw, void *context)
-{
-	u32 sign = 0;
-	int err = 0;
-	struct cimax_spi *spi = (struct cimax_spi *)context;
-
-	if (!fw)
-		return;
-
-	pr_dbg("got fw: %zd @ %p\n", fw->size, fw->data);
-
-    /*cimax_spi_hw_reset(spi, 1);*/
-
-	err = cimax_spi_upload_firmware(spi, fw->data, &sign);
-	if (err)
-		goto end;
-	pr_dbg("upload fw done.\n");
-	err = cimax_spi_check_bistrom(spi,
-		CIMAX_FW_START_ADDR, CIMAX_FW_STOP_ADDR, sign);
-	if (err != 0x2)
-		goto end;
-	pr_dbg("check bistrom done.\n");
-	err = cimax_spi_init_firmware(spi);
-	if (err)
-		goto end;
-end:
-	if (fw)
-		release_firmware(fw);
-	if (err)
-		return;
-
-	if (downloadCfg(spi)) {
-		pr_error("download config fail.\n");
-		return;
-	}
-
-	cimax_spi_setup_poll(spi, cimax_poll_mode ? POLL_MODE : INT_MODE);
-
-	return;
-}
-
-static int cimax_spi_load_fw(struct cimax_spi *spi)
-{
-	char *name = "cimax_spidvb.bin";
-	return request_firmware_nowait(THIS_MODULE, 1, name,
-			&spi->dev->dev, GFP_KERNEL, spi, request_fw_callback);
-}
-
-static int cimax_spi_dev_probe(struct spi_device *spi)
-{
-	int ret;
-	struct cimax_spi *cimax_spi;
-
-	pr_dbg("dev probe\n");
-	/*setup again?*/
-	spi->bits_per_word = 8;
-	ret = spi_setup(spi);
-	if (ret)
-		pr_dbg("spi setup failed\n");
-
-	cimax_spi = dev_get_platdata(&spi->dev);
-	cimax_spi->dev = spi;
-
-	spi_set_drvdata(spi, cimax_spi);
-
-	return cimax_spi_load_fw(cimax_spi);
-}
-
-static int cimax_spi_dev_remove(struct spi_device *spi)
-{
-	struct cimax_spi *cimax_spi = dev_get_drvdata(&spi->dev);
-
-	pr_dbg("dev remove\n");
-	cimax_spi_setup_poll(cimax_spi, STOP_MODE);
-	return 0;
-}
-
-static int cimax_spi_get_config_from_dts(struct cimax_spi *spi,
-		struct spi_board_info *bdinfo)
-{
-	struct device_node *child = NULL;
-	struct platform_device *pdev = spi->pdev;
-	struct device_node *np = pdev->dev.of_node;
-	unsigned int val;
-	int ret = 0;
-	pr_dbg("fetch cimax spi in dts\n");
-
-	child = of_get_child_by_name(np, "cimax");
-	if (child == NULL) {
-		pr_error("cimax not found in dts\n");
-		return -1;
-	}
-	child = of_get_child_by_name(child, "spi");
-	if (!child) {
-		pr_error("spi not found in cimax");
-		return -1;
-	}
-
-	/* get spi config */
-	ret = of_property_read_u32(child, "bus_num", &val);
-	if (ret)
-		pr_error("bus_num not found, use default.\n");
-	else
-		bdinfo->bus_num = val;
-	pr_dbg("bus_num: %d\n", bdinfo->bus_num);
-	ret = of_property_read_u32(child, "chip_select", &val);
-	if (ret)
-		pr_error("chip_select not found, use default.\n");
-	else
-		bdinfo->chip_select = val;
-	pr_dbg("chip_select: %d\n", bdinfo->chip_select);
-	ret = of_property_read_u32(child, "max_frequency", &val);
-	if (ret)
-		pr_error("max_frequency not found, use default.\n");
-	else
-		bdinfo->max_speed_hz = val;
-	pr_dbg("max_speed_hz: %d\n", bdinfo->max_speed_hz);
-	ret = of_property_read_u32(child, "mode", &val);
-	if (ret)
-		pr_error("mode not found, use default.\n");
-	else
-		bdinfo->mode = val;
-	pr_dbg("mode: %d\n", bdinfo->mode);
-/*
-dvbci {
-	compatible = "amlogic, dvbci";
-	dev_name = "dvbci";
-	io_type = <2>;//0:iobus,1:spi,2:cimax
-	cimax {
-		io_type = <0> //0:spi 1:usb
-		spi {
-			spi_bus_num = <0>;
-			spi_chip_select = <0>;
-			spi_max_frequency = <3000000>;
-
-			rst_gpio = <&gpio_ao GPIOAO_2 GPIO_ACTIVE_HIGH>;
-
-			irq_gpio = <&gpio_ao GPIOAO_2 GPIO_ACTIVE_HIGH>;
-			irq = <2>;
-			interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
-		};
-	};
-
-};
-*/
-#ifdef USE_INT_PIO
-	{
-		int ret = 0;
-		int gpio = -1;
-		gpio = of_get_named_gpio_flags(child, "irq-gpios", 0, NULL);
-		ret = gpio_request(gpio, "cimax-irq");
-		if (ret < 0) {
-			pr_error("irq-gpios request fail.\n");
-			return ret;
-		}
-
-		ret = gpio_direction_input(gpio);
-
-		spi->irq_io = gpio;
-		pr_dbg("irq_io: %d\n", spi->irq_io);
-	}
-#ifdef CIMAX_IRQ
-	{
-		int irq;
-		unsigned int irqflag;
-		ret = of_property_read_u32(child, "irq", &gpio_irq);
-		irq = irq_of_parse_and_map(child, 0);
-
-		gpio_for_irq(gpio,
-			AML_GPIO_IRQ(gpio_irq, FILTER_NUM7, GPIO_IRQ_FALLING));
-		spi->irq = irq;
-		pr_dbg("irq: %d\n", spi->irq);
-	}
-#else
-	spi->irq = -1;
-#endif
-#endif/*USE_INT_PIO*/
-	{
-		int ret = 0;
-		int gpio = -1;
-		gpio = of_get_named_gpio_flags(child, "rst-gpios", 0, NULL);
-		if (gpio != -1) {
-			ret = gpio_request(gpio, "cimax");
-			if (ret < 0) {
-				pr_error("rst-gpios request fail.\n");
-				return ret;
-			}
-
-			cimax_spi_hw_reset(spi, 1);
-
-			spi->rst_io = gpio;
-			pr_dbg("rst: %d\n", spi->rst_io);
-		} else {
-			pr_error("rst io got fail, %d\n", gpio);
-		}
-	}
-	return 0;
-}
-
-static struct spi_board_info cimax_spi_bdinfo = {
-	.modalias = "cimax_spi",
-	.mode = SPI_MODE_3,
-	.max_speed_hz = 1000000, /* 1MHz */
-	.bus_num = 0, /* SPI bus No. */
-	.chip_select = 0, /* the device index on the spi bus */
-	.controller_data = NULL,
-};
-
-static struct spi_driver cimax_spi_dev_driver = {
-	.probe = cimax_spi_dev_probe,
-	.remove = cimax_spi_dev_remove,
-	.driver = {
-		.name = "cimax_spi",
-		.owner = THIS_MODULE,
-	},
-};
-
-int aml_cimax_spi_init(struct platform_device *pdev, struct aml_cimax *cimax)
-{
-	int ret;
-	struct cimax_spi *cimax_spi;
-
-	cimax_spi = kzalloc(sizeof(struct cimax_spi), GFP_KERNEL);
-	if (!cimax_spi)
-		return -ENOMEM;
-
-	cimax_spi->pdev = pdev;
-	cimax_spi->cimax = cimax;
-	cimax_spi_get_config_from_dts(cimax_spi, &cimax_spi_bdinfo);
-
-	/*init spi_lock*/
-	lock_init(cimax_spi);
-
-	/*register device*/
-	cimax_spi_bdinfo.platform_data = cimax_spi;
-	spi_register_board_info(&cimax_spi_bdinfo, 1);
-
-	/*register driver*/
-	ret = spi_register_driver(&cimax_spi_dev_driver);
-	if (ret) {
-		pr_error("register cimax spi driver failed\n");
-		return ret;
-	}
-
-	/*init cimax used api.*/
-#define WI(_f)\
-	cimax->ops._f = aml_cimax_spi_##_f
-	WI(read_cis);
-	WI(write_cor);
-	WI(negotiate);
-	WI(read_lpdu);
-	WI(write_lpdu);
-	WI(read_cam_status);
-	WI(cam_reset);
-	WI(slot_reset);
-	WI(slot_shutdown);
-	WI(slot_ts_enable);
-	WI(slot_status);
-	/*WI(start);*/
-	/*WI(stop);*/
-	WI(read_reg);
-	WI(write_reg);
-
-	cimax->priv = cimax_spi;
-
-	g_spi = cimax_spi;
-
-	aml_cimax_spi_mod_init();
-	
-	return 0;
-}
-EXPORT_SYMBOL(aml_cimax_spi_init);
-
-int aml_cimax_spi_exit(struct aml_cimax *cimax)
-{
-	struct cimax_spi *spi = cimax_to_spi(cimax);
-
-	if (!spi)
-		return -ENODEV;
-
-	aml_cimax_spi_mod_exit();
-
-	/*unregister driver*/
-	spi_unregister_driver(&cimax_spi_dev_driver);
-	/*unregister device*/
-	spi_unregister_device(spi->dev);
-
-	if (spi->irq_io)
-		gpio_free(spi->irq_io);
-	if (spi->rst_io)
-		gpio_free(spi->rst_io);
-
-	kfree(spi->cis);
-
-	kfree(spi);
-	cimax->priv = NULL;
-
-	g_spi = NULL;
-	return 0;
-}
-EXPORT_SYMBOL(aml_cimax_spi_exit);
-
-static int cimax_spi_reset(struct cimax_spi *spi, int reset_val)
-{
-	pr_dbg("reset spi:%p, rst:%d\n", spi, spi ? spi->rst_io : -1);
-	if (!spi)
-		return -ENODEV;
-
-	pr_dbg("cimax spi reset\n");
-
-	cimax_spi_setup_poll(spi, STOP_MODE);
-
-	cimax_spi_hw_reset(spi, reset_val);
-
-	/*notify unplugged*/
-	aml_cimax_camchanged(spi->cimax, 0, 0);
-	aml_cimax_camchanged(spi->cimax, 1, 0);
-
-	spi->cam_inserted[0] = spi->cam_inserted[1] = 0;
-	spi->cam_data_ready[0] = spi->cam_data_ready[1] = 0;
-
-	/*async start fw*/
-	cimax_spi_load_fw(spi);
-
-	/*cimax_spi_setup_poll(spi, cimax_poll_mode? POLL_MODE : INT_MODE);*/
-	return 0;
-}
-
-static ssize_t reset_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret;
-	ret = sprintf(buf, "echo 1 > %s\n", attr->attr.name);
-	return ret;
-}
-
-static ssize_t reset_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int ret;
-	int val = 0;
-	if (!g_spi)
-		return size;
-	ret = sscanf(buf, "%i", &val);
-	if (ret == 1)
-		ret = cimax_spi_reset(g_spi, val);
-	return size;
-}
-
-static ssize_t debug_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	if (!g_spi)
-		return ret;
-
-	ret = sprintf(buf, "poll mode: %d\n", g_spi->poll_mode);
-	ret += sprintf(buf+ret, "status slot[0]=[%d] slot[1]=[%d]\n",
-		g_spi->cam_inserted[0], g_spi->cam_inserted[1]);
-	ret += sprintf(buf+ret, "data slot[0]=[%d] slot[1]=[%d]\n",
-		g_spi->cam_data_ready[0], g_spi->cam_data_ready[1]);
-	ret += sprintf(buf+ret, "work cnt:%d\n", g_spi->work_cnt);
-	return ret;
-}
-
-static int reg_addr;
-static ssize_t addr_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	ret = sprintf(buf, "addr = 0x%04x\n", reg_addr);
-	return ret;
-}
-
-static ssize_t addr_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	if (!g_spi)
-		return size;
-	if (sscanf(buf, "%i", &reg_addr) == 1)
-		return size;
-	return size;
-}
-
-static ssize_t reg_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	u8 reg_val = 0;
-	struct aml_cimax *cimax = NULL;
-
-	if (!g_spi)
-		return ret;
-
-	cimax = g_spi->cimax;
-	ret = aml_cimax_spi_read_reg(cimax, reg_addr, &reg_val, 1);
-	if (ret)
-		ret = sprintf(buf, "read fail, err=%d\n", ret);
-	else
-		ret = sprintf(buf, "reg[0x%04x] = 0x%02x\n", reg_addr, reg_val);
-	return ret;
-}
-
-static ssize_t reg_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int ret = 0;
-	struct aml_cimax *cimax = NULL;
-	int val = 0;
-	u8 reg_val = 0;
-
-	if (!g_spi)
-		return size;
-
-	if (sscanf(buf, "%i", &val) != 1)
-		return size;
-	reg_val = val;
-	cimax = g_spi->cimax;
-	ret = aml_cimax_spi_write_reg(cimax, reg_addr, &reg_val, 1);
-	if (ret)
-		return ret;
-	return size;
-}
-
-static int cis_mode; /*0:hex 1:binary*/
-static ssize_t cis_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-
-	if (!g_spi || !g_spi->cis)
-		return ret;
-
-	if (cis_mode == 0) {
-		int i;
-		for (i = 0; i < CIS_MAX; i++) {
-			if (i && !(i & 0xf))
-				ret += sprintf(buf+ret, "\n");
-			ret += sprintf(buf+ret, "%02X ", g_spi->cis[i]);
-		}
-		ret += sprintf(buf+ret, "\n");
-		return ret;
-	} else {
-		memcpy(buf, g_spi->cis, CIS_MAX);
-		return CIS_MAX;
-	}
-	return ret;
-}
-
-static ssize_t cis_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	if (size >= 3
-		&& !memcmp(buf, "bin", 3))
-		cis_mode = 1;
-	else
-		cis_mode = 0;
-	return size;
-}
-
-static ssize_t ts_rate_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	u8 lsb = 0, msb = 0, plen = 0;
-	struct aml_cimax *cimax = NULL;
-	int err = 0;
-
-	if (!g_spi)
-		return ret;
-
-	cimax = g_spi->cimax;
-	err = aml_cimax_spi_read_reg(cimax, PCK_LENGTH, &plen, 1);
-	err |= aml_cimax_spi_read_reg(cimax, BITRATE_CH0_LSB, &lsb, 1);
-	err |= aml_cimax_spi_read_reg(cimax, BITRATE_CH0_MSB, &msb, 1);
-	if (err || !byte_to_u16(msb, lsb))
-		ret += sprintf(buf+ret, "read fail, err=%d\n", err);
-	else
-		ret += sprintf(buf+ret, "rate[0] = %d Kbps\n",
-			540*plen*8/byte_to_u16(msb, lsb));
-	if (err)
-		return ret;
-
-	err = aml_cimax_spi_read_reg(cimax, BITRATE_CH1_LSB, &lsb, 1);
-	err |= aml_cimax_spi_read_reg(cimax, BITRATE_CH1_MSB, &msb, 1);
-	if (err || !byte_to_u16(msb, lsb))
-		ret += sprintf(buf+ret, "read fail, err=%d\n", err);
-	else
-		ret += sprintf(buf+ret, "rate[1] = %d Kbps\n",
-			540*plen*8/byte_to_u16(msb, lsb));
-	return ret;
-}
-
-static ssize_t loop_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	u8 ch = 0, mod = 0;
-	struct aml_cimax *cimax = NULL;
-	int err = 0;
-
-	if (!g_spi)
-		return ret;
-
-	cimax = g_spi->cimax;
-	err = aml_cimax_spi_read_reg(cimax, ROUTER_CAM_CH, &ch, 1);
-	err |= aml_cimax_spi_read_reg(cimax, ROUTER_CAM_MOD, &mod, 1);
-	if (err) {
-		ret = sprintf(buf, "read fail, err=%d\n", err);
-		return ret;
-	}
-	ret += sprintf(buf + ret, "OUT-0 <= ");
-	switch (ch & 0x0f) {
-	case 0x0:
-		ret += sprintf(buf + ret, "CAM-A"); break;
-	case 0x1:
-		ret += sprintf(buf + ret, "CH0-IN"); break;
-	case 0x2:
-		ret += sprintf(buf + ret, "CH1-IN"); break;
-	case 0x3:
-		ret += sprintf(buf + ret, "REMAPPER"); break;
-	case 0x4:
-		ret += sprintf(buf + ret, "PREHEADER"); break;
-	case 0x5:
-		ret += sprintf(buf + ret, "CAM-B"); break;
-	case 0x6:
-		ret += sprintf(buf + ret, "GAPREMOVER-0"); break;
-	case 0x7:
-		ret += sprintf(buf + ret, "GAPREMOVER-1"); break;
-	case 0x8:
-		ret += sprintf(buf + ret, "NONE"); break;
-	default:
-		ret += sprintf(buf + ret, "UNKNOWN"); break;
-	}
-	ret += sprintf(buf + ret, "\nCAM-A <= ");
-	switch (mod & 0x07) {
-	case 0x1:
-		ret += sprintf(buf + ret, "CH0-IN"); break;
-	case 0x2:
-		ret += sprintf(buf + ret, "CH1-IN"); break;
-	case 0x3:
-		ret += sprintf(buf + ret, "REMAPPER"); break;
-	case 0x4:
-		ret += sprintf(buf + ret, "PREHEADER"); break;
-	case 0x5:
-		ret += sprintf(buf + ret, "CAM-B"); break;
-	case 0x6:
-		ret += sprintf(buf + ret, "GAPREMOVER-0"); break;
-	case 0x7:
-		ret += sprintf(buf + ret, "GAPREMOVER-1"); break;
-	default:
-		ret += sprintf(buf + ret, "NONE"); break;
-	}
-	ret += sprintf(buf + ret, "\n");
-
-	return ret;
-}
-
-
-static ssize_t loop_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int loop = 0;
-	int err = 0;
-	struct aml_cimax *cimax = NULL;
-
-	if (!g_spi)
-		return size;
-
-	if (sscanf(buf, "%i", &loop) == 1) {
-		int a = g_spi->cam_inserted[0];
-		int b = g_spi->cam_inserted[1];
-		u8 cm[2];
-		cm[0] = loop ? (b ? 0x85 : 0x80) : 0x81;/*CH*/
-		cm[1] = loop ? (a ? 0x51 : 0x11) : 0x00;/*MOD*/
-		cimax = g_spi->cimax;
-		err = aml_cimax_spi_write_reg(cimax, ROUTER_CAM_CH, cm, 2);
-	}
-	return size;
-}
-
-static ssize_t slot_reset_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int err = 0;
-	int slot = 0;
-	struct aml_cimax *cimax = NULL;
-
-	if (!g_spi)
-		return size;
-
-	if (sscanf(buf, "%i", &slot) == 1) {
-		if (slot == 0 || slot == 1) {
-			pr_dbg("reset slot %d\n", slot);
-			cimax = g_spi->cimax;
-			err = aml_cimax_spi_slot_reset(cimax, slot);
-		}
-	}
-	return size;
-}
-
-static ssize_t detect_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int err = 0;
-	int slot = 0;
-	struct aml_cimax *cimax = NULL;
-
-	if (!g_spi)
-		return size;
-
-	if (sscanf(buf, "%i", &slot) == 1) {
-		if (slot == 0 || slot == 1) {
-			int addr = (!slot) ? MOD_CTRL_A : MOD_CTRL_B;
-			u8 reg = 0;
-			cimax = g_spi->cimax;
-			err = aml_cimax_spi_read_reg(cimax, addr, &reg, 1);
-			g_spi->cam_inserted[slot] = reg & 1;
-			pr_dbg("detect slot(%d): %d\n", slot, reg & 1);
-		}
-	}
-	return size;
-}
-
-static struct class_attribute cimax_spi_class_attrs[] = {
-	__ATTR_RW(reset),
-	__ATTR_RO(debug),
-	__ATTR_RW(addr),
-	__ATTR_RW(reg),
-	__ATTR_RW(cis),
-	__ATTR_RO(ts_rate),
-	__ATTR_RW(loop),
-	__ATTR_WO(slot_reset),
-	__ATTR_WO(detect),
-	__ATTR_NULL
-};
-
-static struct class cimax_spi_class = {
-	.name = "cimax_spi",
-	.class_attrs = cimax_spi_class_attrs,
-};
-
-static int aml_cimax_spi_mod_init(void)
-{
-	int ret;
-	pr_dbg("Amlogic CIMAX SPI Init\n");
-	ret = class_register(&cimax_spi_class);
-	return 0;
-}
-
-static void aml_cimax_spi_mod_exit(void)
-{
-	pr_dbg("Amlogic CIMAX SPI Exit\n");
-	class_unregister(&cimax_spi_class);
-}
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_spi.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_spi.h
deleted file mode 100644
index 3548de0..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_spi.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/***************************************************************************
- * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
- *
- * This source code is subject to the terms and conditions defined in the
- * file 'LICENSE' which is part of this source code package.
- *
- * Description:
- *
-***************************************************************************/
-
-#ifndef _AML_CIMAX_SPI_H_
-#define _AML_CIMAX_SPI_H_
-
-#include <linux/platform_device.h>
-#include "aml_cimax.h"
-
-int aml_cimax_spi_init(struct platform_device *pdev, struct aml_cimax *ci);
-int aml_cimax_spi_exit(struct aml_cimax *ci);
-
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_usb.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_usb.c
deleted file mode 100644
index b74b34a..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_usb.c
+++ /dev/null
@@ -1,1714 +0,0 @@
-/***************************************************************************
- * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
- *
- * This source code is subject to the terms and conditions defined in the
- * file 'LICENSE' which is part of this source code package.
- *
- * Description:
- *
-***************************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/gpio/consumer.h>
-#include <linux/device.h>
-#include <linux/slab.h>
-#include <linux/of_irq.h>
-#include <linux/irq.h>
-#include <linux/mutex.h>
-#include <linux/firmware.h>
-#include <linux/delay.h>
-//#include <linux/switch.h>
-
-#include "aml_cimax.h"
-#include "./usb/SRC/cimax+usb-driver.h"
-
-#define MOD_NAME       "aml_cimax_usb"
-
-#define pr_dbg(fmt...)\
-	do {\
-		if (cimax_usb_debug)\
-			pr_info("cimax_usb: "fmt);\
-	} while (0)
-#define pr_inf(fmt...) pr_info("cimax_usb: "fmt)
-#define pr_error(fmt...) pr_err("AML_CIMAX_USB: " fmt)
-
-/*
-  Uncomment below and enable permanent power in cfg
-  to disable dynamic power control mechanism
-*/
-/*#define DISABLE_POWER_PATCH*/
-
-#define BUFFIN_CFG                        0x0000
-#define BUFFIN_ADDR_LSB                   0x0001
-#define BUFFIN_ADDR_MSB                   0x0002
-#define BUFFIN_DATA                       0x0003
-#define BUFFOUT_CFG                       0x0004
-#define BUFFOUT_ADDR_LSB                  0x0005
-#define BUFFOUT_ADDR_MSB                  0x0006
-#define BUFFOUT_DATA                      0x0007
-#define BOOT_Key                          0x0008
-#define BOOT_Status                       0x0009
-#define BOOT_Test                         0x000A
-#define usb2_0_irq_mask                   0x0010
-#define usb2_0_status                     0x0011
-#define usb2_0_rx                         0x0012
-#define usb2_0_tx                         0x0013
-#define SPI_Slave_Ctrl                    0x0018
-#define SPI_Slave_Status                  0x0019
-#define SPI_Slave_Rx                      0x001A
-#define SPI_Slave_Tx                      0x001B
-#define SPI_Slave_Mask                    0x001C
-#define UCSG_Ctrl                         0x0020
-#define UCSG_Status                       0x0021
-#define UCSG_RxData                       0x0022
-#define UCSG_TxData                       0x0023
-#define PCtrl_Ctrl                        0x0028
-#define PCtrl_Status                      0x0029
-#define PCtrl_NbByte_LSB                  0x002A
-#define PCtrl_NbByte_MSB                  0x002B
-#define SPI_Master_Ctl                    0x0030
-#define SPI_Master_NCS                    0x0031
-#define SPI_Master_Status                 0x0032
-#define SPI_Master_TxBuf                  0x0033
-#define SPI_Master_RxBuf                  0x0034
-#define BISTRAM_Ctl                       0x0038
-#define BISTRAM_Bank                      0x0039
-#define BISTRAM_Pat                       0x003A
-#define BISTRAM_SM                        0x003B
-#define BISTRAM_AddrLSB                   0x003C
-#define BISTROM_Config                    0x0040
-#define BISTROM_SignatureLSB              0x0041
-#define BISTROM_SignatureMSB              0x0042
-#define BISTROM_StartAddrLSB              0x0043
-#define BISTROM_StartAddrMSB              0x0043
-#define BISTROM_StopAddrLSB               0x0043
-#define BISTROM_StopAddrMSB               0x0043
-#define CkMan_Config                      0x0048
-#define CkMan_Select                      0x0049
-#define CkMan_Test                        0x004A
-#define Revision_Number                   0x004B
-#define ResMan_Config                     0x0050
-#define ResMan_Status                     0x0051
-#define ResMan_WD                         0x0052
-#define ResMan_WD_MSB                     0x0053
-#define CPU_Test                          0x0060
-#define IrqMan_Config0                    0x0068
-#define IrqMan_Config1                    0x0069
-#define IrqMan_Irq0                       0x006A
-#define IrqMan_NMI                        0x006B
-#define IrqMan_SleepKey                   0x006C
-#define Tim_Config                        0x0070
-#define Tim_Value_LSB                     0x0071
-#define Tim_Value_MSB                     0x0072
-#define Tim_Comp_LSB                      0x0073
-#define Tim_Comp_MSB                      0x0074
-#define TI_Config                         0x0076
-#define TI_Data                           0x0077
-#define TI_Reg0                           0x0078
-#define TI_Reg1                           0x0079
-#define TI_Reg2                           0x007A
-#define TI_Reg3                           0x007B
-#define TI_Reg4                           0x007C
-#define TI_ROM1                           0x007D
-#define TI_ROM2                           0x007E
-#define TI_ROM3                           0x007F
-#define DVBCI_START_ADDR                  0x0100
-#define DVBCI_END_ADDR                    0x017F
-#define DATA                              0x0180
-/*#define CTRL                            0x0181*/
-#define QB_HOST                           0x0182
-#define LEN_HOST_LSB                      0x0183
-#define LEN_HOST_MSB                      0x0184
-#define FIFO_TX_TH_LSB                    0x0185
-#define FIFO_TX_TH_MSB                    0x0186
-#define FIFO_TX_D_NB_LSB                  0x0187
-#define FIFO_TX_D_NB_MSB                  0x0188
-#define QB_MOD_CURR                       0x0189
-#define LEN_MOD_CURR_LSB                  0x018A
-#define LEN_MOD_CURR_MSB                  0x018B
-#define QB_MOD                            0x018C
-#define LEN_MOD_LSB                       0x018D
-#define LEN_MOD_MSB                       0x018E
-#define FIFO_RX_TH_LSB                    0x018F
-#define FIFO_RX_TH_MSB                    0x0190
-#define FIFO_RX_D_NB_LSB                  0x0191
-#define FIFO_RX_D_NB_MSB                  0x0192
-#define IT_STATUS_0                       0x0193
-#define IT_STATUS_1                       0x0194
-#define IT_MASK_0                         0x0195
-#define IT_MASK_1                         0x0196
-#define IT_HOST_PIN_CFG                   0x0200
-#define CFG_0                             0x0201
-#define CFG_1                             0x0202
-#define CFG_2                             0x0203
-#define IT_HOST                           0x0204
-#define MOD_IT_STATUS                     0x0205
-#define MOD_IT_MASK                       0x0206
-#define MOD_CTRL_A                        0x0207
-#define MOD_CTRL_B                        0x0208
-#define DEST_SEL                          0x0209
-#define CAM_MSB_ADD                       0x020A
-#define GPIO0_DIR                         0x020B
-#define GPIO0_DATA_IN                     0x020C
-#define GPIO0_DATA_OUT                    0x020D
-#define GPIO0_STATUS                      0x020E
-#define GPIO0_IT_MASK                     0x020F
-#define GPIO0_DFT                         0x0210
-#define GPIO0_MASK_DATA                   0x0211
-#define GPIO1_DIR                         0x0212
-#define GPIO1_DATA_IN                     0x0213
-#define GPIO1_DATA_OUT                    0x0214
-#define GPIO1_STATUS                      0x0215
-#define GPIO1_IT_MASK                     0x0216
-#define MEM_ACC_TIME_A                    0x0217
-#define MEM_ACC_TIME_B                    0x0218
-#define IO_ACC_TIME_A                     0x0219
-#define IO_ACC_TIME_B                     0x021A
-#define EXT_CH_ACC_TIME_A                 0x021B
-#define EXT_CH_ACC_TIME_B                 0x021C
-#define PAR_IF_0                          0x021D
-#define PAR_IF_1                          0x021E
-#define PAR_IF_CTRL                       0x021F
-#define PCK_LENGTH                        0x0220
-#define USB2TS_CTRL                       0x0221
-#define USB2TS0_RDL                       0x0222
-#define USB2TS1_RDL                       0x0223
-#define TS2USB_CTRL                       0x0224
-#define TSOUT_PAR_CTRL                    0x0225
-#define TSOUT_PAR_CLK_SEL                 0x0226
-#define S2P_CH0_CTRL                      0x0227
-#define S2P_CH1_CTRL                      0x0228
-#define P2S_CH0_CTRL                      0x0229
-#define P2S_CH1_CTRL                      0x022A
-#define TS_IT_STATUS                      0x022B
-#define TS_IT_MASK                        0x022C
-#define IN_SEL                            0x022D
-#define OUT_SEL                           0x022E
-#define ROUTER_CAM_CH                     0x022F
-#define ROUTER_CAM_MOD                    0x0230
-#define FIFO_CTRL                         0x0231
-#define FIFO1_2_STATUS                    0x0232
-#define FIFO3_4_STATUS                    0x0233
-#define GAP_REMOVER_CH0_CTRL              0x0234
-#define GAP_REMOVER_CH1_CTRL              0x0235
-#define SYNC_RTV_CTRL                     0x0236
-#define SYNC_RTV_CH0_SYNC_NB              0x0237
-#define SYNC_RTV_CH0_PATTERN              0x0238
-#define SYNC_RTV_CH1_SYNC_NB              0x0239
-#define SYNC_RTV_CH1_PATTERN              0x023A
-#define SYNC_RTV_OFFSET_PATT              0x023B
-#define CTRL_FILTER                       0x023D
-#define PID_EN_FILTER_CH0                 0x023E
-#define PID_EN_FILTER_CH1                 0x023F
-#define PID_LSB_FILTER_CH0_0              0x0240
-#define PID_MSB_FILTER_CH0_0              0x0241
-#define PID_LSB_FILTER_CH0_1              0x0242
-#define PID_MSB_FILTER_CH0_1              0x0243
-#define PID_LSB_FILTER_CH0_2              0x0244
-#define PID_MSB_FILTER_CH0_2              0x0245
-#define PID_LSB_FILTER_CH0_3              0x0246
-#define PID_MSB_FILTER_CH0_3              0x0247
-#define PID_LSB_FILTER_CH0_4              0x0248
-#define PID_MSB_FILTER_CH0_4              0x0249
-#define PID_LSB_FILTER_CH0_5              0x024A
-#define PID_MSB_FILTER_CH0_5              0x024B
-#define PID_LSB_FILTER_CH0_6              0x024C
-#define PID_MSB_FILTER_CH0_6              0x024D
-#define PID_LSB_FILTER_CH0_7              0x024E
-#define PID_MSB_FILTER_CH0_7              0x024F
-#define PID_LSB_FILTER_CH1_0              0x0260
-#define PID_MSB_FILTER_CH1_0              0x0261
-#define PID_LSB_FILTER_CH1_1              0x0262
-#define PID_MSB_FILTER_CH1_1              0x0263
-#define PID_LSB_FILTER_CH1_2              0x0264
-#define PID_MSB_FILTER_CH1_2              0x0265
-#define PID_LSB_FILTER_CH1_3              0x0266
-#define PID_MSB_FILTER_CH1_3              0x0267
-#define PID_LSB_FILTER_CH1_4              0x0268
-#define PID_MSB_FILTER_CH1_4              0x0269
-#define PID_LSB_FILTER_CH1_5              0x026A
-#define PID_MSB_FILTER_CH1_5              0x026B
-#define PID_LSB_FILTER_CH1_6              0x026C
-#define PID_MSB_FILTER_CH1_6              0x026D
-#define PID_LSB_FILTER_CH1_7              0x026E
-#define PID_MSB_FILTER_CH1_7              0x026F
-#define PID_OLD_LSB_REMAPPER_0            0x0280
-#define PID_OLD_MSB_REMAPPER_0            0x0281
-#define PID_OLD_LSB_REMAPPER_1            0x0282
-#define PID_OLD_MSB_REMAPPER_1            0x0283
-#define PID_OLD_LSB_REMAPPER_2            0x0284
-#define PID_OLD_MSB_REMAPPER_2            0x0285
-#define PID_OLD_LSB_REMAPPER_3            0x0286
-#define PID_OLD_MSB_REMAPPER_3            0x0287
-#define PID_OLD_LSB_REMAPPER_4            0x0288
-#define PID_OLD_MSB_REMAPPER_4            0x0289
-#define PID_OLD_LSB_REMAPPER_5            0x028A
-#define PID_OLD_MSB_REMAPPER_5            0x028B
-#define PID_OLD_LSB_REMAPPER_6            0x028C
-#define PID_OLD_MSB_REMAPPER_6            0x028D
-#define PID_OLD_LSB_REMAPPER_7            0x028E
-#define PID_OLD_MSB_REMAPPER_7            0x028F
-#define PID_NEW_LSB_REMAPPER_0            0x02A0
-#define PID_NEW_MSB_REMAPPER_0            0x02A1
-#define PID_NEW_LSB_REMAPPER_1            0x02A2
-#define PID_NEW_MSB_REMAPPER_1            0x02A3
-#define PID_NEW_LSB_REMAPPER_2            0x02A4
-#define PID_NEW_MSB_REMAPPER_2            0x02A5
-#define PID_NEW_LSB_REMAPPER_3            0x02A6
-#define PID_NEW_MSB_REMAPPER_3            0x02A7
-#define PID_NEW_LSB_REMAPPER_4            0x02A8
-#define PID_NEW_MSB_REMAPPER_4            0x02A9
-#define PID_NEW_LSB_REMAPPER_5            0x02AA
-#define PID_NEW_MSB_REMAPPER_5            0x02AB
-#define PID_NEW_LSB_REMAPPER_6            0x02AC
-#define PID_NEW_MSB_REMAPPER_6            0x02AD
-#define PID_NEW_LSB_REMAPPER_7            0x02AE
-#define PID_NEW_MSB_REMAPPER_7            0x02AF
-#define MERGER_DIV_MICLK                  0x02C0
-#define PID_AND_SYNC_REMAPPER_CTRL        0x02C1
-#define PID_EN_REMAPPER                   0x02C2
-#define SYNC_SYMBOL                       0x02C3
-#define PID_AND_SYNC_REMAPPER_INV_CTRL    0x02C4
-#define BITRATE_CH0_LSB                   0x02C5
-#define BITRATE_CH0_MSB                   0x02C6
-#define BITRATE_CH1_LSB                   0x02C7
-#define BITRATE_CH1_MSB                   0x02C8
-#define STATUS_CLK_SWITCH_0               0x02C9
-#define STATUS_CLK_SWITCH_1               0x02CA
-#define RESET_CLK_SWITCH_0                0x02CB
-#define RESET_CLK_SWITCH_1                0x02CC
-#define PAD_DRVSTR_CTRL                   0x02CD
-#define PAD_PUPD_CTRL                     0x02CE
-#define PRE_HEADER_ADDER_CH0_0            0x02D0
-#define PRE_HEADER_ADDER_CH0_1            0x02D1
-#define PRE_HEADER_ADDER_CH0_2            0x02D2
-#define PRE_HEADER_ADDER_CH0_3            0x02D3
-#define PRE_HEADER_ADDER_CH0_4            0x02D4
-#define PRE_HEADER_ADDER_CH0_5            0x02D5
-#define PRE_HEADER_ADDER_CH0_6            0x02D6
-#define PRE_HEADER_ADDER_CH0_7            0x02D7
-#define PRE_HEADER_ADDER_CH0_8            0x02D8
-#define PRE_HEADER_ADDER_CH0_9            0x02D9
-#define PRE_HEADER_ADDER_CH0_10           0x02DA
-#define PRE_HEADER_ADDER_CH0_11           0x02DB
-#define PRE_HEADER_ADDER_CH1_0            0x02E0
-#define PRE_HEADER_ADDER_CH1_1            0x02E1
-#define PRE_HEADER_ADDER_CH1_2            0x02E2
-#define PRE_HEADER_ADDER_CH1_3            0x02E3
-#define PRE_HEADER_ADDER_CH1_4            0x02E4
-#define PRE_HEADER_ADDER_CH1_5            0x02E5
-#define PRE_HEADER_ADDER_CH1_6            0x02E6
-#define PRE_HEADER_ADDER_CH1_7            0x02E7
-#define PRE_HEADER_ADDER_CH1_8            0x02E8
-#define PRE_HEADER_ADDER_CH1_9            0x02E9
-#define PRE_HEADER_ADDER_CH1_10           0x02EA
-#define PRE_HEADER_ADDER_CH1_11           0x02EB
-#define PRE_HEADER_ADDER_CTRL             0x02EC
-#define PRE_HEADER_ADDER_LEN              0x02ED
-#define PRE_HEADER_REMOVER_CTRL           0x02EE
-#define FSM_DVB                           0x02F0
-#define TS2USB_FSM_DEBUG                  0x02F2
-#define TSOUT_PAR_FSM_DEBUG               0x02F3
-#define GAP_REMOVER_FSM_DEBUG             0x02F4
-#define PID_AND_SYNC_REMAPPER_FSM_DEBUG   0x02F5
-#define PRE_HEADER_ADDER_FSM_DEBUG        0x02F6
-#define SYNC_RTV_FSM_DEBUG                0x02F7
-#define CHECK_PHY_CLK                     0x0E00
-#define USB_CTRL1                         0x0E01
-#define USB_ISO2_out                      0x0800
-#define USB_ISO1_out                      0x1000
-#define USB_Interrupt_out                 0x1E00
-#define USB_Bulk_in                       0x1F00
-#define CC2_Buffer_out                    0x2000
-#define USB_EP0                           0x30C0
-#define CC2_Buffer_in                     0x4000
-#define USB_ISO2_in                       0x5800
-#define USB_ISO1_in                       0x6000
-#define nmb_vector_address_lsb            0xFFFA
-#define nmb_vector_address_msb            0xFFFB
-#define reset_vector_address_lsb          0xFFFC
-#define reset_vector_address_msb          0xFFFD
-#define irb_vector_address_lsb            0xFFFE
-#define irb_vector_address_msb            0xFFFF
-
-
-#define CIMAX_REG_HDR_SIZE 4
-#define CIMAX_REG_PLD_SIZE 255
-#define CIMAX_CAM_HDR_SIZE 4
-#define CIMAX_CAM_PLD_SIZE 65535
-
-#define DEF_LOCK(_l_) struct mutex _l_
-
-struct cimax_usb {
-	struct platform_device *pdev;
-	struct device_s *dev;
-
-	struct aml_cimax *cimax;
-
-	u8 buf[CIMAX_REG_HDR_SIZE + CIMAX_CAM_HDR_SIZE + CIMAX_CAM_PLD_SIZE];
-	int buf_size;
-
-	int cam_inserted[2];
-#define IN_INSERTED 0x01
-#define IN_POWERED  0x02
-#define IN_LINKED   0x04
-	int cam_data_ready[2];
-
-	int poll_mode;
-#define STOP_MODE 0
-#define POLL_MODE 1
-#define INT_MODE  2
-
-	int rst_io;
-
-	struct workqueue_struct *workq;
-	struct delayed_work work;
-	int work_auto_restart;
-	int work_cnt;
-
-	struct delayed_work power_work;
-	int power_work_cnt;
-	int cam_det;
-
-	DEF_LOCK(lock);
-#define lock_init(_usb) mutex_init(&(_usb)->lock)
-#define lock_lock(_usb) do {\
-	int err = mutex_lock_interruptible(&(_usb)->lock);\
-	if (err)\
-		return err;\
-} while (0)
-#define lock_unlock(_usb) mutex_unlock(&(_usb)->lock)
-
-	u8 *cis;
-#define CIS_MAX 512
-};
-
-static struct cimax_usb *g_usb;
-
-MODULE_PARM_DESC(usbdebug, "enable verbose debug messages");
-static int cimax_usb_debug = 1;
-module_param_named(usbdebug, cimax_usb_debug, int, 0644);
-
-MODULE_PARM_DESC(usbpoll_interval, "interval for usb poll");
-static int usb_poll_interval = 100;
-module_param_named(usbpoll_interval, usb_poll_interval, int, 0644);
-
-MODULE_PARM_DESC(usbpoll_mode, "set cimax poll mode, need reset");
-static int cimax_poll_mode = 1;
-module_param_named(usbpoll_mode, cimax_poll_mode, int, 0644);
-
-MODULE_PARM_DESC(usbcam_irq_mode, "set cam irq mode, need reset");
-static int cam_irq_mode;
-module_param_named(usbcam_irq_mode, cam_irq_mode, int, 0644);
-
-
-#define CIMAX_REG_READ     0xff
-#define CIMAX_REG_READ_OK  0x4c
-#define CIMAX_REG_WRITE    0x7f
-#define CIMAX_REG_WRITE_OK 0x4d
-#define CIMAX_REG_INIT     0x00
-#define CIMAX_REG_INIT_OK  0x4b
-#define CIMAX_REG_CMD_ERROR 0x51
-
-#define CIMAX_CAM_RESET    0x01
-#define CIMAX_CAM_RESET_OK 0x40
-#define CIMAX_CAM_CIS      0x02
-#define CIMAX_CAM_CIS_OK   0x41
-#define CIMAX_CAM_COR      0x03
-#define CIMAX_CAM_COR_OK   0x42
-#define CIMAX_CAM_NEG      0x04
-#define CIMAX_CAM_NEG_OK   0x43
-#define CIMAX_CAM_WLPDU    0x05
-#define CIMAX_CAM_WLPDU_OK 0x44
-#define CIMAX_CAM_RLPDU    0x06
-#define CIMAX_CAM_RLPDU_OK 0x46
-#define CIMAX_CAM_EVT         0x0d
-#define CIMAX_CAM_DET_OK      0x45
-#define CIMAX_CAM_NOCAM       0x49
-#define CIMAX_CAM_ERROR       0x4a
-#define CIMAX_CAM_NOEVT       0x55
-#define CIMAX_CAM_DATA_READY  0x4e
-#define CIMAX_CAM_WBUSY       0x54
-#define CIMAX_CAM_PENDING     0x56
-#define CIMAX_CAM_REGSTAT     0x0e
-#define CIMAX_CAM_REGSTAT_OK  0x57
-
-
-#define CIMAX_CAM_PKT_CNT_VAL 1
-
-#define CIMAX_SLOT_A 0
-#define CIMAX_SLOT_B 1
-
-#define CIMAX_CMD_RESP_MASK 0x7f
-
-#define cimax_to_usb(_c) ((struct cimax_usb *)((_c)->priv))
-#define dev_to_usb(_d) ((struct cimax_usb *)usb_get_drvdata(_d))
-
-#define byte_to_u16(_b1, _b2)   (((_b1)<<8) | (_b2))
-
-#define hdr_cmd_resp(_s)     ((_s)->buf[0] & CIMAX_CMD_RESP_MASK)
-
-#define reg_hdr(_s)          ((_s)->buf)
-#define reg_addr(_s)         byte_to_u16((_s)->buf[1], (_s)->buf[2])
-#define reg_hdr_dat_size(_s) ((_s)->buf[3])
-#define reg_dat(_s)          (&((_s)->buf[CIMAX_REG_HDR_SIZE]))
-
-#define cam_hdr(_s)          ((_s)->buf)
-#define cam_hdr_slot(_s)     (((_s)->buf[0] & 0x80) ? 1 : 0)
-#define cam_hdr_pkt_cnt(_s)  ((_s)->buf[1])
-#define cam_hdr_dat_size(_s) byte_to_u16((_s)->buf[2], (_s)->buf[3])
-#define cam_dat(_s)          (&((_s)->buf[CIMAX_CAM_HDR_SIZE]))
-
-#define REG_TIMEOUT 500
-#define CAM_TIMEOUT 5000
-
-static int aml_cimax_usb_mod_init(void);
-static void aml_cimax_usb_mod_exit(void);
-
-static int cimax_usb_set_loop(struct cimax_usb *usb, int loop);
-
-static void dump(char *title, u8 *buf, int size)
-{
-	int i;
-	pr_info("%s\n", title);
-	for (i = 0; i < size; i++) {
-		if (!(i & 0xf))
-			pr_info("\n\t");
-		pr_info("%02x ", *(buf+i));
-	}
-	pr_info("\n");
-}
-
-static void perr(char *err, struct cimax_usb *usb)
-{
-	pr_error("error: %s\n", err);
-	dump("dump:", usb->buf, 16);
-}
-
-static inline unsigned long get_jiffies(void)
-{
-	return (unsigned long)(sched_clock()/10000000);
-}
-
-static int cam_usb_cam_detect(struct cimax_usb *usb, int slot, int flag)
-{
-	usb->cam_inserted[slot] = flag;
-	pr_inf("detect slot(%d): 0x%x(%s)\n",
-		slot, usb->cam_inserted[slot],
-		(!flag) ? "none" :
-		(flag & IN_LINKED) ? "linked" :
-		(flag & IN_POWERED) ? "powered" :
-		(flag & IN_INSERTED) ? "inserted" :
-		"unknown");
-	aml_cimax_slot_state_changed(usb->cimax, slot,
-		usb->cam_inserted[slot]);
-	return 0;
-}
-
-static inline void set_usb_cam_ready(struct cimax_usb *usb, int slot)
-{
-	if (usb->cam_inserted[slot] & IN_POWERED) {
-		cam_usb_cam_detect(usb, slot,
-			usb->cam_inserted[slot] | IN_LINKED);
-		cimax_usb_set_loop(usb, 1);/*set auto-loop*/
-	}
-}
-
-static int init_reg_hdr(u8 *hdr, u8 tag, int addr, int size)
-{
-	hdr[0] = tag;
-	hdr[1] = (addr>>8) & 0xff;
-	hdr[2] = addr & 0xff;
-	hdr[3] = size;
-	return 0;
-}
-
-static int check_reg_hdr(u8 *hdr, u8 tag, int addr, int size)
-{
-	return hdr[0] != tag
-		|| hdr[1] != ((addr>>8) & 0xff)
-		|| hdr[2] != (addr & 0xff)
-		|| hdr[3] != size;
-}
-
-static int aml_cimax_usb_read_reg(struct aml_cimax *cimax, int addr,
-		u8 *buf, int size)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	struct device_s *dev = usb->dev;
-	u8 out[CIMAX_REG_HDR_SIZE];
-	int err = 0;
-
-	init_reg_hdr(out, CIMAX_REG_READ, addr, size);
-
-	lock_lock(usb);
-
-	/*pr_dbg("rd %02x:%02x:%02x:%02x\n",
-		out[0], out[1],
-		out[2], out[3]);*/
-	err = cimax_usb_ci_write(dev,
-			out, CIMAX_REG_HDR_SIZE, usb->buf, sizeof(usb->buf));
-	if (err)
-		goto end;
-	if (check_reg_hdr(reg_hdr(usb), CIMAX_REG_READ_OK, addr, size) != 0) {
-		pr_dbg("rd %02x:%02x:%02x:%02x\n",
-			out[0], out[1],
-			out[2], out[3]);
-		perr("read reg fail.", usb);
-		err = -EINVAL;
-		goto end;
-	}
-	memcpy(buf, reg_dat(usb), size);
-end:
-	lock_unlock(usb);
-	return err;
-}
-
-static int aml_cimax_usb_write_reg(struct aml_cimax *cimax, int addr,
-		u8 *buf, int size)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	struct device_s *dev = usb->dev;
-	u8 out[CIMAX_REG_HDR_SIZE + CIMAX_REG_PLD_SIZE];
-	int err = 0;
-
-	init_reg_hdr(out, CIMAX_REG_WRITE, addr, size);
-	memcpy(&out[CIMAX_REG_HDR_SIZE], buf, size);
-
-	lock_lock(usb);
-
-	pr_dbg("wr %02x:%02x:%02x:%02x\n",
-		out[0], out[1],
-		out[2], out[3]);
-	err = cimax_usb_ci_write(dev,
-		out, CIMAX_REG_HDR_SIZE + size, usb->buf, sizeof(usb->buf));
-	if (err)
-		goto end;
-	if (check_reg_hdr(reg_hdr(usb), CIMAX_REG_WRITE_OK, addr, 0) != 0) {
-		perr("write reg fail.", usb);
-		err = -EINVAL;
-		goto end;
-	}
-end:
-	lock_unlock(usb);
-	return err;
-}
-
-static inline int init_cam_hdr(u8 *hdr, int cmd, int size)
-{
-	hdr[0] = cmd;
-	hdr[1] = CIMAX_CAM_PKT_CNT_VAL;
-	hdr[2] = (size>>8) & 0xff;
-	hdr[3] = size & 0xff;
-	return 0;
-}
-
-static inline int cam_err(struct cimax_usb *usb)
-{
-	if (hdr_cmd_resp(usb) != CIMAX_CAM_ERROR
-		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(usb) != 2)
-		return 0;
-	return byte_to_u16(cam_dat(usb)[0], cam_dat(usb)[1]);
-}
-
-static inline char *cam_err_str(int err)
-{
-#define CAMERROR_RESET           0x0101
-#define CAMERROR_CIS_BUF         0x0201
-#define CAMERROR_CIS_SIZE        0x0202
-#define CAMERROR_CAM_NOT_ACT     0x0203
-#define CAMERROR_COR_NOT_READY   0x0301
-#define CAMERROR_COR_VAL_CHK     0x0302
-#define CAMERROR_NEG_NO_RESP     0x0401
-#define CAMERROR_NEG_BAD_SIZE    0x0402
-#define CAMERROR_NEG_NOT_READY   0x0403
-#define CAMERROR_LPDU_NOT_AVAIL  0x0601
-	struct { int err; char *str; } cam_err_strings[] = {
-		{CAMERROR_RESET, "reset error, not ready."},
-		{CAMERROR_CIS_BUF, "cis error, buffer not allocated."},
-		{CAMERROR_CIS_SIZE, "cis error, bad cis size."},
-		{CAMERROR_CAM_NOT_ACT, "cam not activated."},
-		{CAMERROR_COR_NOT_READY, "cam not ready during write COR."},
-		{CAMERROR_COR_VAL_CHK, "COR value check failed."},
-		{CAMERROR_NEG_NO_RESP, "cam not responding when negotiation."},
-		{CAMERROR_NEG_BAD_SIZE, "cam buf size length != 2."},
-		{CAMERROR_NEG_NOT_READY, "cam not ready during negotiation."},
-		{CAMERROR_LPDU_NOT_AVAIL, "lpdu not available."}
-	};
-	int i;
-	for (i = 0;
-		i < sizeof(cam_err_strings)/sizeof(cam_err_strings[0]); i++) {
-		if (cam_err_strings[i].err == err)
-			return cam_err_strings[i].str;
-	}
-	return "err unknown.";
-}
-
-static int cimax_usb_access_cam(struct cimax_usb *usb, int slot,
-		int cmd, u8 *tx, int tx_size, u8 *rx, int rx_size)
-{
-	struct device_s *dev = usb->dev;
-	u8 *out = NULL;
-	int err = 0;
-
-	out = kzalloc(CIMAX_CAM_HDR_SIZE + CIMAX_CAM_PLD_SIZE, GFP_KERNEL);
-	if (!out) {
-		pr_err("no mem for access cam.\n");
-		return -ENOMEM;
-	}
-
-	cmd |= slot ? 0x80 : 0;
-	init_cam_hdr(out, cmd, tx_size);
-	memcpy(&out[CIMAX_CAM_HDR_SIZE], tx, tx_size);
-	/*dump("access cam:", out, CIMAX_CAM_HDR_SIZE+size);*/
-
-	lock_lock(usb);
-
-	err = cimax_usb_ci_write(dev,
-			out, CIMAX_CAM_HDR_SIZE + tx_size, rx, rx_size);
-	if (err)
-		goto end;
-	if (cam_hdr_slot(usb) != slot) {
-		pr_error("expect slot(%d), but slot(%d)\n",
-			slot, cam_hdr_slot(usb));
-		err = -EINVAL;
-		goto end;
-	}
-	switch (hdr_cmd_resp(usb)) {
-	case CIMAX_CAM_NOCAM:
-		pr_dbg("no cam\n");
-		err = -ENODEV;
-		break;
-	case CIMAX_CAM_ERROR:
-		pr_error("cam error\n");
-		pr_error("err code: 0x%04x(%s)\n", cam_err(usb),
-			cam_err_str(cam_err(usb)));
-		err = -ENODEV;
-		break;
-	case CIMAX_CAM_WBUSY:
-		pr_dbg("cam busy\n");
-		err = -EBUSY;
-		break;
-	case CIMAX_CAM_PENDING:
-		pr_dbg("cam pending\n");
-		err = -EAGAIN;
-		break;
-	}
-end:
-	kfree(out);
-	lock_unlock(usb);
-	return err;
-}
-
-static int aml_cimax_usb_read_cis(struct aml_cimax *cimax, int slot,
-		u8 *buf, int size)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	int err = 0;
-	int len;
-
-	err = cimax_usb_access_cam(usb, slot, CIMAX_CAM_CIS,
-		NULL, 0, usb->buf, sizeof(usb->buf));
-	if (err)
-		goto end;
-	if (hdr_cmd_resp(usb) != CIMAX_CAM_CIS_OK
-		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL) {
-		perr("read cis fail.", usb);
-		err = -EINVAL;
-		goto end;
-	}
-	len = cam_hdr_dat_size(usb);
-	if (size < len) {
-		pr_error("cis size too large, expect<%d, but:%d\n", size, len);
-		perr("cis fail.", usb);
-		err = -EINVAL;
-		goto end;
-	}
-	memcpy(buf, cam_dat(usb), len);
-
-	if (!usb->cis)
-		usb->cis = kzalloc((len < 512) ? 512 : len, GFP_KERNEL);
-	if (usb->cis)
-		memcpy(usb->cis, cam_dat(usb), len);
-
-end:
-	return err;
-}
-#define CIMAX_CAM_COR_PLD_SIZE 5
-static int aml_cimax_usb_write_cor(struct aml_cimax *cimax, int slot,
-		int addr, u8 *buf)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	int err = 0;
-	u8 out[CIMAX_CAM_COR_PLD_SIZE + 8];
-	int sz = CIMAX_CAM_COR_PLD_SIZE;
-
-	out[0] = addr>>8 & 0xff;
-	out[1] = addr & 0xff;
-	out[2] = buf[0];
-	out[3] = 0;
-	out[4] = 0;
-
-	if (!cam_irq_mode) {
-		out[5] = 0x40;/*cam poll mode*/
-		sz++;
-	}
-
-	err = cimax_usb_access_cam(usb, slot, CIMAX_CAM_COR,
-			out, sz, usb->buf, sizeof(usb->buf));
-	if (err)
-		goto end;
-	if (hdr_cmd_resp(usb) != CIMAX_CAM_COR_OK
-		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(usb) != 0) {
-		perr("write cor fail.", usb);
-		err = -EINVAL;
-		goto end;
-	}
-end:
-	return err;
-}
-#define CIMAX_CAM_NEG_PLD_SIZE 2
-static int aml_cimax_usb_negotiate(struct aml_cimax *cimax, int slot, int size)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	int ret = 0;
-	u8 out[CIMAX_CAM_NEG_PLD_SIZE];
-
-	out[0] = (size>>8) & 0xff;
-	out[1] = size & 0xff;
-
-	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_NEG,
-			out, CIMAX_CAM_NEG_PLD_SIZE,
-			usb->buf, sizeof(usb->buf));
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(usb) != CIMAX_CAM_NEG_OK
-		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(usb) != 2) {
-		perr("negotiate fail.", usb);
-		ret = -EINVAL;
-		goto end;
-	}
-	ret = byte_to_u16(cam_dat(usb)[0], cam_dat(usb)[1]);
-
-	set_usb_cam_ready(usb, slot);
-end:
-	return ret;
-}
-
-static int aml_cimax_usb_write_lpdu(struct aml_cimax *cimax, int slot,
-		u8 *buf, int size)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	int ret = 0;
-
-	/*dump("lpdu ->", buf, size);*/
-	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_WLPDU,
-		buf, size, usb->buf, sizeof(usb->buf));
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(usb) != CIMAX_CAM_WLPDU_OK
-		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(usb) != 0) {
-		perr("write lpdu fail.", usb);
-		ret = -EINVAL;
-		goto end;
-	}
-	ret = size;
-end:
-	return ret;
-}
-
-static int aml_cimax_usb_read_lpdu(struct aml_cimax *cimax, int slot,
-		u8 *buf, int size)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	int ret = 0;
-
-	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_RLPDU,
-		NULL, 0, usb->buf, sizeof(usb->buf));
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(usb) != CIMAX_CAM_RLPDU_OK
-		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL) {
-		perr("read lpdu fail.", usb);
-		ret = -EINVAL;
-		goto end;
-	}
-	ret = cam_hdr_dat_size(usb);
-	memcpy(buf, cam_dat(usb), ret);
-
-	/*dump("lpdu <-", buf, ret);*/
-
-	usb->cam_data_ready[slot] = 0;
-end:
-	return ret;
-}
-
-static int aml_cimax_usb_read_cam_status(struct aml_cimax *cimax, int slot)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	int ret = 0;
-
-	if (cam_irq_mode && usb->cam_data_ready[slot])
-		return 0x80;
-
-	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_REGSTAT,
-		NULL, 0, usb->buf, sizeof(usb->buf));
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(usb) != CIMAX_CAM_REGSTAT_OK
-		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(usb) != 1) {
-		perr("read cam status fail.", usb);
-		ret = -EINVAL;
-		goto end;
-	}
-
-	ret = cam_dat(usb)[0];
-end:
-	return ret;
-}
-
-static int aml_cimax_usb_slot_reset(struct aml_cimax *cimax, int slot)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	int ret = 0;
-
-	usb->cam_data_ready[slot] = 0;
-
-	ret = cimax_usb_access_cam(usb, slot, CIMAX_CAM_RESET,
-		NULL, 0, usb->buf, sizeof(usb->buf));
-	if (ret)
-		goto end;
-	if (hdr_cmd_resp(usb) != CIMAX_CAM_RESET_OK
-		|| cam_hdr_pkt_cnt(usb) != CIMAX_CAM_PKT_CNT_VAL
-		|| cam_hdr_dat_size(usb) != 0) {
-		perr("slot reset fail.", usb);
-		ret = -EINVAL;
-		goto end;
-	}
-end:
-	return ret;
-}
-
-static int aml_cimax_usb_cam_reset(struct aml_cimax *cimax, int slot)
-{
-	pr_dbg("Slot(%d): camreset\n", slot);
-	return 0;
-}
-
-static int aml_cimax_usb_slot_shutdown(struct aml_cimax *cimax, int slot)
-{
-	pr_dbg("Slot(%d): shutdown\n", slot);
-	return 0;
-}
-static int aml_cimax_usb_slot_ts_enable(struct aml_cimax *cimax, int slot)
-{
-	pr_dbg("Slot(%d): ts control\n", slot);
-	return 0;
-}
-static int aml_cimax_usb_slot_status(struct aml_cimax *cimax, int slot)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-	if (usb->cam_inserted[slot] & IN_POWERED) {
-		/*pr_dbg("CA Module present and ready\n");*/
-		return DVB_CA_EN50221_POLL_CAM_PRESENT |
-			DVB_CA_EN50221_POLL_CAM_READY;
-	} else {
-		/*pr_error("CA Module not present or not ready\n");*/
-	}
-	return 0;
-}
-
-static int cimax_usb_cam_plugin(struct cimax_usb *usb, int slot, int plugin)
-{
-	pr_dbg("cam plug: slot(%d) %s\n",
-		slot, plugin ? "plugged" : "unplugged");
-	return aml_cimax_camchanged(usb->cimax, slot, plugin);
-}
-
-static int cimax_usb_set_power(struct cimax_usb *usb, int on)
-{
-	u8 reg = 0;
-	int err = 0;
-	if (!on) {
-		reg = 0;
-		err = aml_cimax_usb_read_reg(usb->cimax, MOD_IT_MASK, &reg, 1);
-		if (err)
-			return err;
-		reg |= 0x03;
-		reg &= 0xf3;
-
-		err = aml_cimax_usb_write_reg(usb->cimax, MOD_IT_MASK, &reg, 1);
-		if (err)
-			return err;
-	}
-	reg = on ? 0x3 : 0x0;
-	return aml_cimax_usb_write_reg(usb->cimax, GPIO0_DATA_OUT, &reg, 1);
-}
-
-static int cimax_usb_check_poe(struct cimax_usb *usb, int *on)
-{
-	u8 reg = 0;
-	int err = 0;
-
-	*on = 0;
-
-	err = aml_cimax_usb_read_reg(usb->cimax, CFG_1, &reg, 1);
-	if (err)
-		return err;
-	if (reg & 0x20) {/*if VCCEN*/
-		reg |= 0x08;/*set POE*/
-		err = aml_cimax_usb_write_reg(usb->cimax, CFG_1, &reg, 1);
-		if (err)
-			return err;
-		err = aml_cimax_usb_read_reg(usb->cimax, CFG_1, &reg, 1);
-		if (err)
-			return err;
-		if (reg & 0x08)/*if POE ok*/
-			*on = 1;
-	}
-	return err;
-}
-
-static void cimax_usb_power_work(struct work_struct *work)
-{
-	struct cimax_usb *usb = container_of(to_delayed_work(work),
-		struct cimax_usb, power_work);
-	int power = 0;
-	int err = 0;
-
-	usb->power_work_cnt++;
-	err = cimax_usb_set_power(usb, 1);
-	if (err)
-		return;
-
-	err = cimax_usb_check_poe(usb, &power);
-	if (err)
-		return;
-
-	if (power) {
-		return;
-	}
-
-	schedule_delayed_work(&usb->power_work, usb_poll_interval);
-}
-
-static int cimax_usb_cam_powerctrl(struct cimax_usb *usb,
-		int slot, int power)
-{
-	if (slot != 0)
-		return 0;
-
-#ifdef DISABLE_POWER_PATCH
-	if (power) {
-		cam_usb_cam_detect(usb, slot,
-			usb->cam_inserted[slot] | IN_POWERED);
-		cimax_usb_cam_plugin(usb, slot, 1);
-	}
-	return 0;
-#else
-	pr_inf("cancel power ctrl previous\n");
-	cancel_delayed_work_sync(&usb->power_work);
-
-	if (!power) {
-		int err = 0;
-		err = cimax_usb_set_power(usb, 0);
-		pr_inf("slot[%d] power off\n", slot);
-		return 0;
-	}
-
-	INIT_DELAYED_WORK(&usb->power_work, &cimax_usb_power_work);
-	schedule_delayed_work(&usb->power_work, usb_poll_interval);
-	pr_inf("slot[%d] power ctrl started\n", slot);
-#endif
-	return 0;
-}
-
-static int cimax_usb_poll(struct cimax_usb *usb)
-{
-	struct device_s *dev = usb->dev;
-	int power = 0;
-	int err = 0;
-	int slot = 0;
-
-	if (!usb->cam_det) {
-		for (slot = 0; slot < 2; slot++) {
-			int addr = (!slot) ? MOD_CTRL_A : MOD_CTRL_B;
-			u8 reg = 0;
-			err = aml_cimax_usb_read_reg(usb->cimax,
-					addr, &reg, 1);
-			if (reg & 1) {
-				cam_usb_cam_detect(usb, slot,
-					(reg & 1) ? IN_INSERTED : 0);
-				msleep(200);
-				err = cimax_usb_set_power(usb, (reg & 1));
-				err = cimax_usb_check_poe(usb, &power);
-				pr_inf("slot[%d] power on\n", slot);
-				msleep(200);
-				if (power) {
-					cam_usb_cam_detect(usb, slot,
-					usb->cam_inserted[slot] | IN_POWERED);
-					cimax_usb_cam_plugin(usb, slot, 1);
-					usb->cam_det = 1;
-				}
-			}
-		}
-		return 0;
-	}
-	err = cimax_usb_ci_read_evt(dev, CIMAX_SLOT_A,
-			usb->buf, sizeof(usb->buf));
-	if (err)
-		goto end;
-
-	switch (hdr_cmd_resp(usb)) {
-	case CIMAX_CAM_DET_OK: {
-		int slot = cam_hdr_slot(usb);
-		int insert = cam_dat(usb)[0];
-		if ((!!usb->cam_inserted[slot]) != insert) {
-			cam_usb_cam_detect(usb, slot,
-				insert ? IN_INSERTED : 0);
-			cimax_usb_cam_powerctrl(usb, slot, insert);
-		}
-		if (!insert)
-			usb->cam_det = 0;
-		} break;
-	case CIMAX_CAM_DATA_READY: {
-		int slot = cam_hdr_slot(usb);
-		usb->cam_data_ready[slot] = 1;
-		} break;
-	case CIMAX_CAM_NOEVT:
-		break;
-	default:
-		pr_error("unknown resp:%02x\n", hdr_cmd_resp(usb));
-		break;
-	}
-end:
-	return 0;
-}
-
-static void cimax_usb_poll_work(struct work_struct *work)
-{
-	struct cimax_usb *usb =
-		container_of(to_delayed_work(work), struct cimax_usb, work);
-	usb->work_cnt++;
-	cimax_usb_poll(usb);
-	if (usb->work_auto_restart)
-		queue_delayed_work(usb->workq, &usb->work, usb_poll_interval);
-}
-
-#define CTRL_DISABLE -1
-#define CTRL_STOP     0
-#define CTRL_START    1
-
-static inline int cimax_usb_poll_ctrl(struct cimax_usb *usb, int ctrl)
-{
-	if (ctrl == CTRL_START) {
-		if (usb->workq)
-			return 0;
-		usb->work_auto_restart = 1;
-		usb->workq = create_singlethread_workqueue("cimax_usb");
-		INIT_DELAYED_WORK(&usb->work, &cimax_usb_poll_work);
-		queue_delayed_work(usb->workq,
-			&usb->work, usb_poll_interval);
-		pr_inf("poll started\n");
-	} else {
-		if (!usb->workq)
-			return 0;
-		usb->work_auto_restart = 0;
-		cancel_delayed_work_sync(&usb->work);
-		destroy_workqueue(usb->workq);
-		usb->workq = NULL;
-		pr_inf("poll stopped\n");
-	}
-	return 0;
-}
-
-static int cimax_usb_setup_poll(struct cimax_usb *usb, int poll_mode)
-{
-	if (poll_mode == usb->poll_mode)
-		return 0;
-	switch (poll_mode) {
-	case POLL_MODE:
-		cimax_usb_poll_ctrl(usb, CTRL_START);
-		usb->poll_mode = POLL_MODE;
-		break;
-	case STOP_MODE:
-		if (usb->poll_mode == POLL_MODE)
-			cimax_usb_poll_ctrl(usb, CTRL_DISABLE);
-		usb->poll_mode = STOP_MODE;
-		break;
-	default:
-		break;
-	}
-	return 0;
-}
-
-static int cimax_usb_hw_reset(struct cimax_usb *usb, int reset_val)
-{
-	/*trigger reset io*/
-	if (usb->rst_io) {
-		gpio_direction_output(usb->rst_io, reset_val ? 1 : 0);
-		msleep(50);
-		gpio_direction_output(usb->rst_io, reset_val ? 0 : 1);
-	}
-	return 0;
-}
-
-static int cimax_usb_set_loop(struct cimax_usb *usb, int loop)
-{
-	int a = usb->cam_inserted[0];
-	int b = usb->cam_inserted[1];
-	u8 cm[2];
-
-	pr_inf("set loop: %d\n", loop);
-
-	cm[0] = loop ? (b ? 0x85 : 0x80) : 0x81;/*CH*/
-	cm[1] = loop ? (a ? 0x51 : 0x11) : 0x00;/*MOD*/
-
-	return aml_cimax_usb_write_reg(usb->cimax, ROUTER_CAM_CH, cm, 2);
-}
-
-int cimax_usb_dev_add(struct device_s *dev, int id)
-{
-	pr_inf("dev add\n");
-	if (!g_usb)
-		return 0;
-
-	id = id;
-
-	cimax_usb_device_open(dev);
-	cimax_usb_select_interface(dev, 3);
-
-	lock_lock(g_usb);
-	g_usb->dev = dev;
-	lock_unlock(g_usb);
-
-	if (0)
-	{
-		/*
-		  the cimax's fw do not report cam status
-		  when board power on with cam plugged,
-		  have to check manually here.
-		*/
-		int slot = 0;
-		int err = 0;
-		for (slot = 0; slot < 2; slot++) {
-			int addr = (!slot) ? MOD_CTRL_A : MOD_CTRL_B;
-			u8 reg = 0;
-			err = aml_cimax_usb_read_reg(g_usb->cimax,
-					addr, &reg, 1);
-			cam_usb_cam_detect(g_usb, slot,
-				(reg & 1) ? IN_INSERTED : 0);
-			cimax_usb_cam_powerctrl(g_usb, slot, (reg & 1));
-		}
-	}
-	cimax_usb_set_power(g_usb, 0);
-	cimax_usb_setup_poll(g_usb, cimax_poll_mode ? POLL_MODE : INT_MODE);
-	return 0;
-}
-EXPORT_SYMBOL(cimax_usb_dev_add);
-
-int cimax_usb_dev_remove(struct device_s *dev, int id)
-{
-	pr_dbg("dev remove\n");
-	if (!g_usb)
-		return 0;
-	id = id;
-	pr_dbg("setup poll -> stop\n");
-	cimax_usb_setup_poll(g_usb, STOP_MODE);
-	pr_dbg("setup poll end\n");
-	lock_lock(g_usb);
-	g_usb->dev = NULL;
-	lock_unlock(g_usb);
-	return 0;
-}
-EXPORT_SYMBOL(cimax_usb_dev_remove);
-
-static int cimax_usb_get_config_from_dts(struct cimax_usb *usb)
-{
-	struct device_node *child = NULL;
-	struct platform_device *pdev = usb->pdev;
-	struct device_node *np = pdev->dev.of_node;
-	pr_dbg("fetch cimax usb in dts\n");
-
-	child = of_get_child_by_name(np, "cimax");
-	if (child == NULL) {
-		pr_error("cimax not found in dts\n");
-		return -1;
-	}
-	child = of_get_child_by_name(child, "usb");
-	if (!child) {
-		pr_error("usb not found in cimax");
-		return -1;
-	}
-/*
-dvbci {
-	compatible = "amlogic, dvbci";
-	dev_name = "dvbci";
-	io_type = <2>;//0:iobus,1:usb,2:cimax
-	cimax {
-		io_type = <1> //0:spi 1:usb
-		usb {
-			rst_gpio = <&gpio_ao GPIOAO_2 GPIO_ACTIVE_HIGH>;
-		};
-	};
-
-};
-*/
-	{
-		int ret = 0;
-		int gpio = -1;
-		gpio = of_get_named_gpio_flags(child, "rst-gpios", 0, NULL);
-		if (gpio != -1) {
-			ret = gpio_request(gpio, "cimax");
-			if (ret < 0) {
-				pr_error("rst-gpios request fail.\n");
-				return ret;
-			}
-			usb->rst_io = gpio;
-			cimax_usb_hw_reset(usb, 1);
-			pr_dbg("rst: %d\n", usb->rst_io);
-		} else {
-			pr_error("rst io got fail, %d\n", gpio);
-		}
-	}
-	return 0;
-}
-
-int aml_cimax_usb_init(struct platform_device *pdev, struct aml_cimax *cimax)
-{
-	struct cimax_usb *cimax_usb;
-
-	cimax_usb = kzalloc(sizeof(struct cimax_usb), GFP_KERNEL);
-	if (!cimax_usb)
-		return -ENOMEM;
-
-	cimax_usb->pdev = pdev;
-	cimax_usb->cimax = cimax;
-	cimax_usb_get_config_from_dts(cimax_usb);
-
-	/*init usb_lock*/
-	lock_init(cimax_usb);
-
-	/*init cimax used api.*/
-#define WI(_f)\
-	cimax->ops._f = aml_cimax_usb_##_f
-	WI(read_cis);
-	WI(write_cor);
-	WI(negotiate);
-	WI(read_lpdu);
-	WI(write_lpdu);
-	WI(read_cam_status);
-	WI(cam_reset);
-	WI(slot_reset);
-	WI(slot_shutdown);
-	WI(slot_ts_enable);
-	WI(slot_status);
-	WI(read_reg);
-	WI(write_reg);
-
-	cimax->priv = cimax_usb;
-
-	g_usb = cimax_usb;
-
-	aml_cimax_usb_mod_init();
-
-	cimax_usb_set_cb(cimax_usb_dev_add, cimax_usb_dev_remove);
-
-	return 0;
-}
-EXPORT_SYMBOL(aml_cimax_usb_init);
-
-int aml_cimax_usb_exit(struct aml_cimax *cimax)
-{
-	struct cimax_usb *usb = cimax_to_usb(cimax);
-
-	if (!usb)
-		return -ENODEV;
-
-	aml_cimax_usb_mod_exit();
-
-	cimax_usb_device_close(usb->dev);
-	cimax_usb_setup_poll(usb, STOP_MODE);
-
-	if (usb->rst_io)
-		gpio_free(usb->rst_io);
-
-	kfree(usb->cis);
-
-	kfree(usb);
-	cimax->priv = NULL;
-
-	g_usb = NULL;
-	return 0;
-}
-EXPORT_SYMBOL(aml_cimax_usb_exit);
-
-static int cimax_usb_reset(struct cimax_usb *usb, int reset_val)
-{
-	pr_dbg("reset usb:%p, rst:%d\n", usb, usb ? usb->rst_io : -1);
-	if (!usb)
-		return -ENODEV;
-
-	pr_inf("cimax usb reset\n");
-
-	/*notify unplugged*/
-	aml_cimax_camchanged(usb->cimax, 0, 0);
-	aml_cimax_camchanged(usb->cimax, 1, 0);
-
-	if (usb->dev)
-		cimax_usb_device_close(usb->dev);
-
-	cimax_usb_setup_poll(usb, STOP_MODE);
-
-	usb->cam_inserted[0] = usb->cam_inserted[1] = 0;
-	usb->cam_data_ready[0] = usb->cam_data_ready[1] = 0;
-
-	cimax_usb_hw_reset(usb, reset_val);
-
-	pr_inf("cimax usb reset end\n");
-	return 0;
-}
-
-static ssize_t reset_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret;
-	ret = sprintf(buf, "echo 1 > %s\n", attr->attr.name);
-	return ret;
-}
-
-static ssize_t reset_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int ret;
-	int val = 0;
-	if (!g_usb)
-		return size;
-	ret = sscanf(buf, "%i", &val);
-	if (ret == 1)
-		ret = cimax_usb_reset(g_usb, val);
-	return size;
-}
-
-static ssize_t debug_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	if (!g_usb)
-		return ret;
-
-	ret = sprintf(buf, "poll mode: %d\n", g_usb->poll_mode);
-	ret += sprintf(buf+ret, "status slot[0]=[%d] slot[1]=[%d]\n",
-		g_usb->cam_inserted[0], g_usb->cam_inserted[1]);
-	{
-		int power = 0;
-		int err = cimax_usb_check_poe(g_usb, &power);
-		ret += sprintf(buf+ret, "power slot[0]=[%d] slot[1]=[%d]\n",
-			err ? -1 : power, 0);
-	}
-	ret += sprintf(buf+ret, "data slot[0]=[%d] slot[1]=[%d]\n",
-		g_usb->cam_data_ready[0], g_usb->cam_data_ready[1]);
-	ret += sprintf(buf+ret, "work cnt:%d\n", g_usb->work_cnt);
-	ret += sprintf(buf+ret, "pwr work cnt:%d\n", g_usb->power_work_cnt);
-	return ret;
-}
-
-static int reg_addr;
-static ssize_t addr_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	ret = sprintf(buf, "addr = 0x%04x\n", reg_addr);
-	return ret;
-}
-
-static ssize_t addr_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	if (!g_usb)
-		return size;
-	if (sscanf(buf, "%i", &reg_addr) != 1)
-		return size;
-	return size;
-}
-
-static ssize_t reg_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	u8 reg_val = 0;
-	struct aml_cimax *cimax = NULL;
-
-	if (!g_usb)
-		return ret;
-
-	cimax = g_usb->cimax;
-	ret = aml_cimax_usb_read_reg(cimax, reg_addr, &reg_val, 1);
-	if (ret)
-		ret = sprintf(buf, "read fail, err=%d\n", ret);
-	else
-		ret = sprintf(buf, "reg[0x%04x] = 0x%02x\n", reg_addr, reg_val);
-	return ret;
-}
-
-static ssize_t reg_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int ret = 0;
-	struct aml_cimax *cimax = NULL;
-	int val = 0;
-	u8 reg_val = 0;
-
-	if (!g_usb)
-		return size;
-
-	if (sscanf(buf, "%i", &val) != 1)
-		return size;
-	reg_val = val;
-	cimax = g_usb->cimax;
-	ret = aml_cimax_usb_write_reg(cimax, reg_addr, &reg_val, 1);
-	if (ret)
-		return ret;
-	return size;
-}
-
-static int cis_mode; /*0:hex 1:binary*/
-static ssize_t cis_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-
-	if (!g_usb || !g_usb->cis)
-		return ret;
-
-	if (cis_mode == 0) {
-		int i;
-		for (i = 0; i < CIS_MAX; i++) {
-			if (i && !(i & 0xf))
-				ret += sprintf(buf+ret, "\n");
-			ret += sprintf(buf+ret, "%02X ", g_usb->cis[i]);
-		}
-		ret += sprintf(buf+ret, "\n");
-		return ret;
-	} else {
-		memcpy(buf, g_usb->cis, CIS_MAX);
-		return CIS_MAX;
-	}
-	return ret;
-}
-
-static ssize_t cis_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	if (size >= 3
-		&& !memcmp(buf, "bin", 3))
-		cis_mode = 1;
-	else
-		cis_mode = 0;
-	return size;
-}
-
-static ssize_t ts_rate_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	u8 lsb = 0, msb = 0, plen = 0;
-	struct aml_cimax *cimax = NULL;
-	int err = 0;
-
-	if (!g_usb)
-		return ret;
-
-	cimax = g_usb->cimax;
-	err = aml_cimax_usb_read_reg(cimax, PCK_LENGTH, &plen, 1);
-	err |= aml_cimax_usb_read_reg(cimax, BITRATE_CH0_LSB, &lsb, 1);
-	err |= aml_cimax_usb_read_reg(cimax, BITRATE_CH0_MSB, &msb, 1);
-	if (err)
-		ret += sprintf(buf+ret, "read fail, err=%d\n", err);
-	else if (!byte_to_u16(msb, lsb))
-		ret += sprintf(buf+ret, "rate[0] = 0 Kbps\n");
-	else
-		ret += sprintf(buf+ret, "rate[0] = %d Kbps\n",
-			540*plen*8/byte_to_u16(msb, lsb));
-	if (err)
-		return ret;
-
-	err = aml_cimax_usb_read_reg(cimax, BITRATE_CH1_LSB, &lsb, 1);
-	err |= aml_cimax_usb_read_reg(cimax, BITRATE_CH1_MSB, &msb, 1);
-	if (err)
-		ret += sprintf(buf+ret, "read fail, err=%d\n", err);
-	else if (!byte_to_u16(msb, lsb))
-		ret += sprintf(buf+ret, "rate[1] = 0 Kbps\n");
-	else
-		ret += sprintf(buf+ret, "rate[1] = %d Kbps\n",
-			540*plen*8/byte_to_u16(msb, lsb));
-	return ret;
-}
-
-static ssize_t loop_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int ret = 0;
-	u8 ch = 0, mod = 0;
-	struct aml_cimax *cimax = NULL;
-	int err = 0;
-
-	if (!g_usb)
-		return ret;
-
-	cimax = g_usb->cimax;
-	err = aml_cimax_usb_read_reg(cimax, ROUTER_CAM_CH, &ch, 1);
-	err |= aml_cimax_usb_read_reg(cimax, ROUTER_CAM_MOD, &mod, 1);
-	if (err) {
-		ret = sprintf(buf, "read fail, err=%d\n", err);
-		return ret;
-	}
-	ret += sprintf(buf + ret, "OUT-0 <= ");
-	switch (ch & 0x0f) {
-	case 0x0:
-		ret += sprintf(buf + ret, "CAM-A"); break;
-	case 0x1:
-		ret += sprintf(buf + ret, "CH0-IN"); break;
-	case 0x2:
-		ret += sprintf(buf + ret, "CH1-IN"); break;
-	case 0x3:
-		ret += sprintf(buf + ret, "REMAPPER"); break;
-	case 0x4:
-		ret += sprintf(buf + ret, "PREHEADER"); break;
-	case 0x5:
-		ret += sprintf(buf + ret, "CAM-B"); break;
-	case 0x6:
-		ret += sprintf(buf + ret, "GAPREMOVER-0"); break;
-	case 0x7:
-		ret += sprintf(buf + ret, "GAPREMOVER-1"); break;
-	case 0x8:
-		ret += sprintf(buf + ret, "NONE"); break;
-	default:
-		ret += sprintf(buf + ret, "UNKNOWN"); break;
-	}
-	ret += sprintf(buf + ret, "\nCAM-A <= ");
-	switch (mod & 0x07) {
-	case 0x1:
-		ret += sprintf(buf + ret, "CH0-IN"); break;
-	case 0x2:
-		ret += sprintf(buf + ret, "CH1-IN"); break;
-	case 0x3:
-		ret += sprintf(buf + ret, "REMAPPER"); break;
-	case 0x4:
-		ret += sprintf(buf + ret, "PREHEADER"); break;
-	case 0x5:
-		ret += sprintf(buf + ret, "CAM-B"); break;
-	case 0x6:
-		ret += sprintf(buf + ret, "GAPREMOVER-0"); break;
-	case 0x7:
-		ret += sprintf(buf + ret, "GAPREMOVER-1"); break;
-	default:
-		ret += sprintf(buf + ret, "NONE"); break;
-	}
-	ret += sprintf(buf + ret, "\n");
-
-	return ret;
-}
-
-static ssize_t loop_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int loop = 0;
-
-	if (!g_usb)
-		return size;
-
-	if (sscanf(buf, "%i", &loop) == 1)
-		cimax_usb_set_loop(g_usb, loop);
-	return size;
-}
-
-static ssize_t slot_reset_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int err = 0;
-	int slot = 0;
-	struct aml_cimax *cimax = NULL;
-
-	if (!g_usb)
-		return size;
-
-	if (sscanf(buf, "%i", &slot) == 1) {
-		if (slot == 0 || slot == 1) {
-			pr_dbg("reset slot %d\n", slot);
-			cimax = g_usb->cimax;
-			err = aml_cimax_usb_slot_reset(cimax, slot);
-		}
-	}
-	return size;
-}
-
-static ssize_t detect_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t size)
-{
-	int err = 0;
-	int slot = 0;
-	struct aml_cimax *cimax = NULL;
-
-	if (!g_usb)
-		return size;
-
-	if (sscanf(buf, "%i", &slot) == 1) {
-		if (slot == 0 || slot == 1) {
-			int addr = (!slot) ? MOD_CTRL_A : MOD_CTRL_B;
-			u8 reg = 0;
-			cimax = g_usb->cimax;
-			err = aml_cimax_usb_read_reg(cimax, addr, &reg, 1);
-			cam_usb_cam_detect(g_usb, slot,
-				(reg & 1) ? IN_INSERTED : 0);
-			cimax_usb_cam_powerctrl(g_usb, slot, (reg & 1));
-		}
-	}
-	return size;
-}
-
-
-static struct class_attribute cimax_usb_class_attrs[] = {
-	__ATTR_RW(reset),
-	__ATTR_RO(debug),
-	__ATTR_RW(addr),
-	__ATTR_RW(reg),
-	__ATTR_RW(cis),
-	__ATTR_RO(ts_rate),
-	__ATTR_RW(loop),
-	__ATTR_WO(slot_reset),
-	__ATTR_WO(detect),
-	__ATTR_NULL
-};
-
-static struct class cimax_usb_class = {
-	.name = "cimax_usb",
-	.class_attrs = cimax_usb_class_attrs,
-};
-
-static int aml_cimax_usb_mod_init(void)
-{
-	int ret;
-	pr_dbg("Amlogic CIMAX USB Init\n");
-	ret = class_register(&cimax_usb_class);
-	return 0;
-}
-
-static void aml_cimax_usb_mod_exit(void)
-{
-	pr_dbg("Amlogic CIMAX USB Exit\n");
-	class_unregister(&cimax_usb_class);
-}
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_usb.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_usb.h
deleted file mode 100644
index 471d2da..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_usb.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/***************************************************************************
- * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
- *
- * This source code is subject to the terms and conditions defined in the
- * file 'LICENSE' which is part of this source code package.
- *
- * Description:
- *
-***************************************************************************/
-
-#ifndef _AML_CIMAX_USB_H_
-#define _AML_CIMAX_USB_H_
-
-#include <linux/platform_device.h>
-#include "aml_cimax.h"
-
-int aml_cimax_usb_init(struct platform_device *pdev, struct aml_cimax *ci);
-int aml_cimax_usb_exit(struct aml_cimax *ci);
-
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_usb_priv.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_usb_priv.h
deleted file mode 100644
index aec694c..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/aml_cimax_usb_priv.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/***************************************************************************
- * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
- *
- * This source code is subject to the terms and conditions defined in the
- * file 'LICENSE' which is part of this source code package.
- *
- * Description:
- *
-***************************************************************************/
-
-#ifndef _CIMAX_USB_DEV_H_
-#define _CIMAX_USB_DEV_H_
-
-#if 0
-__attribute__ ((weak))
-int cimax_usb_dev_add(struct device_s *device, int id);
-__attribute__ ((weak))
-int cimax_usb_dev_remove(struct device_s *device, int id);
-#endif
-
-#endif
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ca_en50221_cimax.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ca_en50221_cimax.c
deleted file mode 100644
index 0f09799..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ca_en50221_cimax.c
+++ /dev/null
@@ -1,1985 +0,0 @@
-/*
- * dvb_ca.c: generic DVB functions for EN50221 CAM CIMAX interfaces
- *
- * Parts of this file were based on sources as follows:
- *
- * based on code:
- *
- * Copyright (C) 1999-2002 Ralph  Metzler
- *                       & Marcus Metzler for convergence integrated media GmbH
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/vmalloc.h>
-#include <linux/delay.h>
-#include <linux/spinlock.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-
-#include "dvb_ca_en50221_cimax.h"
-#include "dvb_ringbuffer.h"
-
-#define READ_LPDU_PKT
-
-static int dvb_ca_en50221_debug = 1;
-
-module_param_named(cam_debug, dvb_ca_en50221_debug, int, 0644);
-MODULE_PARM_DESC(cam_debug, "enable verbose debug messages");
-
-#define HOST_LINK_BUF_SIZE 0x1000
-
-static int dvb_ca_en50221_link_size = HOST_LINK_BUF_SIZE;
-module_param_named(link_size, dvb_ca_en50221_link_size, int, 0644);
-MODULE_PARM_DESC(link_size, "debug only, no more than 0x1000");
-
-static int dvb_ca_en50221_buffer_free;
-module_param_named(buffer_free, dvb_ca_en50221_buffer_free, int, 0644);
-MODULE_PARM_DESC(buffer_free, "debug only");
-
-#define dprintk(args...)\
-	do {\
-		if (dvb_ca_en50221_debug)\
-			printk(args);\
-	} while (0)
-#define pr_error(fmt, args...) printk("CA EN50211: " fmt, ## args)
-
-#define INIT_TIMEOUT_SECS 40
-
-
-#define RX_BUFFER_SIZE 65535
-
-#define MAX_RX_PACKETS_PER_ITERATION 10
-
-#define CTRLIF_DATA      0
-#define CTRLIF_COMMAND   1
-#define CTRLIF_STATUS    1
-#define CTRLIF_SIZE_LOW  2
-#define CTRLIF_SIZE_HIGH 3
-
-#define CMDREG_HC        1	/* Host control */
-#define CMDREG_SW        2	/* Size write */
-#define CMDREG_SR        4	/* Size read */
-#define CMDREG_RS        8	/* Reset interface */
-#define CMDREG_FRIE   0x40	/* Enable FR interrupt */
-#define CMDREG_DAIE   0x80	/* Enable DA interrupt */
-#define IRQEN (CMDREG_DAIE)
-
-#define STATUSREG_RE     1	/* read error */
-#define STATUSREG_WE     2	/* write error */
-#define STATUSREG_FR  0x40	/* module free */
-#define STATUSREG_DA  0x80	/* data available */
-#define STATUSREG_TXERR (STATUSREG_RE|STATUSREG_WE)/* general transfer error */
-
-
-#define DVB_CA_SLOTSTATE_NONE           0
-#define DVB_CA_SLOTSTATE_UNINITIALISED  1
-#define DVB_CA_SLOTSTATE_RUNNING        2
-#define DVB_CA_SLOTSTATE_INVALID        3
-#define DVB_CA_SLOTSTATE_WAITREADY      4
-#define DVB_CA_SLOTSTATE_VALIDATE       5
-#define DVB_CA_SLOTSTATE_WAITFR         6
-#define DVB_CA_SLOTSTATE_LINKINIT       7
-#define DVB_CA_SLOTSTATE_WAITLINKINIT   8
-
-#define MAX_CIS_SIZE  512
-
-/* Information on a CA slot */
-struct dvb_ca_slot {
-
-	/* current state of the CAM */
-	int slot_state;
-
-	/* mutex used for serializing access to one CI slot */
-	struct mutex slot_lock;
-
-	/* Number of CAMCHANGES that have occurred since last processing */
-	atomic_t camchange_count;
-
-	/* Type of last CAMCHANGE */
-	int camchange_type;
-
-	/* base address of CAM config */
-	u32 config_base;
-
-	/* value to write into Config Control register */
-	u8 config_option;
-
-	/* if 1, the CAM supports DA IRQs */
-	u8 da_irq_supported:1;
-
-#ifdef READ_LPDU_PKT
-	/* Offset into current ringbuffer when user buffer was not big enough
-	   to return entire pkt */
-	int rx_offset;
-#endif
-
-	/* size of the buffer to use when talking to the CAM */
-	int link_buf_size;
-
-	/* buffer for incoming packets */
-	struct dvb_ringbuffer rx_buffer;
-
-	/* timer used during various states of the slot */
-	unsigned long timeout;
-};
-
-/* Private CA-interface information */
-struct dvb_ca_private {
-
-	/* pointer back to the public data structure */
-	struct dvb_ca_en50221_cimax *pub;
-
-	/* the DVB device */
-	struct dvb_device *dvbdev;
-
-	/* Flags describing the interface (DVB_CA_FLAG_*) */
-	u32 flags;
-
-	/* number of slots supported by this CA interface */
-	unsigned int slot_count;
-
-	/* information on each slot */
-	struct dvb_ca_slot *slot_info;
-
-	/* wait queues for read() and write() operations */
-	wait_queue_head_t wait_queue;
-
-	/* PID of the monitoring thread */
-	struct task_struct *thread;
-
-	/* Flag indicating if the CA device is open */
-	unsigned int open:1;
-
-	/* Flag indicating the thread should wake up now */
-	unsigned int wakeup:1;
-
-	/* Delay the main thread should use */
-	unsigned long delay;
-
-	/* Slot to start looking for data
-	to read from in the next user-space read operation */
-	int next_read_slot;
-
-	/* mutex serializing ioctls */
-	struct mutex ioctl_mutex;
-
-	/*two bufs for read/write*/
-	u8 *rbuf;
-	u8 *wbuf;
-};
-
-static void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca);
-static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca,
-		int slot, u8 *ebuf, int ecount);
-static int dvb_ca_en50221_write_data(struct dvb_ca_private *ca,
-		int slot, u8 *ebuf, int ecount);
-
-
-/**
- * Safely find needle in haystack.
- *
- * @param haystack Buffer to look in.
- * @param hlen Number of bytes in haystack.
- * @param needle Buffer to find.
- * @param nlen Number of bytes in needle.
- * @return Pointer into haystack needle was found at, or NULL if not found.
- */
-static char *findstr(char *haystack, int hlen, char *needle, int nlen)
-{
-	int i;
-
-	if (hlen < nlen)
-		return NULL;
-
-	for (i = 0; i <= hlen - nlen; i++) {
-		if (!strncmp(haystack + i, needle, nlen))
-			return haystack + i;
-	}
-
-	return NULL;
-}
-
-
-
-/* ************************************************************************** */
-/* EN50221 physical interface functions */
-
-
-/**
- * Check CAM status.
- */
-static int dvb_ca_en50221_check_camstatus(struct dvb_ca_private *ca, int slot)
-{
-	int slot_status;
-	int cam_present;
-	int cam_changed;
-
-	/* IRQ mode */
-	if (ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)
-		return atomic_read(&ca->slot_info[slot].camchange_count) != 0;
-
-	/* poll mode */
-	slot_status = ca->pub->poll_slot_status(ca->pub, slot, ca->open);
-
-	cam_present = (slot_status & DVB_CA_EN50221_POLL_CAM_PRESENT) ? 1 : 0;
-	cam_changed = (slot_status & DVB_CA_EN50221_POLL_CAM_CHANGED) ? 1 : 0;
-	if (!cam_changed) {
-		int cam_present_old =
-			(ca->slot_info[slot].slot_state
-				!= DVB_CA_SLOTSTATE_NONE);
-		cam_changed = (cam_present != cam_present_old);
-	}
-
-	if (cam_changed) {
-		if (!cam_present) {
-			ca->slot_info[slot].camchange_type =
-				DVB_CA_EN50221_CAMCHANGE_REMOVED;
-		} else {
-			ca->slot_info[slot].camchange_type =
-				DVB_CA_EN50221_CAMCHANGE_INSERTED;
-		}
-		atomic_set(&ca->slot_info[slot].camchange_count, 1);
-	} else {
-		if ((ca->slot_info[slot].slot_state
-			== DVB_CA_SLOTSTATE_WAITREADY) &&
-				(slot_status & DVB_CA_EN50221_POLL_CAM_READY)) {
-			/* move to validate state if reset is completed */
-			ca->slot_info[slot].slot_state =
-				DVB_CA_SLOTSTATE_VALIDATE;
-		}
-	}
-	return cam_changed;
-}
-
-
-/**
- * Initialise the link layer connection to a CAM.
- *
- * @param ca CA instance.
- * @param slot Slot id.
- *
- * @return 0 on success, nonzero on failure.
- */
-static int dvb_ca_en50221_link_init(struct dvb_ca_private *ca, int slot)
-{
-	int ret;
-	dprintk("%s\n", __func__);
-
-	/* we'll be determining these during this function */
-	ca->slot_info[slot].da_irq_supported = 0;
-#ifdef READ_LPDU_PKT
-	ca->slot_info[slot].rx_offset = 0;
-#endif
-	/* set the host link buffer size temporarily.
-	   it will be overwritten with the real negotiated size later. */
-	ca->slot_info[slot].link_buf_size = dvb_ca_en50221_link_size;
-	dprintk("negotiate: host(%i)\n", ca->slot_info[slot].link_buf_size);
-
-	ret = ca->pub->negotiate(ca->pub,
-		slot, ca->slot_info[slot].link_buf_size);
-	if (ret <= 0)
-		return ret;
-
-	ca->slot_info[slot].link_buf_size = ret;
-	dprintk("Chosen link buffer size of %i\n", ret);
-
-	/* success */
-	return 0;
-}
-
-/**
- * Read a tuple from attribute memory.
- *
- * @param ca CA instance.
- * @param slot Slot id.
- * @param cis CIS data
- * @param address Address to read from. Updated.
- * @param tupleType Tuple id byte. Updated.
- * @param tupleLength Tuple length. Updated.
- * @param tuple Dest buffer for tuple (must be 256 bytes). Updated.
- *
- * @return 0 on success, nonzero on error.
- */
-static int dvb_ca_en50221_read_tuple(struct dvb_ca_private *ca,
-		int slot, u8 *cis,
-		int *address, int *tupleType, int *tupleLength, u8 *tuple)
-{
-	int i;
-	int _tupleType;
-	int _tupleLength;
-	int _address = *address;
-
-	/* grab the next tuple length and type */
-	_tupleType = cis[_address];
-	if (_tupleType < 0)
-		return _tupleType;
-	if (_tupleType == 0xff) {
-		dprintk("END OF CHAIN TUPLE type:0x%x\n", _tupleType);
-		*address += 1;
-		*tupleType = _tupleType;
-		*tupleLength = 0;
-		return 0;
-	}
-	_tupleLength = cis[_address + 1];
-	if (_tupleLength < 0)
-		return _tupleLength;
-	_address += 2;
-
-	dprintk("TUPLE type:0x%x length:%i\n", _tupleType, _tupleLength);
-
-	/* read in the whole tuple */
-	for (i = 0; i < _tupleLength; i++) {
-		tuple[i] = cis[_address + (i)];
-		dprintk("  0x%02x: 0x%02x %c\n",
-			i, tuple[i] & 0xff,
-			((tuple[i] > 31) && (tuple[i] < 127)) ? tuple[i] : '.');
-	}
-	_address += (_tupleLength);
-
-	/* success */
-	*tupleType = _tupleType;
-	*tupleLength = _tupleLength;
-	*address = _address;
-	return 0;
-}
-
-
-/**
- * Parse attribute memory of a CAM module, extracting Config register,
- * and checking it is a DVB CAM module.
- *
- * @param ca CA instance.
- * @param slot Slot id.
- *
- * @return 0 on success, <0 on failure.
- */
-static int dvb_ca_en50221_parse_attributes(struct dvb_ca_private *ca, int slot)
-{
-	int address = 0;
-	int tupleLength;
-	int tupleType;
-	u8 tuple[257];
-	char *dvb_str;
-	int rasz;
-	int status;
-	int got_cftableentry = 0;
-	int end_chain = 0;
-	int i;
-	u16 manfid = 0;
-	u16 devid = 0;
-	u8 cis[MAX_CIS_SIZE];
-
-	status = ca->pub->read_cis(ca->pub, slot, cis, MAX_CIS_SIZE);
-	if (status != 0)
-		return -EINVAL;
-
-	/* CISTPL_DEVICE_0A */
-	status =
-	     dvb_ca_en50221_read_tuple(ca, slot, cis, &address,
-		&tupleType, &tupleLength, tuple);
-	if (status < 0) {
-			pr_error("read status error\r\n");
-			return status;
-		}
-	if (tupleType != 0x1D) {
-		pr_error("read tupleType error [0x%x]\r\n", tupleType);
-		return -EINVAL;
-	}
-
-
-
-	/* CISTPL_DEVICE_0C */
-	status = dvb_ca_en50221_read_tuple(ca, slot, cis, &address,
-			&tupleType, &tupleLength, tuple);
-
-	if (status < 0) {
-		pr_error("read read cis error\r\n");
-		return -EINVAL;
-	}
-	if (tupleType != 0x1C) {
-		pr_error("read read cis type error\r\n");
-		return -EINVAL;
-	}
-
-
-
-	/* CISTPL_VERS_1 */
-	status =
-	     dvb_ca_en50221_read_tuple(ca, slot, cis,
-		&address, &tupleType, &tupleLength, tuple);
-	if (status < 0) {
-		pr_error("read read cis  version error\r\n");
-		return status;
-	}
-	if (tupleType != 0x15) {
-		pr_error("read read cis version type error\r\n");
-		return -EINVAL;
-	}
-
-
-
-	/* CISTPL_MANFID */
-	status = dvb_ca_en50221_read_tuple(ca, slot, cis, &address, &tupleType,
-						&tupleLength, tuple);
-	if (status < 0) {
-		pr_error("read read cis manfid error\r\n");
-		return status;
-	}
-	if (tupleType != 0x20) {
-		pr_error("read read cis manfid type error\r\n");
-		return -EINVAL;
-	}
-	if (tupleLength != 4) {
-		pr_error("read read cis manfid len error\r\n");
-		return -EINVAL;
-	}
-	manfid = (tuple[1] << 8) | tuple[0];
-	devid = (tuple[3] << 8) | tuple[2];
-
-
-
-	/* CISTPL_CONFIG */
-	status = dvb_ca_en50221_read_tuple(ca, slot, cis, &address, &tupleType,
-						&tupleLength, tuple);
-	if (status < 0) {
-		pr_error("read read cis config error\r\n");
-		return status;
-	}
-	if (tupleType != 0x1A) {
-		pr_error("read read cis config type error\r\n");
-		return -EINVAL;
-	}
-	if (tupleLength < 3) {
-		pr_error("read read cis config len error\r\n");
-		return -EINVAL;
-	}
-
-	/* extract the configbase */
-	rasz = tuple[0] & 3;
-	if (tupleLength < (3 + rasz + 14)) {
-		pr_error("read extract the configbase  error\r\n");
-		return -EINVAL;
-	}
-	ca->slot_info[slot].config_base = 0;
-	for (i = 0; i < rasz + 1; i++)
-		ca->slot_info[slot].config_base |= (tuple[2 + i] << (8 * i));
-
-	/* check it contains the correct DVB string */
-	dvb_str = findstr((char *)tuple, tupleLength, "DVB_CI_V", 8);
-	if (dvb_str == NULL) {
-		pr_error("find dvb str DVB_CI_V  error\r\n");
-		return -EINVAL;
-	}
-	if (tupleLength < ((dvb_str - (char *) tuple) + 12)) {
-		pr_error("find dvb str DVB_CI_V len error\r\n");
-	    return -EINVAL;
-	}
-
-	/* is it a version we support? */
-	if (strncmp(dvb_str + 8, "1.00", 4)) {
-		pr_info("dvb_ca adapter %d: ", ca->dvbdev->adapter->num);
-		pr_info("Unsupported DVB CAM module version %c%c%c%c\n",
-			dvb_str[8], dvb_str[9], dvb_str[10], dvb_str[11]);
-		return -EINVAL;
-	}
-
-	/* process the CFTABLE_ENTRY tuples, and any after those */
-	while ((!end_chain) && (address < 0x1000)) {
-		status = dvb_ca_en50221_read_tuple(ca, slot, cis, &address,
-		&tupleType, &tupleLength, tuple);
-		if (status < 0) {
-				pr_error("process tuples error\r\n");
-			   return status;
-			}
-
-		switch (tupleType) {
-		case 0x1B:	/* CISTPL_CFTABLE_ENTRY */
-			if (tupleLength < (2 + 11 + 17))
-				break;
-
-			/* if we've already parsed one, just use it */
-			if (got_cftableentry)
-				break;
-
-			/* get the config option */
-			ca->slot_info[slot].config_option = tuple[0] & 0x3f;
-
-			/* OK, check it contains the correct strings */
-			if ((findstr((char *)tuple, tupleLength, "DVB_HOST", 8)
-				== NULL)
-				|| (findstr((char *)tuple,
-					tupleLength, "DVB_CI_MODULE", 13)
-					== NULL)) {
-				break;
-			}
-			got_cftableentry = 1;
-			break;
-
-		case 0x14:	/* CISTPL_NO_LINK */
-			break;
-
-		case 0xFF:	/* CISTPL_END */
-			end_chain = 1;
-			break;
-
-		default:	/* Unknown tuple type
-			-just skip this tuple and move to the next one */
-			dprintk("dvb_ca: Skipping unknown tuple type:0x%x",
-				tupleType);
-			dprintk(" length:0x%x\n", tupleLength);
-			break;
-		}
-	}
-
-	if ((address > 0x1000) || (!got_cftableentry)) {
-		pr_error("got_cftableentry :%d\r\n", got_cftableentry);
-		return -EINVAL;
-	}
-
-	dprintk("Valid DVB CAM detected MANID:%x DEVID:%x", manfid, devid);
-	dprintk(" CONFIGBASE:0x%x CONFIGOPTION:0x%x\n",
-		ca->slot_info[slot].config_base,
-		ca->slot_info[slot].config_option);
-
-	/* success! */
-	return 0;
-}
-
-
-/**
- * Set CAM's configoption correctly.
- *
- * @param ca CA instance.
- * @param slot Slot containing the CAM.
- */
-static int dvb_ca_en50221_set_configoption(struct dvb_ca_private *ca, int slot)
-{
-	int configoption;
-
-	dprintk("%s\n", __func__);
-
-	/* set the config option */
-	ca->pub->write_cor(ca->pub, slot,
-				     ca->slot_info[slot].config_base,
-				     &ca->slot_info[slot].config_option);
-
-	configoption = ca->slot_info[slot].config_option;
-	dprintk("Set configoption 0x%x, base 0x%x\n",
-		ca->slot_info[slot].config_option,
-		ca->slot_info[slot].config_base);
-
-	/* fine! */
-	return 0;
-
-}
-
-
-/**
- * This function talks to an EN50221 CAM control interface. It reads a buffer of
- * data from the CAM. The data can either be stored in a supplied buffer, or
- * automatically be added to the slot's rx_buffer.
- *
- * @param ca CA instance.
- * @param slot Slot to read from.
- * @param ebuf If non-NULL, the data will be written to this buffer. If NULL,
- * the data will be added into the buffering system as a normal fragment.
- * @param ecount Size of ebuf. Ignored if ebuf is NULL.
- *
- * @return Number of bytes read, or < 0 on error
- */
-static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca,
-		int slot, u8 *ebuf, int ecount)
-{
-	int bytes_read;
-	int status;
-	u8 *buf = ca->rbuf;
-
-	/* dprintk("%s\n", __func__); */
-
-	/* check if we have space for a link buf in the rx_buffer */
-	if (ebuf == NULL) {
-		int buf_free;
-
-		if (ca->slot_info[slot].rx_buffer.data == NULL) {
-			status = -EIO;
-			goto exit;
-		}
-		buf_free = dvb_ringbuffer_free(&ca->slot_info[slot].rx_buffer);
-		dvb_ca_en50221_buffer_free = buf_free;
-
-		if (buf_free < (ca->slot_info[slot].link_buf_size
-				+ DVB_RINGBUFFER_PKTHDRSIZE)) {
-			status = -EAGAIN;
-			goto exit;
-		}
-	}
-
-	/* check if there is data available */
-	status = ca->pub->read_cam_status(ca->pub, slot);
-	if (status < 0)
-		goto exit;
-	if (!(status & STATUSREG_DA)) {
-		/* no data */
-		status = 0;
-		goto exit;
-	}
-
-	/* read the amount of data */
-	status = ca->pub->read_lpdu(ca->pub,
-			slot, buf, dvb_ca_en50221_link_size);
-	if (status < 0) {
-		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
-		status = -EIO;
-		goto exit;
-	}
-
-	bytes_read = status;
-
-	/* check it will fit */
-	if (ebuf == NULL) {
-		if (bytes_read > ca->slot_info[slot].link_buf_size) {
-			pr_error("dvb_ca adapter %d:",
-				ca->dvbdev->adapter->num);
-			pr_error(" CAM tried to send a buffer larger ");
-			pr_error("than the link buffer size(%i > %i)!\n",
-			       bytes_read, ca->slot_info[slot].link_buf_size);
-			ca->slot_info[slot].slot_state =
-				DVB_CA_SLOTSTATE_LINKINIT;
-			status = -EIO;
-			goto exit;
-		}
-		if (bytes_read < 2) {
-			pr_error("dvb_ca adapter %d: ",
-					ca->dvbdev->adapter->num);
-			pr_error("CAM sent a buffer");
-			pr_error("that was less than 2B!\n");
-			ca->slot_info[slot].slot_state =
-				DVB_CA_SLOTSTATE_LINKINIT;
-			status = -EIO;
-			goto exit;
-		}
-	} else {
-		if (bytes_read > ecount) {
-			pr_error("dvb_ca adapter %d:",
-				ca->dvbdev->adapter->num);
-			pr_error(" CAM tried to send a buffer larger");
-			pr_error(" than the ecount size!\n");
-			status = -EIO;
-			goto exit;
-		}
-	}
-
-	/* OK, add it to the receive buffer,
-	   or copy into external buffer if supplied */
-	if (ebuf == NULL) {
-		if (ca->slot_info[slot].rx_buffer.data == NULL) {
-			status = -EIO;
-			goto exit;
-		}
-		dvb_ringbuffer_pkt_write(&ca->slot_info[slot].rx_buffer,
-			buf, bytes_read);
-	} else {
-		memcpy(ebuf, buf, bytes_read);
-	}
-
-#ifndef READ_LPDU_PKT
-	/* wake up readers when a last_fragment is received */
-	if ((buf[1] & 0x80) == 0x00)
-#endif
-		wake_up_interruptible(&ca->wait_queue);
-	status = bytes_read;
-
-exit:
-	return status;
-}
-
-
-/**
- * This function talks to an EN50221 CAM control interface.
- * It writes a buffer of data
- * to a CAM.
- *
- * @param ca CA instance.
- * @param slot Slot to write to.
- * @param ebuf The data in this buffer
- * is treated as a complete link-level packet to be written.
- * @param count Size of ebuf.
- *
- * @return Number of bytes written, or < 0 on error.
- */
-static int dvb_ca_en50221_write_data(struct dvb_ca_private *ca,
-		int slot, u8 *buf, int bytes_write)
-{
-	int status;
-
-	/* dprintk("%s\n", __func__); */
-
-	/* sanity check */
-	if (bytes_write > ca->slot_info[slot].link_buf_size)
-		return -EINVAL;
-
-	/* it is possible we are dealing with a single buffer implementation,
-	   thus if there is data available for read or if there is even a read
-	   already in progress, we do nothing but awake the kernel thread to
-	   process the data if necessary. */
-	status = ca->pub->read_cam_status(ca->pub, slot);
-	if (status < 0)
-		return status;
-	if (status & (STATUSREG_DA | STATUSREG_RE)) {
-		if (status & STATUSREG_DA)
-			dvb_ca_en50221_thread_wakeup(ca);
-		status = -EAGAIN;
-		return status;
-	}
-
-	if (!(status & STATUSREG_FR)) {
-		status = -EAGAIN;
-		return status;
-	}
-
-	status = ca->pub->write_lpdu(ca->pub, slot, buf, bytes_write);
-	if (status < 0) {
-		if (status == -EBUSY) {
-			status = -EAGAIN;
-			return status;
-		} else {
-			ca->slot_info[slot].slot_state =
-				DVB_CA_SLOTSTATE_LINKINIT;
-			status = -EIO;
-			return status;
-		}
-	}
-
-	status = bytes_write;
-
-	return status;
-}
-EXPORT_SYMBOL(dvb_ca_en50221_cimax_camchange_irq);
-
-
-
-/* ************************************************************************** */
-/* EN50221 higher level functions */
-
-
-/**
- * A CAM has been removed => shut it down.
- *
- * @param ca CA instance.
- * @param slot Slot to shut down.
- */
-static int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private *ca, int slot)
-{
-	dprintk("%s\n", __func__);
-
-	ca->pub->slot_shutdown(ca->pub, slot);
-	ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
-
-	/* need to wake up all processes to check if they're now
-	   trying to write to a defunct CAM */
-	wake_up_interruptible(&ca->wait_queue);
-
-	dprintk("Slot %i shutdown\n", slot);
-
-	/* success */
-	return 0;
-}
-EXPORT_SYMBOL(dvb_ca_en50221_cimax_camready_irq);
-
-
-/**
- * A CAMCHANGE IRQ has occurred.
- *
- * @param ca CA instance.
- * @param slot Slot concerned.
- * @param change_type One of the DVB_CA_CAMCHANGE_* values.
- */
-void dvb_ca_en50221_cimax_camchange_irq(struct dvb_ca_en50221_cimax *pubca,
-		int slot, int change_type)
-{
-	struct dvb_ca_private *ca = pubca->private;
-
-	dprintk("CAMCHANGE IRQ slot:%i change_type:%i\n", slot, change_type);
-
-	switch (change_type) {
-	case DVB_CA_EN50221_CAMCHANGE_REMOVED:
-	case DVB_CA_EN50221_CAMCHANGE_INSERTED:
-		break;
-
-	default:
-		return;
-	}
-
-	ca->slot_info[slot].camchange_type = change_type;
-	atomic_inc(&ca->slot_info[slot].camchange_count);
-	dvb_ca_en50221_thread_wakeup(ca);
-}
-EXPORT_SYMBOL(dvb_ca_en50221_cimax_frda_irq);
-
-
-/**
- * A CAMREADY IRQ has occurred.
- *
- * @param ca CA instance.
- * @param slot Slot concerned.
- */
-void dvb_ca_en50221_cimax_camready_irq(struct dvb_ca_en50221_cimax *pubca,
-		int slot)
-{
-	struct dvb_ca_private *ca = pubca->private;
-
-	dprintk("CAMREADY IRQ slot:%i\n", slot);
-
-	if (ca->slot_info[slot].slot_state == DVB_CA_SLOTSTATE_WAITREADY) {
-		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_VALIDATE;
-		dvb_ca_en50221_thread_wakeup(ca);
-	}
-}
-
-
-/**
- * An FR or DA IRQ has occurred.
- *
- * @param ca CA instance.
- * @param slot Slot concerned.
- */
-void dvb_ca_en50221_cimax_frda_irq(struct dvb_ca_en50221_cimax *pubca,
-		int slot)
-{
-	struct dvb_ca_private *ca = pubca->private;
-	int flags;
-
-	dprintk("FR/DA IRQ slot:%i\n", slot);
-
-	switch (ca->slot_info[slot].slot_state) {
-	case DVB_CA_SLOTSTATE_LINKINIT:
-		flags = ca->pub->get_capbility(pubca, slot);
-		if (flags & DVB_CA_EN50221_CAP_IRQ) {
-			dprintk("CAM supports DA IRQ\n");
-			ca->slot_info[slot].da_irq_supported = 1;
-		}
-		break;
-
-	case DVB_CA_SLOTSTATE_RUNNING:
-		if (ca->open)
-			dvb_ca_en50221_thread_wakeup(ca);
-		break;
-	}
-}
-
-
-
-/* ************************************************************************** */
-/* EN50221 thread functions */
-
-/**
- * Wake up the DVB CA thread
- *
- * @param ca CA instance.
- */
-static void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca)
-{
-
-	dprintk("%s\n", __func__);
-
-	ca->wakeup = 1;
-	mb(); /*original*/
-	wake_up_process(ca->thread);
-}
-
-/**
- * Update the delay used by the thread.
- *
- * @param ca CA instance.
- */
-static void dvb_ca_en50221_thread_update_delay(struct dvb_ca_private *ca)
-{
-	int delay;
-	int curdelay = 100000000;
-	int slot;
-
-	/* Beware of too high polling frequency, because one polling
-	 * call might take several hundred milliseconds until timeout!
-	 */
-	for (slot = 0; slot < ca->slot_count; slot++) {
-		switch (ca->slot_info[slot].slot_state) {
-		default:
-		case DVB_CA_SLOTSTATE_NONE:
-			delay = HZ * 60;  /* 60s */
-			if (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
-				delay = HZ * 5;  /* 5s */
-			break;
-		case DVB_CA_SLOTSTATE_INVALID:
-			delay = HZ * 60;  /* 60s */
-			if (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
-				delay = HZ / 10;  /* 100ms */
-			break;
-
-		case DVB_CA_SLOTSTATE_UNINITIALISED:
-		case DVB_CA_SLOTSTATE_WAITREADY:
-		case DVB_CA_SLOTSTATE_VALIDATE:
-		case DVB_CA_SLOTSTATE_WAITFR:
-		case DVB_CA_SLOTSTATE_LINKINIT:
-			delay = HZ / 10;  /* 100ms */
-			break;
-		case DVB_CA_SLOTSTATE_WAITLINKINIT:
-			delay = HZ * 2;
-			break;
-
-		case DVB_CA_SLOTSTATE_RUNNING:
-			delay = HZ * 60;  /* 60s */
-			if (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
-				delay = HZ / 10;  /* 100ms */
-			if (ca->open) {
-				if ((!ca->slot_info[slot].da_irq_supported) ||
-				    (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_DA)))
-					delay = HZ / 10;  /* 100ms */
-			}
-			break;
-		}
-
-		if (delay < curdelay)
-			curdelay = delay;
-	}
-
-	ca->delay = curdelay;
-}
-
-static int dvb_ca_en50221_slot_process(struct dvb_ca_private *ca, int slot)
-{
-	int flags;
-	int status;
-	int pktcount;
-	void *rxbuf;
-
-	mutex_lock(&ca->slot_info[slot].slot_lock);
-
-	/*check the cam status + deal with CAMCHANGEs*/
-	while (dvb_ca_en50221_check_camstatus(ca, slot)) {
-		/* clear down an old CI slot if necessary */
-		if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE)
-			dvb_ca_en50221_slot_shutdown(ca, slot);
-
-		/* if a CAM is NOW present, initialise it */
-		if (ca->slot_info[slot].camchange_type
-				== DVB_CA_EN50221_CAMCHANGE_INSERTED)
-			ca->slot_info[slot].slot_state =
-				DVB_CA_SLOTSTATE_UNINITIALISED;
-
-		/* we've handled one CAMCHANGE */
-		dvb_ca_en50221_thread_update_delay(ca);
-		atomic_dec(&ca->slot_info[slot].camchange_count);
-	}
-
-	/* CAM state machine */
-	switch (ca->slot_info[slot].slot_state) {
-	case DVB_CA_SLOTSTATE_NONE:
-	case DVB_CA_SLOTSTATE_INVALID:
-		/* no action needed */
-		break;
-
-	case DVB_CA_SLOTSTATE_UNINITIALISED:
-		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITREADY;
-		ca->pub->slot_reset(ca->pub, slot);
-		ca->slot_info[slot].timeout = jiffies
-			+ (INIT_TIMEOUT_SECS * HZ);
-		break;
-
-	case DVB_CA_SLOTSTATE_WAITREADY:
-		if (time_after(jiffies, ca->slot_info[slot].timeout)) {
-			dprintk("%d: PC card did not respond\n",
-				ca->dvbdev->adapter->num);
-			ca->slot_info[slot].slot_state =
-				DVB_CA_SLOTSTATE_INVALID;
-			dvb_ca_en50221_thread_update_delay(ca);
-			break;
-		}
-		/* no other action needed; will automatically
-		 * change state when ready
-		 */
-		break;
-
-	case DVB_CA_SLOTSTATE_VALIDATE:
-		if (dvb_ca_en50221_parse_attributes(ca, slot) != 0) {
-			/* we need this extra check
-			   for annoying interfaces like the budget-av */
-			if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
-					&& (ca->pub->poll_slot_status)) {
-				status = ca->pub->poll_slot_status(ca->pub,
-						slot, 0);
-				if (!(status
-					& DVB_CA_EN50221_POLL_CAM_PRESENT)) {
-					ca->slot_info[slot].slot_state =
-						DVB_CA_SLOTSTATE_NONE;
-					dvb_ca_en50221_thread_update_delay(ca);
-					break;
-				}
-			}
-			dprintk(" %d: Invalid PC card inserted :(\n",
-			       ca->dvbdev->adapter->num);
-			ca->slot_info[slot].slot_state =
-					DVB_CA_SLOTSTATE_INVALID;
-			dvb_ca_en50221_thread_update_delay(ca);
-			break;
-		}
-		if (dvb_ca_en50221_set_configoption(ca, slot) != 0) {
-			dprintk("%d: Unable initialise CAM:(\n",
-			       ca->dvbdev->adapter->num);
-			ca->slot_info[slot].slot_state =
-					DVB_CA_SLOTSTATE_INVALID;
-			dvb_ca_en50221_thread_update_delay(ca);
-			break;
-		}
-
-		if (ca->pub->cam_reset(ca->pub, slot) != 0) {
-			dprintk("%d: Unable to reset CAM IF\n",
-			       ca->dvbdev->adapter->num);
-			ca->slot_info[slot].slot_state =
-					DVB_CA_SLOTSTATE_INVALID;
-			dvb_ca_en50221_thread_update_delay(ca);
-			break;
-		}
-
-		dprintk("DVB CAM validated successfully\n");
-
-		ca->slot_info[slot].timeout =
-				jiffies + (INIT_TIMEOUT_SECS * HZ);
-		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITFR;
-		ca->wakeup = 1;
-		break;
-
-	case DVB_CA_SLOTSTATE_WAITFR:
-		if (time_after(jiffies, ca->slot_info[slot].timeout)) {
-			pr_error("dvb_ca adapter %d: ",
-				ca->dvbdev->adapter->num);
-			pr_error("DVB CAM did not respond :(\n");
-			ca->slot_info[slot].slot_state =
-					DVB_CA_SLOTSTATE_INVALID;
-			dvb_ca_en50221_thread_update_delay(ca);
-			break;
-		}
-
-		/*flags = ca->pub->read_cam_status(ca->pub, slot);*/
-		flags = STATUSREG_FR;
-		if (flags & STATUSREG_FR) {
-			ca->slot_info[slot].slot_state =
-					DVB_CA_SLOTSTATE_LINKINIT;
-			ca->wakeup = 1;
-		}
-		break;
-
-	case DVB_CA_SLOTSTATE_WAITLINKINIT:
-		if (time_after(jiffies, ca->slot_info[slot].timeout)) {
-			pr_error("dvb_ca adapter %d: ",
-					ca->dvbdev->adapter->num);
-			pr_error("DVB CAM link initialisation failed :(\n");
-			ca->slot_info[slot].slot_state =
-					DVB_CA_SLOTSTATE_INVALID;
-			dvb_ca_en50221_thread_update_delay(ca);
-			break;
-		}
-
-	case DVB_CA_SLOTSTATE_LINKINIT:
-		if (dvb_ca_en50221_link_init(ca, slot) != 0) {
-			/* we need this extra check for annoying interfaces
-			   like the budget-av */
-			if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))
-				&& (ca->pub->poll_slot_status)) {
-				status = ca->pub->poll_slot_status(ca->pub,
-						slot, 0);
-				if (!(status
-					& DVB_CA_EN50221_POLL_CAM_PRESENT)) {
-					ca->slot_info[slot].slot_state =
-							DVB_CA_SLOTSTATE_NONE;
-					dvb_ca_en50221_thread_update_delay(ca);
-					break;
-				}
-			}
-
-			ca->slot_info[slot].timeout =
-					jiffies + (INIT_TIMEOUT_SECS * HZ);
-			ca->slot_info[slot].slot_state =
-					DVB_CA_SLOTSTATE_WAITLINKINIT;
-			ca->wakeup = 1;
-			break;
-		}
-
-		if (ca->slot_info[slot].rx_buffer.data == NULL) {
-			rxbuf = vmalloc(RX_BUFFER_SIZE);
-			if (rxbuf == NULL) {
-				pr_error("dvb_ca adapter %d: ",
-						ca->dvbdev->adapter->num);
-				pr_error("Unable to allocate CAM rx buffer\n");
-				ca->slot_info[slot].slot_state =
-						DVB_CA_SLOTSTATE_INVALID;
-				dvb_ca_en50221_thread_update_delay(ca);
-				break;
-			}
-			dvb_ringbuffer_init(&ca->slot_info[slot].rx_buffer,
-					rxbuf, RX_BUFFER_SIZE);
-		}
-
-		ca->pub->slot_ts_enable(ca->pub, slot);
-		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;
-		dvb_ca_en50221_thread_update_delay(ca);
-		dprintk("%d: DVB CAM Initialised successfully\n",
-		ca->dvbdev->adapter->num);
-		break;
-
-	case DVB_CA_SLOTSTATE_RUNNING:
-		if (!ca->open)
-			break;
-
-		pktcount = 0;
-		while ((status = dvb_ca_en50221_read_data(ca, slot, NULL, 0))
-			> 0) {
-			if (!ca->open)
-				break;
-
-			/* if a CAMCHANGE occurred at some point,
-			   do not do any more processing of this slot */
-			if (dvb_ca_en50221_check_camstatus(ca, slot)) {
-				/* we dont want to sleep on the next iteration
-				   so we can handle the cam change*/
-				ca->wakeup = 1;
-				break;
-			}
-
-			/* check if we've hit our limit this time */
-			if (++pktcount >= MAX_RX_PACKETS_PER_ITERATION) {
-				/*dont sleep;
-				  there is likely to be more data to read*/
-				ca->wakeup = 1;
-				break;
-			}
-		}
-		break;
-	}
-
-	mutex_unlock(&ca->slot_info[slot].slot_lock);
-	return 0;
-}
-
-
-/**
- * Kernel thread which monitors CA slots for CAM changes,
- * and performs data transfers.
- */
-static int dvb_ca_en50221_thread(void *data)
-{
-	struct dvb_ca_private *ca = data;
-	int slot;
-
-	dprintk(" %s\n", __func__);
-	/* choose the correct initial delay */
-	dvb_ca_en50221_thread_update_delay(ca);
-
-	/* main loop */
-	while (!kthread_should_stop()) {
-		/* sleep for a bit */
-		if (!ca->wakeup) {
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(ca->delay);
-			if (kthread_should_stop())
-				return 0;
-		}
-		ca->wakeup = 0;
-
-		/* go through all the slots processing them */
-		for (slot = 0; slot < ca->slot_count; slot++)
-			dvb_ca_en50221_slot_process(ca, slot);
-	}
-
-	return 0;
-}
-
-
-
-/* ************************************************************************** */
-/* EN50221 IO interface functions */
-
-/**
- * Real ioctl implementation.
- * NOTE: CA_SEND_MSG/CA_GET_MSG ioctls have userspace buffers passed to them.
- *
- * @param inode Inode concerned.
- * @param file File concerned.
- * @param cmd IOCTL command.
- * @param arg Associated argument.
- *
- * @return 0 on success, <0 on error.
- */
-static int dvb_ca_en50221_io_do_ioctl(struct file *file,
-				      unsigned int cmd, void *parg)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct dvb_ca_private *ca = dvbdev->priv;
-	int err = 0;
-	int slot;
-
-	if (mutex_lock_interruptible(&ca->ioctl_mutex)) {
-		pr_error("ci lock interrupt error\r\n");
-		return -ERESTARTSYS;
-	}
-
-	switch (cmd) {
-	case CA_RESET:
-		dprintk("ci reset---\r\n");
-		for (slot = 0; slot < ca->slot_count; slot++) {
-			mutex_lock(&ca->slot_info[slot].slot_lock);
-			if (ca->slot_info[slot].slot_state
-				== DVB_CA_SLOTSTATE_NONE)
-				goto next;
-			dvb_ca_en50221_slot_shutdown(ca, slot);
-			if (ca->flags
-				& DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)
-				dvb_ca_en50221_cimax_camchange_irq(
-					ca->pub,
-					slot,
-					DVB_CA_EN50221_CAMCHANGE_INSERTED);
-next:
-			mutex_unlock(&ca->slot_info[slot].slot_lock);
-		}
-		ca->next_read_slot = 0;
-		dvb_ca_en50221_thread_wakeup(ca);
-		break;
-
-	case CA_GET_CAP: {
-		struct ca_caps *caps = parg;
-
-		caps->slot_num = ca->slot_count;
-		caps->slot_type = CA_CI_LINK;
-		caps->descr_num = 0;
-		caps->descr_type = 0;
-		break;
-	}
-
-	case CA_GET_SLOT_INFO: {
-		struct ca_slot_info *info = parg;
-
-		if ((info->num > ca->slot_count) || (info->num < 0)) {
-			err = -EINVAL;
-			pr_error("info num error :%d\r\n", info->num);
-			goto out_unlock;
-		}
-
-		info->type = CA_CI_LINK;
-		info->flags = 0;
-		if ((ca->slot_info[info->num].slot_state
-				!= DVB_CA_SLOTSTATE_NONE)
-			&& (ca->slot_info[info->num].slot_state
-				!= DVB_CA_SLOTSTATE_INVALID)) {
-			info->flags = CA_CI_MODULE_PRESENT;
-		}
-		if (ca->slot_info[info->num].slot_state
-				== DVB_CA_SLOTSTATE_RUNNING) {
-			info->flags |= CA_CI_MODULE_READY;
-		}
-		break;
-	}
-
-	default:
-	    pr_error("Invalid cmd :%d\r\n", cmd);
-		err = -EINVAL;
-		break;
-	}
-
-out_unlock:
-	mutex_unlock(&ca->ioctl_mutex);
-	return err;
-}
-
-
-static int dvb_usercopy__(struct file *file,
-		   unsigned int cmd, unsigned long arg,
-		   int (*func)(struct file *file,
-		   unsigned int cmd, void *arg))
-{
-  char	  sbuf[128];
-  void	  *mbuf = NULL;
-  void	  *parg = NULL;
-  int	  err  = -EINVAL;
-
-  /*  Copy arguments into temp kernel buffer  */
-  switch (_IOC_DIR(cmd)) {
-  case _IOC_NONE:
-	  /*
-	   * For this command, the pointer is actually an integer
-	   * argument.
-	   */
-	  parg = (void *) arg;
-	  break;
-  case _IOC_READ: /* some v4l ioctls are marked wrong ... */
-  case _IOC_WRITE:
-  case (_IOC_WRITE | _IOC_READ):
-	  if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
-		  parg = sbuf;
-	  } else {
-		  /* too big to allocate from stack */
-		  mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
-		  if (NULL == mbuf)
-			  return -ENOMEM;
-		  parg = mbuf;
-	  }
-
-	  err = -EFAULT;
-	  if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
-		  goto out;
-	  break;
-  }
-
-  /* call driver */
-  if ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)
-	  err = -ENOTTY;
-
-  if (err < 0)
-	  goto out;
-
-  /*  Copy results into user buffer  */
-  switch (_IOC_DIR(cmd))
-  {
-  case _IOC_READ:
-  case (_IOC_WRITE | _IOC_READ):
-	  if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
-		  err = -EFAULT;
-	  break;
-  }
-
-out:
-  kfree(mbuf);
-  return err;
-}
-
-
-
-/**
- * Wrapper for ioctl implementation.
- *
- * @param inode Inode concerned.
- * @param file File concerned.
- * @param cmd IOCTL command.
- * @param arg Associated argument.
- *
- * @return 0 on success, <0 on error.
- */
-static long dvb_ca_en50221_io_ioctl(struct file *file,
-				    unsigned int cmd, unsigned long arg)
-{
-	return dvb_usercopy__(file, cmd, arg, dvb_ca_en50221_io_do_ioctl);
-}
-
-
-/**
- * Implementation of write() syscall.
- *
- * @param file File structure.
- * @param buf Source buffer.
- * @param count Size of source buffer.
- * @param ppos Position in file (ignored).
- *
- * @return Number of bytes read, or <0 on error.
- */
-static ssize_t dvb_ca_en50221_io_write(struct file *file,
-			const char __user *buf, size_t count, loff_t *ppos)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct dvb_ca_private *ca = dvbdev->priv;
-	u8 slot, connection_id;
-	int status;
-	u8 *fragbuf = ca->wbuf;
-	int fragpos = 0;
-	int fraglen;
-	unsigned long timeout;
-	int written;
-
-	/* dprintk("%s\n", __func__); */
-
-	/* Incoming packet has a 2 byte header.
-	   hdr[0] = slot_id, hdr[1] = connection_id */
-	if (count < 2)
-		return -EINVAL;
-
-	/* extract slot & connection id */
-	if (copy_from_user(&slot, buf, 1))
-		return -EFAULT;
-	if (copy_from_user(&connection_id, buf + 1, 1))
-		return -EFAULT;
-	buf += 2;
-	count -= 2;
-
-	if (slot >= ca->slot_count)
-		return -EFAULT;
-	/* check if the slot is actually running */
-	if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
-		return -EINVAL;
-
-	/* fragment the packets & store in the buffer */
-	while (fragpos < count) {
-		fraglen = ca->slot_info[slot].link_buf_size - 2;
-		if (fraglen < 0)
-			break;
-		if (fraglen > dvb_ca_en50221_link_size - 2)
-			fraglen = dvb_ca_en50221_link_size - 2;
-		if ((count - fragpos) < fraglen)
-			fraglen = count - fragpos;
-
-		fragbuf[0] = connection_id;
-		fragbuf[1] = ((fragpos + fraglen) < count) ? 0x80 : 0x00;
-		status = copy_from_user(fragbuf + 2, buf + fragpos, fraglen);
-		if (status) {
-			status = -EFAULT;
-			goto exit;
-		}
-
-		timeout = jiffies + HZ / 2;
-		written = 0;
-		while (!time_after(jiffies, timeout)) {
-			/* check the CAM hasn't been removed/reset
-			   in the meantime */
-			if (ca->slot_info[slot].slot_state
-					!= DVB_CA_SLOTSTATE_RUNNING) {
-				status = -EIO;
-				goto exit;
-			}
-
-			mutex_lock(&ca->slot_info[slot].slot_lock);
-			status = dvb_ca_en50221_write_data(ca,
-					slot, fragbuf, fraglen + 2);
-			mutex_unlock(&ca->slot_info[slot].slot_lock);
-			if (status == (fraglen + 2)) {
-				written = 1;
-				break;
-			}
-			if (status != -EAGAIN)
-				goto exit;
-
-			msleep(20);
-		}
-		if (!written) {
-			status = -EIO;
-			goto exit;
-		}
-
-		fragpos += fraglen;
-	}
-	status = count + 2;
-
-exit:
-	return status;
-}
-
-
-/**
- * Condition for waking up in dvb_ca_en50221_io_read_condition
- */
-static int dvb_ca_en50221_io_read_condition(struct dvb_ca_private *ca,
-					    int *result, int *_slot)
-{
-	int slot;
-	int slot_count = 0;
-	int idx;
-	size_t fraglen;
-	int connection_id = -1;
-	int found = 0;
-	u8 hdr[2];
-
-	slot = ca->next_read_slot;
-	while ((slot_count < ca->slot_count) && (!found)) {
-		if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
-			goto nextslot;
-
-		if (ca->slot_info[slot].rx_buffer.data == NULL)
-			return 0;
-#ifdef READ_LPDU_PKT
-		if (ca->slot_info[slot].rx_offset != 0) {
-			*_slot = slot;
-			return 1;
-		}
-#endif
-		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer,
-				-1, &fraglen);
-		while (idx != -1) {
-			dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer,
-					idx, 0, hdr, 2);
-			if (connection_id == -1)
-				connection_id = hdr[0];
-			if ((hdr[0] == connection_id)
-#ifndef READ_LPDU_PKT
-				&& ((hdr[1] & 0x80) == 0)
-#endif
-			) {
-				*_slot = slot;
-				found = 1;
-				break;
-			}
-
-			idx = dvb_ringbuffer_pkt_next(
-				&ca->slot_info[slot].rx_buffer,
-				idx,
-				&fraglen);
-		}
-
-nextslot:
-		slot = (slot + 1) % ca->slot_count;
-		slot_count++;
-	}
-
-	ca->next_read_slot = slot;
-	return found;
-}
-
-
-/**
- * Implementation of read() syscall.
- *
- * @param file File structure.
- * @param buf Destination buffer.
- * @param count Size of destination buffer.
- * @param ppos Position in file (ignored).
- *
- * @return Number of bytes read, or <0 on error.
- */
-static ssize_t dvb_ca_en50221_io_read(struct file *file, char __user *buf,
-				      size_t count, loff_t *ppos)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct dvb_ca_private *ca = dvbdev->priv;
-	int status;
-	int result = 0;
-	u8 hdr[2];
-	int slot;
-	int connection_id = -1;
-	size_t idx, idx2;
-	int last_fragment = 0;
-	size_t fraglen;
-	int pktlen;
-	int dispose = 0;
-
-#ifdef READ_LPDU_PKT
-	int offset;
-	u8 flag = 0;
-#endif
-
-	/* dprintk("%s\n", __func__); */
-
-	/* Outgoing packet has a 2 byte header.
-	   hdr[0] = slot_id, hdr[1] = connection_id */
-	if (count < 2)
-		return -EINVAL;
-
-	/* wait for some data */
-	status = dvb_ca_en50221_io_read_condition(ca, &result, &slot);
-	if (status == 0) {
-		/* if we're in nonblocking mode, exit immediately */
-		if (file->f_flags & O_NONBLOCK)
-			return -EWOULDBLOCK;
-
-		/* wait for some data */
-		status = wait_event_interruptible(ca->wait_queue,
-					  dvb_ca_en50221_io_read_condition
-					  (ca, &result, &slot));
-	}
-	if ((status < 0) || (result < 0)) {
-		if (result)
-			return result;
-		return status;
-	}
-
-	idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer,
-			-1, &fraglen);
-	pktlen = 2;
-	do {
-		if (idx == -1) {
-			pr_error("dvb_ca adapter %d: ",
-				ca->dvbdev->adapter->num);
-			pr_error("BUG: read packet ended");
-			pr_error("before last_fragment encountered\n");
-			status = -EIO;
-			goto exit;
-		}
-#ifdef READ_LPDU_PKT
-		offset = 2 + ca->slot_info[slot].rx_offset;
-#endif
-		dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer,
-				idx, 0, hdr, 2);
-		if (connection_id == -1)
-			connection_id = hdr[0];
-#ifdef READ_LPDU_PKT
-		flag = hdr[1];
-		if (hdr[0] == connection_id) {
-			if (pktlen < count) {
-				if ((pktlen + fraglen - offset) > (count - 2)) {
-					fraglen = (count - 2) - pktlen;
-					ca->slot_info[slot].rx_offset +=
-									fraglen;
-					/* more data for user,
-					   but cannot send,
-					   so force return to user,
-					   rather than dispose of it */
-					flag |= 0x80;
-				} else {
-					ca->slot_info[slot].rx_offset = 0;
-					fraglen -= offset;
-					dispose = 1;
-				}
-
-				status = dvb_ringbuffer_pkt_read_user(
-					&ca->slot_info[slot].rx_buffer,
-					idx,
-					offset,
-					buf + pktlen + 2,
-					fraglen);
-				if (status < 0)
-					goto exit;
-				pktlen += fraglen;
-			}
-
-			last_fragment = 1;
-		}
-#else
-		if (hdr[0] == connection_id) {
-			if (pktlen < count) {
-				if ((pktlen + fraglen - 2) > count)
-					fraglen = count - pktlen;
-				else
-					fraglen -= 2;
-
-				status = dvb_ringbuffer_pkt_read_user(
-					&ca->slot_info[slot].rx_buffer,
-					idx,
-					2,
-					buf + pktlen,
-					fraglen);
-				if (status < 0)
-					goto exit;
-				pktlen += fraglen;
-			}
-
-			if ((hdr[1] & 0x80) == 0)
-				last_fragment = 1;
-			dispose = 1;
-		}
-#endif
-		idx2 = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer,
-				idx, &fraglen);
-		if (dispose)
-			dvb_ringbuffer_pkt_dispose(
-				&ca->slot_info[slot].rx_buffer, idx);
-		idx = idx2;
-		dispose = 0;
-	} while (!last_fragment);
-
-	hdr[0] = slot;
-	hdr[1] = connection_id;
-	status = copy_to_user(buf, hdr, 2);
-	if (status) {
-		status = -EFAULT;
-		goto exit;
-	}
-	status = pktlen;
-
-#ifdef READ_LPDU_PKT
-	hdr[0] = flag;
-	hdr[1] = 0;
-
-	status = copy_to_user(buf + 2, hdr, 2);
-	if (status) {
-		status = -EFAULT;
-		goto exit;
-	}
-	status = pktlen + 2;
-#endif
-exit:
-	return status;
-}
-
-
-/**
- * Implementation of file open syscall.
- *
- * @param inode Inode concerned.
- * @param file File concerned.
- *
- * @return 0 on success, <0 on failure.
- */
-static int dvb_ca_en50221_io_open(struct inode *inode, struct file *file)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct dvb_ca_private *ca = dvbdev->priv;
-	int err;
-	int i;
-
-	dprintk("%s\n", __func__);
-
-	if (!try_module_get(ca->pub->owner))
-		return -EIO;
-
-	err = dvb_generic_open(inode, file);
-	if (err < 0) {
-		module_put(ca->pub->owner);
-		return err;
-	}
-
-	for (i = 0; i < ca->slot_count; i++) {
-
-		if (ca->slot_info[i].slot_state == DVB_CA_SLOTSTATE_RUNNING) {
-			if (ca->slot_info[i].rx_buffer.data != NULL) {
-				/* it is safe to call this here without locks
-				   because ca->open == 0.
-				   Data is not read in this case */
-				dvb_ringbuffer_flush(
-					&ca->slot_info[i].rx_buffer);
-			}
-		}
-	}
-
-	ca->open = 1;
-	dvb_ca_en50221_thread_update_delay(ca);
-	dvb_ca_en50221_thread_wakeup(ca);
-
-	return 0;
-}
-
-
-/**
- * Implementation of file close syscall.
- *
- * @param inode Inode concerned.
- * @param file File concerned.
- *
- * @return 0 on success, <0 on failure.
- */
-static int dvb_ca_en50221_io_release(struct inode *inode, struct file *file)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct dvb_ca_private *ca = dvbdev->priv;
-	int err;
-
-	dprintk("%s\n", __func__);
-
-	/* mark the CA device as closed */
-	ca->open = 0;
-	dvb_ca_en50221_thread_update_delay(ca);
-
-	err = dvb_generic_release(inode, file);
-
-	module_put(ca->pub->owner);
-
-	return err;
-}
-
-
-/**
- * Implementation of poll() syscall.
- *
- * @param file File concerned.
- * @param wait poll wait table.
- *
- * @return Standard poll mask.
- */
-static unsigned int dvb_ca_en50221_io_poll(struct file *file, poll_table *wait)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct dvb_ca_private *ca = dvbdev->priv;
-	unsigned int mask = 0;
-	int slot;
-	int result = 0;
-
-	/* dprintk("%s\n", __func__); */
-
-	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1)
-		mask |= POLLIN;
-
-	/* if there is something, return now */
-	if (mask)
-		return mask;
-
-	/* wait for something to happen */
-	poll_wait(file, &ca->wait_queue, wait);
-
-	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1)
-		mask |= POLLIN;
-
-	return mask;
-}
-EXPORT_SYMBOL(dvb_ca_en50221_cimax_init);
-
-#ifdef CONFIG_COMPAT
-static long dvb_ca_en50221_compat_ioctl(struct file *filp,
-			unsigned int cmd, unsigned long args)
-{
-	unsigned long ret;
-
-	args = (unsigned long)compat_ptr(args);
-	ret = dvb_ca_en50221_io_ioctl(filp, cmd, args);
-	return ret;
-}
-#endif
-static const struct file_operations dvb_ca_fops = {
-	.owner = THIS_MODULE,
-	.read = dvb_ca_en50221_io_read,
-	.write = dvb_ca_en50221_io_write,
-	.unlocked_ioctl = dvb_ca_en50221_io_ioctl,
-	.open = dvb_ca_en50221_io_open,
-	.release = dvb_ca_en50221_io_release,
-	.poll = dvb_ca_en50221_io_poll,
-	.llseek = noop_llseek,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= dvb_ca_en50221_compat_ioctl,
-#endif
-};
-
-static struct dvb_device dvbdev_ca = {
-	.priv = NULL,
-	.users = 1,
-	.readers = 1,
-	.writers = 1,
-	.fops = &dvb_ca_fops,
-};
-
-
-/* ************************************************************************** */
-/* Initialisation/shutdown functions */
-
-
-/**
- * Initialise a new DVB CA EN50221 CIMAX interface device.
- *
- * @param dvb_adapter DVB adapter to attach the new CA device to.
- * @param ca The dvb_ca instance.
- * @param flags Flags describing the CA device (DVB_CA_FLAG_*).
- * @param slot_count Number of slots supported.
- *
- * @return 0 on success, nonzero on failure
- */
-int dvb_ca_en50221_cimax_init(struct dvb_adapter *dvb_adapter,
-			struct dvb_ca_en50221_cimax *pubca,
-			int flags, int slot_count)
-{
-	int ret;
-	struct dvb_ca_private *ca = NULL;
-	int i;
-
-	dprintk("%s\n", __func__);
-
-	if (slot_count < 1)
-		return -EINVAL;
-
-	/* initialise the system data */
-	ca = kzalloc(sizeof(struct dvb_ca_private), GFP_KERNEL);
-	if (ca == NULL) {
-		ret = -ENOMEM;
-		goto error;
-	}
-	ca->pub = pubca;
-	ca->flags = flags;
-	ca->slot_count = slot_count;
-	ca->slot_info =
-		kcalloc(slot_count, sizeof(struct dvb_ca_slot), GFP_KERNEL);
-	if (ca->slot_info == NULL) {
-		ret = -ENOMEM;
-		goto error;
-	}
-	init_waitqueue_head(&ca->wait_queue);
-	ca->open = 0;
-	ca->wakeup = 0;
-	ca->next_read_slot = 0;
-	ca->rbuf = kcalloc(HOST_LINK_BUF_SIZE, 1, GFP_KERNEL);
-	ca->wbuf = kcalloc(HOST_LINK_BUF_SIZE, 1, GFP_KERNEL);
-	if (ca->rbuf == NULL || ca->wbuf == NULL) {
-		ret = -ENOMEM;
-		goto error;
-	}
-	pubca->private = ca;
-
-	/* register the DVB device */
-	ret = dvb_register_device(dvb_adapter,
-			&ca->dvbdev, &dvbdev_ca, ca, DVB_DEVICE_CA, 0);
-	if (ret)
-		goto error;
-
-	/* now initialise each slot */
-	for (i = 0; i < slot_count; i++) {
-		memset(&ca->slot_info[i], 0, sizeof(struct dvb_ca_slot));
-		ca->slot_info[i].slot_state = DVB_CA_SLOTSTATE_NONE;
-		atomic_set(&ca->slot_info[i].camchange_count, 0);
-		ca->slot_info[i].camchange_type =
-				DVB_CA_EN50221_CAMCHANGE_REMOVED;
-		mutex_init(&ca->slot_info[i].slot_lock);
-	}
-
-	mutex_init(&ca->ioctl_mutex);
-
-	if (signal_pending(current)) {
-		ret = -EINTR;
-		goto error;
-	}
-	mb();/*original*/
-
-	/* create a kthread for monitoring this CA device */
-	ca->thread = kthread_run(dvb_ca_en50221_thread, ca, "kdvb-ca-%i:%i",
-				 ca->dvbdev->adapter->num, ca->dvbdev->id);
-	if (IS_ERR(ca->thread)) {
-		ret = PTR_ERR(ca->thread);
-		printk("dvb_ca_init: failed to start kernel_thread (%d)\n",
-			ret);
-		goto error;
-	}
-	return 0;
-
-error:
-	if (ca != NULL) {
-		if (ca->dvbdev != NULL)
-			dvb_unregister_device(ca->dvbdev);
-		kfree(ca->slot_info);
-		kfree(ca->rbuf);
-		kfree(ca->wbuf);
-		kfree(ca);
-	}
-	pubca->private = NULL;
-	return ret;
-}
-EXPORT_SYMBOL(dvb_ca_en50221_cimax_release);
-
-
-
-/**
- * Release a DVB CA EN50221 CIMAX interface device.
- *
- * @param ca_dev The dvb_struct device_s instance for the CA device.
- * @param ca The associated dvb_ca instance.
- */
-void dvb_ca_en50221_cimax_release(struct dvb_ca_en50221_cimax *pubca)
-{
-	struct dvb_ca_private *ca = pubca->private;
-	int i;
-
-	dprintk("%s\n", __func__);
-
-	/* shutdown the thread if there was one */
-	kthread_stop(ca->thread);
-
-	for (i = 0; i < ca->slot_count; i++) {
-		dvb_ca_en50221_slot_shutdown(ca, i);
-		vfree(ca->slot_info[i].rx_buffer.data);
-	}
-	kfree(ca->slot_info);
-	kfree(ca->rbuf);
-	kfree(ca->wbuf);
-	dvb_unregister_device(ca->dvbdev);
-	kfree(ca);
-	pubca->private = NULL;
-}
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ca_en50221_cimax.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ca_en50221_cimax.h
deleted file mode 100644
index e2ebde6..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ca_en50221_cimax.h
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * dvb_ca_cimax.h: generic DVB functions for EN50221 CA CIMAX interfaces
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation; either version 2.1
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- */
-
-#ifndef _DVB_CA_EN50221_CIMAX_H_
-#define _DVB_CA_EN50221_CIMAX_H_
-
-#include <linux/list.h>
-#include <linux/dvb/ca.h>
-
-#include "dvbdev.h"
-
-#define DVB_CA_EN50221_POLL_CAM_PRESENT	1
-#define DVB_CA_EN50221_POLL_CAM_CHANGED	2
-#define DVB_CA_EN50221_POLL_CAM_READY		4
-
-#define DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE	1
-#define DVB_CA_EN50221_FLAG_IRQ_FR		2
-#define DVB_CA_EN50221_FLAG_IRQ_DA		4
-
-#define DVB_CA_EN50221_CAMCHANGE_REMOVED		0
-#define DVB_CA_EN50221_CAMCHANGE_INSERTED		1
-
-#define DVB_CA_EN50221_CAP_IRQ	1
-
-/* Structure describing a CA interface */
-struct dvb_ca_en50221_cimax {
-
-	/* the module owning this structure */
-	struct module *owner;
-
-	/* NOTE: the read_*, write_* and poll_slot_status functions will be
-	 * called for different slots concurrently and need to use locks where
-	 * and if appropriate. There will be no concurrent access to one slot.
-	 */
-
-	/* functions for accessing attribute memory on the CAM */
-	int (*read_cis)(struct dvb_ca_en50221_cimax *ca,
-			int slot, u8 *buf, int size);
-	int (*write_cor)(struct dvb_ca_en50221_cimax *ca,
-			int slot, int address, u8 *buf);
-      /*return the final size or -1 for error*/
-	int (*negotiate)(struct dvb_ca_en50221_cimax *ca, int slot, int size);
-
-	/* functions for accessing the control interface on the CAM */
-	int (*read_lpdu)(struct dvb_ca_en50221_cimax *ca,
-			int slot, u8 *buf, int size);
-	int (*write_lpdu)(struct dvb_ca_en50221_cimax *ca,
-			int slot, u8 *buf, int size);
-
-	int (*cam_reset)(struct dvb_ca_en50221_cimax *ca, int slot);
-	int (*read_cam_status)(struct dvb_ca_en50221_cimax *ca, int slot);
-	int (*get_capbility)(struct dvb_ca_en50221_cimax *ca, int slot);
-
-	/* Functions for controlling slots */
-	int (*slot_reset)(struct dvb_ca_en50221_cimax *ca, int slot);
-	int (*slot_shutdown)(struct dvb_ca_en50221_cimax *ca, int slot);
-	int (*slot_ts_enable)(struct dvb_ca_en50221_cimax *ca, int slot);
-
-	/*
-	* Poll slot status.
-	* Only necessary if DVB_CA_FLAG_EN50221_IRQ_CAMCHANGE is not set
-	*/
-	int (*poll_slot_status)(struct dvb_ca_en50221_cimax *ca,
-			int slot, int open);
-
-	/* private data, used by caller */
-	void *data;
-
-	/* Opaque data used by the dvb_ca core. Do not modify! */
-	void *private;
-};
-
-
-
-
-/* ************************************************************************* */
-/* Functions for reporting IRQ events */
-
-/**
- * A CAMCHANGE IRQ has occurred.
- *
- * @param ca CA instance.
- * @param slot Slot concerned.
- * @param change_type One of the DVB_CA_CAMCHANGE_* values
- */
-void dvb_ca_en50221_cimax_camchange_irq(struct dvb_ca_en50221_cimax *pubca,
-		int slot, int change_type);
-
-/**
- * A CAMREADY IRQ has occurred.
- *
- * @param ca CA instance.
- * @param slot Slot concerned.
- */
-void dvb_ca_en50221_cimax_camready_irq(struct dvb_ca_en50221_cimax *pubca,
-		int slot);
-
-/**
- * An FR or a DA IRQ has occurred.
- *
- * @param ca CA instance.
- * @param slot Slot concerned.
- */
-void dvb_ca_en50221_cimax_frda_irq(struct dvb_ca_en50221_cimax *ca, int slot);
-
-
-
-/* ************************************************************************** */
-/* Initialisation/shutdown functions */
-
-/**
- * Initialise a new DVB CA device.
- *
- * @param dvb_adapter DVB adapter to attach the new CA device to.
- * @param ca The dvb_ca instance.
- * @param flags Flags describing the CA device (DVB_CA_EN50221_FLAG_*).
- * @param slot_count Number of slots supported.
- *
- * @return 0 on success, nonzero on failure
- */
-extern int dvb_ca_en50221_cimax_init(struct dvb_adapter *dvb_adapter,
-		struct dvb_ca_en50221_cimax *ca, int flags, int slot_count);
-
-/**
- * Release a DVB CA device.
- *
- * @param ca The associated dvb_ca instance.
- */
-extern void dvb_ca_en50221_cimax_release(struct dvb_ca_en50221_cimax *ca);
-
-
-
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ringbuffer.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ringbuffer.c
deleted file mode 100644
index fa5c163..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ringbuffer.c
+++ /dev/null
@@ -1,381 +0,0 @@
-/*
- *
- * dvb_ringbuffer.c: ring buffer implementation for the dvb driver
- *
- * Copyright (C) 2003 Oliver Endriss
- * Copyright (C) 2004 Andrew de Quincey
- *
- * based on code originally found in av7110.c & dvb_ci.c:
- * Copyright (C) 1999-2003 Ralph  Metzler
- *                       & Marcus Metzler for convergence integrated media GmbH
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation; either version 2.1
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-
-
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/sched.h>
-#include <linux/string.h>
-#include <asm/uaccess.h>
-
-#include "dvb_ringbuffer.h"
-
-#define PKT_READY 0
-#define PKT_DISPOSED 1
-
-
-void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data, size_t len)
-{
-	rbuf->pread=rbuf->pwrite=0;
-	rbuf->data=data;
-	rbuf->size=len;
-	rbuf->error=0;
-
-	init_waitqueue_head(&rbuf->queue);
-
-	spin_lock_init(&(rbuf->lock));
-}
-
-
-
-int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf)
-{
-	/* smp_load_acquire() to load write pointer on reader side
-	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),
-	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()
-	 *
-	 * for memory barriers also see Documentation/circular-buffers.txt
-	 */
-	return (rbuf->pread == smp_load_acquire(&rbuf->pwrite));
-}
-
-
-
-ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)
-{
-	ssize_t free;
-
-	/* ACCESS_ONCE() to load read pointer on writer side
-	 * this pairs with smp_store_release() in dvb_ringbuffer_read(),
-	 * dvb_ringbuffer_read_user(), dvb_ringbuffer_flush(),
-	 * or dvb_ringbuffer_reset()
-	 */
-	free = ACCESS_ONCE(rbuf->pread) - rbuf->pwrite;
-	if (free <= 0)
-		free += rbuf->size;
-	return free-1;
-}
-
-
-
-ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)
-{
-	ssize_t avail;
-
-	/* smp_load_acquire() to load write pointer on reader side
-	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),
-	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()
-	 */
-	avail = smp_load_acquire(&rbuf->pwrite) - rbuf->pread;
-	if (avail < 0)
-		avail += rbuf->size;
-	return avail;
-}
-
-
-
-void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf)
-{
-	/* dvb_ringbuffer_flush() counts as read operation
-	 * smp_load_acquire() to load write pointer
-	 * smp_store_release() to update read pointer, this ensures that the
-	 * correct pointer is visible for subsequent dvb_ringbuffer_free()
-	 * calls on other cpu cores
-	 */
-	smp_store_release(&rbuf->pread, smp_load_acquire(&rbuf->pwrite));
-	rbuf->error = 0;
-}
-//EXPORT_SYMBOL(dvb_ringbuffer_flush);
-
-void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf)
-{
-	/* dvb_ringbuffer_reset() counts as read and write operation
-	 * smp_store_release() to update read pointer
-	 */
-	smp_store_release(&rbuf->pread, 0);
-	/* smp_store_release() to update write pointer */
-	smp_store_release(&rbuf->pwrite, 0);
-	rbuf->error = 0;
-}
-
-void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&rbuf->lock, flags);
-	dvb_ringbuffer_flush(rbuf);
-	spin_unlock_irqrestore(&rbuf->lock, flags);
-
-	wake_up(&rbuf->queue);
-}
-
-ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf, u8 __user *buf, size_t len)
-{
-	size_t todo = len;
-	size_t split;
-
-	split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
-	if (split > 0) {
-		if (copy_to_user(buf, rbuf->data+rbuf->pread, split))
-			return -EFAULT;
-		buf += split;
-		todo -= split;
-		/* smp_store_release() for read pointer update to ensure
-		 * that buf is not overwritten until read is complete,
-		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()
-		 */
-		smp_store_release(&rbuf->pread, 0);
-	}
-	if (copy_to_user(buf, rbuf->data+rbuf->pread, todo))
-		return -EFAULT;
-
-	/* smp_store_release() to update read pointer, see above */
-	smp_store_release(&rbuf->pread, (rbuf->pread + todo) % rbuf->size);
-
-	return len;
-}
-
-void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len)
-{
-	size_t todo = len;
-	size_t split;
-
-	split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
-	if (split > 0) {
-		memcpy(buf, rbuf->data+rbuf->pread, split);
-		buf += split;
-		todo -= split;
-		/* smp_store_release() for read pointer update to ensure
-		 * that buf is not overwritten until read is complete,
-		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()
-		 */
-		smp_store_release(&rbuf->pread, 0);
-	}
-	memcpy(buf, rbuf->data+rbuf->pread, todo);
-
-	/* smp_store_release() to update read pointer, see above */
-	smp_store_release(&rbuf->pread, (rbuf->pread + todo) % rbuf->size);
-}
-
-
-ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t len)
-{
-	size_t todo = len;
-	size_t split;
-
-	split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
-
-	if (split > 0) {
-		memcpy(rbuf->data+rbuf->pwrite, buf, split);
-		buf += split;
-		todo -= split;
-		/* smp_store_release() for write pointer update to ensure that
-		 * written data is visible on other cpu cores before the pointer
-		 * update, this pairs with smp_load_acquire() in
-		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()
-		 */
-		smp_store_release(&rbuf->pwrite, 0);
-	}
-	memcpy(rbuf->data+rbuf->pwrite, buf, todo);
-	/* smp_store_release() for write pointer update, see above */
-	smp_store_release(&rbuf->pwrite, (rbuf->pwrite + todo) % rbuf->size);
-
-	return len;
-}
-
-ssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,
-				  const u8 __user *buf, size_t len)
-{
-	int status;
-	size_t todo = len;
-	size_t split;
-
-	split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
-
-	if (split > 0) {
-		status = copy_from_user(rbuf->data+rbuf->pwrite, buf, split);
-		if (status)
-			return len - todo;
-		buf += split;
-		todo -= split;
-		/* smp_store_release() for write pointer update to ensure that
-		 * written data is visible on other cpu cores before the pointer
-		 * update, this pairs with smp_load_acquire() in
-		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()
-		 */
-		smp_store_release(&rbuf->pwrite, 0);
-	}
-	status = copy_from_user(rbuf->data+rbuf->pwrite, buf, todo);
-	if (status)
-		return len - todo;
-	/* smp_store_release() for write pointer update, see above */
-	smp_store_release(&rbuf->pwrite, (rbuf->pwrite + todo) % rbuf->size);
-
-	return len;
-}
-
-ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8* buf, size_t len)
-{
-	int status;
-	ssize_t oldpwrite = rbuf->pwrite;
-
-	DVB_RINGBUFFER_WRITE_BYTE(rbuf, len >> 8);
-	DVB_RINGBUFFER_WRITE_BYTE(rbuf, len & 0xff);
-	DVB_RINGBUFFER_WRITE_BYTE(rbuf, PKT_READY);
-	status = dvb_ringbuffer_write(rbuf, buf, len);
-
-	if (status < 0) rbuf->pwrite = oldpwrite;
-	return status;
-}
-
-ssize_t dvb_ringbuffer_pkt_read_user(struct dvb_ringbuffer *rbuf, size_t idx,
-				int offset, u8 __user *buf, size_t len)
-{
-	size_t todo;
-	size_t split;
-	size_t pktlen;
-
-	pktlen = rbuf->data[idx] << 8;
-	pktlen |= rbuf->data[(idx + 1) % rbuf->size];
-	if (offset > pktlen) return -EINVAL;
-	if ((offset + len) > pktlen) len = pktlen - offset;
-
-	idx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;
-	todo = len;
-	split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
-	if (split > 0) {
-		if (copy_to_user(buf, rbuf->data+idx, split))
-			return -EFAULT;
-		buf += split;
-		todo -= split;
-		idx = 0;
-	}
-	if (copy_to_user(buf, rbuf->data+idx, todo))
-		return -EFAULT;
-
-	return len;
-}
-
-ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
-				int offset, u8* buf, size_t len)
-{
-	size_t todo;
-	size_t split;
-	size_t pktlen;
-
-	pktlen = rbuf->data[idx] << 8;
-	pktlen |= rbuf->data[(idx + 1) % rbuf->size];
-	if (offset > pktlen) return -EINVAL;
-	if ((offset + len) > pktlen) len = pktlen - offset;
-
-	idx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;
-	todo = len;
-	split = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;
-	if (split > 0) {
-		memcpy(buf, rbuf->data+idx, split);
-		buf += split;
-		todo -= split;
-		idx = 0;
-	}
-	memcpy(buf, rbuf->data+idx, todo);
-	return len;
-}
-
-void dvb_ringbuffer_pkt_dispose(struct dvb_ringbuffer *rbuf, size_t idx)
-{
-	size_t pktlen;
-
-	rbuf->data[(idx + 2) % rbuf->size] = PKT_DISPOSED;
-
-	// clean up disposed packets
-	while(dvb_ringbuffer_avail(rbuf) > DVB_RINGBUFFER_PKTHDRSIZE) {
-		if (DVB_RINGBUFFER_PEEK(rbuf, 2) == PKT_DISPOSED) {
-			pktlen = DVB_RINGBUFFER_PEEK(rbuf, 0) << 8;
-			pktlen |= DVB_RINGBUFFER_PEEK(rbuf, 1);
-			DVB_RINGBUFFER_SKIP(rbuf, pktlen + DVB_RINGBUFFER_PKTHDRSIZE);
-		} else {
-			// first packet is not disposed, so we stop cleaning now
-			break;
-		}
-	}
-}
-
-ssize_t dvb_ringbuffer_pkt_next(struct dvb_ringbuffer *rbuf, size_t idx, size_t* pktlen)
-{
-	int consumed;
-	int curpktlen;
-	int curpktstatus;
-
-	if (idx == -1) {
-	       idx = rbuf->pread;
-	} else {
-		curpktlen = rbuf->data[idx] << 8;
-		curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
-		idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
-	}
-
-	consumed = (idx - rbuf->pread) % rbuf->size;
-
-	while((dvb_ringbuffer_avail(rbuf) - consumed) > DVB_RINGBUFFER_PKTHDRSIZE) {
-
-		curpktlen = rbuf->data[idx] << 8;
-		curpktlen |= rbuf->data[(idx + 1) % rbuf->size];
-		curpktstatus = rbuf->data[(idx + 2) % rbuf->size];
-
-		if (curpktstatus == PKT_READY) {
-			*pktlen = curpktlen;
-			return idx;
-		}
-
-		consumed += curpktlen + DVB_RINGBUFFER_PKTHDRSIZE;
-		idx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;
-	}
-
-	// no packets available
-	return -1;
-}
-
-
-#if 0
-EXPORT_SYMBOL(dvb_ringbuffer_init);
-EXPORT_SYMBOL(dvb_ringbuffer_empty);
-EXPORT_SYMBOL(dvb_ringbuffer_free);
-EXPORT_SYMBOL(dvb_ringbuffer_avail);
-EXPORT_SYMBOL(dvb_ringbuffer_flush_spinlock_wakeup);
-EXPORT_SYMBOL(dvb_ringbuffer_read_user);
-EXPORT_SYMBOL(dvb_ringbuffer_read);
-EXPORT_SYMBOL(dvb_ringbuffer_write);
-EXPORT_SYMBOL(dvb_ringbuffer_write_user);
-#endif
-EXPORT_SYMBOL(dvb_ringbuffer_pkt_read);
-EXPORT_SYMBOL(dvb_ringbuffer_pkt_write);
-EXPORT_SYMBOL(dvb_ringbuffer_pkt_next);
-EXPORT_SYMBOL(dvb_ringbuffer_pkt_dispose);
-EXPORT_SYMBOL(dvb_ringbuffer_pkt_read_user);
-
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ringbuffer.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ringbuffer.h
deleted file mode 100644
index bbe9487..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvb_ringbuffer.h
+++ /dev/null
@@ -1,280 +0,0 @@
-/*
- *
- * dvb_ringbuffer.h: ring buffer implementation for the dvb driver
- *
- * Copyright (C) 2003 Oliver Endriss
- * Copyright (C) 2004 Andrew de Quincey
- *
- * based on code originally found in av7110.c & dvb_ci.c:
- * Copyright (C) 1999-2003 Ralph Metzler & Marcus Metzler
- *                         for convergence integrated media GmbH
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation; either version 2.1
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- */
-
-#ifndef _DVB_RINGBUFFER_H_
-#define _DVB_RINGBUFFER_H_
-
-#include <linux/spinlock.h>
-#include <linux/wait.h>
-
-/**
- * struct dvb_ringbuffer - Describes a ring buffer used at DVB framework
- *
- * @data: Area were the ringbuffer data is written
- * @size: size of the ringbuffer
- * @pread: next position to read
- * @pwrite: next position to write
- * @error: used by ringbuffer clients to indicate that an error happened.
- * @queue: Wait queue used by ringbuffer clients to indicate when buffer
- *         was filled
- * @lock: Spinlock used to protect the ringbuffer
- */
-struct dvb_ringbuffer {
-	u8               *data;
-	ssize_t           size;
-	ssize_t           pread;
-	ssize_t           pwrite;
-	int               error;
-
-	wait_queue_head_t queue;
-	spinlock_t        lock;
-};
-
-#define DVB_RINGBUFFER_PKTHDRSIZE 3
-
-/**
- * dvb_ringbuffer_init - initialize ring buffer, lock and queue
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- * @data: pointer to the buffer where the data will be stored
- * @len: bytes from ring buffer into @buf
- */
-extern void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data,
-				size_t len);
-
-/**
- * dvb_ringbuffer_empty - test whether buffer is empty
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- */
-extern int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf);
-
-/**
- * dvb_ringbuffer_free - returns the number of free bytes in the buffer
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- *
- * Return: number of free bytes in the buffer
- */
-extern ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf);
-
-/**
- * dvb_ringbuffer_avail - returns the number of bytes waiting in the buffer
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- *
- * Return: number of bytes waiting in the buffer
- */
-extern ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf);
-
-/**
- * dvb_ringbuffer_reset - resets the ringbuffer to initial state
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- *
- * Resets the read and write pointers to zero and flush the buffer.
- *
- * This counts as a read and write operation
- */
-extern void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf);
-
-/*
- * read routines & macros
- */
-
-/**
- * dvb_ringbuffer_flush - flush buffer
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- */
-extern void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf);
-
-/**
- * dvb_ringbuffer_flush_spinlock_wakeup- flush buffer protected by spinlock
- *      and wake-up waiting task(s)
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- */
-extern void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf);
-
-/**
- * DVB_RINGBUFFER_PEEK - peek at byte @offs in the buffer
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- * @offs: offset inside the ringbuffer
- */
-#define DVB_RINGBUFFER_PEEK(rbuf, offs)	\
-			((rbuf)->data[((rbuf)->pread + (offs)) % (rbuf)->size])
-
-/**
- * DVB_RINGBUFFER_SKIP - advance read ptr by @num bytes
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- * @num: number of bytes to advance
- */
-#define DVB_RINGBUFFER_SKIP(rbuf, num)	{\
-			(rbuf)->pread = ((rbuf)->pread + (num)) % (rbuf)->size;\
-}
-
-/**
- * dvb_ringbuffer_read_user - Reads a buffer into an user pointer
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- * @buf: pointer to the buffer where the data will be stored
- * @len: bytes from ring buffer into @buf
- *
- * This variant assumes that the buffer is a memory at the userspace. So,
- * it will internally call copy_to_user().
- *
- * Return: number of bytes transferred or -EFAULT
- */
-extern ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf,
-				   u8 __user *buf, size_t len);
-
-/**
- * dvb_ringbuffer_read - Reads a buffer into a pointer
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- * @buf: pointer to the buffer where the data will be stored
- * @len: bytes from ring buffer into @buf
- *
- * This variant assumes that the buffer is a memory at the Kernel space
- *
- * Return: number of bytes transferred or -EFAULT
- */
-extern void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf,
-				   u8 *buf, size_t len);
-
-/*
- * write routines & macros
- */
-
-/**
- * DVB_RINGBUFFER_WRITE_BYTE - write single byte to ring buffer
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- * @byte: byte to write
- */
-#define DVB_RINGBUFFER_WRITE_BYTE(rbuf, byte)	\
-			{ (rbuf)->data[(rbuf)->pwrite] = (byte); \
-			(rbuf)->pwrite = ((rbuf)->pwrite + 1) % (rbuf)->size; }
-
-/**
- * dvb_ringbuffer_write - Writes a buffer into the ringbuffer
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- * @buf: pointer to the buffer where the data will be read
- * @len: bytes from ring buffer into @buf
- *
- * This variant assumes that the buffer is a memory at the Kernel space
- *
- * return: number of bytes transferred or -EFAULT
- */
-extern ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf,
-				    size_t len);
-
-/**
- * dvb_ringbuffer_write_user - Writes a buffer received via an user pointer
- *
- * @rbuf: pointer to struct dvb_ringbuffer
- * @buf: pointer to the buffer where the data will be read
- * @len: bytes from ring buffer into @buf
- *
- * This variant assumes that the buffer is a memory at the userspace. So,
- * it will internally call copy_from_user().
- *
- * Return: number of bytes transferred or -EFAULT
- */
-extern ssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,
-					 const u8 __user *buf, size_t len);
-
-/**
- * dvb_ringbuffer_pkt_write - Write a packet into the ringbuffer.
- *
- * @rbuf: Ringbuffer to write to.
- * @buf: Buffer to write.
- * @len: Length of buffer (currently limited to 65535 bytes max).
- *
- * Return: Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.
- */
-extern ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8 *buf,
-					size_t len);
-
-/**
- * dvb_ringbuffer_pkt_read_user - Read from a packet in the ringbuffer.
- *
- * @rbuf: Ringbuffer concerned.
- * @idx: Packet index as returned by dvb_ringbuffer_pkt_next().
- * @offset: Offset into packet to read from.
- * @buf: Destination buffer for data.
- * @len: Size of destination buffer.
- *
- * Return: Number of bytes read, or -EFAULT.
- *
- * .. note::
- *
- *    unlike dvb_ringbuffer_read(), this does **NOT** update the read pointer
- *    in the ringbuffer. You must use dvb_ringbuffer_pkt_dispose() to mark a
- *    packet as no longer required.
- */
-extern ssize_t dvb_ringbuffer_pkt_read_user(struct dvb_ringbuffer *rbuf,
-					    size_t idx,
-					    int offset, u8 __user *buf,
-					    size_t len);
-
-/**
- * dvb_ringbuffer_pkt_read - Read from a packet in the ringbuffer.
- * Note: unlike dvb_ringbuffer_read_user(), this DOES update the read pointer
- * in the ringbuffer.
- *
- * @rbuf: Ringbuffer concerned.
- * @idx: Packet index as returned by dvb_ringbuffer_pkt_next().
- * @offset: Offset into packet to read from.
- * @buf: Destination buffer for data.
- * @len: Size of destination buffer.
- *
- * Return: Number of bytes read, or -EFAULT.
- */
-extern ssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,
-				       int offset, u8 *buf, size_t len);
-
-/**
- * dvb_ringbuffer_pkt_dispose - Dispose of a packet in the ring buffer.
- *
- * @rbuf: Ring buffer concerned.
- * @idx: Packet index as returned by dvb_ringbuffer_pkt_next().
- */
-extern void dvb_ringbuffer_pkt_dispose(struct dvb_ringbuffer *rbuf, size_t idx);
-
-/**
- * dvb_ringbuffer_pkt_next - Get the index of the next packet in a ringbuffer.
- *
- * @rbuf: Ringbuffer concerned.
- * @idx: Previous packet index, or -1 to return the first packet index.
- * @pktlen: On success, will be updated to contain the length of the packet
- *          in bytes.
- * returns Packet index (if >=0), or -1 if no packets available.
- */
-extern ssize_t dvb_ringbuffer_pkt_next(struct dvb_ringbuffer *rbuf,
-				       size_t idx, size_t *pktlen);
-
-#endif /* _DVB_RINGBUFFER_H_ */
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvbdev.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvbdev.c
deleted file mode 100644
index 0e9599b..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvbdev.c
+++ /dev/null
@@ -1,968 +0,0 @@
-/*
- * dvbdev.c
- *
- * Copyright (C) 2000 Ralph  Metzler <ralph@convergence.de>
- *                  & Marcus Metzler <marcus@convergence.de>
- *                    for convergence integrated media GmbH
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation; either version 2.1
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- */
-
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/mutex.h>
-#include "dvbdev.h"
-
-/* Due to enum tuner_pad_index */
-#include <media/tuner.h>
-
-static DEFINE_MUTEX(dvbdev_mutex);
-static int dvbdev_debug;
-
-module_param(dvbdev_debug, int, 0644);
-MODULE_PARM_DESC(dvbdev_debug, "Turn on/off device debugging (default:off).");
-
-#define dprintk if (dvbdev_debug) printk
-
-static LIST_HEAD(dvb_adapter_list);
-static DEFINE_MUTEX(dvbdev_register_lock);
-
-static const char * const dnames[] = {
-	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
-	"net", "osd"
-};
-
-#ifdef CONFIG_DVB_DYNAMIC_MINORS
-#define MAX_DVB_MINORS		256
-#define DVB_MAX_IDS		MAX_DVB_MINORS
-#else
-#define DVB_MAX_IDS		4
-#define nums2minor(num, type, id)	((num << 6) | (id << 4) | type)
-#define MAX_DVB_MINORS		(DVB_MAX_ADAPTERS*64)
-#endif
-
-static struct class *dvb_class;
-
-static struct dvb_device *dvb_minors[MAX_DVB_MINORS];
-static DECLARE_RWSEM(minor_rwsem);
-
-static int dvb_device_open(struct inode *inode, struct file *file)
-{
-	struct dvb_device *dvbdev;
-
-	mutex_lock(&dvbdev_mutex);
-	down_read(&minor_rwsem);
-	dvbdev = dvb_minors[iminor(inode)];
-
-	if (dvbdev && dvbdev->fops) {
-		int err = 0;
-		const struct file_operations *new_fops;
-
-		new_fops = fops_get(dvbdev->fops);
-		if (!new_fops)
-			goto fail;
-		file->private_data = dvbdev;
-		replace_fops(file, new_fops);
-		if (file->f_op->open)
-			err = file->f_op->open(inode, file);
-		up_read(&minor_rwsem);
-		mutex_unlock(&dvbdev_mutex);
-		return err;
-	}
-fail:
-	up_read(&minor_rwsem);
-	mutex_unlock(&dvbdev_mutex);
-	return -ENODEV;
-}
-
-
-static const struct file_operations dvb_device_fops =
-{
-	.owner =	THIS_MODULE,
-	.open =		dvb_device_open,
-	.llseek =	noop_llseek,
-};
-
-static struct cdev dvb_device_cdev;
-
-int dvb_generic_open(struct inode *inode, struct file *file)
-{
-	struct dvb_device *dvbdev = file->private_data;
-
-	if (!dvbdev)
-		return -ENODEV;
-
-	if (!dvbdev->users)
-		return -EBUSY;
-
-	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
-		if (!dvbdev->readers)
-			return -EBUSY;
-		dvbdev->readers--;
-	} else {
-		if (!dvbdev->writers)
-			return -EBUSY;
-		dvbdev->writers--;
-	}
-
-	dvbdev->users--;
-	return 0;
-}
-EXPORT_SYMBOL(dvb_generic_open);
-
-
-int dvb_generic_release(struct inode *inode, struct file *file)
-{
-	struct dvb_device *dvbdev = file->private_data;
-
-	if (!dvbdev)
-		return -ENODEV;
-
-	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
-		dvbdev->readers++;
-	} else {
-		dvbdev->writers++;
-	}
-
-	dvbdev->users++;
-	return 0;
-}
-EXPORT_SYMBOL(dvb_generic_release);
-
-
-long dvb_generic_ioctl(struct file *file,
-		       unsigned int cmd, unsigned long arg)
-{
-	struct dvb_device *dvbdev = file->private_data;
-
-	if (!dvbdev)
-		return -ENODEV;
-
-	if (!dvbdev->kernel_ioctl)
-		return -EINVAL;
-
-	return dvb_usercopy(file, cmd, arg, dvbdev->kernel_ioctl);
-}
-EXPORT_SYMBOL(dvb_generic_ioctl);
-
-
-static int dvbdev_get_free_id (struct dvb_adapter *adap, int type)
-{
-	u32 id = 0;
-
-	while (id < DVB_MAX_IDS) {
-		struct dvb_device *dev;
-		list_for_each_entry(dev, &adap->device_list, list_head)
-			if (dev->type == type && dev->id == id)
-				goto skip;
-		return id;
-skip:
-		id++;
-	}
-	return -ENFILE;
-}
-
-static void dvb_media_device_free(struct dvb_device *dvbdev)
-{
-#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
-	if (dvbdev->entity) {
-		media_device_unregister_entity(dvbdev->entity);
-		kfree(dvbdev->entity);
-		kfree(dvbdev->pads);
-		dvbdev->entity = NULL;
-		dvbdev->pads = NULL;
-	}
-
-	if (dvbdev->tsout_entity) {
-		int i;
-
-		for (i = 0; i < dvbdev->tsout_num_entities; i++) {
-			media_device_unregister_entity(&dvbdev->tsout_entity[i]);
-			kfree(dvbdev->tsout_entity[i].name);
-		}
-		kfree(dvbdev->tsout_entity);
-		kfree(dvbdev->tsout_pads);
-		dvbdev->tsout_entity = NULL;
-		dvbdev->tsout_pads = NULL;
-
-		dvbdev->tsout_num_entities = 0;
-	}
-
-	if (dvbdev->intf_devnode) {
-		media_devnode_remove(dvbdev->intf_devnode);
-		dvbdev->intf_devnode = NULL;
-	}
-
-	if (dvbdev->adapter->conn) {
-		media_device_unregister_entity(dvbdev->adapter->conn);
-		dvbdev->adapter->conn = NULL;
-		kfree(dvbdev->adapter->conn_pads);
-		dvbdev->adapter->conn_pads = NULL;
-	}
-#endif
-}
-
-#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
-static int dvb_create_tsout_entity(struct dvb_device *dvbdev,
-				    const char *name, int npads)
-{
-	int i, ret = 0;
-
-	dvbdev->tsout_pads = kcalloc(npads, sizeof(*dvbdev->tsout_pads),
-				     GFP_KERNEL);
-	if (!dvbdev->tsout_pads)
-		return -ENOMEM;
-
-	dvbdev->tsout_entity = kcalloc(npads, sizeof(*dvbdev->tsout_entity),
-				       GFP_KERNEL);
-	if (!dvbdev->tsout_entity)
-		return -ENOMEM;
-
-	dvbdev->tsout_num_entities = npads;
-
-	for (i = 0; i < npads; i++) {
-		struct media_pad *pads = &dvbdev->tsout_pads[i];
-		struct media_entity *entity = &dvbdev->tsout_entity[i];
-
-		entity->name = kasprintf(GFP_KERNEL, "%s #%d", name, i);
-		if (!entity->name)
-			return -ENOMEM;
-
-		entity->function = MEDIA_ENT_F_IO_DTV;
-		pads->flags = MEDIA_PAD_FL_SINK;
-
-		ret = media_entity_pads_init(entity, 1, pads);
-		if (ret < 0)
-			return ret;
-
-		ret = media_device_register_entity(dvbdev->adapter->mdev,
-						   entity);
-		if (ret < 0)
-			return ret;
-	}
-	return 0;
-}
-
-#define DEMUX_TSOUT	"demux-tsout"
-#define DVR_TSOUT	"dvr-tsout"
-
-static int dvb_create_media_entity(struct dvb_device *dvbdev,
-				   int type, int demux_sink_pads)
-{
-	int i, ret, npads;
-
-	switch (type) {
-	case DVB_DEVICE_FRONTEND:
-		npads = 2;
-		break;
-	case DVB_DEVICE_DVR:
-		ret = dvb_create_tsout_entity(dvbdev, DVR_TSOUT,
-					      demux_sink_pads);
-		return ret;
-	case DVB_DEVICE_DEMUX:
-		npads = 1 + demux_sink_pads;
-		ret = dvb_create_tsout_entity(dvbdev, DEMUX_TSOUT,
-					      demux_sink_pads);
-		if (ret < 0)
-			return ret;
-		break;
-	case DVB_DEVICE_CA:
-		npads = 2;
-		break;
-	case DVB_DEVICE_NET:
-		/*
-		 * We should be creating entities for the MPE/ULE
-		 * decapsulation hardware (or software implementation).
-		 *
-		 * However, the number of for the MPE/ULE decaps may not be
-		 * fixed. As we don't have yet dynamic support for PADs at
-		 * the Media Controller, let's not create the decap
-		 * entities yet.
-		 */
-		return 0;
-	default:
-		return 0;
-	}
-
-	dvbdev->entity = kzalloc(sizeof(*dvbdev->entity), GFP_KERNEL);
-	if (!dvbdev->entity)
-		return -ENOMEM;
-
-	dvbdev->entity->name = dvbdev->name;
-
-	if (npads) {
-		dvbdev->pads = kcalloc(npads, sizeof(*dvbdev->pads),
-				       GFP_KERNEL);
-		if (!dvbdev->pads)
-			return -ENOMEM;
-	}
-
-	switch (type) {
-	case DVB_DEVICE_FRONTEND:
-		dvbdev->entity->function = MEDIA_ENT_F_DTV_DEMOD;
-		dvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;
-		dvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;
-		break;
-	case DVB_DEVICE_DEMUX:
-		dvbdev->entity->function = MEDIA_ENT_F_TS_DEMUX;
-		dvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;
-		for (i = 1; i < npads; i++)
-			dvbdev->pads[i].flags = MEDIA_PAD_FL_SOURCE;
-		break;
-	case DVB_DEVICE_CA:
-		dvbdev->entity->function = MEDIA_ENT_F_DTV_CA;
-		dvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;
-		dvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;
-		break;
-	default:
-		/* Should never happen, as the first switch prevents it */
-		kfree(dvbdev->entity);
-		kfree(dvbdev->pads);
-		dvbdev->entity = NULL;
-		dvbdev->pads = NULL;
-		return 0;
-	}
-
-	if (npads) {
-		ret = media_entity_pads_init(dvbdev->entity, npads, dvbdev->pads);
-		if (ret)
-			return ret;
-	}
-	ret = media_device_register_entity(dvbdev->adapter->mdev,
-					   dvbdev->entity);
-	if (ret)
-		return ret;
-
-	printk(KERN_DEBUG "%s: media entity '%s' registered.\n",
-		__func__, dvbdev->entity->name);
-
-	return 0;
-}
-#endif
-
-static int dvb_register_media_device(struct dvb_device *dvbdev,
-				     int type, int minor,
-				     unsigned demux_sink_pads)
-{
-#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
-	struct media_link *link;
-	u32 intf_type;
-	int ret;
-
-	if (!dvbdev->adapter->mdev)
-		return 0;
-
-	ret = dvb_create_media_entity(dvbdev, type, demux_sink_pads);
-	if (ret)
-		return ret;
-
-	switch (type) {
-	case DVB_DEVICE_FRONTEND:
-		intf_type = MEDIA_INTF_T_DVB_FE;
-		break;
-	case DVB_DEVICE_DEMUX:
-		intf_type = MEDIA_INTF_T_DVB_DEMUX;
-		break;
-	case DVB_DEVICE_DVR:
-		intf_type = MEDIA_INTF_T_DVB_DVR;
-		break;
-	case DVB_DEVICE_CA:
-		intf_type = MEDIA_INTF_T_DVB_CA;
-		break;
-	case DVB_DEVICE_NET:
-		intf_type = MEDIA_INTF_T_DVB_NET;
-		break;
-	default:
-		return 0;
-	}
-
-	dvbdev->intf_devnode = media_devnode_create(dvbdev->adapter->mdev,
-						    intf_type, 0,
-						    DVB_MAJOR, minor);
-
-	if (!dvbdev->intf_devnode)
-		return -ENOMEM;
-
-	/*
-	 * Create the "obvious" link, e. g. the ones that represent
-	 * a direct association between an interface and an entity.
-	 * Other links should be created elsewhere, like:
-	 *		DVB FE intf    -> tuner
-	 *		DVB demux intf -> dvr
-	 */
-
-	if (!dvbdev->entity)
-		return 0;
-
-	link = media_create_intf_link(dvbdev->entity, &dvbdev->intf_devnode->intf,
-				      MEDIA_LNK_FL_ENABLED);
-	if (!link)
-		return -ENOMEM;
-#endif
-	return 0;
-}
-
-int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
-			const struct dvb_device *template, void *priv, int type,
-			int demux_sink_pads)
-{
-	struct dvb_device *dvbdev;
-	struct file_operations *dvbdevfops;
-	struct device *clsdev;
-	int minor;
-	int id, ret;
-
-	mutex_lock(&dvbdev_register_lock);
-
-	if ((id = dvbdev_get_free_id (adap, type)) < 0){
-		mutex_unlock(&dvbdev_register_lock);
-		*pdvbdev = NULL;
-		printk(KERN_ERR "%s: couldn't find free device id\n", __func__);
-		return -ENFILE;
-	}
-
-	*pdvbdev = dvbdev = kzalloc(sizeof(*dvbdev), GFP_KERNEL);
-
-	if (!dvbdev){
-		mutex_unlock(&dvbdev_register_lock);
-		return -ENOMEM;
-	}
-
-	dvbdevfops = kzalloc(sizeof(struct file_operations), GFP_KERNEL);
-
-	if (!dvbdevfops){
-		kfree (dvbdev);
-		mutex_unlock(&dvbdev_register_lock);
-		return -ENOMEM;
-	}
-
-	memcpy(dvbdev, template, sizeof(struct dvb_device));
-	dvbdev->type = type;
-	dvbdev->id = id;
-	dvbdev->adapter = adap;
-	dvbdev->priv = priv;
-	dvbdev->fops = dvbdevfops;
-	init_waitqueue_head (&dvbdev->wait_queue);
-
-	memcpy(dvbdevfops, template->fops, sizeof(struct file_operations));
-	dvbdevfops->owner = adap->module;
-
-	list_add_tail (&dvbdev->list_head, &adap->device_list);
-
-	down_write(&minor_rwsem);
-#ifdef CONFIG_DVB_DYNAMIC_MINORS
-	for (minor = 0; minor < MAX_DVB_MINORS; minor++)
-		if (dvb_minors[minor] == NULL)
-			break;
-
-	if (minor == MAX_DVB_MINORS) {
-		kfree(dvbdevfops);
-		kfree(dvbdev);
-		up_write(&minor_rwsem);
-		mutex_unlock(&dvbdev_register_lock);
-		return -EINVAL;
-	}
-#else
-	minor = nums2minor(adap->num, type, id);
-#endif
-
-	dvbdev->minor = minor;
-	dvb_minors[minor] = dvbdev;
-	up_write(&minor_rwsem);
-
-	ret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);
-	if (ret) {
-		printk(KERN_ERR
-		      "%s: dvb_register_media_device failed to create the mediagraph\n",
-		      __func__);
-
-		dvb_media_device_free(dvbdev);
-		kfree(dvbdevfops);
-		kfree(dvbdev);
-		up_write(&minor_rwsem);
-		mutex_unlock(&dvbdev_register_lock);
-		return ret;
-	}
-
-	mutex_unlock(&dvbdev_register_lock);
-
-	clsdev = device_create(dvb_class, adap->device,
-			       MKDEV(DVB_MAJOR, minor),
-			       dvbdev, "dvb%d.%s%d", adap->num, dnames[type], id);
-	if (IS_ERR(clsdev)) {
-		printk(KERN_ERR "%s: failed to create device dvb%d.%s%d (%ld)\n",
-		       __func__, adap->num, dnames[type], id, PTR_ERR(clsdev));
-		return PTR_ERR(clsdev);
-	}
-	dprintk(KERN_DEBUG "DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
-		adap->num, dnames[type], id, minor, minor);
-
-	return 0;
-}
-EXPORT_SYMBOL(dvb_register_device);
-
-
-void dvb_unregister_device(struct dvb_device *dvbdev)
-{
-	if (!dvbdev)
-		return;
-
-	down_write(&minor_rwsem);
-	dvb_minors[dvbdev->minor] = NULL;
-	up_write(&minor_rwsem);
-
-	dvb_media_device_free(dvbdev);
-
-	device_destroy(dvb_class, MKDEV(DVB_MAJOR, dvbdev->minor));
-
-	list_del (&dvbdev->list_head);
-	kfree (dvbdev->fops);
-	kfree (dvbdev);
-}
-EXPORT_SYMBOL(dvb_unregister_device);
-
-
-#ifdef CONFIG_MEDIA_CONTROLLER_DVB
-
-static int dvb_create_io_intf_links(struct dvb_adapter *adap,
-				    struct media_interface *intf,
-				    char *name)
-{
-	struct media_device *mdev = adap->mdev;
-	struct media_entity *entity;
-	struct media_link *link;
-
-	media_device_for_each_entity(entity, mdev) {
-		if (entity->function == MEDIA_ENT_F_IO_DTV) {
-			if (strncmp(entity->name, name, strlen(name)))
-				continue;
-			link = media_create_intf_link(entity, intf,
-						      MEDIA_LNK_FL_ENABLED);
-			if (!link)
-				return -ENOMEM;
-		}
-	}
-	return 0;
-}
-
-int dvb_create_media_graph(struct dvb_adapter *adap,
-			   bool create_rf_connector)
-{
-	struct media_device *mdev = adap->mdev;
-	struct media_entity *entity, *tuner = NULL, *demod = NULL, *conn;
-	struct media_entity *demux = NULL, *ca = NULL;
-	struct media_link *link;
-	struct media_interface *intf;
-	unsigned demux_pad = 0;
-	unsigned dvr_pad = 0;
-	unsigned ntuner = 0, ndemod = 0;
-	int ret;
-	static const char *connector_name = "Television";
-
-	if (!mdev)
-		return 0;
-
-	media_device_for_each_entity(entity, mdev) {
-		switch (entity->function) {
-		case MEDIA_ENT_F_TUNER:
-			tuner = entity;
-			ntuner++;
-			break;
-		case MEDIA_ENT_F_DTV_DEMOD:
-			demod = entity;
-			ndemod++;
-			break;
-		case MEDIA_ENT_F_TS_DEMUX:
-			demux = entity;
-			break;
-		case MEDIA_ENT_F_DTV_CA:
-			ca = entity;
-			break;
-		}
-	}
-
-	/*
-	 * Prepare to signalize to media_create_pad_links() that multiple
-	 * entities of the same type exists and a 1:n or n:1 links need to be
-	 * created.
-	 * NOTE: if both tuner and demod have multiple instances, it is up
-	 * to the caller driver to create such links.
-	 */
-	if (ntuner > 1)
-		tuner = NULL;
-	if (ndemod > 1)
-		demod = NULL;
-
-	if (create_rf_connector) {
-		conn = kzalloc(sizeof(*conn), GFP_KERNEL);
-		if (!conn)
-			return -ENOMEM;
-		adap->conn = conn;
-
-		adap->conn_pads = kzalloc(sizeof(*adap->conn_pads), GFP_KERNEL);
-		if (!adap->conn_pads)
-			return -ENOMEM;
-
-		conn->flags = MEDIA_ENT_FL_CONNECTOR;
-		conn->function = MEDIA_ENT_F_CONN_RF;
-		conn->name = connector_name;
-		adap->conn_pads->flags = MEDIA_PAD_FL_SOURCE;
-
-		ret = media_entity_pads_init(conn, 1, adap->conn_pads);
-		if (ret)
-			return ret;
-
-		ret = media_device_register_entity(mdev, conn);
-		if (ret)
-			return ret;
-
-		if (!ntuner)
-			ret = media_create_pad_links(mdev,
-						     MEDIA_ENT_F_CONN_RF,
-						     conn, 0,
-						     MEDIA_ENT_F_DTV_DEMOD,
-						     demod, 0,
-						     MEDIA_LNK_FL_ENABLED,
-						     false);
-		else
-			ret = media_create_pad_links(mdev,
-						     MEDIA_ENT_F_CONN_RF,
-						     conn, 0,
-						     MEDIA_ENT_F_TUNER,
-						     tuner, TUNER_PAD_RF_INPUT,
-						     MEDIA_LNK_FL_ENABLED,
-						     false);
-		if (ret)
-			return ret;
-	}
-
-	if (ntuner && ndemod) {
-		ret = media_create_pad_links(mdev,
-					     MEDIA_ENT_F_TUNER,
-					     tuner, TUNER_PAD_OUTPUT,
-					     MEDIA_ENT_F_DTV_DEMOD,
-					     demod, 0, MEDIA_LNK_FL_ENABLED,
-					     false);
-		if (ret)
-			return ret;
-	}
-
-	if (ndemod && demux) {
-		ret = media_create_pad_links(mdev,
-					     MEDIA_ENT_F_DTV_DEMOD,
-					     demod, 1,
-					     MEDIA_ENT_F_TS_DEMUX,
-					     demux, 0, MEDIA_LNK_FL_ENABLED,
-					     false);
-		if (ret)
-			return ret;
-	}
-	if (demux && ca) {
-		ret = media_create_pad_link(demux, 1, ca,
-					    0, MEDIA_LNK_FL_ENABLED);
-		if (ret)
-			return ret;
-	}
-
-	/* Create demux links for each ringbuffer/pad */
-	if (demux) {
-		media_device_for_each_entity(entity, mdev) {
-			if (entity->function == MEDIA_ENT_F_IO_DTV) {
-				if (!strncmp(entity->name, DVR_TSOUT,
-				    strlen(DVR_TSOUT))) {
-					ret = media_create_pad_link(demux,
-								++dvr_pad,
-							    entity, 0, 0);
-					if (ret)
-						return ret;
-				}
-				if (!strncmp(entity->name, DEMUX_TSOUT,
-				    strlen(DEMUX_TSOUT))) {
-					ret = media_create_pad_link(demux,
-							      ++demux_pad,
-							    entity, 0, 0);
-					if (ret)
-						return ret;
-				}
-			}
-		}
-	}
-
-	/* Create interface links for FE->tuner, DVR->demux and CA->ca */
-	media_device_for_each_intf(intf, mdev) {
-		if (intf->type == MEDIA_INTF_T_DVB_CA && ca) {
-			link = media_create_intf_link(ca, intf,
-						      MEDIA_LNK_FL_ENABLED);
-			if (!link)
-				return -ENOMEM;
-		}
-
-		if (intf->type == MEDIA_INTF_T_DVB_FE && tuner) {
-			link = media_create_intf_link(tuner, intf,
-						      MEDIA_LNK_FL_ENABLED);
-			if (!link)
-				return -ENOMEM;
-		}
-#if 0
-		/*
-		 * Indirect link - let's not create yet, as we don't know how
-		 *		   to handle indirect links, nor if this will
-		 *		   actually be needed.
-		 */
-		if (intf->type == MEDIA_INTF_T_DVB_DVR && demux) {
-			link = media_create_intf_link(demux, intf,
-						      MEDIA_LNK_FL_ENABLED);
-			if (!link)
-				return -ENOMEM;
-		}
-#endif
-		if (intf->type == MEDIA_INTF_T_DVB_DVR) {
-			ret = dvb_create_io_intf_links(adap, intf, DVR_TSOUT);
-			if (ret)
-				return ret;
-		}
-		if (intf->type == MEDIA_INTF_T_DVB_DEMUX) {
-			ret = dvb_create_io_intf_links(adap, intf, DEMUX_TSOUT);
-			if (ret)
-				return ret;
-		}
-	}
-	return 0;
-}
-EXPORT_SYMBOL_GPL(dvb_create_media_graph);
-#endif
-
-static int dvbdev_check_free_adapter_num(int num)
-{
-	struct list_head *entry;
-	list_for_each(entry, &dvb_adapter_list) {
-		struct dvb_adapter *adap;
-		adap = list_entry(entry, struct dvb_adapter, list_head);
-		if (adap->num == num)
-			return 0;
-	}
-	return 1;
-}
-
-static int dvbdev_get_free_adapter_num (void)
-{
-	int num = 0;
-
-	while (num < DVB_MAX_ADAPTERS) {
-		if (dvbdev_check_free_adapter_num(num))
-			return num;
-		num++;
-	}
-
-	return -ENFILE;
-}
-
-
-int dvb_register_adapter(struct dvb_adapter *adap, const char *name,
-			 struct module *module, struct device *device,
-			 short *adapter_nums)
-{
-	int i, num;
-
-	mutex_lock(&dvbdev_register_lock);
-
-	for (i = 0; i < DVB_MAX_ADAPTERS; ++i) {
-		num = adapter_nums[i];
-		if (num >= 0  &&  num < DVB_MAX_ADAPTERS) {
-		/* use the one the driver asked for */
-			if (dvbdev_check_free_adapter_num(num))
-				break;
-		} else {
-			num = dvbdev_get_free_adapter_num();
-			break;
-		}
-		num = -1;
-	}
-
-	if (num < 0) {
-		mutex_unlock(&dvbdev_register_lock);
-		return -ENFILE;
-	}
-
-	memset (adap, 0, sizeof(struct dvb_adapter));
-	INIT_LIST_HEAD (&adap->device_list);
-
-	printk(KERN_INFO "DVB: registering new adapter (%s)\n", name);
-
-	adap->num = num;
-	adap->name = name;
-	adap->module = module;
-	adap->device = device;
-	adap->mfe_shared = 0;
-	adap->mfe_dvbdev = NULL;
-	mutex_init (&adap->mfe_lock);
-
-	list_add_tail (&adap->list_head, &dvb_adapter_list);
-
-	mutex_unlock(&dvbdev_register_lock);
-
-	return num;
-}
-EXPORT_SYMBOL(dvb_register_adapter);
-
-
-int dvb_unregister_adapter(struct dvb_adapter *adap)
-{
-	mutex_lock(&dvbdev_register_lock);
-	list_del (&adap->list_head);
-	mutex_unlock(&dvbdev_register_lock);
-	return 0;
-}
-EXPORT_SYMBOL(dvb_unregister_adapter);
-
-/* if the miracle happens and "generic_usercopy()" is included into
-   the kernel, then this can vanish. please don't make the mistake and
-   define this as video_usercopy(). this will introduce a dependecy
-   to the v4l "videodev.o" module, which is unnecessary for some
-   cards (ie. the budget dvb-cards don't need the v4l module...) */
-int dvb_usercopy(struct file *file,
-		     unsigned int cmd, unsigned long arg,
-		     int (*func)(struct file *file,
-		     unsigned int cmd, void *arg))
-{
-	char    sbuf[128];
-	void    *mbuf = NULL;
-	void    *parg = NULL;
-	int     err  = -EINVAL;
-
-	/*  Copy arguments into temp kernel buffer  */
-	switch (_IOC_DIR(cmd)) {
-	case _IOC_NONE:
-		/*
-		 * For this command, the pointer is actually an integer
-		 * argument.
-		 */
-		parg = (void *) arg;
-		break;
-	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
-	case _IOC_WRITE:
-	case (_IOC_WRITE | _IOC_READ):
-		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
-			parg = sbuf;
-		} else {
-			/* too big to allocate from stack */
-			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
-			if (NULL == mbuf)
-				return -ENOMEM;
-			parg = mbuf;
-		}
-
-		err = -EFAULT;
-		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
-			goto out;
-		break;
-	}
-
-	/* call driver */
-	if ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)
-		err = -ENOTTY;
-
-	if (err < 0)
-		goto out;
-
-	/*  Copy results into user buffer  */
-	switch (_IOC_DIR(cmd))
-	{
-	case _IOC_READ:
-	case (_IOC_WRITE | _IOC_READ):
-		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
-			err = -EFAULT;
-		break;
-	}
-
-out:
-	kfree(mbuf);
-	return err;
-}
-EXPORT_SYMBOL(dvb_usercopy);
-static int dvb_uevent(struct device *dev, struct kobj_uevent_env *env)
-{
-	struct dvb_device *dvbdev = dev_get_drvdata(dev);
-
-	add_uevent_var(env, "DVB_ADAPTER_NUM=%d", dvbdev->adapter->num);
-	add_uevent_var(env, "DVB_DEVICE_TYPE=%s", dnames[dvbdev->type]);
-	add_uevent_var(env, "DVB_DEVICE_NUM=%d", dvbdev->id);
-	return 0;
-}
-
-static char *dvb_devnode(struct device *dev, umode_t *mode)
-{
-	struct dvb_device *dvbdev = dev_get_drvdata(dev);
-
-	return kasprintf(GFP_KERNEL, "dvb/adapter%d/%s%d",
-		dvbdev->adapter->num, dnames[dvbdev->type], dvbdev->id);
-}
-
-
-static int __init init_dvbdev(void)
-{
-	int retval;
-	dev_t dev = MKDEV(DVB_MAJOR, 0);
-
-	if ((retval = register_chrdev_region(dev, MAX_DVB_MINORS, "DVB")) != 0) {
-		printk(KERN_ERR "dvb-core: unable to get major %d\n", DVB_MAJOR);
-		return retval;
-	}
-
-	cdev_init(&dvb_device_cdev, &dvb_device_fops);
-	if ((retval = cdev_add(&dvb_device_cdev, dev, MAX_DVB_MINORS)) != 0) {
-		printk(KERN_ERR "dvb-core: unable register character device\n");
-		goto error;
-	}
-
-	dvb_class = class_create(THIS_MODULE, "dvb");
-	if (IS_ERR(dvb_class)) {
-		retval = PTR_ERR(dvb_class);
-		goto error;
-	}
-	dvb_class->dev_uevent = dvb_uevent;
-	dvb_class->devnode = dvb_devnode;
-	return 0;
-
-error:
-	cdev_del(&dvb_device_cdev);
-	unregister_chrdev_region(dev, MAX_DVB_MINORS);
-	return retval;
-}
-
-
-static void __exit exit_dvbdev(void)
-{
-	class_destroy(dvb_class);
-	cdev_del(&dvb_device_cdev);
-	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
-}
-#if 0
-subsys_initcall(init_dvbdev);
-module_exit(exit_dvbdev);
-
-MODULE_DESCRIPTION("DVB Core Driver");
-MODULE_AUTHOR("Marcus Metzler, Ralph Metzler, Holger Waechtler");
-MODULE_LICENSE("GPL");
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvbdev.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvbdev.h
deleted file mode 100644
index 4aff7bd..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/dvbdev.h
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- * dvbdev.h
- *
- * Copyright (C) 2000 Ralph Metzler & Marcus Metzler
- *                    for convergence integrated media GmbH
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Lesser Public License
- * as published by the Free Software Foundation; either version 2.1
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- */
-
-#ifndef _DVBDEV_H_
-#define _DVBDEV_H_
-
-#include <linux/types.h>
-#include <linux/poll.h>
-#include <linux/fs.h>
-#include <linux/list.h>
-#include <media/media-device.h>
-
-#define DVB_MAJOR 212
-
-#if defined(CONFIG_DVB_MAX_ADAPTERS) && CONFIG_DVB_MAX_ADAPTERS > 0
-  #define DVB_MAX_ADAPTERS CONFIG_DVB_MAX_ADAPTERS
-#else
-  #define DVB_MAX_ADAPTERS 8
-#endif
-
-#define DVB_UNSET (-1)
-
-#define DVB_DEVICE_VIDEO      0
-#define DVB_DEVICE_AUDIO      1
-#define DVB_DEVICE_SEC        2
-#define DVB_DEVICE_FRONTEND   3
-#define DVB_DEVICE_DEMUX      4
-#define DVB_DEVICE_DVR        5
-#define DVB_DEVICE_CA         6
-#define DVB_DEVICE_NET        7
-#define DVB_DEVICE_OSD        8
-
-#define DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr) \
-	static short adapter_nr[] = \
-		{[0 ... (DVB_MAX_ADAPTERS - 1)] = DVB_UNSET }; \
-	module_param_array(adapter_nr, short, NULL, 0444); \
-	MODULE_PARM_DESC(adapter_nr, "DVB adapter numbers")
-
-struct dvb_frontend;
-
-/**
- * struct dvb_adapter - represents a Digital TV adapter using Linux DVB API
- *
- * @num:		Number of the adapter
- * @list_head:		List with the DVB adapters
- * @device_list:	List with the DVB devices
- * @name:		Name of the adapter
- * @proposed_mac:	proposed MAC address for the adapter
- * @priv:		private data
- * @device:		pointer to struct device
- * @module:		pointer to struct module
- * @mfe_shared:		mfe shared: indicates mutually exclusive frontends
- *			Thie usage of this flag is currently deprecated
- * @mfe_dvbdev:		Frontend device in use, in the case of MFE
- * @mfe_lock:		Lock to prevent using the other frontends when MFE is
- *			used.
- * @mdev:		pointer to struct media_device, used when the media
- *			controller is used.
- * @conn:		RF connector. Used only if the device has no separate
- *			tuner.
- * @conn_pads:		pointer to struct media_pad associated with @conn;
- */
-struct dvb_adapter {
-	int num;
-	struct list_head list_head;
-	struct list_head device_list;
-	const char *name;
-	u8 proposed_mac [6];
-	void* priv;
-
-	struct device *device;
-
-	struct module *module;
-
-	int mfe_shared;			/* indicates mutually exclusive frontends */
-	struct dvb_device *mfe_dvbdev;	/* frontend device in use */
-	struct mutex mfe_lock;		/* access lock for thread creation */
-
-#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
-	struct media_device *mdev;
-	struct media_entity *conn;
-	struct media_pad *conn_pads;
-#endif
-};
-
-/**
- * struct dvb_device - represents a DVB device node
- *
- * @list_head:	List head with all DVB devices
- * @fops:	pointer to struct file_operations
- * @adapter:	pointer to the adapter that holds this device node
- * @type:	type of the device: DVB_DEVICE_SEC, DVB_DEVICE_FRONTEND,
- *		DVB_DEVICE_DEMUX, DVB_DEVICE_DVR, DVB_DEVICE_CA, DVB_DEVICE_NET
- * @minor:	devnode minor number. Major number is always DVB_MAJOR.
- * @id:		device ID number, inside the adapter
- * @readers:	Initialized by the caller. Each call to open() in Read Only mode
- *		decreases this counter by one.
- * @writers:	Initialized by the caller. Each call to open() in Read/Write
- *		mode decreases this counter by one.
- * @users:	Initialized by the caller. Each call to open() in any mode
- *		decreases this counter by one.
- * @wait_queue:	wait queue, used to wait for certain events inside one of
- *		the DVB API callers
- * @kernel_ioctl: callback function used to handle ioctl calls from userspace.
- * @name:	Name to be used for the device at the Media Controller
- * @entity:	pointer to struct media_entity associated with the device node
- * @pads:	pointer to struct media_pad associated with @entity;
- * @priv:	private data
- * @intf_devnode: Pointer to media_intf_devnode. Used by the dvbdev core to
- *		store the MC device node interface
- * @tsout_num_entities: Number of Transport Stream output entities
- * @tsout_entity: array with MC entities associated to each TS output node
- * @tsout_pads: array with the source pads for each @tsout_entity
- *
- * This structure is used by the DVB core (frontend, CA, net, demux) in
- * order to create the device nodes. Usually, driver should not initialize
- * this struct diretly.
- */
-struct dvb_device {
-	struct list_head list_head;
-	const struct file_operations *fops;
-	struct dvb_adapter *adapter;
-	int type;
-	int minor;
-	u32 id;
-
-	/* in theory, 'users' can vanish now,
-	   but I don't want to change too much now... */
-	int readers;
-	int writers;
-	int users;
-
-	wait_queue_head_t	  wait_queue;
-	/* don't really need those !? -- FIXME: use video_usercopy  */
-	int (*kernel_ioctl)(struct file *file, unsigned int cmd, void *arg);
-
-	/* Needed for media controller register/unregister */
-#if defined(CONFIG_MEDIA_CONTROLLER_DVB)
-	const char *name;
-
-	/* Allocated and filled inside dvbdev.c */
-	struct media_intf_devnode *intf_devnode;
-
-	unsigned tsout_num_entities;
-	struct media_entity *entity, *tsout_entity;
-	struct media_pad *pads, *tsout_pads;
-#endif
-
-	void *priv;
-};
-
-/**
- * dvb_register_adapter - Registers a new DVB adapter
- *
- * @adap:	pointer to struct dvb_adapter
- * @name:	Adapter's name
- * @module:	initialized with THIS_MODULE at the caller
- * @device:	pointer to struct device that corresponds to the device driver
- * @adapter_nums: Array with a list of the numbers for @dvb_register_adapter;
- * 		to select among them. Typically, initialized with:
- *		DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nums)
- */
-int dvb_register_adapter(struct dvb_adapter *adap, const char *name,
-			 struct module *module, struct device *device,
-			 short *adapter_nums);
-
-/**
- * dvb_unregister_adapter - Unregisters a DVB adapter
- *
- * @adap:	pointer to struct dvb_adapter
- */
-int dvb_unregister_adapter(struct dvb_adapter *adap);
-
-/**
- * dvb_register_device - Registers a new DVB device
- *
- * @adap:	pointer to struct dvb_adapter
- * @pdvbdev:	pointer to the place where the new struct dvb_device will be
- *		stored
- * @template:	Template used to create &pdvbdev;
- * @priv:	private data
- * @type:	type of the device: %DVB_DEVICE_SEC, %DVB_DEVICE_FRONTEND,
- *		%DVB_DEVICE_DEMUX, %DVB_DEVICE_DVR, %DVB_DEVICE_CA,
- *		%DVB_DEVICE_NET
- * @demux_sink_pads: Number of demux outputs, to be used to create the TS
- *		outputs via the Media Controller.
- */
-int dvb_register_device(struct dvb_adapter *adap,
-			struct dvb_device **pdvbdev,
-			const struct dvb_device *template,
-			void *priv,
-			int type,
-			int demux_sink_pads);
-
-/**
- * dvb_unregister_device - Unregisters a DVB device
- *
- * @dvbdev:	pointer to struct dvb_device
- */
-void dvb_unregister_device(struct dvb_device *dvbdev);
-
-#ifdef CONFIG_MEDIA_CONTROLLER_DVB
-/**
- * dvb_create_media_graph - Creates media graph for the Digital TV part of the
- * 				device.
- *
- * @adap:			pointer to struct dvb_adapter
- * @create_rf_connector:	if true, it creates the RF connector too
- *
- * This function checks all DVB-related functions at the media controller
- * entities and creates the needed links for the media graph. It is
- * capable of working with multiple tuners or multiple frontends, but it
- * won't create links if the device has multiple tuners and multiple frontends
- * or if the device has multiple muxes. In such case, the caller driver should
- * manually create the remaining links.
- */
-__must_check int dvb_create_media_graph(struct dvb_adapter *adap,
-					bool create_rf_connector);
-
-static inline void dvb_register_media_controller(struct dvb_adapter *adap,
-						 struct media_device *mdev)
-{
-	adap->mdev = mdev;
-}
-
-static inline struct media_device
-*dvb_get_media_controller(struct dvb_adapter *adap)
-{
-	return adap->mdev;
-}
-#else
-static inline
-int dvb_create_media_graph(struct dvb_adapter *adap,
-			   bool create_rf_connector)
-{
-	return 0;
-};
-#define dvb_register_media_controller(a, b) {}
-#define dvb_get_media_controller(a) NULL
-#endif
-
-int dvb_generic_open (struct inode *inode, struct file *file);
-int dvb_generic_release (struct inode *inode, struct file *file);
-long dvb_generic_ioctl (struct file *file,
-			      unsigned int cmd, unsigned long arg);
-
-/* we don't mess with video_usercopy() any more,
-we simply define out own dvb_usercopy(), which will hopefully become
-generic_usercopy()  someday... */
-
-int dvb_usercopy(struct file *file, unsigned int cmd, unsigned long arg,
-		 int (*func)(struct file *file, unsigned int cmd, void *arg));
-
-/** generic DVB attach function. */
-#ifdef CONFIG_MEDIA_ATTACH
-#define dvb_attach(FUNCTION, ARGS...) ({ \
-	void *__r = NULL; \
-	typeof(&FUNCTION) __a = symbol_request(FUNCTION); \
-	if (__a) { \
-		__r = (void *) __a(ARGS); \
-		if (__r == NULL) \
-			symbol_put(FUNCTION); \
-	} else { \
-		printk(KERN_ERR "DVB: Unable to find symbol "#FUNCTION"()\n"); \
-	} \
-	__r; \
-})
-
-#define dvb_detach(FUNC)	symbol_put_addr(FUNC)
-
-#else
-#define dvb_attach(FUNCTION, ARGS...) ({ \
-	FUNCTION(ARGS); \
-})
-
-#define dvb_detach(FUNC)	{}
-
-#endif
-
-#endif /* #ifndef _DVBDEV_H_ */
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/COPYING.LESSER b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/COPYING.LESSER
deleted file mode 100644
index 8f4a860..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/COPYING.LESSER
+++ /dev/null
@@ -1,499 +0,0 @@
-                  GNU LESSER GENERAL PUBLIC LICENSE
-                       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-                            Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-                  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.
-We sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-                            NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-                     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library.
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/README.txt b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/README.txt
deleted file mode 100644
index 1d6a01c..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/README.txt
+++ /dev/null
@@ -1,61 +0,0 @@
-April 28, 2011
-
-Linux CIMaX+ Kernel driver.
-Release Code version:
-
-DISCLAIMER
-----------
-
-This is a Smardtv' Linux Kernel driver for use with
-the CIMaX+ USB reference board hardware.
-
-IMPORTANT NOTE
---------------
-
-This packages contains a Linux Kernel driver to be installed in the
-/lib/modules target directory in order to be loaded automaticaly.
-
-1. High level driver: cimax+usb_driver.ko
-  This driver provide the high level interface to control the CIMaX+ USB interface.
-
-2. Firmware
-  To have a functional hardware, the firmware must be uploaded to the device.
-
-  The firmwares is delivered in 2 files for dedicated usage and must be
-  installed in the Linux firmware directory on the target board:
-
-    - /lib/firmware
-
-  A) CIMaX+ firmware binary file
-    Copy the following firmware file to the /lib/firmware directory:
-      - firmware/cimax+_usbdvb.bin
-
-  B) CIMaX+ configuration file
-    Copy the following firmware file to the /lib/firmware directory:
-      - firmware/cimax+usb.cfg
-
-
-BUILD AND INSTALLATION INSTRUCTIONS
------------------------------------
-
-2. Building LINUX USB DVB driver
-  On the target machine performs the following commands:
-
-  1. cd src
-  2. make
-  3. make install
-
-3. Installing firmware files
-  On the target machine performs the following command:
-
-  1. cp firmware/*.* /lib/firmware/
-
-4. Installing rules file
-  1. cp src/99-cimax+usb.rules /etc/udev/rules.d/
-  2. udevadm control --reload-rules
-
-5. Build modules dependencies
-  On the target machine performs the following command:
-
-  1. depmod -a
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/99-cimax+usb.rules b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/99-cimax+usb.rules
deleted file mode 100644
index 82af370..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/99-cimax+usb.rules
+++ /dev/null
@@ -1,4 +0,0 @@
-BUS=="usb", ACTION=="add", SYSFS{idProduct}=="2F00", SYSFS{idVendor}=="1B0D"
-KERNEL=="cimaxusb[0-9]", GROUP="users"
-
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/HOWTO.txt b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/HOWTO.txt
deleted file mode 100644
index 23de038..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/HOWTO.txt
+++ /dev/null
@@ -1,85 +0,0 @@
-The following examples shows how to use the cimax+usb driver.
-All structures and macro are defined in file cimax+usb-driver.h.
-
-
-1.Open the device cimax+usb
-===========================
-/* open device */
-dev = open("/dev/cimaxusb0", O_RDWR);
-/* select USB alt_setting */
-ioctl(dev, DEVICE_IOC_SELECT_INTF, alt_setting);
-
-
-2.Close the device cimax+usb
-============================
-/* unlock read queue */
-ioctl(dev, DEVICE_IOC_UNLOCK_READ, 0);
-/* close device */
-close(dev);
-
-
-3.Send a CI message to a CAM through the device
-===============================================
-/* Send CAM A Reset command */
-uint8 command[5] = {0x01,    /* Command       */
-										0x01,    /* Counter       */
-										0x00,    /* MSB data size */
-										0x01,    /* LSB data size */
-										0x00};   /* data          */
-uint8 response[4100];
-struct ioctl_data_s stData;
-stData.txData = command;
-stData.txSize = 5;
-stData.rxData = response;
-stData.rxSize = 4100;
-ioctl(dev, DEVICE_IOC_CI_WRITE, &stData);
-
-/* Send CAM B Get CIS command */
-uint8 command[5] = {0x82,    /* Command       */
-										0x01,    /* Counter       */
-										0x00,    /* MSB data size */
-										0x00};   /* LSB data size */
-uint8 response[4100];
-struct ioctl_data_s stData;
-stData.txData = command;
-stData.txSize = 4;
-stData.rxData = response;
-stData.rxSize = 4100;
-ioctl(dev, DEVICE_IOC_CI_WRITE, &stData);
-
-
-4.Send a Transport Stream to a CAM through the device
-=====================================================
-/* Send to CAM A */
-struct rw_data_s rwData;
-rwData.type = DEVICE_TYPE_TS_WRITE;
-rwData.moduleId = 0; /* CAM A */
-rwData.data = stream;
-rwData.size = size;
-rwData.copiedSize = 0;
-write(dev, &rwData, sizeof(struct rw_data_s));
-
-
-5.Read a Transport Stream from a CAM through the device
-=======================================================
-/* Read from CAM B */
-struct rw_data_s rwData;
-rwData.type = DEVICE_TYPE_TS_READ;
-rwData.moduleId = 1; /* CAM B */
-rwData.data = stream;
-rwData.size = size;
-rwData.copiedSize = 0;
-read(dev, &rwData, sizeof(struct rw_data_s));
-
-
-6.Read a CI message from a CAM through the device
-=================================================
-/* Read from CAM A */
-uint8 response[4096];
-struct rw_data_s rwData;
-rwData.type = DEVICE_TYPE_CI_READ;
-rwData.moduleId = 0; /* CAM A */
-rwData.data = response;
-rwData.size = 4096;
-rwData.copiedSize = 0;
-read(dev, &rwData, sizeof(struct rw_data_s));
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/Makefile b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/Makefile
deleted file mode 100644
index bc79945..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/Makefile
+++ /dev/null
@@ -1,35 +0,0 @@
-TARGET = cimax+usb_driver
-OBJS = cimax+usb_driver.o
-MDIR = drivers/misc
-
-ccflags-y = -DEXPORT_SYMTAB
-#ccflags-y = -DEXPORT_SYMTAB -DDEBUG
-CURRENT = $(shell uname -r)
-KDIR = /lib/modules/$(CURRENT)/build
-PWD = $(shell pwd)
-DEST = /lib/modules/$(CURRENT)/kernel/$(MDIR)
-
-obj-m := $(TARGET).o
-cimax+usb_driver-y :=  cimax+usb-driver.o cimax+usb_fw.o
-cimax+usb_driver-y +=  cimax+usb_config.o
-cimax+usb_driver-y +=  cimax+usb_time.o
-
-default:
-	make -C /usr/src/linux SUBDIRS=$(PWD) modules
-#	make -C /lib/modules/`uname -r`/build M=$(PWD) modules
-
-$(TARGET).o: $(OBJS)
-	$(LD) $(LD_RFLAG) -r -o $@ $(OBJS)
-
-ifneq (,$(findstring 2.4.,$(CURRENT)))
-install:
-	su -c "cp -v $(TARGET).o $(DEST) && /sbin/depmod -a"
-else
-install:
-	su -c "cp -v $(TARGET).ko $(DEST) && /sbin/depmod -a"
-endif
-
-clean:
-	-rm -f *.o *.ko .*.cmd .*.flags *.mod.c
-
--include $(KDIR)/Rules.make
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/bodydef.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/bodydef.h
deleted file mode 100644
index f93fef5..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/bodydef.h
+++ /dev/null
@@ -1,424 +0,0 @@
-/**************************************************************************//**
- * @file    bodydef.h
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- ******************************************************************************/
-
-#ifndef __BODYDEF_H
-#define __BODYDEF_H
-
-struct reg_s {
-	__u8     RegisterName[50];
-	__u16    RegAddr;
-};
-
-/*=======================================================================
- Input/Output Ports and Data Direction Registers
-=======================================================================*/
-struct reg_s cimax_reg_map[] = {
-	{"BUFFIN_CFG"                      , 0x0000},
-	{"BUFFIN_ADDR_LSB"                 , 0x0001},
-	{"BUFFIN_ADDR_MSB"                 , 0x0002},
-	{"BUFFIN_DATA"                     , 0x0003},
-	{"BUFFOUT_CFG"                     , 0x0004},
-	{"BUFFOUT_ADDR_LSB"                , 0x0005},
-	{"BUFFOUT_ADDR_MSB"                , 0x0006},
-	{"BUFFOUT_DATA"                    , 0x0007},
-	{"BOOT_Key"                        , 0x0008},
-	{"BOOT_Status"                     , 0x0009},
-	{"BOOT_Test "                      , 0x000A},
-	{"RxDMA_Ctrl"                      , 0x0010},
-	{"RxDMA_Status"                    , 0x0011},
-	{"RxDMA_DbgL"                      , 0x0012},
-	{"RxDMA_DbgH"                      , 0x0013},
-	{"SPI_Slave_Ctrl"                  , 0x0018},
-	{"SPI_Slave_Status"                , 0x0019},
-	{"SPI_Slave_Rx"                    , 0x001A},
-	{"SPI_Slave_Tx"                    , 0x001B},
-	{"SPI_Slave_Mask"                  , 0x001C},
-	{"UCSG_Ctrl"                       , 0x0020},
-	{"UCSG_Status"                     , 0x0021},
-	{"UCSG_RxData"                     , 0x0022},
-	{"UCSG_TxData"                     , 0x0023},
-	{"PCtrl_Ctrl"                      , 0x0028},
-	{"PCtrl_Status"                    , 0x0029},
-	{"PCtrl_NbByte_LSB"                , 0x002A},
-	{"PCtrl_NbByte_MSB"                , 0x002B},
-	{"SPI_Master_Ctl"                  , 0x0030},
-	{"SPI_Master_NCS"                  , 0x0031},
-	{"SPI_Master_Status"               , 0x0032},
-	{"SPI_Master_TxBuf"                , 0x0033},
-	{"SPI_Master_RxBuf"                , 0x0034},
-	{"BISTRAM_Ctl"                     , 0x0038},
-	{"BISTRAM_Bank"                    , 0x0039},
-	{"BISTRAM_Pat"                     , 0x003A},
-	{"BISTRAM_SM"                      , 0x003B},
-	{"BISTRAM_AddrLSB"                 , 0x003C},
-	{"BISTROM_Config"                  , 0x0040},
-	{"BISTROM_SignatureLSB"            , 0x0041},
-	{"BISTROM_SignatureMSB"            , 0x0042},
-	{"BISTROM_StartAddrLSB"            , 0x0043},
-	{"BISTROM_StartAddrMSB"            , 0x0044},
-	{"BISTROM_StopAddrLSB"             , 0x0045},
-	{"BISTROM_StopAddrMSB"             , 0x0046},
-	{"CkMan_Config"                    , 0x0048},
-	{"CkMan_Select"                    , 0x0049},
-	{"CkMan_Test"                      , 0x004A},
-	{"Revision_Number"                 , 0x004B},
-	{"CkMan_PD_Key"                    , 0x004C},
-	{"USB_Power_Mode"                  , 0x004D},
-	{"ResMan_Config"                   , 0x0050},
-	{"ResMan_Status"                   , 0x0051},
-	{"ResMan_WD"                      , 0x0052},
-	{"ResMan_WD_MSB"                   , 0x0053},
-	{"TxDMA_Ctrl"                      , 0x0058},
-	{"TxDMA_Status"                    , 0x0059},
-	{"TxDMA_StartAddrL"                , 0x005A},
-	{"TxDMA_StartAddrH"                , 0x005B},
-	{"TxDMA_StopAddrL"                 , 0x005C},
-	{"TxDMA_StopAddrH"                 , 0x005D},
-	{"CPU_Test"                      , 0x0060},
-	{"IrqMan_Config0"                  , 0x0068},
-	{"IrqMan_Config1"                  , 0x0069},
-	{"IrqMan_Irq0"                     , 0x006A},
-	{"IrqMan_NMI"                      , 0x006B},
-	{"IrqMan_SleepKey"                 , 0x006C},
-	{"Tim_Config"                      , 0x0070},
-	{"Tim_Value_LSB"                   , 0x0071},
-	{"Tim_Value_MSB"                   , 0x0072},
-	{"Tim_Comp_LSB"                    , 0x0073},
-	{"Tim_Comp_MSB"                    , 0x0074},
-	{"TI_Config"                       , 0x0076},
-	{"TI_Data"                      , 0x0077},
-	{"TI_Reg0"                      , 0x0078},
-	{"TI_Reg1"                      , 0x0079},
-	{"TI_Reg2"                      , 0x007A},
-	{"TI_Reg3"                      , 0x007B},
-	{"TI_Reg4"                      , 0x007C},
-	{"TI_ROM1"                      , 0x007D},
-	{"TI_ROM2"                      , 0x007E},
-	{"TI_ROM3"                      , 0x007F},
-	{"DVBCI_START_ADDR"                , 0x0100},
-	{"DVBCI_END_ADDR"                  , 0x017F},
-	{"DATA"                      , 0x0180},
-	{"CTRL"                      , 0x0181},
-	{"QB_HOST"                      , 0x0182},
-	{"LEN_HOST_LSB"                    , 0x0183},
-	{"LEN_HOST_MSB"                    , 0x0184},
-	{"FIFO_TX_TH_LSB"                  , 0x0185},
-	{"FIFO_TX_TH_MSB"                  , 0x0186},
-	{"FIFO_TX_D_NB_LSB"                , 0x0187},
-	{"FIFO_TX_D_NB_MSB"                , 0x0188},
-	{"QB_MOD_CURR"                     , 0x0189},
-	{"LEN_MOD_CURR_LSB"                , 0x018A},
-	{"LEN_MOD_CURR_MSB"                , 0x018B},
-	{"QB_MOD"                      , 0x018C},
-	{"LEN_MOD_LSB"                     , 0x018D},
-	{"LEN_MOD_MSB"                     , 0x018E},
-	{"FIFO_RX_TH_LSB"                  , 0x018F},
-	{"FIFO_RX_TH_MSB"                  , 0x0190},
-	{"FIFO_RX_D_NB_LSB"                , 0x0191},
-	{"FIFO_RX_D_NB_MSB"                , 0x0192},
-	{"IT_STATUS_0"                     , 0x0193},
-	{"IT_STATUS_1"                     , 0x0194},
-	{"IT_MASK_0"                      , 0x0195},
-	{"IT_MASK_1"                      , 0x0196},
-	{"IT_HOST_PIN_CFG"                 , 0x0200},
-	{"CFG_0"                      , 0x0201},
-	{"CFG_1"                      , 0x0202},
-	{"CFG_2"                      , 0x0203},
-	{"IT_HOST"                      , 0x0204},
-	{"MOD_IT_STATUS"                   , 0x0205},
-	{"MOD_IT_MASK"                     , 0x0206},
-	{"MOD_CTRL_A"                      , 0x0207},
-	{"MOD_CTRL_B"                      , 0x0208},
-	{"DEST_SEL"                      , 0x0209},
-	{"CAM_MSB_ADD"                     , 0x020A},
-	{"GPIO0_DIR"                      , 0x020B},
-	{"GPIO0_DATA_IN"                   , 0x020C},
-	{"GPIO0_DATA_OUT"                  , 0x020D},
-	{"GPIO0_STATUS"                    , 0x020E},
-	{"GPIO0_IT_MASK"                   , 0x020F},
-	{"GPIO0_DFT"                      , 0x0210},
-	{"GPIO0_MASK_DATA"                 , 0x0211},
-	{"GPIO1_DIR"                      , 0x0212},
-	{"GPIO1_DATA_IN"                   , 0x0213},
-	{"GPIO1_DATA_OUT"                  , 0x0214},
-	{"GPIO1_STATUS"                    , 0x0215},
-	{"GPIO1_IT_MASK"                   , 0x0216},
-	{"MEM_ACC_TIME_A"                  , 0x0217},
-	{"MEM_ACC_TIME_B"                  , 0x0218},
-	{"IO_ACC_TIME_A"                   , 0x0219},
-	{"IO_ACC_TIME_B"                   , 0x021A},
-	{"EXT_CH_ACC_TIME_A"               , 0x021B},
-	{"EXT_CH_ACC_TIME_B"               , 0x021C},
-	{"PAR_IF_0"                      , 0x021D},
-	{"PAR_IF_1"                      , 0x021E},
-	{"PAR_IF_CTRL"                     , 0x021F},
-	{"PCK_LENGTH"                      , 0x0220},
-	{"USB2TS_CTRL"                     , 0x0221},
-	{"USB2TS0_RDL"                    , 0x0222},
-	{"USB2TS1_RDL"                     , 0x0223},
-	{"TS2USB_CTRL"                     , 0x0224},
-	{"TSOUT_PAR_CTRL"                  , 0x0225},
-	{"TSOUT_PAR_CLK_SEL"               , 0x0226},
-	{"S2P_CH0_CTRL"                    , 0x0227},
-	{"S2P_CH1_CTRL"                    , 0x0228},
-	{"P2S_CH0_CTRL"                    , 0x0229},
-	{"P2S_CH1_CTRL"                    , 0x022A},
-	{"TS_IT_STATUS"                    , 0x022B},
-	{"TS_IT_MASK"                      , 0x022C},
-	{"IN_SEL"                      , 0x022D},
-	{"OUT_SEL"                      , 0x022E},
-	{"ROUTER_CAM_CH"                   , 0x022F},
-	{"ROUTER_CAM_MOD"                  , 0x0230},
-	{"FIFO_CTRL"                      , 0x0231},
-	{"FIFO1_2_STATUS"                  , 0x0232},
-	{"FIFO3_4_STATUS"                  , 0x0233},
-	{"GAP_REMOVER_CH0_CTRL"            , 0x0234},
-	{"GAP_REMOVER_CH1_CTRL"            , 0x0235},
-	{"SYNC_RTV_CTRL"                   , 0x0236},
-	{"SYNC_RTV_CH0_SYNC_NB"            , 0x0237},
-	{"SYNC_RTV_CH0_PATTERN"            , 0x0238},
-	{"SYNC_RTV_CH1_SYNC_NB"            , 0x0239},
-	{"SYNC_RTV_CH1_PATTERN"            , 0x023A},
-	{"SYNC_RTV_OFFSET_PATT"            , 0x023B},
-	{"CTRL_FILTER"                     , 0x023D},
-	{"PID_EN_FILTER_CH0"               , 0x023E},
-	{"PID_EN_FILTER_CH1"               , 0x023F},
-	{"PID_LSB_FILTER_CH0_0"            , 0x0240},
-	{"PID_MSB_FILTER_CH0_0"            , 0x0241},
-	{"PID_LSB_FILTER_CH0_1"            , 0x0242},
-	{"PID_MSB_FILTER_CH0_1"            , 0x0243},
-	{"PID_LSB_FILTER_CH0_2"            , 0x0244},
-	{"PID_MSB_FILTER_CH0_2"            , 0x0245},
-	{"PID_LSB_FILTER_CH0_3"            , 0x0246},
-	{"PID_MSB_FILTER_CH0_3"            , 0x0247},
-	{"PID_LSB_FILTER_CH0_4"            , 0x0248},
-	{"PID_MSB_FILTER_CH0_4"            , 0x0249},
-	{"PID_LSB_FILTER_CH0_5"            , 0x024A},
-	{"PID_MSB_FILTER_CH0_5"            , 0x024B},
-	{"PID_LSB_FILTER_CH0_6"            , 0x024C},
-	{"PID_MSB_FILTER_CH0_6"            , 0x024D},
-	{"PID_LSB_FILTER_CH0_7"            , 0x024E},
-	{"PID_MSB_FILTER_CH0_7"            , 0x024F},
-	{"PID_LSB_FILTER_CH1_0"            , 0x0260},
-	{"PID_MSB_FILTER_CH1_0"            , 0x0261},
-	{"PID_LSB_FILTER_CH1_1"            , 0x0262},
-	{"PID_MSB_FILTER_CH1_1"            , 0x0263},
-	{"PID_LSB_FILTER_CH1_2"            , 0x0264},
-	{"PID_MSB_FILTER_CH1_2"            , 0x0265},
-	{"PID_LSB_FILTER_CH1_3"            , 0x0266},
-	{"PID_MSB_FILTER_CH1_3"            , 0x0267},
-	{"PID_LSB_FILTER_CH1_4"            , 0x0268},
-	{"PID_MSB_FILTER_CH1_4"            , 0x0269},
-	{"PID_LSB_FILTER_CH1_5"            , 0x026A},
-	{"PID_MSB_FILTER_CH1_5"            , 0x026B},
-	{"PID_LSB_FILTER_CH1_6"            , 0x026C},
-	{"PID_MSB_FILTER_CH1_6"            , 0x026D},
-	{"PID_LSB_FILTER_CH1_7"            , 0x026E},
-	{"PID_MSB_FILTER_CH1_7"            , 0x026F},
-	{"PID_OLD_LSB_REMAPPER_0"          , 0x0280},
-	{"PID_OLD_MSB_REMAPPER_0"          , 0x0281},
-	{"PID_OLD_LSB_REMAPPER_1"          , 0x0282},
-	{"PID_OLD_MSB_REMAPPER_1"          , 0x0283},
-	{"PID_OLD_LSB_REMAPPER_2"          , 0x0284},
-	{"PID_OLD_MSB_REMAPPER_2"          , 0x0285},
-	{"PID_OLD_LSB_REMAPPER_3"          , 0x0286},
-	{"PID_OLD_MSB_REMAPPER_3"          , 0x0287},
-	{"PID_OLD_LSB_REMAPPER_4"          , 0x0288},
-	{"PID_OLD_MSB_REMAPPER_4"          , 0x0289},
-	{"PID_OLD_LSB_REMAPPER_5"          , 0x028A},
-	{"PID_OLD_MSB_REMAPPER_5"          , 0x028B},
-	{"PID_OLD_LSB_REMAPPER_6"          , 0x028C},
-	{"PID_OLD_MSB_REMAPPER_6"          , 0x028D},
-	{"PID_OLD_LSB_REMAPPER_7"          , 0x028E},
-	{"PID_OLD_MSB_REMAPPER_7"          , 0x028F},
-	{"PID_NEW_LSB_REMAPPER_0"          , 0x02A0},
-	{"PID_NEW_MSB_REMAPPER_0"          , 0x02A1},
-	{"PID_NEW_LSB_REMAPPER_1"          , 0x02A2},
-	{"PID_NEW_MSB_REMAPPER_1"          , 0x02A3},
-	{"PID_NEW_LSB_REMAPPER_2"          , 0x02A4},
-	{"PID_NEW_MSB_REMAPPER_2"          , 0x02A5},
-	{"PID_NEW_LSB_REMAPPER_3"          , 0x02A6},
-	{"PID_NEW_MSB_REMAPPER_3"          , 0x02A7},
-	{"PID_NEW_LSB_REMAPPER_4"          , 0x02A8},
-	{"PID_NEW_MSB_REMAPPER_4"          , 0x02A9},
-	{"PID_NEW_LSB_REMAPPER_5"         , 0x02AA},
-	{"PID_NEW_MSB_REMAPPER_5"          , 0x02AB},
-	{"PID_NEW_LSB_REMAPPER_6"          , 0x02AC},
-	{"PID_NEW_MSB_REMAPPER_6"          , 0x02AD},
-	{"PID_NEW_LSB_REMAPPER_7"          , 0x02AE},
-	{"PID_NEW_MSB_REMAPPER_7"          , 0x02AF},
-	{"MERGER_DIV_MICLK"                , 0x02C0},
-	{"PID_AND_SYNC_REMAPPER_CTRL"      , 0x02C1},
-	{"PID_EN_REMAPPER"                 , 0x02C2},
-	{"SYNC_SYMBOL"                     , 0x02C3},
-	{"PID_AND_SYNC_REMAPPER_INV_CTRL"  , 0x02C4},
-	{"BITRATE_CH0_LSB"                 , 0x02C5},
-	{"BITRATE_CH0_MSB"                 , 0x02C6},
-	{"BITRATE_CH1_LSB"                 , 0x02C7},
-	{"BITRATE_CH1_MSB"                 , 0x02C8},
-	{"STATUS_CLK_SWITCH_0"             , 0x02C9},
-	{"STATUS_CLK_SWITCH_1"             , 0x02CA},
-	{"RESET_CLK_SWITCH_0"              , 0x02CB},
-	{"RESET_CLK_SWITCH_1"              , 0x02CC},
-	{"PAD_DRVSTR_CTRL"                 , 0x02CD},
-	{"PAD_PUPD_CTRL"                   , 0x02CE},
-	{"PRE_HEADER_ADDER_CH0_0"          , 0x02D0},
-	{"PRE_HEADER_ADDER_CH0_1"          , 0x02D1},
-	{"PRE_HEADER_ADDER_CH0_2"          , 0x02D2},
-	{"PRE_HEADER_ADDER_CH0_3"          , 0x02D3},
-	{"PRE_HEADER_ADDER_CH0_4"          , 0x02D4},
-	{"PRE_HEADER_ADDER_CH0_5"          , 0x02D5},
-	{"PRE_HEADER_ADDER_CH0_6"          , 0x02D6},
-	{"PRE_HEADER_ADDER_CH0_7"          , 0x02D7},
-	{"PRE_HEADER_ADDER_CH0_8"          , 0x02D8},
-	{"PRE_HEADER_ADDER_CH0_9"          , 0x02D9},
-	{"PRE_HEADER_ADDER_CH0_10"         , 0x02DA},
-	{"PRE_HEADER_ADDER_CH0_11"         , 0x02DB},
-	{"PRE_HEADER_ADDER_CH1_0"          , 0x02E0},
-	{"PRE_HEADER_ADDER_CH1_1"          , 0x02E1},
-	{"PRE_HEADER_ADDER_CH1_2"          , 0x02E2},
-	{"PRE_HEADER_ADDER_CH1_3"          , 0x02E3},
-	{"PRE_HEADER_ADDER_CH1_4"          , 0x02E4},
-	{"PRE_HEADER_ADDER_CH1_5"          , 0x02E5},
-	{"PRE_HEADER_ADDER_CH1_6"          , 0x02E6},
-	{"PRE_HEADER_ADDER_CH1_7"          , 0x02E7},
-	{"PRE_HEADER_ADDER_CH1_8"          , 0x02E8},
-	{"PRE_HEADER_ADDER_CH1_9"          , 0x02E9},
-	{"PRE_HEADER_ADDER_CH1_10"         , 0x02EA},
-	{"PRE_HEADER_ADDER_CH1_11"         , 0x02EB},
-	{"PRE_HEADER_ADDER_CTRL"           , 0x02EC},
-	{"PRE_HEADER_ADDER_LEN"            , 0x02ED},
-	{"PRE_HEADER_REMOVER_CTRL"         , 0x02EE},
-	{"FSM_DVB"                      , 0x02F0},
-	{"TS2USB_FSM_DEBUG"                , 0x02F2},
-	{"TSOUT_PAR_FSM_DEBUG"             , 0x02F3},
-	{"GAP_REMOVER_FSM_DEBUG"           , 0x02F4},
-	{"PID_AND_SYNC_REMAPPER_FSM_DEBUG" , 0x02F5},
-	{"PRE_HEADER_ADDER_FSM_DEBUG"      , 0x02F6},
-	{"SYNC_RTV_FSM_DEBUG"              , 0x02F7},
-	{"CHECK_PHY_CLK"                   , 0x0E00},
-	{"CONTROL1"                      , 0x0E01},
-	{"WAKE_UP"                      , 0x0E02},
-	{"CONTROL2"                      , 0x0E03},
-	{"PHY_RELATED"                     , 0x0E04},
-	{"EP_CFG"                      , 0x0E05},
-	{"MAX_PKT_EP1L"                    , 0x0E06},
-	{"MAX_PKT_EP1H"                    , 0x0E07},
-	{"MAX_PKT_EP2L"                    , 0x0E08},
-	{"MAX_PKT_EP2H"                    , 0x0E09},
-	{"MAX_PKT_EP3L"                    , 0x0E0A},
-	{"MAX_PKT_EP3H"                    , 0x0E0B},
-	{"MAX_PKT_EP4L"                    , 0x0E0C},
-	{"MAX_PKT_EP4H"                    , 0x0E0D},
-	{"EPS_STALL_SET"                   , 0x0E10},
-	{"EPS_STALL_CLR"                   , 0x0E11},
-	{"EPS_ENABLE"                      , 0x0E12},
-	{"DMA_ACC_EPS"                     , 0x0E13},
-	{"CPU_ACC_EPS_EN"                  , 0x0E14},
-	{"SETUP_BYTE0"                     , 0x0E15},
-	{"SETUP_BYTE1"                     , 0x0E16},
-	{"SETUP_BYTE2"                     , 0x0E17},
-	{"SETUP_BYTE3"                     , 0x0E18},
-	{"SETUP_BYTE4"                     , 0x0E19},
-	{"SETUP_BYTE5"                     , 0x0E1A},
-	{"SETUP_BYTE6"                     , 0x0E1B},
-	{"SETUP_BYTE7"                     , 0x0E1C},
-	{"SETUP_DT_VLD"                    , 0x0E1D},
-	{"CLR_EPS_TOG"                     , 0x0E1E},
-	{"EP0_CTRL"                      , 0x0E20},
-	{"EP0_DATA_CNT"                    , 0x0E21},
-	{"EP0_DATA"                      , 0x0E22},
-	{"EP1_CTRL"                      , 0x0E30},
-	{"EP1_DATA_CNTL"                   , 0x0E31},
-	{"EP1_DATA_CNTH"                   , 0x0E32},
-	{"EP1_DATA"                      , 0x0E33},
-	{"EP1_HEADER"                      , 0x0E34},
-	{"EP2_CTRL"                      , 0x0E40},
-	{"EP2_DATA_CNTL"                   , 0x0E41},
-	{"EP2_DATA_CNTH"                   , 0x0E42},
-	{"EP2_DATA"                      , 0x0E43},
-	{"EP2_HEADER"                      , 0x0E44},
-	{"EP3_DATA_CNTL"                   , 0x0E50},
-	{"EP3_DATA_CNTH"                   , 0x0E51},
-	{"EP3_DATA"                      , 0x0E52},
-	{"EP3_HEADER"                      , 0x0E53},
-	{"EP3_HEADER_CNT"                  , 0x0E54},
-	{"EP3_HEADER_DATA"                 , 0x0E55},
-	{"EP4_DATA_CNTL"                   , 0x0E60},
-	{"EP4_DATA_CNTH"                   , 0x0E61},
-	{"EP4_DATA"                      , 0x0E62},
-	{"EP4_HEADER"                      , 0x0E63},
-	{"EP4_HEADER_CNT"                  , 0x0E64},
-	{"EP4_HEADER_DATA"                 , 0x0E65},
-	{"EP5_CTRL"                      , 0x0E70},
-	{"EP5_DATA_CNTL"                   , 0x0E71},
-	{"EP5_DATA_CNTH"                   , 0x0E72},
-	{"EP5_DATA"                      , 0x0E73},
-	{"MAX_PKT_EP5L"                    , 0x0E74},
-	{"MAX_PKT_EP5H"                    , 0x0E75},
-	{"EP6_DATA_CNTL"                   , 0x0E80},
-	{"EP6_DATA_CNTH"                   , 0x0E81},
-	{"EP6_DATA"                      , 0x0E82},
-	{"MAX_PKT_EP6L"                    , 0x0E83},
-	{"MAX_PKT_EP6H"                    , 0x0E84},
-	{"FRAME_NUML"                      , 0x0E90},
-	{"FRAME_NUMH"                      , 0x0E91},
-	{"FRAME_TIMEL"                     , 0x0E92},
-	{"FRAME_TIMEH"                     , 0x0E93},
-	{"STC_DIVL"                      , 0x0E94},
-	{"STC_DIVM"                      , 0x0E95},
-	{"STC_DIVH"                      , 0x0E96},
-	{"USB_STATUS"                      , 0x0E97},
-	{"DEV_STATE1"                      , 0x0E98},
-	{"DEV_STATE2"                      , 0x0E99},
-	{"DEV_STATE3"                      , 0x0E9A},
-	{"DEV_STATE4"                      , 0x0E9B},
-	{"INTR_EN1"                      , 0x0EA0},
-	{"INTR_EN2"                      , 0x0EA1},
-	{"INTR_EN3"                      , 0x0EA2},
-	{"INTR_EN4"                      , 0x0EA3},
-	{"INTR_SRC1"                      , 0x0EB0},
-	{"INTR_SRC2"                      , 0x0EB1},
-	{"INTR_SRC3"                      , 0x0EB2},
-	{"INTR_SRC4"                      , 0x0EB3},
-	{"INTR_FLAG1"                      , 0x0EC0},
-	{"INTR_FLAG2"                      , 0x0EC1},
-	{"INTR_FLAG3"                      , 0x0EC2},
-	{"INTR_FLAG4"                      , 0x0EC3},
-	{"EP0_INAK_CNT"                    , 0x0ED0},
-	{"EP0_ONAK_CNT"                    , 0x0ED1},
-	{"EP1_NAK_CNT"                     , 0x0ED2},
-	{"EP2_NAK_CNT"                     , 0x0ED3},
-	{"EP3_NAK_CNT"                     , 0x0ED4},
-	{"EP4_NAK_CNT"                     , 0x0ED5},
-	{"EP5_NAK_CNT"                     , 0x0ED6},
-	{"EP6_NAK_CNT"                     , 0x0ED7},
-	{"NAK_CNT_LEVEL"                   , 0x0ED8},
-	{"CC2_Buffer_out"                  , 0x2000},
-	{"CC2_Buffer_in"                   , 0x4000},
-	{"nmb_vector_address_lsb"          , 0xFFFA},
-	{"nmb_vector_address_msb"          , 0xFFFB},
-	{"reset_vector_address_lsb"        , 0xFFFC},
-	{"reset_vector_address_msb"        , 0xFFFD},
-	{"irb_vector_address_lsb"          , 0xFFFE},
-	{"irb_vector_address_msb"          , 0xFFFF}
-};
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb-driver.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb-driver.c
deleted file mode 100644
index 43cdcde..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb-driver.c
+++ /dev/null
@@ -1,2535 +0,0 @@
-/**************************************************************************//**
- * @file    cimax+usb-driver.c
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- ******************************************************************************/
-
-#define FRBIT
-/*#define DEBUG*/
-/*#define DEBUG_BITRATE*/
-/*#define DEBUG_ISOC_IN*/
-/*#define DEBUG_ISOC_OUT*/
-/*#define DEBUG_CONTINUITY*/
-
-/******************************************************************************
- * Include
- ******************************************************************************/
-#include <linux/slab.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/poll.h>
-#include <linux/usb.h>
-#include <linux/uaccess.h>
-#include <linux/mutex.h>
-#include <linux/list.h>
-#include <linux/hrtimer.h>
-#include <linux/ktime.h>
-#include <linux/dvb/ca.h>
-
-#include "cimax+usb-driver.h"
-#include "cimax+usb_fw.h"
-#include "cimax+usb_config.h"
-#ifdef TIMESTAMP
-#include "cimax+usb_time.h"
-#endif
-#include "../../aml_cimax_usb_priv.h"
-
-/******************************************************************************
- * Defines
- *****************************************************************************/
-#define DRIVER_VERSION "v1.1.2"
-#define DRIVER_AUTHOR "Bruno Tonelli, tonelli@smardtv.com"
-#define DRIVER_DESC "CIMaX+ USB Driver for Linux (c)2009-2011"
-
-#define DRIVER_MAX_NUMBER   1
-
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_LICENSE("GPL");
-
-/******************************************************************************
- * Structures
- ******************************************************************************/
-/******************************************************************************
- * Globals
- ******************************************************************************/
-#ifdef FRBIT
-int CimaxCfg = 1;
-module_param_named(CimaxCfg, CimaxCfg, int, 0644);
-MODULE_PARM_DESC(CimaxCfg, "Turn on/off configuration of CIMaX+ (default: on)");
-int CimaxDwnl = 1;
-module_param_named(CimaxDwnl, CimaxDwnl, int, 0644);
-MODULE_PARM_DESC(CimaxDwnl, "Enable upload of FW in CIMaX+ chip (default: on)");
-#endif
-
-static struct device_s *gdevice;
-static unsigned int gdeviceNumber;
-
-static struct usb_driver device_driver;
-static struct timespec gStart;
-
-static __u8 nullHeader[] = {
-	0x47, 0x1F, 0xFF, 0x1F, 0xFA, 0xDE, 0xBA, 0xBE
-};
-
-static struct bulk_timer_s gbulk_timer[DEVICE_NUM_CAM];
-int (*cimax_usb_dev_add)(struct device_s *device, int id);
-int (*cimax_usb_dev_remove)(struct device_s *device, int id);
-
-#ifdef TIMESTAMP
-static int bSetTimestamps;
-#endif
-
-/******************************************************************************
- * Functions
- ******************************************************************************/
-#ifdef DEBUG_CONTINUITY
-#define TS_MAXPIDS 8192                  /* max value of a PID */
-unsigned char    tab_cc[TS_MAXPIDS];
-
-__u16 get_ts_pid(unsigned char *pid)
-{
-	__u16 pp = 0;
-
-	pp = (pid[0] & 0X1f)<<8;
-	pp |= pid[1];
-
-	return pp;
-}
-
-static void init_tab_cc(void)
-{
-	memset(tab_cc, 0xff, TS_MAXPIDS);
-}
-
-static int dbg_cc(unsigned char *buf)
-{
-	int pid;
-	unsigned char cc;
-
-	if (buf[0] != DEVICE_MPEG2_SYNC_BYTE) {
-		err("Out Of Sync: ");
-		return -1;
-	}
-
-	pid = get_ts_pid(buf + 1);
-
-	if (!(buf[3] & 0x10))   /* no payload?*/
-		return 0;
-
-	if (buf[1] & 0x80)
-		err("Error in TS for PID: %d\n", pid);
-
-	/* Check continuity count*/
-	cc = tab_cc[pid];
-	if (cc == 255)
-		cc = (buf[3] & 15);
-	else {
-		cc = ((cc) + 1) & 15;
-		if (cc != (buf[3] & 15)) {
-			/* Otherwise, this is a real corruption */
-			err("pid %d cc %d expected cc %d actual\n",
-					pid, cc, buf[3] & 15);
-			cc = (buf[3] & 15);
-		}
-	}
-	return 0;
-}
-#endif
-
-/*-------------------------------------------------------------------*/
-#ifdef DEBUG
-static void dbg_dump(char *hdr, unsigned char *data, int size)
-{
-	int i;
-	char line[40];
-	char str[9];
-	line[0] = 0;
-	for (i = 0; i < size; i++) {
-		sprintf(line, "%s%.2x ", line, data[i]);
-		if ((data[i] >= 32) && (data[i] <= 126))
-			str[i%8] = data[i];
-		else
-			str[i%8] = '.';
-		if (!((i+1)%8)) {
-			str[i%8 + 1] = 0;
-			dbg_s("%s %s %s", hdr, line, str);
-			line[0] = 0;
-		} /* if */
-	} /* for */
-	if (i%8) {
-		int j;
-		str[i%8 + 1] = 0;
-		for (j = (i%8); j < 8; j++)
-			sprintf(line, "%s   ", line);
-		dbg_s("%s %s %s", hdr, line, str);
-		line[0] = 0;
-	} /* if */
-} /* dbg_dump */
-#else
-#define dbg_dump(format, arg...) do {} while (0)
-#endif /* DEBUG */
-
-static unsigned long copyDataFrom(int us,
-		void *to, const void *from, unsigned long n)
-{
-	if (us)
-		return copy_from_user(to, from, n);
-	memcpy(to, from, n);
-	return 0;
-}
-
-static unsigned long copyDataTo(int us,
-		void *to, const void *from, unsigned long n)
-{
-	if (us)
-		return copy_to_user(to, from, n);
-	memcpy(to, from, n);
-	return 0;
-}
-
-static void vb_init(struct video_buf_s *buf)
-{
-	buf->readOffset = 0;
-	buf->writeOffset = 0;
-	buf->isEmpty = 1;
-} /* vb_init */
-
-static int vb_get_write_size(struct video_buf_s *buf)
-{
-	int writeSize = 0;
-
-	if (buf->writeOffset == buf->readOffset) {
-		if (buf->isEmpty)
-			writeSize = DEVICE_VB_LENGTH;
-	} else if (buf->writeOffset > buf->readOffset)
-		writeSize =
-			DEVICE_VB_LENGTH - (buf->writeOffset - buf->readOffset);
-	else
-		writeSize = buf->readOffset - buf->writeOffset;
-	return writeSize;
-} /* vb_get_write_size */
-
-static int vb_write(struct video_buf_s *buf, __u8 *data, int size)
-{
-	int writeSize = vb_get_write_size(buf);
-	int firstPart = DEVICE_VB_LENGTH - buf->writeOffset;
-	if (size > writeSize)
-		size = writeSize;
-
-	if (size < firstPart) {
-		memcpy(&buf->data[buf->writeOffset], data, size);
-		buf->writeOffset += size;
-	} /* if */ else {
-		memcpy(&buf->data[buf->writeOffset], data, firstPart);
-		memcpy(buf->data, &data[firstPart], size - firstPart);
-		buf->writeOffset = size - firstPart;
-	} /* else */
-
-	if (size > 0)
-		buf->isEmpty = 0;
-	return size;
-} /* vb_write */
-
-static int vb_read_next(struct video_buf_s *buf, __u8 *data)
-{
-	int readSize;
-	int firstPart;
-	int nextOffset;
-	int isStuffing;
-	int ret;
-
-	readSize = DEVICE_VB_LENGTH - vb_get_write_size(buf);
-	nextOffset = buf->readOffset + DEVICE_MPEG2_PACKET_SIZE;
-	if (nextOffset >= DEVICE_VB_LENGTH)
-		nextOffset -= DEVICE_VB_LENGTH;
-	while (readSize > DEVICE_MPEG2_PACKET_SIZE) {
-		if ((buf->data[buf->readOffset] == DEVICE_MPEG2_SYNC_BYTE) &&
-			(buf->data[nextOffset] == DEVICE_MPEG2_SYNC_BYTE)) {
-			/* packet in sync */
-			break;
-		} /* if */
-		buf->readOffset++;
-		if (buf->readOffset == DEVICE_VB_LENGTH)
-			buf->readOffset = 0;
-		nextOffset++;
-		if (nextOffset == DEVICE_VB_LENGTH)
-			nextOffset = 0;
-		readSize--;
-	} /* while */
-	if (readSize <= DEVICE_MPEG2_PACKET_SIZE) {
-		buf->isEmpty = 1;
-		return 0;
-	} /* if */
-
-	/* packet is in sync, check if it is a stuffing packet */
-	isStuffing = 0;
-	firstPart = DEVICE_VB_LENGTH - buf->readOffset;
-	if (firstPart < DEVICE_NULL_HEADER_SIZE) {
-		if ((memcmp(nullHeader, &buf->data[buf->readOffset], firstPart)
-				== 0) &&
-				(memcmp(&nullHeader[firstPart], buf->data,
-					    DEVICE_NULL_HEADER_SIZE - firstPart)
-					== 0)) {
-			isStuffing = 1;
-		} /* if */
-	} /* if */
-	else {
-		if (memcmp(nullHeader, &buf->data[buf->readOffset],
-					DEVICE_NULL_HEADER_SIZE) == 0) {
-			isStuffing = 1;
-		} /* if */
-	} /* else */
-	readSize -= DEVICE_MPEG2_PACKET_SIZE;
-	if (readSize <= DEVICE_MPEG2_PACKET_SIZE)
-		buf->isEmpty = 1;
-
-	/* skip stuffing packet */
-	if (isStuffing) {
-		buf->readOffset = nextOffset;
-		return 0;
-	} /* if */
-
-	/* copy packet to user space */
-	if (firstPart >= DEVICE_MPEG2_PACKET_SIZE) {
-		ret = copy_to_user(data,
-			&buf->data[buf->readOffset], DEVICE_MPEG2_PACKET_SIZE);
-	} /* if */ else {
-		ret = copy_to_user(data,
-			&buf->data[buf->readOffset], firstPart);
-		ret = copy_to_user(&data[firstPart],
-			buf->data, DEVICE_MPEG2_PACKET_SIZE - firstPart);
-	} /* else */
-	buf->readOffset = nextOffset;
-	return DEVICE_MPEG2_PACKET_SIZE;
-} /* vb_read_next */
-
-/*-------------------------------------------------------------------*/
-#ifdef DEBUG_BITRATE
-static void print_bitrate(struct ts_channel_s *channel, __u8 channel_number)
-{
-	int     readSize;
-	ktime_t  currentTime;
-	int  diffTime_us;
-	int bitrate;
-
-	currentTime = ktime_get_real();
-	if (!(channel->bitrateTime.tv64)) {
-		channel->bitrateTime = currentTime;
-	} else {
-		readSize = DEVICE_VB_LENGTH - vb_get_write_size(&channel->inVb);
-		dbg("%d bytes received\n", readSize);
-		diffTime_us = (int)(ktime_us_delta(currentTime,
-					channel->bitrateTime));
-		if (diffTime_us) {
-			bitrate = (int)((readSize * 8 * USEC_PER_SEC)
-					/ diffTime_us);
-		}
-		channel->bitrateTime = currentTime;
-		dbg("received bitrate for channel[%d] = %dbps\n",
-			channel_number, bitrate);
-	}
-}
-#endif /* DEBUG_BITRATE */
-/*-------------------------------------------------------------------*/
-
-static void device_cibulk_complete(struct urb *urb)
-{
-	dbg("start");
-	kfree(urb->transfer_buffer);
-	usb_free_urb(urb);
-	dbg("end");
-} /* device_cibulk_complete */
-
-static int device_cibulk_send(struct device_s *device,
-		struct ioctl_data_s *data,
-		int user_space)
-{
-	int         res;
-	struct urb *urb;
-	int         size;
-	int         index = -1;
-	__u8        *ptr;
-	__u32       todo = data->txSize;
-	__u8        *userData = data->txData;
-
-	dbg("start");
-
-	do {
-		/* get a free bulk message */
-		urb = usb_alloc_urb(0, GFP_KERNEL);
-		if (!urb) {
-			err("alloc urb");
-			return -ENOMEM;
-		} /* if */
-		urb->dev = device->usbdev;
-
-		/* allocate bulk data */
-		size = device->ciBulk.outMaxPacketSize;
-		if (todo < size)
-			size = todo;
-		urb->transfer_buffer = kmalloc(size, GFP_KERNEL);
-		if (!urb->transfer_buffer) {
-			err("alloc transfer buffer");
-			usb_free_urb(urb);
-			return -ENOMEM;
-		} /* if */
-
-		/* copy data */
-		ptr = urb->transfer_buffer;
-		res = copyDataFrom(user_space, ptr, userData, size);
-
-#ifdef TIMESTAMP
-		if (bSetTimestamps) {
-			if (index == -1) {
-				SetTimestamp("urb %x, toSend %d, send %d",
-					    urb, todo, size);
-				SetTimestamp("cmd 0x%02x", ptr[0]);
-			} else {
-				SetTimestamp("urb %x, toSend %d, send %d",
-					    urb, todo, size);
-			}
-		}
-#endif
-
-		/* first packet, get index */
-		if (index == -1) {
-			if ((ptr[DEVICE_COMMAND_OFFSET] == DEVICE_CMD_INIT) ||
-				(ptr[DEVICE_COMMAND_OFFSET]
-					== DEVICE_CMD_WRITE_REG) ||
-				(ptr[DEVICE_COMMAND_OFFSET]
-					== DEVICE_CMD_READ_REG)) {
-				index = 0; /* register command, no module */
-			} else if (ptr[DEVICE_COMMAND_OFFSET]
-					& DEVICE_SEL_MASK) {
-				index = 1; /* module B */
-			} else {
-				index = 0; /* module A */
-			} /* else */
-			device->ciBulk.ciData[index].syncDataSize = 0;
-			device->ciBulk.ciData[index].syncSignal = 0;
-		} /* if */
-
-		/* submit bulk */
-		urb->pipe = usb_sndbulkpipe(device->usbdev,
-				DEVICE_BULK_OUT_PIPE);
-		urb->transfer_buffer_length = size;
-		urb->complete = device_cibulk_complete;
-		urb->context  = NULL;
-		dbg_dump("txBuf", urb->transfer_buffer,
-				urb->transfer_buffer_length);
-		res = usb_submit_urb(urb, GFP_KERNEL);
-		if (res < 0) {
-			err("submit urb res = %d", res);
-			kfree(urb->transfer_buffer);
-			usb_free_urb(urb);
-			return -ENOMEM;
-		} /* if */
-		todo -= size;
-		userData += size;
-	} while (todo);
-
-	device->ciBulk.ciData[index].bPendingSend = 1;
-	dbg("end");
-	return index;
-} /* device_cibulk_send */
-
-static void device_int_complete(struct urb *urb)
-{
-	unsigned long   flags;
-	struct device_s *device = urb->context;
-	__u8            *dataToCopy;
-	int             sizeToCopy, SizeReceived;
-	__u8            isFirstPacket = 0;
-	__u8            isLastPacket = 0;
-	__u8            index, i;
-	__u8            status;
-	struct message_node_s *message;
-
-	dbg("start");
-
-	if (urb->status) {
-		dbg("urb status %d, not submitted again", urb->status);
-		kfree(urb->transfer_buffer);
-		usb_free_urb(urb);
-		for (i = 0; i < DEVICE_NUM_INT_IN_URBS; i++) {
-			if (device->ciBulk.intUrb[i] == urb)
-				device->ciBulk.intUrb[i] = NULL;
-		}
-		return;
-	} /* if */
-
-	spin_lock_irqsave(&device->ciBulk.intUrbLock, flags);
-	dbg("urb status %d, transfer_buffer_length %d actual_length %d",
-			urb->status,
-			urb->transfer_buffer_length,
-			urb->actual_length);
-	dataToCopy = urb->transfer_buffer;
-	SizeReceived =  urb->actual_length;
-	dbg_dump("total rxBuf", dataToCopy, SizeReceived);
-
-
-	do {
-		if (device->ciBulk.intSizeToReceive == 0) {
-			if (!dataToCopy[DEVICE_STATUS_OFFSET] &&
-					!dataToCopy[DEVICE_LENGTH_MSB_OFFSET] &&
-					!dataToCopy[DEVICE_LENGTH_LSB_OFFSET] &&
-					!dataToCopy[DEVICE_COUNTER_OFFSET]){
-				dbg("no data receive");
-				memset(urb->transfer_buffer,
-						0, urb->transfer_buffer_length);
-				usb_submit_urb(urb, GFP_ATOMIC);
-				return;
-			}
-			/* first packet, read header */
-			isFirstPacket = 1;
-			device->ciBulk.intCurrStatus =
-				dataToCopy[DEVICE_STATUS_OFFSET] &
-				DEVICE_CMD_MASK;
-			if (dataToCopy[DEVICE_STATUS_OFFSET]
-				& DEVICE_SEL_MASK) {
-				device->ciBulk.intCurrIndex = 1; /* module B */
-			} else {
-				device->ciBulk.intCurrIndex = 0; /* module A */
-			}
-			if ((device->ciBulk.intCurrStatus == DEVICE_READ_REGOK)
-				|| (device->ciBulk.intCurrStatus
-					== DEVICE_WRITE_REGOK)) {
-				device->ciBulk.intSizeToReceive =
-					dataToCopy[DEVICE_LENGTH_LSB_OFFSET] +
-					DEVICE_DATA_OFFSET;
-			} else {
-				device->ciBulk.intSizeToReceive =
-				dataToCopy[DEVICE_LENGTH_MSB_OFFSET] * 256
-					+ dataToCopy[DEVICE_LENGTH_LSB_OFFSET]
-					+ DEVICE_DATA_OFFSET;
-			}
-		} /* if */
-
-		/* get last packet state */
-		status     = device->ciBulk.intCurrStatus;
-		index      = device->ciBulk.intCurrIndex;
-		sizeToCopy = device->ciBulk.intSizeToReceive;
-		if (sizeToCopy > urb->actual_length) {
-			/* limit size to received buffer size */
-			sizeToCopy = urb->actual_length;
-		} /* if */ else
-			isLastPacket = 1;
-		dbg_dump("rxBuf", dataToCopy, sizeToCopy);
-
-#ifndef FRBIT
-		if (status == DEVICE_DATAREADY) {
-			if (device->ciBulk.ciData[index].bPendingSend)
-				status = DEVICE_DATAREADY_SYNC;
-		}
-#endif
-
-#ifdef TIMESTAMP
-		if (device->ciBulk.intSizeToReceive > 2000)
-			bSetTimestamps = 1;
-		if (bSetTimestamps) {
-			SetTimestamp("urb %x,toReceive %d,received %d,toCopy%d",
-				urb,
-				device->ciBulk.intSizeToReceive,
-				SizeReceived,
-				sizeToCopy);
-			SetTimestamp("status 0x%02x, camIndex %d, isLast %d",
-				status, index, isLastPacket);
-		}
-#endif
-
-		switch (status) {
-		case DEVICE_INITOK:
-		case DEVICE_READ_REGOK:
-		case DEVICE_WRITE_REGOK:
-			index = 0;
-		case DEVICE_CAMRESETOK:
-			/*only for debug*/
-			if (!dataToCopy[DEVICE_STATUS_OFFSET] &&
-				!dataToCopy[DEVICE_LENGTH_MSB_OFFSET] &&
-				!dataToCopy[DEVICE_LENGTH_LSB_OFFSET] &&
-				!dataToCopy[DEVICE_COUNTER_OFFSET]){
-				break;
-			}
-		case DEVICE_CISOK:
-		case DEVICE_WRITECOROK:
-		case DEVICE_NEGOTIATEOK:
-		case DEVICE_WRITELPDUOK:
-		case DEVICE_WRITELPDUBUSY:
-		case DEVICE_READLPDUOK:
-		case DEVICE_WRITEEXTOK:
-		case DEVICE_READEXTOK:
-		case DEVICE_NO_CAM:
-		case DEVICE_NOK:
-		case DEVICE_MCARD_WRITEOK:
-		case DEVICE_CAMPARSE_ERROR:
-		case DEVICE_CMDPENDING:
-		case DEVICE_REGSTATUSOK:
-		case DEVICE_DATAREADY_SYNC:
-			/* copy partial message */
-			spin_lock_irqsave(&device->ciBulk.intLock,
-				flags);
-			memcpy(&device->ciBulk.ciData[index].
-				syncData[device->ciBulk.ciData[index].
-				syncDataSize],
-				dataToCopy, sizeToCopy);
-			device->ciBulk.intSizeToReceive -= sizeToCopy;
-			device->ciBulk.ciData[index].syncDataSize +=
-				sizeToCopy;
-			spin_unlock_irqrestore(&device->ciBulk.intLock,
-				flags);
-			dbg("copied %d bytes at offset %d", sizeToCopy,
-				device->ciBulk.ciData[index].
-				syncDataSize - sizeToCopy);
-
-			if (isLastPacket) {
-				/* last packet received, sync message */
-				device->ciBulk.ciData[index].syncSignal = 1;
-				wake_up_interruptible(&device->ciBulk.
-					ciData[index].syncWait);
-				device->ciBulk.ciData[index].bPendingSend = 0;
-				dbg("sync signal return %d %d ",
-					device->ciBulk.ciData[index].
-						syncDataSize, index);
-			} /* if */
-			break;
-		case DEVICE_CAMDET:
-		case DEVICE_DATAREADY:
-		case DEVICE_MCARD_READ:
-		case DEVICE_FRBit:
-			if (isFirstPacket) {
-				/* create new async message */
-				message = kmalloc(sizeof(struct message_node_s),
-					GFP_ATOMIC);
-				if (!message) {
-					err("cannot allocate async message");
-					break;
-				}
-				memset(message,
-					0, sizeof(struct message_node_s));
-				list_add_tail(&message->node,
-					&device->ciBulk.ciData[index].
-						asyncDataList);
-			} /* if */
-			else {
-				/* get tail message */
-				message = list_entry((device->ciBulk.
-					ciData[index].asyncDataList.prev),
-					struct message_node_s, node);
-			} /* else */
-
-			/* copy partial message */
-			spin_lock_irqsave(&device->ciBulk.intLock, flags);
-			memcpy(&message->data[message->size],
-					dataToCopy, sizeToCopy);
-			device->ciBulk.intSizeToReceive -= sizeToCopy;
-			message->size += sizeToCopy;
-			spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
-			dbg("async copied %d bytes at offset %d", sizeToCopy,
-				message->size - sizeToCopy);
-
-			if (isLastPacket) {
-				/* last packet received, signal async message */
-				wake_up_interruptible(&device->ciBulk.
-					ciData[index].asyncWait);
-				dbg("async signal %d", index);
-			} /* if */
-			break;
-		case DEVICE_GPIOCHANGE:
-			info("GPIO change %x %x %x",
-				status, dataToCopy[4], dataToCopy[5]);
-			device->ciBulk.intSizeToReceive -= sizeToCopy;
-			break;
-		default:
-			err("unknown status 0x%2x", status);
-			break;
-		} /* switch */
-		dataToCopy += sizeToCopy;
-		SizeReceived -= sizeToCopy;
-
-	} while (SizeReceived > 0);
-
-	memset(urb->transfer_buffer, 0, urb->transfer_buffer_length);
-	usb_submit_urb(urb, GFP_ATOMIC);
-
-#ifdef TIMESTAMP
-	/*if (bSetTimestamps) {
-		SetTimestamp("urb %x submitted", urb);
-	}*/
-#endif
-
-	spin_unlock_irqrestore(&device->ciBulk.intUrbLock, flags);
-
-	dbg("end");
-} /* device_int_complete */
-
-static int device_wait_sync_data(struct device_s *device,
-		__u8          index,
-		struct ioctl_data_s *data,
-		int user_space)
-{
-	unsigned long flags;
-	int ret;
-
-	dbg("start %d", index);
-
-	spin_lock_irqsave(&device->ciBulk.intLock, flags);
-	while (device->ciBulk.ciData[index].syncSignal == 0) {
-		/* nothing to copy */
-		spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
-		if (wait_event_interruptible(device->ciBulk.
-				ciData[index].syncWait,
-				device->ciBulk.ciData[index].syncSignal)) {
-			device->ciBulk.ciData[index].bPendingSend = 0;
-			err("interrupt");
-			return -ERESTARTSYS;
-			/* signal: tell the fs layer to handle it */
-		} /* if */
-		/* otherwise loop, but first reacquire the lock */
-		spin_lock_irqsave(&device->ciBulk.intLock, flags);
-	} /* while */
-
-	/* copy packet to user space buffer */
-	if (device->ciBulk.ciData[index].syncDataSize < data->rxSize)
-		/* truncate returned message against user buffer size */
-		data->rxSize = device->ciBulk.ciData[index].syncDataSize;
-	spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
-	/* release the lock */
-	ret = copyDataTo(user_space,
-			data->rxData,
-			device->ciBulk.ciData[index].syncData, data->rxSize);
-	dbg_dump("userMsg",
-		device->ciBulk.ciData[index].syncData, data->rxSize);
-	dbg("userRet %d", data->rxSize);
-	device->ciBulk.ciData[index].syncDataSize = 0;
-	device->ciBulk.ciData[index].syncSignal = 0;
-
-	dbg("end");
-	return 0;
-} /* device_wait_sync_data */
-
-static int device_wait_async_data(struct device_s *device,
-		__u8       index,
-		struct rw_data_s *data,
-		int user_space)
-{
-	struct list_head *item;
-	struct message_node_s *message;
-	unsigned long     flags;
-	int ret;
-
-	dbg("start %d", index);
-
-	if ((device->askToRelease) || (device->askToSuspend)) {
-		err("ask to release or ask to suspend");
-		return -EINTR; /* device close interrupt */
-	} /* if */
-
-	if (index >= DEVICE_NUM_CAM) {
-		err("bad index(%d)", index);
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&device->ciBulk.intLock, flags);
-	while (list_empty(&device->ciBulk.ciData[index].asyncDataList)) {
-		/* nothing to copy */
-		spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
-		/* release the lock */
-		if (wait_event_interruptible(device->ciBulk.
-				ciData[index].asyncWait,
-			device->askToRelease ||
-			device->askToSuspend ||
-			(!list_empty(&device->ciBulk.
-				ciData[index].asyncDataList)))) {
-			err("interrupt");
-			return -ERESTARTSYS;
-			/* signal: tell the fs layer to handle it */
-		} /* if */
-		if ((device->askToRelease) || (device->askToSuspend)) {
-			err("ask to release or ask to suspend");
-			return -EINTR; /* device close interrupt */
-		} /* if */
-		/* otherwise loop, but first reacquire the lock */
-		spin_lock_irqsave(&device->ciBulk.intLock, flags);
-	} /* while */
-
-	/* ok, data is there, return first item */
-	item = device->ciBulk.ciData[index].asyncDataList.next;
-	message = list_entry(item, struct message_node_s, node);
-	if (message->size < data->size) {
-		/* truncate returned message against user buffer size */
-		data->size = message->size;
-	} /* if */
-	spin_unlock_irqrestore(&device->ciBulk.intLock, flags);
-	/* release the lock */
-	ret = copyDataTo(user_space, data->data, message->data, data->size);
-	dbg_dump("userMsg", message->data, data->size);
-	dbg("userRet %d", data->size);
-	list_del(item);
-	kfree(message);
-
-	dbg("end");
-	return 0;
-} /* device_wait_async_data */
-
-static int device_start_intr(struct device_s *device)
-{
-	__u8        i, j;
-	struct urb *urb;
-
-	dbg("start");
-
-	for (i = 0; i < DEVICE_NUM_INT_IN_URBS; i++) {
-		urb = usb_alloc_urb(0, GFP_KERNEL);
-		if (!urb) {
-			err("alloc urb");
-			return -ENOMEM;
-		} /* if */
-		urb->transfer_buffer =
-			kmalloc(device->ciBulk.inMaxPacketSize, GFP_KERNEL);
-		if (!urb->transfer_buffer) {
-			err("alloc transfer buffer");
-			usb_free_urb(urb);
-			urb = NULL;
-			return -ENOMEM;
-		} /* if */
-
-		urb->dev  = device->usbdev;
-		urb->pipe = usb_rcvintpipe(device->usbdev, DEVICE_INT_IN_PIPE);
-		urb->transfer_buffer_length = device->ciBulk.inMaxPacketSize;
-		urb->complete = device_int_complete;
-		urb->context  = device;
-		urb->interval = 1;
-		device->ciBulk.intUrb[i] = urb;
-		for (j = 0; j < DEVICE_NUM_CAM; j++) {
-			init_waitqueue_head(&device->ciBulk.ciData[j].syncWait);
-			init_waitqueue_head(&device->ciBulk.
-				ciData[j].asyncWait);
-		} /* for */
-		usb_submit_urb(device->ciBulk.intUrb[i], GFP_KERNEL);
-	}
-
-	dbg("end");
-	return 0;
-} /* device_start_intr */
-
-static void device_stop_intr(struct device_s *device)
-{
-	struct list_head *item;
-	struct list_head *tmp;
-	struct message_node_s *message;
-	int               i, j;
-
-	dbg("start");
-
-	for (i = 0; i < DEVICE_NUM_INT_IN_URBS; i++) {
-		if (!device->ciBulk.intUrb[i])
-			break;
-		usb_unlink_urb(device->ciBulk.intUrb[i]);
-		device->ciBulk.intUrb[i] = NULL;
-		for (j = 0; j < DEVICE_NUM_CAM; j++) {
-			for (item = device->ciBulk.ciData[j].asyncDataList.next;
-				item != &device->ciBulk.ciData[j].asyncDataList;
-				) {
-				message = list_entry(item,
-						struct message_node_s, node);
-				tmp = item->next;
-				list_del(item);
-				kfree(item);
-				item = tmp;
-			} /* for */
-		} /* for */
-		dbg("unlink urb");
-	}
-
-	dbg("end");
-} /* device_stop_intr */
-
-static void device_iso_in_complete(struct urb *urb)
-{
-	unsigned long flags;
-	struct ts_channel_s *channel = urb->context;
-	__u8          i;
-	__u8          *data;
-
-	/*dbg("start");*/
-
-	if (urb->status) {
-		dbg("urb status %d, not submitted again", urb->status);
-		kfree(urb->transfer_buffer);
-		usb_free_urb(urb);
-		return;
-	} /* if */
-
-	spin_lock_irqsave(&channel->inLock, flags);
-	for (i = 0; i < urb->number_of_packets; i++) {
-		data = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
-		if (!urb->iso_frame_desc[i].status &&
-				(urb->iso_frame_desc[i].actual_length > 0)) {
-			if (vb_get_write_size(&channel->inVb)
-				>= urb->iso_frame_desc[i].actual_length) {
-				vb_write(&channel->inVb, data,
-					urb->iso_frame_desc[i].actual_length);
-			} /* if */
-			else {
-				err("video buffer is full, packet loss %d",
-					urb->iso_frame_desc[i].actual_length);
-			} /* else */
-		} /* if */
-		else {
-			err("frame rejected, status %x, actual_length %d bytes",
-				urb->iso_frame_desc[i].status,
-				urb->iso_frame_desc[i].actual_length);
-		}
-	} /* for */
-	spin_unlock_irqrestore(&channel->inLock, flags);
-
-	if (!channel->inVb.isEmpty)
-		wake_up_interruptible(&channel->inWait);
-
-	memset(urb->transfer_buffer,
-		0, DEVICE_ISOC_LENGTH(channel->maxPacketSize));
-	urb->transfer_buffer_length =
-		DEVICE_ISOC_LENGTH(channel->maxPacketSize);
-	urb->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
-	urb->complete = device_iso_in_complete;
-	urb->context = channel;
-	urb->transfer_flags = URB_ISO_ASAP;
-	urb->interval = 1;
-	for (i = 0; i < DEVICE_NUM_FRAMES_PER_URB; i++) {
-		urb->iso_frame_desc[i].offset = i * channel->maxPacketSize;
-		urb->iso_frame_desc[i].length = channel->maxPacketSize;
-	} /* for */
-	usb_submit_urb(urb, GFP_ATOMIC);
-
-	/*dbg("end");*/
-} /* device_iso_in_complete */
-
-static void device_tsbulk_in_complete(struct urb *urb)
-{
-	unsigned long flags;
-	struct ts_channel_s *channel = urb->context;
-	__u8          *data;
-#ifdef DEBUG_CONTINUITY
-	unsigned int i;
-#endif
-
-	/*dbg("start");*/
-
-	if (urb->status) {
-		err("urb status %d(%x), not submitted again",
-			urb->status, urb->status);
-		kfree(urb->transfer_buffer);
-		usb_free_urb(urb);
-		return;
-	} /* if */
-
-	spin_lock_irqsave(&channel->inLock, flags);
-	data = urb->transfer_buffer;
-
-#ifdef DEBUG_CONTINUITY
-	i = 0;
-	/* check synchro byte*/
-	while (i < urb->actual_length) {
-		if (!((data[i] == DEVICE_MPEG2_SYNC_BYTE) &&
-			(data[i+DEVICE_MPEG2_PACKET_SIZE]
-				== DEVICE_MPEG2_SYNC_BYTE))) {
-			i++;
-		} else {
-			/* Synchro find*/
-			break;
-		}
-	}
-
-	/* Synchro Ok, check discontinuity*/
-	while (i < urb->actual_length) {
-		if (dbg_cc(&data[i]) < 0) {
-			dbg("(actual_length= %d i=%d pkt=%d)",
-				urb->actual_length,
-				i,
-				i/DEVICE_MPEG2_PACKET_SIZE);
-			dbg("%02x %02x %02x %02x %02x %02x %02x %02x\n",
-				data[i-4], data[i-3], data[i-2], data[i-1],
-				data[i], data[i+1], data[i+2], data[i+3]);
-		}
-		i += DEVICE_MPEG2_PACKET_SIZE;
-	}
-#endif
-
-	if (urb->actual_length) {
-		channel->nbByteRead += urb->actual_length;
-		if (vb_get_write_size(&channel->inVb) >= urb->actual_length)
-			vb_write(&channel->inVb, data, urb->actual_length);
-		else
-			err("video buffer is full, packet loss %d",
-				urb->actual_length);
-	} else {
-		/*warn("receive size of 0\n");*/
-	}
-
-	spin_unlock_irqrestore(&channel->inLock, flags);
-	/*  dbg("urb->actual_length=%d",urb->actual_length);*/
-	/*  info("urb->actual_length=%d\n",urb->actual_length);*/
-
-	if (!channel->inVb.isEmpty)
-		wake_up_interruptible(&channel->inWait);
-	kfree(urb->transfer_buffer);
-	usb_free_urb(urb);
-	/*dbg("end");*/
-} /* device_tsbulk_in_complete */
-
-static int device_fill_ts(struct device_s *device,
-		__u8       index,
-		struct rw_data_s *data)
-{
-	unsigned long flags;
-	__u32         copiedSize;
-	struct ts_channel_s *channel = &device->channel[index];
-
-	/*dbg("start");*/
-
-	spin_lock_irqsave(&channel->inLock, flags);
-	do {
-		while (channel->inVb.isEmpty) {
-			/* nothing to copy */
-			spin_unlock_irqrestore(&channel->inLock, flags);
-			/* release the lock */
-			if (wait_event_interruptible(channel->inWait,
-					    device->askToRelease ||
-					    device->askToSuspend ||
-					    (!channel->inVb.isEmpty))) {
-				err("interrupt");
-				return -ERESTARTSYS;
-				/* signal: tell the fs layer to handle it */
-			} /* if */
-			if ((device->askToRelease) || (device->askToSuspend)) {
-				err("ask to release or ask to suspend");
-				return -EINTR; /* device close interrupt */
-			} /* if */
-			/* otherwise loop, but first reacquire the lock */
-			spin_lock_irqsave(&channel->inLock, flags);
-		} /* while */
-
-		spin_unlock_irqrestore(&channel->inLock, flags);
-
-		copiedSize = vb_read_next(&channel->inVb,
-			&data->data[data->copiedSize]);
-		if (copiedSize) {
-			/*dbg("copied %d bytes in buffer 0x%p, offset %d",
-			  copiedSize, data->data, data->copiedSize);*/
-			data->copiedSize += copiedSize;
-		} /* if */
-		spin_lock_irqsave(&channel->inLock, flags);
-	} while ((data->copiedSize+DEVICE_MPEG2_PACKET_SIZE) <= data->size);
-	/* buffer not full */
-
-	spin_unlock_irqrestore(&channel->inLock, flags);
-
-#ifdef DEBUG_BITRATE
-	print_bitrate(channel, index);
-#endif
-
-	/*dbg("end, buffer 0x%p", data->data);*/
-	return 0;
-} /* device_fill_ts */
-
-static int device_start_iso_in(struct device_s *device, __u8 index)
-{
-	int         i, j;
-	int         ret = 0;
-	struct urb *urb;
-
-	/*dbg("start");*/
-
-#ifdef DEBUG_BITRATE
-	device->channel[index].bitrateTime = ktime_set(0, 0);
-#endif
-	for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++) {
-		urb = usb_alloc_urb(DEVICE_NUM_FRAMES_PER_URB, GFP_KERNEL);
-		device->channel[index].isocInUrb[i] = urb;
-		if (urb) {
-			/*urb->transfer_buffer =
-				kmalloc(DEVICE_ISOC_LENGTH, GFP_KERNEL);*/
-			urb->transfer_buffer =
-				kmalloc(DEVICE_ISOC_LENGTH(
-					device->channel[index].maxPacketSize),
-					GFP_KERNEL);
-			if (!urb->transfer_buffer) {
-				ret = -ENOMEM;
-				err("transfer_buffer allocation failed %d", i);
-				break;
-			} /* if */
-		} /* if */ else {
-			ret = -ENOMEM;
-			err("usb_alloc_urb failed %d", i);
-			break;
-		} /* if */
-	} /* for */
-
-	if (ret) {
-		/* Allocation error, must free already allocated data */
-		for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++) {
-			urb = device->channel[index].isocInUrb[i];
-			if (urb) {
-				kfree(urb->transfer_buffer);
-				if (urb->transfer_buffer)
-					urb->transfer_buffer = NULL;
-				usb_free_urb(urb);
-				device->channel[index].isocInUrb[i] = NULL;
-			} /* if */
-		} /* for */
-		return ret;
-	} /* if */
-
-	for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++) {
-		urb = device->channel[index].isocInUrb[i];
-		memset(urb->transfer_buffer,
-			0,
-			DEVICE_ISOC_LENGTH(
-				device->channel[index].maxPacketSize));
-		urb->transfer_buffer_length =
-			DEVICE_ISOC_LENGTH(
-				device->channel[index].maxPacketSize);
-		urb->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
-		urb->complete = device_iso_in_complete;
-		urb->context = &device->channel[index];
-		urb->dev = device->usbdev;
-		urb->pipe = usb_rcvisocpipe(
-			device->usbdev, DEVICE_TS_IN_PIPE + index);
-		urb->transfer_flags = URB_ISO_ASAP;
-		urb->interval = 1;
-		for (j = 0; j < DEVICE_NUM_FRAMES_PER_URB; j++) {
-			urb->iso_frame_desc[j].offset =
-				j * device->channel[index].maxPacketSize;
-			urb->iso_frame_desc[j].length =
-				device->channel[index].maxPacketSize;
-		} /* for */
-	} /* for */
-	for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++)
-		usb_submit_urb(device->channel[index].isocInUrb[i], GFP_KERNEL);
-
-	/*dbg("end");*/
-	return 0;
-} /* device_start_iso_in */
-
-static void device_stop_iso_in(struct device_s *device, __u8 index)
-{
-	int i;
-
-	/*dbg("start");*/
-
-	for (i = 0; i < DEVICE_NUM_ISOC_IN_URBS; i++) {
-		if (device->channel[index].isocInUrb[i]) {
-			usb_unlink_urb(device->channel[index].isocInUrb[i]);
-			device->channel[index].isocInUrb[i] = NULL;
-			dbg("unlink urb %i", i);
-		} /* if */
-	} /* for */
-
-	/*dbg("end");*/
-} /* device_stop_iso_in */
-
-static int device_start_tsbulk_in(struct device_s *device, __u8 index)
-{
-	struct urb *urb;
-
-	dbg("start");
-
-	urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (urb) {
-		urb->transfer_buffer  = kmalloc(3072, GFP_KERNEL);
-		if (!urb->transfer_buffer) {
-			err("transfer_buffer allocation failed");
-			usb_free_urb(urb);
-			return -ENOMEM;
-		} /* if */
-	} /* if */ else {
-		err("usb_alloc_urb failed");
-		return -ENOMEM;
-	} /* if */
-	device->channel[index].bulkInUrb = urb;
-	memset(urb->transfer_buffer, 0, 3072);
-	urb->transfer_buffer_length = 3072;
-
-	urb->complete = device_tsbulk_in_complete;
-	urb->context = &device->channel[index];
-	urb->dev = device->usbdev;
-	urb->pipe = usb_rcvbulkpipe(device->usbdev, DEVICE_TS_IN_PIPE + index);
-	usb_submit_urb(device->channel[index].bulkInUrb, GFP_KERNEL);
-
-	dbg("end");
-	return 0;
-} /* device_start_tsbulk_in */
-
-static void device_stop_tsbulk_in(struct device_s *device, __u8 index)
-{
-	dbg("start");
-
-	if (device->channel[index].bulkInUrb) {
-		usb_unlink_urb(device->channel[index].bulkInUrb);
-		device->channel[index].bulkInUrb = NULL;
-		dbg("unlink urb");
-	} /* if */
-
-	dbg("end");
-} /* device_stop_tsbulk_in */
-
-static void device_iso_out_complete(struct urb *urb)
-{
-	struct ts_channel_s *channel = urb->context;
-	struct urb    *tmpUrb;
-	int           i;
-	int ret = 0;
-
-	/*dbg("start");*/
-
-/*dbg_dump("txBuf", urb->transfer_buffer, urb->transfer_buffer_length);*/
-
-	if (urb->status || channel->outStop) {
-		/* error, free all coming urbs */
-		err("free urb");
-		channel->outStop = 1;
-		atomic_dec(&channel->numOutUrbs);
-		kfree(urb->transfer_buffer);
-		usb_free_urb(urb);
-		return;
-	} /* if */
-
-	for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS; i++) {
-		if (urb == channel->isocOutUrb[i])
-			break;
-	} /* for */
-	if (i == DEVICE_NUM_ISOC_OUT_URBS) {
-		/* urb must be deleted */
-		kfree(urb->transfer_buffer);
-		usb_free_urb(urb);
-	} /* if */
-
-	if (atomic_dec_and_test(&channel->numOutUrbs)) {
-		/* get next free urb */
-		tmpUrb = channel->isocOutUrb[channel->nextFreeOutUrbIndex++];
-		if (channel->nextFreeOutUrbIndex == DEVICE_NUM_ISOC_OUT_URBS)
-			channel->nextFreeOutUrbIndex = 0;
-
-		/* reinitialize urb with null packets */
-		memset(tmpUrb->transfer_buffer,
-			0xCD, DEVICE_ISOC_LENGTH(channel->maxPacketSize));
-		for (i = 0;
-			i < DEVICE_ISOC_LENGTH(channel->maxPacketSize);
-			i += DEVICE_MPEG2_PACKET_SIZE) {
-			memcpy(tmpUrb->transfer_buffer+i,
-				nullHeader, sizeof(nullHeader));
-		} /* for */
-		tmpUrb->transfer_buffer_length =
-			DEVICE_ISOC_LENGTH(channel->maxPacketSize);
-		tmpUrb->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
-		tmpUrb->complete = device_iso_out_complete;
-		tmpUrb->context = channel;
-		tmpUrb->transfer_flags = URB_ISO_ASAP;
-		tmpUrb->interval = 1;
-		for (i = 0; i < DEVICE_NUM_FRAMES_PER_URB; i++) {
-			tmpUrb->iso_frame_desc[i].offset =
-				i * channel->maxPacketSize;
-			tmpUrb->iso_frame_desc[i].length =
-				channel->maxPacketSize;
-		} /* for */
-
-		/* submit urb */
-		ret = usb_submit_urb(tmpUrb, GFP_ATOMIC);
-		if (ret)
-			err("usb_submit_urb failed %d", ret);
-
-		atomic_inc(&channel->numOutUrbs);
-	} /* if */
-
-	/*dbg("end");*/
-} /* device_iso_out_complete */
-
-static int device_tsiso_send(struct device_s *device,
-	__u8 index, __u8 *data, int size)
-{
-	int          i, j;
-	struct urb   **urb;
-	__u32        numUrbs;
-	int          ret = 0;
-
-	/*  dbg("start");*/
-
-	numUrbs =
-		size / DEVICE_ISOC_LENGTH(device->channel[index].maxPacketSize);
-	urb = kmalloc(numUrbs * sizeof(struct urb *), GFP_KERNEL);
-	if (!urb) {
-		err("urb array allocation failed %d", numUrbs);
-		return -ENOMEM;
-
-	} /* if */
-	memset(urb, 0, numUrbs * sizeof(struct urb *));
-
-	for (i = 0; i < numUrbs; i++) {
-		urb[i] = usb_alloc_urb(DEVICE_NUM_FRAMES_PER_URB, GFP_KERNEL);
-		if (urb[i]) {
-			urb[i]->transfer_buffer =
-				kmalloc(DEVICE_ISOC_LENGTH(
-					device->channel[index].maxPacketSize),
-						GFP_KERNEL);
-			if (!urb[i]->transfer_buffer) {
-				ret = -ENOMEM;
-				err("transfer_buffer allocation failed %d", i);
-				break;
-			} /* if */
-		} /* if */
-		else {
-			ret = -ENOMEM;
-			err("usb_alloc_urb failed %d", i);
-			break;
-		} /* if */
-	} /* for */
-	if (ret) {
-		/* Allocation error, must free already allocated data */
-		for (i = 0; i < numUrbs; i++) {
-			if (urb[i]) {
-				kfree(urb[i]->transfer_buffer);
-				urb[i]->transfer_buffer = NULL;
-				usb_free_urb(urb[i]);
-				urb[i] = NULL;
-			} /* if */
-		} /* for */
-		kfree(urb);
-		return ret;
-	} /* if */
-
-	for (i = 0; i < numUrbs; i++) {
-		ret = copy_from_user(urb[i]->transfer_buffer,
-			&data[i*DEVICE_ISOC_LENGTH(
-					device->channel[index].maxPacketSize)],
-				DEVICE_ISOC_LENGTH(
-					device->channel[index].maxPacketSize));
-		urb[i]->transfer_buffer_length = DEVICE_ISOC_LENGTH(
-			device->channel[index].maxPacketSize);
-		urb[i]->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
-		urb[i]->complete = device_iso_out_complete;
-		urb[i]->context = &device->channel[index];
-		urb[i]->dev = device->usbdev;
-		urb[i]->pipe = usb_sndisocpipe(device->usbdev,
-			DEVICE_TS_OUT_PIPE + index);
-		urb[i]->transfer_flags = URB_ISO_ASAP;
-		urb[i]->interval = 1;
-		for (j = 0; j < DEVICE_NUM_FRAMES_PER_URB; j++) {
-			urb[i]->iso_frame_desc[j].offset =
-				j * device->channel[index].maxPacketSize;
-			urb[i]->iso_frame_desc[j].length =
-				device->channel[index].maxPacketSize;
-		} /* for */
-	} /* for */
-
-	atomic_add(numUrbs, &device->channel[index].numOutUrbs);
-	for (i = 0; i < numUrbs; i++) {
-		ret = usb_submit_urb(urb[i], GFP_ATOMIC);
-		if (ret)
-			err("usb_submit_urb failed %d", ret);
-	} /* for */
-
-	kfree(urb);
-
-	/*  dbg("end");*/
-	return size;
-} /* device_tsiso_send */
-
-static int device_start_iso_out(struct device_s *device, __u8 index)
-{
-	int         i, j;
-	int         ret = 0;
-	struct urb  *urb;
-
-	/*dbg("start");*/
-
-	device->channel[index].outStop = 0;
-	for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS; i++) {
-		urb = usb_alloc_urb(DEVICE_NUM_FRAMES_PER_URB, GFP_KERNEL);
-		device->channel[index].isocOutUrb[i] = urb;
-		if (urb) {
-			urb->transfer_buffer = kmalloc(DEVICE_ISOC_LENGTH(
-				device->channel[index].maxPacketSize),
-				GFP_KERNEL);
-			if (!urb->transfer_buffer) {
-				ret = -ENOMEM;
-				err("transfer_buffer allocation failed %d", i);
-				break;
-			} /* if */
-		} /* if */ else {
-			ret = -ENOMEM;
-			err("usb_alloc_urb failed %d", i);
-			break;
-		} /* if */
-	} /* for */
-
-	if (ret) {
-		/* Allocation error, must free already allocated data */
-		for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS; i++) {
-			urb = device->channel[index].isocOutUrb[i];
-			if (urb) {
-				kfree(urb->transfer_buffer);
-				urb->transfer_buffer = NULL;
-				usb_free_urb(urb);
-				device->channel[index].isocOutUrb[i] = NULL;
-			} /* if */
-		} /* for */
-		return ret;
-	} /* if */
-
-	for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS; i++) {
-		urb = device->channel[index].isocOutUrb[i];
-		memset(urb->transfer_buffer, 0, DEVICE_ISOC_LENGTH(
-			device->channel[index].maxPacketSize));
-		for (j = 0;
-			j < DEVICE_ISOC_LENGTH(
-				device->channel[index].maxPacketSize);
-			j += DEVICE_MPEG2_PACKET_SIZE) {
-			memcpy(urb->transfer_buffer+j,
-				nullHeader, sizeof(nullHeader));
-		} /* for */
-		urb->transfer_buffer_length = DEVICE_ISOC_LENGTH(
-			device->channel[index].maxPacketSize);
-		urb->number_of_packets = DEVICE_NUM_FRAMES_PER_URB;
-		urb->complete = device_iso_out_complete;
-		urb->context = &device->channel[index];
-		urb->dev = device->usbdev;
-		urb->pipe = usb_sndisocpipe(device->usbdev,
-			DEVICE_TS_OUT_PIPE + index);
-		urb->transfer_flags = URB_ISO_ASAP;
-		urb->interval = 1;
-		for (j = 0; j < DEVICE_NUM_FRAMES_PER_URB; j++) {
-			urb->iso_frame_desc[j].offset =
-				j * device->channel[index].maxPacketSize;
-			urb->iso_frame_desc[j].length =
-				device->channel[index].maxPacketSize;
-		} /* for */
-	} /* for */
-	device->channel[index].nextFreeOutUrbIndex = DEVICE_NUM_ISOC_OUT_URBS-1;
-	atomic_set(&device->channel[index].numOutUrbs, 1);
-	for (i = 0; i < DEVICE_NUM_ISOC_OUT_URBS-1; i++) {
-		ret = usb_submit_urb(
-			device->channel[index].isocOutUrb[i], GFP_KERNEL);
-		if (ret)
-			err("usb_submit_urb failed %d", ret);
-	} /* for */
-
-	/*dbg("end");*/
-	return 0;
-} /* device_start_iso_out */
-
-static void device_stop_iso_out(struct device_s *device, __u8 index)
-{
-	dbg("start");
-
-	device->channel[index].outStop = 1;
-
-	dbg("end");
-} /* device_stop_iso_out */
-
-static void device_tsbulk_complete(struct urb *urb)
-{
-	struct device_s *device = urb->context;
-	__u8 index = 0;
-
-	/*dbg("start");*/
-	if (!urb->status) {
-		if (usb_endpoint_num(&(urb->ep->desc)) != DEVICE_TS_OUT_PIPE)
-			index = 1;
-		device->channel[index].nbByteSend += urb->actual_length;
-	}
-	kfree(urb->transfer_buffer);
-	usb_free_urb(urb);
-	/*dbg("end");*/
-} /* device_tsbulk_complete */
-
-static int device_tsbulk_send(struct device_s *device,
-	__u8 index, __u8 *data, int size)
-{
-	struct urb *urb;
-	/*  int         todo = size;*/
-	int ret = 0;
-
-	dbg("start");
-
-	/* get a free bulk message */
-	urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!urb) {
-		err("alloc urb");
-		return -ENOMEM;
-	} /* if */
-	urb->dev = device->usbdev;
-
-	/* allocate bulk data */
-	urb->transfer_buffer = kmalloc(size, GFP_KERNEL);
-	if (!urb->transfer_buffer) {
-		err("alloc transfer buffer");
-		usb_free_urb(urb);
-		return -ENOMEM;
-	} /* if */
-
-	/* copy data */
-	ret = copy_from_user(urb->transfer_buffer, data, size);
-
-	/* submit bulk */
-	urb->pipe = usb_sndbulkpipe(device->usbdev, DEVICE_TS_OUT_PIPE + index);
-	urb->transfer_buffer_length = size;
-	urb->complete = device_tsbulk_complete;
-	urb->context  = device;
-	/*dbg("Transmit %d bytes\n",urb->transfer_buffer_length);*/
-	/*dbg_dump("txBuf",
-		urb->transfer_buffer, urb->transfer_buffer_length);*/
-	mod_timer(&(device->channel[index].StartBulkReadTimer),
-		usecs_to_jiffies(50));
-
-	if (usb_submit_urb(urb, GFP_KERNEL) < 0) {
-		err("submit urb");
-		kfree(urb->transfer_buffer);
-		usb_free_urb(urb);
-		return -ENOMEM;
-	} /* if */
-
-	dbg("end");
-	return 0;
-} /* device_tsbulk_send */
-
-/* ---------------------------------------------------------- */
-static void StartBulkRead_func(unsigned long context)
-{
-	struct bulk_timer_s *bulk_time = (struct bulk_timer_s *) context;
-
-	device_start_tsbulk_in(bulk_time->device, bulk_time->index);
-}
-
-static int device_drv_open(struct device_s *device)
-{
-	int index;
-	mutex_lock(&device->lock);
-
-	if (!device->usbdev) {
-		err("no dev, can not start dev");
-		mutex_unlock(&device->lock);
-		return -ENODEV;
-	}
-
-	if (device->opened) {
-		mutex_unlock(&device->lock);
-		device->opened++;
-		info("udev=%p opened=%d", (device->usbdev), device->opened);
-		return 0;
-	} /* while */
-
-	info("set interface 0");
-	if (usb_set_interface(device->usbdev, 0, 0) < 0) {
-		mutex_unlock(&device->lock);
-		err("set_interface fail");
-		return -EINVAL;
-	} /* if */
-
-	device->opened++;
-	device->askToRelease = 0;
-	mutex_unlock(&device->lock);
-
-	for (index = 0; index < DEVICE_NUM_CAM; index++) {
-		device->channel[index].nbByteSend = -376;
-		device->channel[index].nbByteRead = 0;
-		device->channel[index].FirstTransfer = true;
-		gbulk_timer[index].device = device;
-		gbulk_timer[index].index = index;
-		setup_timer(&device->channel[index].StartBulkReadTimer,
-			StartBulkRead_func,
-			(unsigned long)&(gbulk_timer[index]));
-	}
-#ifdef DEBUG_CONTINUITY
-	init_tab_cc();
-#endif
-	info("udev=%p opened=%d", (device->usbdev), device->opened);
-	return 0;
-}
-
-static int device_ci_unlock_read(struct device_s *device)
-{
-	if (device->opened) {
-		/* release blocking functions */
-		device->askToRelease = 1;
-		wake_up_interruptible(&device->ciBulk.ciData[0].asyncWait);
-		wake_up_interruptible(&device->ciBulk.ciData[1].asyncWait);
-		wake_up_interruptible(&device->channel[0].inWait);
-		wake_up_interruptible(&device->channel[1].inWait);
-	}
-	return 0;
-}
-
-static int device_drv_close(struct device_s *device)
-{
-	int i;
-	mutex_lock(&device->lock);
-	if (device->opened && ((--device->opened) == 0)) {
-		device->askToRelease = 1;
-		device_stop_intr(device);
-		for (i = 0; i < DEVICE_NUM_CAM; i++) {
-			if (device->useIsoc) {
-				device_stop_iso_out(device, i);
-				device_stop_iso_in(device, i);
-			} else
-				device_stop_tsbulk_in(device, i);
-		} /* for */
-		device->opened = 0;
-	} /* if */
-	mutex_unlock(&device->lock);
-	return 0;
-}
-
-static int device_open(struct inode *inode, struct file *file)
-{
-	int       devnum = iminor(inode);
-#ifdef DEBUG
-	int        type = (MINOR(inode->i_rdev) >> 4);
-	int        num = (MINOR(inode->i_rdev) & 0xf);
-#endif
-	int   ret = 0;
-
-	struct device_s *device;
-
-	dbg("start, devnum = %d type = %d num = %d", devnum, type, num);
-
-	if (gdeviceNumber >= DRIVER_MAX_NUMBER) {
-		dbg("only support one device open");
-		return -EINVAL;
-	}
-	device = &gdevice[gdeviceNumber];
-	/*gdeviceNumber++;*/
-
-	ktime_get_ts(&gStart);
-
-	ret = device_drv_open(device);
-	if (ret < 0)
-		return ret;
-
-	file->f_pos = 0;
-	file->private_data = device;
-
-	dbg("end");
-	return nonseekable_open(inode, file);
-} /* device_open */
-
-static int device_release(struct inode *inode, struct file *file)
-{
-	struct device_s *device = (struct device_s *)file->private_data;
-
-	dbg("start");
-	device_drv_close(device);
-	dbg("end");
-	return 0;
-} /* device_release */
-
-int cimax_usb_select_interface(struct device_s *device, unsigned long intf)
-{
-	int          max    =  0;
-	int          mult    =  0;
-	int          ret    =  0;
-
-	info("set interface %ld", intf);
-	if (usb_set_interface(device->usbdev, 0, intf) < 0) {
-		err("set_interface failed interface 0, altSetting %ld", intf);
-		return -EINVAL;
-	} /* if */
-
-	/* check endpoints */
-	/* CI bulk out */
-	if (!usb_endpoint_is_bulk_out(
-			&device->usbdev->ep_out[DEVICE_BULK_OUT_PIPE]->desc)) {
-		err("unexpected endpoint %d", DEVICE_BULK_OUT_PIPE);
-		return -EINVAL;
-	} /* if */
-	device->ciBulk.outMaxPacketSize = DEVICE_BULK_OUT_MAXPACKET;
-	dbg("CI bulk out (endpoint %d), packet size %d", DEVICE_BULK_OUT_PIPE,
-			device->ciBulk.outMaxPacketSize);
-	/* CI int in */
-	if (!usb_endpoint_is_int_in(
-			&device->usbdev->ep_in[DEVICE_INT_IN_PIPE]->desc)) {
-		err("unexpected endpoint %d", DEVICE_INT_IN_PIPE);
-		return -EINVAL;
-	} /* if */
-	device->ciBulk.inMaxPacketSize =
-		device->usbdev->ep_in[DEVICE_INT_IN_PIPE]->desc.wMaxPacketSize;
-	dbg("CI int in (endpoint %d), packet size %d", DEVICE_INT_IN_PIPE,
-			device->ciBulk.inMaxPacketSize);
-	/* TS out */
-	if (device->usbdev->ep_out[DEVICE_TS_OUT_PIPE] == NULL)
-		dbg("no TS endpoint");
-	else {
-		if (usb_endpoint_is_bulk_out(
-			&device->usbdev->ep_out[DEVICE_TS_OUT_PIPE]->desc)) {
-			device->useIsoc = 0;
-			dbg("TS is configured as bulk");
-		} else if (usb_endpoint_is_isoc_out(
-			&device->usbdev->ep_out[DEVICE_TS_OUT_PIPE]->desc)) {
-			device->useIsoc = 1;
-			dbg("TS is configured as isochronous");
-		} else {
-			err("unexpected endpoint %d", DEVICE_TS_OUT_PIPE);
-			return -EINVAL;
-		} /* if */
-		max = device->usbdev->
-			ep_out[DEVICE_TS_OUT_PIPE]->desc.wMaxPacketSize;
-		mult = 1 + ((max >> 11) & 0x03);
-		max &= 0x7ff;
-		device->channel[0].maxPacketSize = max * mult;
-		dbg("TS out (endpoint %d), packet size %d", DEVICE_TS_OUT_PIPE,
-				device->channel[0].maxPacketSize);
-
-		max = device->usbdev->
-			ep_out[DEVICE_TS_OUT_PIPE+1]->desc.wMaxPacketSize;
-		mult = 1 + ((max >> 11) & 0x03);
-		max &= 0x7ff;
-		device->channel[1].maxPacketSize = max * mult;
-		dbg("TS out (endpoint %d), packet size %d",
-				DEVICE_TS_OUT_PIPE + 1,
-				device->channel[1].maxPacketSize);
-	}
-
-	/* start intr urb */
-	if (device->ciBulk.intUrb[0] == NULL) {
-		ret = device_start_intr(device);
-		if (ret < 0) {
-			err("cannot start int urb");
-			return ret;
-		} /* if */
-	} /* if */
-
-	return ret;
-}
-EXPORT_SYMBOL(cimax_usb_select_interface);
-
-static int device_ci_write(struct device_s *device,
-		struct ioctl_data_s *data, int isIoctl)
-{
-	int ret = 0;
-	if (!device)
-		return -ENODEV;
-	ret = device_cibulk_send(device, data, isIoctl);
-	if (ret < 0)
-		return ret;
-	return device_wait_sync_data(device, ret, data, isIoctl);
-}
-
-static int device_ci_write_ioctl(struct device_s *device,
-		struct ioctl_data_s *data)
-{
-	return device_ci_write(device, data, 1);
-}
-
-int cimax_usb_ci_write(struct device_s *device,
-		u8 *txData, int txSize, u8 *rxData, int rxSize)
-{
-	struct ioctl_data_s data;
-	if (!device)
-		return -ENODEV;
-	memset(&data, 0, sizeof(data));
-	data.txData = txData;
-	data.txSize = txSize;
-	data.rxData = rxData;
-	data.rxSize = rxSize;
-	return device_ci_write(device, &data, 0);
-}
-EXPORT_SYMBOL(cimax_usb_ci_write);
-
-int cimax_usb_ci_read_evt(struct device_s *device,
-		int moduleId, u8 *buf, int size)
-{
-	int ret = 0;
-	struct rw_data_s data;
-	if (!device || !device->opened)
-		return -ENODEV;
-	memset(&data, 0, sizeof(data));
-	data.moduleId = moduleId;
-	data.data = buf;
-	data.size = size;
-	ret = device_wait_async_data(device, data.moduleId, &data, 0);
-	if (ret < 0) {
-		err("wait ci read failed");
-		return ret;
-	} /* if */
-	dbg("return CI, moduleId %d, data 0x%p, size %d",
-			data.moduleId, data.data, data.size);
-	return ret;
-}
-EXPORT_SYMBOL(cimax_usb_ci_read_evt);
-
-int cimax_usb_device_open(struct device_s *device)
-{
-	return device_drv_open(device);
-}
-EXPORT_SYMBOL(cimax_usb_device_open);
-
-int cimax_usb_device_unlock_read(struct device_s *device)
-{
-	int ret = 0;
-	if (!device)
-		return 0;
-	mutex_lock(&device->lock);
-	ret = device_ci_unlock_read(device);
-	mutex_unlock(&device->lock);
-	return ret;
-}
-EXPORT_SYMBOL(cimax_usb_device_unlock_read);
-
-int cimax_usb_device_close(struct device_s *device)
-{
-	if (!device)
-		return 0;
-	cimax_usb_device_unlock_read(device);
-	if (cimax_usb_dev_remove)
-		cimax_usb_dev_remove(device, gdeviceNumber);
-	return device_drv_close(device);
-}
-EXPORT_SYMBOL(cimax_usb_device_close);
-
-static long device_ioctl(struct file *file,
-		unsigned int cmd, unsigned long arg)
-{
-	struct device_s *device = (struct device_s *)file->private_data;
-	int          err    = 0;
-	int          ret    = 0;
-	struct ioctl_data_s data;
-	void         *transfer_buffer = NULL;
-
-	dbg("start");
-
-	/* Don't decode wrong cmds: return ENOTTY (inappropriate ioctl) */
-	if (_IOC_TYPE(cmd) != DEVICE_IOC_MAGIC)
-		return -ENOTTY;
-	if (_IOC_NR(cmd) > DEVICE_IOC_MAXNR)
-		return -ENOTTY;
-
-	/* Verify direction (read/write) */
-	if (_IOC_DIR(cmd) & _IOC_READ)
-		err = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
-	else if (_IOC_DIR(cmd) & _IOC_WRITE)
-		err = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
-	if (err)
-		return -EFAULT;
-
-	if (mutex_lock_interruptible(&device->lock))
-		return -ERESTARTSYS;
-
-	switch (cmd) {
-	case DEVICE_IOC_SELECT_INTF:
-		dbg("DEVICE_IOC_SELECT_INTF start");
-		ret = cimax_usb_select_interface(device, arg);
-		dbg("DEVICE_IOC_SELECT_INTF end");
-		break;
-
-	case DEVICE_IOC_CI_WRITE:
-		dbg("DEVICE_IOC_CI_WRITE start");
-
-		/* send CI message */
-		ret = copy_from_user(&data,
-			(void __user *)arg, sizeof(struct ioctl_data_s));
-		dbg("inMsg, rx 0x%p, rxSize %d, tx 0x%p, txSize %d",
-			data.rxData,
-			data.rxSize,
-			data.txData,
-			data.txSize);
-		ret = device_ci_write_ioctl(device, &data);
-		if (ret < 0)
-			break;
-		ret = copy_to_user((void __user *)arg,
-			&data, sizeof(struct ioctl_data_s));
-
-		dbg("DEVICE_IOC_CI_WRITE end");
-		break;
-
-	case DEVICE_IOC_UNLOCK_READ:
-		dbg("DEVICE_IOC_UNLOCK_READ start");
-
-		ret = device_ci_unlock_read(device);
-
-		dbg("DEVICE_IOC_UNLOCK_READ end");
-		break;
-
-	case DEVICE_IOC_SET_CONFIG:
-		dbg("DEVICE_IOC_SET_CONFIG start");
-
-		/* send CI message */
-		ret = copy_from_user(&data,
-			(void __user *)arg, sizeof(struct ioctl_data_s));
-		dbg("inMsg, rx 0x%p, rxSize %d, tx 0x%p, txSize %d",
-			data.rxData, data.rxSize,
-			data.txData, data.txSize);
-		transfer_buffer = kmalloc(data.txSize, GFP_KERNEL);
-		memcpy(transfer_buffer, data.txData, data.txSize);
-		dbg_dump("New config", transfer_buffer, data.txSize);
-		err = usb_control_msg(device->usbdev,
-			usb_sndctrlpipe(device->usbdev, 0),
-			USB_REQ_SET_DESCRIPTOR,
-			USB_TYPE_STANDARD,
-			(USB_DT_CONFIG << 8),
-			0,
-			transfer_buffer,
-			data.txSize,
-			5000);
-		if (err < 0) {
-			err("set_config failed %d", err);
-			ret = -EINVAL;
-		}
-		kfree(transfer_buffer);
-		dbg("DEVICE_IOC_SET_CONFIG end");
-		break;
-
-	default:
-		ret = -ENOIOCTLCMD;
-		break;
-	} /* switch */
-	mutex_unlock(&device->lock);
-
-	dbg("end, ret %d", ret);
-	return ret;
-} /* device_ioctl */
-
-static ssize_t device_write(struct file *file, const char __user *buf,
-		size_t count, loff_t *ppos)
-{
-	int       ret;
-	struct rw_data_s data;
-	struct device_s *device = (struct device_s *)file->private_data;
-
-	dbg("start");
-
-	/* get transmission buffer */
-	ret = copy_from_user(&data, buf, sizeof(struct rw_data_s));
-	dbg("txBuffer, moduleId %u, data 0x%p, size %d",
-			data.moduleId, data.data, data.size);
-	if (data.moduleId >= DEVICE_NUM_CAM) {
-		err("bad moduleId");
-		return 0;
-	}
-
-	if (device->useIsoc) {
-		if (!data.size || (data.size % DEVICE_ISOC_LENGTH(
-			device->channel[data.moduleId].maxPacketSize))) {
-			err("transmission buffer size must be a multiple of %d",
-				DEVICE_ISOC_LENGTH(
-				device->channel[data.moduleId].maxPacketSize));
-			return -EINVAL;
-		} /* if */
-	}
-
-	if (device->useIsoc) {
-		if (device->channel[data.moduleId].isocInUrb[0] == NULL) {
-			ret = device_start_iso_in(device, data.moduleId);
-			if (ret < 0)
-				return ret;
-		} /* if */
-
-		if (device->channel[data.moduleId].isocOutUrb[0] == NULL) {
-			ret = device_start_iso_out(device, data.moduleId);
-			if (ret < 0)
-				return ret;
-		} /* if */
-
-		dbg("call device_tsiso_send moduleId %d, data 0x%p, size %d",
-			data.moduleId, data.data, data.size);
-		ret = device_tsiso_send(device,
-			data.moduleId, data.data, data.size);
-	} /* if */
-	else {
-		ret = device_tsbulk_send(device,
-			data.moduleId, data.data, data.size);
-	} /* else */
-
-	dbg("end, moduleId %d return %d", data.moduleId, ret);
-	return ret;
-} /* device_write */
-
-static ssize_t device_read(struct file *file, char __user *buf,
-		size_t count, loff_t *ppos)
-{
-	int       res;
-	struct rw_data_s data;
-	struct device_s *device = (struct device_s *)file->private_data;
-
-	dbg("start");
-
-	if (count != sizeof(struct rw_data_s)) {
-		err("try to read uncorrect size %zd", count);
-		return -EFAULT;
-	} /* if */
-	res = copy_from_user(&data, buf, sizeof(struct rw_data_s));
-	data.copiedSize = 0;
-	if (data.type == DEVICE_TYPE_TS_READ) {
-		res = device_fill_ts(device, data.moduleId, &data);
-		if (res < 0) {
-			err("fill ts buffer failed");
-			return res;
-		} /* if */
-		dbg("return TS, moduleId %d, data 0x%p, size %d, copiedSize %d",
-			data.moduleId, data.data, data.size, data.copiedSize);
-		/*res = count;*/
-		res = data.copiedSize;
-	} /* if */
-	else if (data.type == DEVICE_TYPE_CI_READ) {
-		res = device_wait_async_data(device, data.moduleId, &data, 1);
-		if (res < 0) {
-			err("wait ci read failed");
-			return res;
-		} /* if */
-		dbg("return CI, moduleId %d, data 0x%p, size %d",
-				data.moduleId, data.data, data.size);
-		res = data.size;
-	} /* else if */
-	else {
-		err("unknown data type %d", data.type);
-		res = -EFAULT;
-	} /* else */
-
-	dbg("end, return %d", res);
-	return res;
-} /* device_read */
-
-/******************************************************************************
- * @brief
- *   write data on Control endpoint.
- *
-
- * @param   dev
- *   Pointer to usb device.
- *
- * @param   addr
-
- *   register address to write.
- *
- * @param   data
- *   data to write.
- *
-
- * @param   size
- *   size to write.
- *
- * @return
-
- *   data writen or ENODEV error
- ******************************************************************************/
-int write_ctrl_message(struct usb_device *dev, int addr, void *data, int size)
-{
-	int ret;
-	void *ptr = NULL;
-#ifdef DEBUG
-	/*   int i;*/
-	/*   unsigned char dump[500];*/
-#endif
-
-	/*   info("%s: . addr = %04x size=%d",DRIVER_NAME,addr,size);*/
-
-	if (size <= 0)
-		return 0;
-
-	ptr = kmemdup(data, size, GFP_KERNEL);
-	if (!ptr)
-		return -ENOMEM;
-
-	ret = usb_control_msg
-			(dev, usb_sndctrlpipe(dev, 0), 0xA0, 0x40, addr, 0x0001,
-			ptr, size, 300);
-	if (ret != size) {
-		err("Failed to write CIMaX+ register 0x%04x", addr);
-		ret = -ENODEV;
-	}
-
-#ifdef DEBUG
-	/*   dump[0] =0;
-		 for(i=0;i<size;i++) {
-		 if((i !=0) && ((i%16) == 0)) {
-		 dbg("cimax+usb: %s",dump);
-		 dump[0] =0;
-		 }
-		 sprintf(dump,"%s%02x ",dump,((unsigned char *)ptr)[i]);
-		 }
-		 dbg("cimax+usb: %s",dump);
-	 */
-#endif
-	kfree(ptr);
-
-	return ret;
-}
-
-/******************************************************************************
- * @brief
- *   read data from Control endpoint.
- *
-
- * @param   dev
- *   Pointer to usb device.
- *
- * @param   addr
- *   firmware address to read.
-
- *
- * @param   data
- *   pointer to buffer to fill with register data.
- *
-
- * @param   size
- *   size to read.
- *
- * @return
- *   data writen or ENODEV error
-
- ******************************************************************************/
-int read_ctrl_message(struct usb_device *dev, int addr, void *data, int size)
-{
-	int ret;
-	ret = usb_control_msg
-			(dev, usb_rcvctrlpipe(dev, 0), 0xA0, 0xC0, addr, 0x0001,
-			(void *)data, size, 300);
-	if (ret != size) {
-		err("Failed to read CIMaX+ register 0x%04x return %d",
-			addr, ret);
-		ret = -ENODEV;
-	}
-	return ret;
-}
-
-/******************************************************************************
- * @brief
- *   Start new Firmware.
- *
- * @param   dev
- *   Pointer to usb device.
- *
- * @return
- *   None.
- ******************************************************************************/
-int init_fw(struct usb_device *dev)
-{
-	int len;
-	char *bootStatus = NULL;
-	bootStatus = kmalloc(sizeof(char), GFP_KERNEL);
-	if (!bootStatus) {
-		pr_err("%s: init_fw kmalloc failed\n",
-				DRIVER_NAME);
-		return 0;
-	}
-
-	info("%s: .", DRIVER_NAME);
-	len = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
-		0xA0, 0xC0, 0x0000, 0x0000, bootStatus, 1, 100);
-	if (len == 1) {
-		info("--> Init Status = %02X", *bootStatus);
-		if (bootStatus)
-			kfree(bootStatus);
-		return 0;
-	}
-	if (bootStatus)
-		kfree(bootStatus);
-
-	return len;
-}
-
-/******************************************************************************
- * @brief
- *   Start new Firmware.
- *
- * @param   dev
- *   Pointer to usb device.
-
- *
- * @return
- *   None.
- ******************************************************************************/
-int write_ep6_message(struct usb_device *dev, void *data, int size)
-{
-	int ret;
-	void * ptr = NULL;
-	ptr = kmemdup(data, size, GFP_KERNEL);
-	if (!ptr)
-		return -ENOMEM;
-
-	if (usb_bulk_msg(dev, usb_sndbulkpipe(dev, 6),
-			ptr, size, &ret, 200) < 0) {
-		err("Failed to write cmd 0x%02x", ((unsigned char *)data)[0]);
-		ret = -ENODEV;
-	}
-	kfree(ptr);
-	return ret;
-}
-
-/******************************************************************************
- * @brief
- *   Start new Firmware.
- *
- * @param   dev
- *   Pointer to usb device.
- *
- * @return
- *   None.
- ******************************************************************************/
-int read_ep5_message(struct usb_device *dev, void *data, int size)
-{
-	int ret;
-
-	if (usb_interrupt_msg(dev, usb_rcvintpipe(dev, 5),
-			data, size, &ret, 200) < 0) {
-		err("Failed read interrupt endpoint");
-		ret = -ENODEV;
-	}
-	return ret;
-}
-
-#ifdef CONFIG_COMPAT
-static long device_compat_ioctl(struct file *filp,
-		unsigned int cmd, unsigned long args)
-{
-	unsigned long ret;
-
-	args = (unsigned long)compat_ptr(args);
-	ret = device_ioctl(filp, cmd, args);
-	return ret;
-}
-#endif
-
-static const struct file_operations device_fops = {
-	.owner   = THIS_MODULE,
-	.open    = device_open,
-	.release = device_release,
-	.unlocked_ioctl = device_ioctl,
-	.write   = device_write,
-	.read    = device_read,
-	/*
-	.poll    = device_poll,
-	*/
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = device_compat_ioctl,
-#endif
-};
-
-struct cimaxusb_priv_ops_t cimaxusb_priv_ops = {
-	.write_ctrl_message  = write_ctrl_message,
-	.read_ctrl_message   = read_ctrl_message,
-	.init_fw             = init_fw,
-	.write_ep6_message   = write_ep6_message,
-	.read_ep5_message    = read_ep5_message
-};
-
-static struct usb_class_driver device_class = {
-	.name = "cimaxusb%d",
-	.fops = &device_fops,
-	.minor_base = DEVICE_MINOR,
-};
-
-/* ---------------------------------------------------------- */
-
-
-void cimax_usb_set_cb(void *cb1, void *cb2)
-{
-	cimax_usb_dev_add = cb1;
-	cimax_usb_dev_remove = cb2;
-}
-EXPORT_SYMBOL(cimax_usb_set_cb);
-
-static int device_probe(struct usb_interface *intf,
-		const struct usb_device_id *id)
-{
-	struct usb_device *usbdev = interface_to_usbdev(intf);
-	struct device_s *device;
-	char cmd[] = { 0x0C, 0x01, 0x00, 0x00 };
-	char *rsp;
-
-	dbg("start vendor id 0x%x, product id 0x%x, Device id 0x%x minor 0x%x",
-			le16_to_cpu(usbdev->descriptor.idVendor),
-			le16_to_cpu(usbdev->descriptor.idProduct),
-			le16_to_cpu(usbdev->descriptor.bcdDevice),
-			intf->minor);
-
-	/*  device = &gdevice[intf->minor];*/
-	device = &gdevice[gdeviceNumber];
-
-	mutex_lock(&device->lock);
-	/*  device->usbdev = usbdev;*/
-	device->usbdev = usb_get_dev(usbdev);
-	dbg("device->usbdev 0x%p", (device->usbdev));
-
-	/* set private callback functions */
-	device->ops = &cimaxusb_priv_ops;
-
-	device->askToSuspend = 0;
-
-	usb_set_intfdata(intf, device);
-	mutex_unlock(&device->lock);
-
-	if (usb_register_dev(intf, &device_class)) {
-		err("usb_register_dev");
-		usb_set_intfdata(intf, NULL);
-		return -ENOMEM;
-	} /* if */
-
-	/* test if firmware loafing is needed */
-#ifdef FRBIT
-	if ((le16_to_cpu(usbdev->descriptor.bcdDevice) != 0) &&
-			(CimaxDwnl == 1)) {
-#else
-	if (le16_to_cpu(usbdev->descriptor.bcdDevice) != 0) {
-#endif
-		info("start firmware download");
-		/* load firmware*/
-		cimaxusb_fw_upload(device);
-		info("end firmware download");
-	} else {
-		info("set alternate setting 1");
-		if (usb_set_interface(device->usbdev, 0, 1) < 0) {
-			err("set_interface failed intf 0, alt 1");
-		} else {
-			info("check FW version");
-			/* Get BOOT version */
-			if (write_ep6_message(device->usbdev,
-				cmd, sizeof(cmd)) == sizeof(cmd)) {
-				rsp = kcalloc(256,
-					sizeof(unsigned char),
-					GFP_KERNEL);
-				if (!rsp) {
-					err("out of memory");
-					return -ENOMEM;
-				}
-				if (read_ep5_message(device->usbdev,
-						rsp, 256) >= 0) {
-					info("=> ---- F.W. Version -------");
-					info("=>= %02X.%02X.%02X.%02X.%02X%c",
-						rsp[4], rsp[5], rsp[6],
-						rsp[7], rsp[8], rsp[9]);
-					info("=> Boot Version = %d.%d",
-						rsp[10], rsp[11]);
-					info("=> --------------------");
-				}
-				kfree(rsp);
-			}
-		}
-		info("start cfg download");
-		if (cimaxusb_configuration_setting(device) < 0)
-			err(" Error : set CIMaX+ configuration");
-		info("end cfg download");
-
-		if (cimax_usb_dev_add)
-			cimax_usb_dev_add(device, gdeviceNumber);
-	}
-
-	dbg("end");
-	return 0;
-} /* device_probe */
-
-static void device_disconnect(struct usb_interface *intf)
-{
-	struct device_s *device = usb_get_intfdata(intf);
-	int       i;
-
-	dbg("start");
-
-	if (!device)
-		return;
-
-	mutex_lock(&device->lock);
-	if (device->opened) {
-		/* release blocking functions */
-		device->askToRelease = 1;
-		wake_up_interruptible(&device->ciBulk.ciData[0].asyncWait);
-		wake_up_interruptible(&device->ciBulk.ciData[1].asyncWait);
-		wake_up_interruptible(&device->channel[0].inWait);
-		wake_up_interruptible(&device->channel[1].inWait);
-		device_stop_intr(device);
-		for (i = 0; i < DEVICE_NUM_CAM; i++) {
-			if (device->useIsoc) {
-				device_stop_iso_out(device, i);
-				device_stop_iso_in(device, i);
-			} /* if */
-			else
-				device_stop_tsbulk_in(device, i);
-		} /* for */
-		device->opened = 0;
-
-		if (cimax_usb_dev_remove)
-			cimax_usb_dev_remove(device, gdeviceNumber);
-	} /* if */
-	mutex_unlock(&device->lock);
-	usb_set_intfdata(intf, NULL);
-	if (device) {
-		usb_deregister_dev(intf, &device_class);
-		device->usbdev = NULL;
-	} /* if */
-	dbg("end");
-} /* device_disconnect */
-
-static int cimaxusb_suspend(struct usb_interface *intf, pm_message_t message)
-{
-	struct device_s *device = usb_get_intfdata(intf);
-	int       i;
-
-	dbg("start");
-
-	if (!device)
-		return 0;
-
-	mutex_lock(&device->lock);
-	if (device->opened) {
-		/* release blocking functions */
-		device->askToSuspend = 1;
-		wake_up_interruptible(&device->ciBulk.ciData[0].asyncWait);
-		wake_up_interruptible(&device->ciBulk.ciData[1].asyncWait);
-		wake_up_interruptible(&device->channel[0].inWait);
-		wake_up_interruptible(&device->channel[1].inWait);
-		device_stop_intr(device);
-		for (i = 0; i < DEVICE_NUM_CAM; i++) {
-			if (device->useIsoc) {
-				device_stop_iso_out(device, i);
-				device_stop_iso_in(device, i);
-			} /* if */
-			else
-				device_stop_tsbulk_in(device, i);
-		} /* for */
-		device->opened = 0;
-	} /* if */
-	mutex_unlock(&device->lock);
-	dbg("end");
-
-	return 0;
-}
-
-static int cimaxusb_resume(struct usb_interface *intf)
-{
-	struct device_s *device = usb_get_intfdata(intf);
-
-	dbg("start");
-
-	if (!device)
-		return 0;
-
-	device->askToSuspend = 0;
-	dbg("end");
-	return 0;
-}
-
-static struct usb_device_id device_ids[] = {
-	{ USB_DEVICE(0x1b0d, 0x2f00) },
-	{ USB_DEVICE(0x1b0d, 0x2f01) },
-	{ USB_DEVICE(0x1b0d, 0x2f02) },
-	{ USB_DEVICE(0x1b0d, 0x2f03) },
-	{ USB_DEVICE(0x1b0d, 0x2f04) },
-	{ }           /* Terminating entry */
-};
-
-MODULE_DEVICE_TABLE(usb, device_ids);
-
-
-static struct usb_driver device_driver = {
-	.name = "cimaxusb",
-	.probe = device_probe,
-	.disconnect = device_disconnect,
-	.suspend =  cimaxusb_suspend,
-	.resume = cimaxusb_resume,
-	.id_table = device_ids,
-};
-
-/* ---------------------------------------------------------- */
-
-static int device_init_module(void)
-{
-	int ret = 0;
-	int i, j;
-	struct device_s *device;
-
-	info("start");
-
-	if (!gdevice)
-		gdevice = kcalloc(DRIVER_MAX_NUMBER,
-			sizeof(struct device_s), GFP_KERNEL);
-	if (!gdevice) {
-		err("not enough memory");
-		return -ENOMEM;
-	}
-
-	for (i = 0; i < DRIVER_MAX_NUMBER; i++) {
-		device = &gdevice[i];
-		/* initialize struct */
-		memset(device, 0, sizeof(struct device_s));
-		mutex_init(&device->lock);
-
-		/* initialize ci bulk struct */
-		device->ciBulk.counter = 1;
-		spin_lock_init(&device->ciBulk.intLock);
-		spin_lock_init(&device->ciBulk.intUrbLock);
-		for (j = 0; j < DEVICE_NUM_CAM; j++) {
-			init_waitqueue_head(&device->ciBulk.ciData[j].syncWait);
-			init_waitqueue_head(
-				&device->ciBulk.ciData[j].asyncWait);
-			INIT_LIST_HEAD(&device->ciBulk.ciData[j].asyncDataList);
-		} /* for */
-
-		/* initialize channels */
-		for (j = 0; j < DEVICE_NUM_CAM; j++) {
-			spin_lock_init(&device->channel[j].inLock);
-			init_waitqueue_head(&device->channel[j].inWait);
-			vb_init(&device->channel[j].inVb);
-			device->channel[j].syncOffset = -1;
-			spin_lock_init(&device->channel[j].outLock);
-		} /* for */
-	} /* for */
-
-	/* register misc device */
-	ret = usb_register(&device_driver);
-
-#ifdef TIMESTAMP
-	InitTimestamp();
-#endif
-
-	if (ret)
-		info("end driver register failed");
-	else
-		info("end driver registered");
-
-	info(DRIVER_VERSION ":" DRIVER_DESC);
-
-	return ret;
-} /* device_init_module */
-
-static void device_exit_module(void)
-{
-	int i;
-	struct device_s *device;
-
-	info("start");
-
-#ifdef TIMESTAMP
-	ShowTimestamp();
-#endif
-
-	for (i = 0; i < DRIVER_MAX_NUMBER; i++) {
-		device = &gdevice[i];
-		device->askToRelease = 1;
-		/* destroy struct */
-		mutex_destroy(&device->lock);
-	} /* for */
-	usb_deregister(&device_driver);
-	gdeviceNumber = 0;
-
-	kfree(gdevice);
-	gdevice = NULL;
-	info("end");
-} /* device_exit_module */
-
-module_init(device_init_module);
-module_exit(device_exit_module);
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb-driver.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb-driver.h
deleted file mode 100644
index e4656e0..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb-driver.h
+++ /dev/null
@@ -1,362 +0,0 @@
-/**************************************************************************//**
- * @file    cimax+usb-driver.h
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- ******************************************************************************/
-
-#include <linux/version.h>
-
-#ifndef CIMAXPLUS_USB_DRIVER_H
-#define CIMAXPLUS_USB_DRIVER_H
-
-/******************************************************************************
- * Includes
- *****************************************************************************/
-/******************************************************************************
- * Defines
- *****************************************************************************/
-/**
- *  @brief
- *    Driver Name
- */
-#define DRIVER_NAME        "cimax+usb"
-/**
- *  @brief
- *    An unassigned USB minor.
- */
-#define DEVICE_MINOR                          240
-
-/**
- *  @brief
- *    Driver version.
- */
-#define DEVICE_VERSION                     0x1000
-
-/**
- *  @brief
- *    Number of CA module supported by the driver.
- */
-#define DEVICE_NUM_CAM                          2
-
-/**
- *  @brief
- *    Buffer length.
- */
-#define DEVICE_MESSAGE_LENGTH                4100
-
-/* Offset */
-#define DEVICE_COMMAND_OFFSET                   0
-#define DEVICE_STATUS_OFFSET                    0
-#define DEVICE_COUNTER_OFFSET                   1
-#define DEVICE_LENGTH_MSB_OFFSET                2
-#define DEVICE_LENGTH_LSB_OFFSET                3
-#define DEVICE_DATA_OFFSET                      4
-
-/* Mask */
-#define DEVICE_SEL_MASK                      0x80
-#define DEVICE_TYP_MASK                      0x40
-#define DEVICE_CMD_MASK                      0x3F
-
-/* Command tag */
-#define DEVICE_CMD_INIT                      0x00
-#define DEVICE_CMD_WRITE_REG                 0x7F
-#define DEVICE_CMD_READ_REG                  0xFF
-#define DEVICE_CMD_CAMRESET                  0x01
-#define DEVICE_CMD_GETCIS                    0x02
-#define DEVICE_CMD_WRITECOR                  0x03
-#define DEVICE_CMD_NEGOTIATE                 0x04
-#define DEVICE_CMD_WRITELPDU                 0x05
-#define DEVICE_CMD_READLPDU                  0x06
-#define DEVICE_CMD_WRITEEXT                  0x07
-#define DEVICE_CMD_READEXT                   0x08
-#define DEVICE_CMD_CC1RESET                  0x09
-#define DEVICE_CMD_MCARD_WRITE               0x0a
-
-/* Status field */
-#define DEVICE_CAMRESETOK                    0x00
-#define DEVICE_CISOK                         0x01
-#define DEVICE_WRITECOROK                    0x02
-#define DEVICE_NEGOTIATEOK                   0x03
-#define DEVICE_WRITELPDUOK                   0x04
-#define DEVICE_CAMDET                        0x05
-#define DEVICE_READLPDUOK                    0x06
-#define DEVICE_WRITEEXTOK                    0x07
-#define DEVICE_READEXTOK                     0x08
-#define DEVICE_NO_CAM                        0x09
-#define DEVICE_NOK                           0x0a
-#define DEVICE_INITOK                        0x0b
-#define DEVICE_READ_REGOK                    0x0c
-#define DEVICE_WRITE_REGOK                   0x0d
-#define DEVICE_DATAREADY                     0x0e
-#define DEVICE_MCARD_WRITEOK                 0x0f
-#define DEVICE_MCARD_READ                    0x10
-#define DEVICE_CAMPARSE_ERROR                0x11
-#define DEVICE_WRITELPDUBUSY                 0x14
-#define DEVICE_CMDPENDING                    0x16
-#define DEVICE_REGSTATUSOK                   0x17
-#define DEVICE_GPIOCHANGE                    0x18
-#define DEVICE_FRBit                         0x1A
-
-
-#define DEVICE_DATAREADY_SYNC                0x3e
-
-/**
- *  @brief
- *    MPEG2 transport size,.isochronous size and number of frames per URB.
- */
-#define DEVICE_MPEG2_PACKET_SIZE             188
-#define DEVICE_MPEG2_SYNC_BYTE               0x47
-#define DEVICE_NULL_HEADER_SIZE              8
-#define DEVICE_NUM_FRAMES_PER_URB            8
-#define DEVICE_ISOC_LENGTH(x)                (DEVICE_NUM_FRAMES_PER_URB*x)
-#define DEVICE_VB_LENGTH                     902400
-
-/**
- *  @brief
- *    Endpoint address.
- */
-#define DEVICE_TS_IN_PIPE                      1 /* and 2 */
-#define DEVICE_TS_OUT_PIPE                     3 /* and 4 */
-#define DEVICE_INT_IN_PIPE                     5
-#define DEVICE_BULK_OUT_PIPE                   6
-#define DEVICE_BULK_OUT_MAXPACKET            256
-
-/**
- *  @brief
- *    Number of isochronous/int URBs in the driver.
- */
-#define DEVICE_NUM_ISOC_OUT_URBS                3
-#define DEVICE_NUM_ISOC_IN_URBS                 2
-#define DEVICE_NUM_INT_IN_URBS                  2
-
-/**
- *  @brief
- *    ioctl() calls definition.
- */
-#define DEVICE_IOC_MAGIC        'a'
-#define DEVICE_IOC_SELECT_INTF  _IOWR(DEVICE_IOC_MAGIC,  0, signed long)
-#define DEVICE_IOC_CI_WRITE     _IOWR(DEVICE_IOC_MAGIC,  1, struct ioctl_data_s)
-#define DEVICE_IOC_UNLOCK_READ  _IOWR(DEVICE_IOC_MAGIC,  2, signed long)
-#define DEVICE_IOC_SET_CONFIG   _IOWR(DEVICE_IOC_MAGIC,  3, struct ioctl_data_s)
-#define DEVICE_IOC_MAXNR        4
-
-/******************************************************************************
- * Types
- *****************************************************************************/
-#ifdef __KERNEL__
-#include <linux/list.h>
-#include <linux/atomic.h>
-#include <linux/printk.h>
-
-#undef dbg
-#undef dbg_isoc_in
-#undef dbg_isoc_out
-
-#undef err
-#undef info
-#undef warn
-
-#define DEBUG
-
-#ifdef DEBUG
-#define dbg(format, arg...) pr_debug("cimax+usb: %s> " format "\n" , \
-		__func__, ## arg)
-#define dbg_s(format, arg...)\
-	pr_debug("cimax+usb: " format "\n" , ## arg)
-#else
-#define dbg(format, arg...) do {} while (0)
-#define dbg_s(format, arg...) do {} while (0)
-#endif
-
-#ifdef DEBUG_ISOC_IN
-#define dbg_isoc_in(format, arg...)\
-	pr_debug("cimax+usb: %s> " format "\n" , \
-			__func__, ## arg)
-#else
-#define dbg_isoc_in(format, arg...) do {} while (0)
-#endif
-
-#ifdef DEBUG_ISOC_OUT
-#define dbg_isoc_out(format, arg...)\
-	pr_debug("cimax+usb: %s> " format "\n" , \
-			__func__, ## arg)
-#else
-#define dbg_isoc_out(format, arg...) do {} while (0)
-#endif
-
-#define err(format, arg...)\
-	pr_err("cimax+usb: %s> ERROR " format "\n" , \
-			__func__, ## arg)
-#define info(format, arg...)\
-	pr_info("cimax+usb: %s> " format "\n" , \
-			__func__, ## arg)
-#define warn(format, arg...)\
-	pr_warn("cimax+usb: %s> WARN" format "\n" , \
-			__func__, ## arg)
-
-/**
- *  @brief
- *    Video buffer structure.
- */
-struct video_buf_s {
-	__u8 data[DEVICE_VB_LENGTH];
-	int  readOffset;
-	int  writeOffset;
-	int  isEmpty;
-};
-#endif
-
-/**
- *  @brief
- *    Io control data structure exchanged between user and kernel space.
- */
-struct ioctl_data_s {
-	__u8  *txData;
-	__u32 txSize;
-	__u8  *rxData;
-	__u32 rxSize;
-};
-
-/**
- *  @brief
- *    Read/write type exchanged between user and kernel space.
- */
-enum rw_type_e {
-	DEVICE_TYPE_CI_READ,
-	DEVICE_TYPE_TS_WRITE,
-	DEVICE_TYPE_TS_READ
-};
-
-/**
- *  @brief
- *    Read/write data structure exchanged between user and kernel space.
- */
-struct rw_data_s {
-	enum rw_type_e type;
-	__u8      moduleId;
-	__u8      *data;
-	__u32     size;
-	__u32     copiedSize;
-};
-#ifdef __KERNEL__
-/**
- *  @brief
- *    Message node structure. Can be inserted in a list.
- */
-struct message_node_s {
-	__u8              data[DEVICE_MESSAGE_LENGTH];
-	__u32             size;
-	struct list_head  node;
-};
-
-/**
- *  @brief
- *    Received CI data.
- */
-struct ci_rx_data_s {
-	wait_queue_head_t  syncWait;
-	__u8               syncSignal;
-	__u8               syncData[DEVICE_MESSAGE_LENGTH];
-	__u32              syncDataSize;
-	wait_queue_head_t  asyncWait;
-	struct list_head   asyncDataList;
-	__u8               bPendingSend;
-};
-
-/**
- *  @brief
- *    CI bulk channel.
- */
-struct ci_bulk_s {
-	__u8               counter;
-	__u16              inMaxPacketSize;
-	__u16              outMaxPacketSize;
-	struct urb         *intUrb[DEVICE_NUM_INT_IN_URBS];
-	spinlock_t         intLock;
-	spinlock_t         intUrbLock;
-	__u8               intCurrStatus;
-	__u8               intCurrIndex;
-	__u16              intSizeToReceive;
-	struct ci_rx_data_s       ciData[DEVICE_NUM_CAM];
-};
-
-/**
- *  @brief
- *    TS channel (can use isoc or bulk interface).
- */
-struct ts_channel_s {
-	spinlock_t        inLock;
-	wait_queue_head_t inWait;
-	struct video_buf_s       inVb;
-	int               syncOffset;
-	int               prevOffset;
-	__u8              lastPacket[DEVICE_MPEG2_PACKET_SIZE];
-	__u8              lastPacketSize;
-	spinlock_t        outLock;
-	__u8              nextFreeOutUrbIndex;
-	atomic_t          numOutUrbs;
-	__u8              outStop;
-	__u16             maxPacketSize;
-	/* isochronous urbs */
-	struct urb        *isocInUrb[DEVICE_NUM_ISOC_IN_URBS];
-	struct urb        *isocOutUrb[DEVICE_NUM_ISOC_OUT_URBS];
-	/* bulk urbs */
-	struct urb       *bulkInUrb;
-	int              nbByteSend;
-	int              nbByteRead;
-	__u8             FirstTransfer;
-	struct timer_list StartBulkReadTimer;
-
-#ifdef DEBUG_BITRATE
-	ktime_t bitrateTime
-#endif
-};
-
-struct device_s {
-	struct mutex       lock;
-	struct usb_device  *usbdev;
-	__u8               opened;
-	__u8               askToRelease;
-	__u8               askToSuspend;
-	struct ci_bulk_s          ciBulk;
-	__u8               useIsoc;
-	struct ts_channel_s       channel[DEVICE_NUM_CAM];
-	/* bus adapter private ops callback */
-	struct cimaxusb_priv_ops_t *ops;
-	int                ref;
-};
-
-struct bulk_timer_s {
-	struct device_s *device;
-	__u8      index;
-};
-
-int cimax_usb_select_interface(struct device_s *device, unsigned long intf);
-int cimax_usb_ci_write(struct device_s *device,
-		u8 *txData, int txSize, u8 *rxData, int rxSize);
-int cimax_usb_ci_read_evt(struct device_s *device,
-		int moduleId, u8 *buf, int size);
-
-int cimax_usb_device_unlock_read(struct device_s *device);
-int cimax_usb_device_open(struct device_s *device);
-int cimax_usb_device_close(struct device_s *device);
-void cimax_usb_set_cb(void *cb1, void *cb2);
-
-
-#endif
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_config.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_config.c
deleted file mode 100644
index 4469b87..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_config.c
+++ /dev/null
@@ -1,684 +0,0 @@
-/**************************************************************************//**
- * @file    cimax+usb_config.c
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- ******************************************************************************/
-/******************************************************************************
- * Include
- ******************************************************************************/
-
-
-#include <linux/slab.h>
-#include <linux/init.h>
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/poll.h>
-#include <linux/usb.h>
-
-#include <linux/errno.h>
-#include <linux/firmware.h>
-
-#include <linux/uaccess.h>
-#include <linux/mutex.h>
-
-#include "cimax+usb-driver.h"
-#include "cimax+usb_config.h"
-#include "bodydef.h"
-
-#include <linux/ctype.h>
-
-#define DEBUG
-#include <linux/printk.h>
-
-/******************************************************************************
- * Structures
- ******************************************************************************/
-/******************************************************************************
- * Globals
- ******************************************************************************/
-char *cimax_config_file[4] = {
-	"cimax+usb.cfg",
-	"cimax+usb_vcc0.cfg",
-	"cimax+usb_vcc3.cfg",
-	"cimax+usb_vcc5.cfg"
-};
-
-/******************************************************************************
- * Functions
- ******************************************************************************/
-/******************************************************************************
- * @brief
- *   set CIMaX+ register value.
- *
- * @param   bus_adap
- *   Pointer to CIMaX+ usb adapter.
- *
- * @param   addr
- *   Addr of CIMaX+ register.
- *
- * @param   val
- *   CIMaX+ register value to set.
- *
- * @return
- *   0 if OK otherwise -1.
- ******************************************************************************/
-int usb_setbyte(struct device_s *bus_adap, unsigned int addr, unsigned char val)
-{
-	unsigned char cmd[5];
-	unsigned char *buf;
-	int len;
-	struct usb_device *dev = bus_adap->usbdev;
-
-	cmd[0] = 0x7F;
-	cmd[1] = (unsigned char)((addr>>8)&0xff);
-	cmd[2] = (unsigned char)(addr&0xff);
-	cmd[3] = 0x01;
-	cmd[4] = val;
-	if (bus_adap->ops->write_ep6_message(dev, cmd, sizeof(cmd))
-		== sizeof(cmd)) {
-		/*pr_debug("%s-%s: cmd=0x%x\n",
-			DRIVER_NAME, __func__,cmd[0]);*/
-		buf = kcalloc(256, sizeof(unsigned char), GFP_KERNEL);
-		if (!buf) {
-			pr_err("%s-%s: out of memory.\n",
-				DRIVER_NAME, __func__);
-			return -ENOMEM;
-		}
-
-		while ((len = bus_adap->ops->read_ep5_message(dev, buf, 256))
-				>= 0) {
-			if (len == 0)
-				continue;
-			if ((len == 5) && ((buf[0] & 0x7f) == 0x45))
-				continue;
-			if (len < 4) {
-				pr_err("%s-%s: failed to read addr 0x%x\n",
-					DRIVER_NAME, __func__, addr);
-				kfree(buf);
-				return -1;
-			} else {
-				break;
-			}
-		}
-	} else {
-		pr_err("%s-%s: failed to write addr 0x%x\n",
-			DRIVER_NAME, __func__, addr);
-		return -1;
-	}
-	kfree(buf);
-	return 0;
-}
-
-/******************************************************************************
- * @brief
- *   get CIMaX+ register value.
- *
- * @param   bus_adap
- *   Pointer to CIMaX+ usb adapter.
- *
- * @param   addr
- *   Addr of CIMaX+ register.
- *
- * @param   val
- *   pointer to buffer to store CIMaX+ register value.
- *
- * @return
- *   0 if OK otherwise -1.
- ******************************************************************************/
-int usb_getbyte(struct device_s *bus_adap,
-	unsigned int addr, unsigned char *val)
-{
-	unsigned char cmd[4];
-	unsigned char *buf;
-	int len;
-	struct usb_device *dev = bus_adap->usbdev;
-
-	cmd[0] = 0xFF;
-	cmd[1] = (unsigned char)((addr>>8)&0xff);
-	cmd[2] = (unsigned char)(addr&0xff);
-	cmd[3] = 0x01;
-	if (bus_adap->ops->write_ep6_message(dev, cmd, sizeof(cmd))
-			== sizeof(cmd)) {
-		/*pr_debug("%s-%s: cmd=0x%x\n",
-			DRIVER_NAME, __func__,cmd[0]);*/
-		buf = kcalloc(256, sizeof(unsigned char), GFP_KERNEL);
-		if (!buf) {
-			pr_err("%s-%s: out of memory.\n",
-				DRIVER_NAME, __func__);
-			return -ENOMEM;
-		}
-
-		while ((len = bus_adap->ops->read_ep5_message(dev, buf, 256))
-				>= 0) {
-			if (len == 0)
-				continue;
-			/*pr_debug("%s-%s: 0x%x\n",
-				DRIVER_NAME, __func__,buf[0]);*/
-			if ((len == 5) && ((buf[0] & 0x7f) == 0x45))
-				continue;
-			if (len >= 5) {
-				*val = buf[4];
-				break;
-			} else {
-				pr_err("%s-%s: failed to read addr 0x%x\n",
-					DRIVER_NAME, __func__, addr);
-				kfree(buf);
-				return -1;
-			}
-		}
-	} else {
-		pr_err("%s-%s: failed to read addr 0x%x\n",
-			DRIVER_NAME, __func__, addr);
-		return -1;
-	}
-	kfree(buf);
-	return 0;
-}
-
-/******************************************************************************
- * @brief
- *   compute a logical Or between CIMaX+ register value and a param value.
- *
- * @param   bus_adap
- *   Pointer to CIMaX+ usb adapter.
- *
- * @param   addr
- *   Addr of CIMaX+ register.
- *
- * @param   val
- *   value to compute.
- *
- * @param   pval
- *   pointer to buffer to store CIMaX+ register value.
- *
- * @return
- *   0 if OK otherwise -1.
- ******************************************************************************/
-int setLogicalOr(struct device_s *bus_adap,
-		unsigned int addr, unsigned char val, unsigned char *pval)
-{
-	*pval |= val;
-
-	if (usb_setbyte(bus_adap, addr, *pval) < 0)
-		return -1;
-
-	if (usb_getbyte(bus_adap, addr, pval) < 0)
-		return -1;
-
-	dbg("=> Logical OR [%02X] => %02X\n", val, *pval);
-
-	return 0;
-}
-
-/******************************************************************************
- * @brief
- *   compute a logical And between CIMaX+ register value and a param value.
- *
- * @param   bus_adap
- *   Pointer to CIMaX+ usb adapter.
- *
- * @param   addr
- *   Addr of CIMaX+ register.
- *
- * @param   val
- *   value to compute.
- *
- * @param   pval
- *   pointer to buffer to store CIMaX+ register value.
- *
- * @return
- *   0 if OK otherwise -1.
- ******************************************************************************/
-int setLogicalAnd(struct device_s *bus_adap,
-		unsigned int addr, unsigned char val, unsigned char *pval)
-{
-	*pval &= val;
-
-	if (usb_setbyte(bus_adap, addr, *pval) < 0)
-		return -1;
-
-	if (usb_getbyte(bus_adap, addr, pval) < 0)
-		return -1;
-
-	dbg("=> Logical AND [%02X] => %02X\n", val, *pval);
-
-	return 0;
-}
-
-/******************************************************************************
- * @brief
- *   wait CIMaX+ register value match a param value.
- *
- * @param   bus_adap
- *   Pointer to CIMaX+ usb adapter.
- *
- * @param   addr
- *   Addr of CIMaX+ register.
- *
- * @param   val
- *   value to match.
- *
- * @param   pval
- *   pointer to buffer to store CIMaX+ register value.
- *
- * @return
- *   0 if OK otherwise -1.
- ******************************************************************************/
-int waitForValue(struct device_s *bus_adap,
-		unsigned int addr, unsigned char val, unsigned char *pval)
-{
-	dbg("=> Wait for Value [%02X]\n", val);
-	if (*pval == val)
-		return 0;
-
-	while (1) {
-		if (usb_getbyte(bus_adap, addr, pval) < 0)
-			return -1;
-
-		dbg("\r => %02X", *pval);
-
-		if (*pval == val)
-			break;
-	}
-
-	dbg("\n");
-
-	return 0;
-}
-
-/******************************************************************************
- * @brief
- *   wait CIMaX+ register bits match a param value.
- *
- * @param   bus_adap
- *   Pointer to CIMaX+ usb adapter.
- *
- * @param   addr
- *   Addr of CIMaX+ register.
- *
- * @param   val
- *   value to match.
- *
- * @param   pval
- *   pointer to buffer to store CIMaX+ register value.
- *
- * @return
- *   0 if OK otherwise -1.
- ******************************************************************************/
-int waitForBitsSet(struct device_s *bus_adap,
-		unsigned int addr, unsigned char val, unsigned char *pval)
-{
-	dbg("=> Wait for Bits set [%02X]\n", val);
-	if ((*pval & val) == val)
-		return 0;
-
-	while (1) {
-		if (usb_getbyte(bus_adap, addr, pval) < 0)
-			return -1;
-
-		dbg("\r => %02X", *pval);
-
-		if ((*pval & val) == val)
-			break;
-	}
-
-	dbg("\n");
-
-	return 0;
-}
-
-/******************************************************************************
- * @brief
- *   wait CIMaX+ register bits cleared.
- *
- * @param   bus_adap
- *   Pointer to CIMaX+ usb adapter.
- *
- * @param   addr
- *   Addr of CIMaX+ register.
- *
- * @param   val
- *   bits to check.
- *
- * @param   pval
- *   pointer to buffer to store CIMaX+ register value.
- *
- * @return
- *   0 if OK otherwise -1.
- ******************************************************************************/
-int waitForBitsCleared(struct device_s *bus_adap,
-		unsigned int addr, unsigned char val, unsigned char *pval)
-{
-	dbg("=> Wait for Bits cleared [%02X]\n", val);
-	if ((*pval & val) == 0x00)
-		return 0;
-
-	while (1) {
-		if (usb_getbyte(bus_adap, addr, pval) < 0)
-			return -1;
-
-		dbg("\r => %02X", *pval);
-
-		if ((*pval & val) == 0x00)
-			break;
-	}
-
-	dbg("\n");
-
-	return 0;
-}
-
-/******************************************************************************
- * @brief
- *   retreive addr of CIMaX+ register.
- *
- * @param   dev
- *   Pointer to CIMaX+ register Name.
- *
- * @return
- *   Address of CIMaX+ register.
- *****************************************************************************/
-int cimaxusb_rtr_reg_addr(char *str_addr)
-{
-	int i32NbItem = sizeof(cimax_reg_map) / sizeof(struct reg_s);
-	int i32index;
-	int i32ValAddr = -1;
-
-	for (i32index = 0; i32index < i32NbItem; i32index++) {
-		if (strcmp(str_addr, cimax_reg_map[i32index].RegisterName)
-				== 0) {
-			i32ValAddr = cimax_reg_map[i32index].RegAddr;
-			break;
-		}
-	}
-	return i32ValAddr;
-}
-
-static int cimaxusb_parse_cfg_ops(struct device_s *bus_adap,
-		unsigned char **pptr, size_t *plen)
-{
-	unsigned char op;
-	int ret;
-	char param1[256], param2[256];
-	char line[256], *ptr_line;
-	int val;
-	unsigned char val2;
-	unsigned int  addr;
-	unsigned char *ptr = *pptr;
-	size_t len = *plen;
-
-	ptr_line = line;
-	op = *ptr;
-	ret = sscanf(ptr, "%s %s", param1, param2);
-	ptr++;
-	len++;
-	if (sscanf(ptr, "%s %X", param1, &val) != 2)
-		return -EFAULT;
-	/*pr_debug("%s: param1=%s,param2=%s, val=%x\n",
-		DRIVER_NAME, param1, param2, val);*/
-	strcpy(ptr_line, param1);
-	len += strlen(param1);
-	ptr += strlen(param1);
-	strncat(ptr_line, ptr, 1);
-	len++;
-	ptr++;
-	strcat(ptr_line, param2);
-	len += strlen(param2);
-	ptr += strlen(param2);
-	/*pr_debug("%s: len = %08d line: %s\n",
-		DRIVER_NAME, len, line);*/
-	addr = cimaxusb_rtr_reg_addr(param1);
-	if (((signed)addr) < 0) {
-		pr_err("%s: unknown register name: %s\n",
-			DRIVER_NAME, param1);
-		return -ENODEV;
-	}
-	if (usb_getbyte(bus_adap, addr, &val2) < 0) {
-		pr_err("%s: CIMaX+ register reading problem: %s\n",
-		DRIVER_NAME, param1);
-		return -ENODEV;
-	}
-
-	switch (op) {
-	case '=':
-		if (waitForValue(bus_adap, addr, val, &val2) == -1) {
-			pr_err("%s : waitForValue failed on : %s\n",
-				DRIVER_NAME, param1);
-			return -ENODEV;
-		}
-		pr_info("%s : wait for value ([%x] = %x = %x)\n",
-			line, addr, val, val2);
-	break;
-	case '?':
-		if (waitForBitsSet(bus_adap, addr, val, &val2) == -1) {
-			pr_err("%s : waitForBitsSet failed on : %s\n",
-				DRIVER_NAME, param1);
-			return -ENODEV;
-		}
-		pr_info("%s : wait for bitsset ([%x] = %x = %x)\n",
-			line, addr, val, val2);
-	break;
-	case '!':
-		if (waitForBitsCleared(bus_adap, addr, val, &val2)
-				== -1) {
-			pr_err("%s : waitForBitsCleared failed on : %s\n",
-				DRIVER_NAME, param1);
-			return -ENODEV;
-		}
-		pr_info("%s : wait for bits cleared ([%x] = %x = %x)\n",
-			line, addr, val, val2);
-	break;
-	case '|':
-		if (setLogicalOr(bus_adap, addr, val, &val2) == -1) {
-			pr_err("%s : setLogicalOr failed on : %s\n",
-				DRIVER_NAME, param1);
-			return -ENODEV;
-		}
-		pr_info("%s : setOr ([%x] = %x = %x)\n",
-			line, addr, val, val2);
-	break;
-	case '&':
-		if (setLogicalAnd(bus_adap, addr, val, &val2) == -1) {
-			pr_err("%s : setLogicalAnd failed on : %s\n",
-				DRIVER_NAME, param1);
-			return -ENODEV;
-		}
-		pr_info("%s : setAnd ([%x] = %x = %x)\n",
-			line, addr, val, val2);
-	break;
-	default:
-		pr_err("Error: Marker Unknown <%c> !!!\n", op);
-		return -ENODEV;
-	}
-	*pptr = ptr;
-	*plen = len;
-	return 0;
-}
-
-static int cimaxusb_parse_cfg_default(struct device_s *bus_adap,
-		unsigned char **pptr, size_t *plen)
-{
-	unsigned char *ptr = *pptr;
-	size_t len = *plen;
-	int ret;
-	char param1[256], param2[256];
-	char line[256], *ptr_line;
-	int val;
-	unsigned char val2;
-	unsigned int  addr;
-
-	ptr_line = line;
-
-	ret = sscanf(ptr, "%s %s", param1, param2);
-	ret = sscanf(param2, "%X", &val);
-	/*pr_debug("%s: param1=%s,param2=%s,val=%x\n",
-		DRIVER_NAME,param1,param2,val);*/
-	strcpy(ptr_line, param1);
-	len += strlen(param1);
-	ptr += strlen(param1);
-	strncat(ptr_line, ptr, 1);
-	len++;
-	ptr++;
-	strcat(ptr_line, param2);
-	len += strlen(param2);
-	ptr += strlen(param2);
-	/*pr_debug("%s: len = %08d line: %s\n",
-		DRIVER_NAME, len, line);*/
-	addr = cimaxusb_rtr_reg_addr(param1);
-	if (((signed)addr) < 0) {
-		pr_err("%s: unknown register name: %s\n",
-			DRIVER_NAME, param1);
-		return -ENODEV;
-	}
-	if (usb_getbyte(bus_adap, addr, &val2) < 0) {
-		pr_err("%s: CIMaX+ register reading problem: %s\n",
-			DRIVER_NAME, param1);
-		return -ENODEV;
-	}
-	if (usb_setbyte(bus_adap, addr, val) < 0) {
-		pr_err("%s: CIMaX+ register writing problem: %s\n",
-			DRIVER_NAME, param1);
-		return -ENODEV;
-	}
-	if (usb_getbyte(bus_adap, addr, &val2) < 0) {
-		pr_err("%s: CIMaX+ register checking problem: %s\n",
-			DRIVER_NAME, param1);
-		return -ENODEV;
-	}
-	pr_info("set: %s(0x%04x) : 0x%02x\n", param1, addr, val);
-
-	*pptr = ptr;
-	*plen = len;
-	return 0;
-}
-
-/******************************************************************************
- * @brief
- *   parse CIMaX+ config file.
- *
- * @param   dev
- *   Pointer to usb device.
- *
- * @param   fw_data
- *   Pointer to buffer with firmware data.
- *
- * @return
- *   O if no error otherwise errno.
- *****************************************************************************/
-int cimaxusb_parse_cfg(struct device_s *bus_adap,
-		const unsigned char *cfg_data, size_t size)
-{
-	char line[256], *ptr_line;
-	size_t len = 0;
-	unsigned char *ptr = (unsigned char *)cfg_data;
-	int ret = -EFAULT;
-
-	dbg("%s: %s size = %zd\n", DRIVER_NAME, __func__, size);
-	do {
-		ptr_line = line;
-		switch (*ptr) {
-		case ';':
-			/* continue up to find \r character */
-			while (*ptr != 0x0A) {
-				*ptr_line++ = *ptr;
-				ptr++;
-				len++;
-			}
-			*ptr_line = 0;
-			/*pr_debug("%s: len = %08d line: %s\n",
-				DRIVER_NAME, len, line);*/
-		break;
-		case 0x0A:
-		case 0x0D:
-			ptr++;
-			len++;
-		break;
-		case '=':
-		case '?':
-		case '!':
-		case '|':
-		case '&':
-			ret = cimaxusb_parse_cfg_ops(bus_adap, &ptr, &len);
-			if (ret < 0)
-				return ret;
-		break;
-		default:
-			ret = cimaxusb_parse_cfg_default(bus_adap, &ptr, &len);
-			if (ret < 0)
-				return ret;
-		break;
-		}
-	} while (len < size);
-
-	return (ret == -EFAULT) ? 0 : ret;
-}
-
-/******************************************************************************
- * @brief
- *   read configuration file ( CIMAX_CONFIG_NAME) and set in CIMaX+ chip.
- *
- * @param   bus_adap
- *   Pointer to usb device.
- *
- * @return
- *   None.
- ******************************************************************************/
-/*
-opt: 0: init, 1: off, 2: Vcc3.3 3: Vcc5
-*/
-int cimaxusb_configuration_setting_opt(struct device_s *bus_adap, int opt)
-{
-	int errno = -EFAULT;
-	const struct firmware *config;
-	char *cfg = cimax_config_file[opt];
-
-	struct usb_device *dev = bus_adap->usbdev;
-
-	dbg("request configuration file");
-	/* request kernel to locate firmware file */
-	errno = request_firmware(&config, cfg, &dev->dev);
-	if (errno < 0) {
-		pr_err("%s: unable to locate configuration file: %s\n",
-			 DRIVER_NAME, cfg);
-		goto error;
-	}
-
-	dbg("parse configuration file");
-	errno = cimaxusb_parse_cfg(bus_adap, config->data, config->size);
-	if (errno < 0) {
-		pr_err("%s: unable to parse config file: %s\n",
-			 DRIVER_NAME, cfg);
-		goto error;
-	}
-
-error:
-	/* release firmware if needed */
-	if (config != NULL)
-		release_firmware(config);
-	return errno;
-}
-
-int cimaxusb_configuration_setting(struct device_s *bus_adap)
-{
-	return cimaxusb_configuration_setting_opt(bus_adap, 0);
-}
-
-int cimaxusb_configuration_setting_vcc(struct device_s *bus_adap, int vcc)
-{
-	return cimaxusb_configuration_setting_opt(bus_adap, vcc);
-}
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_config.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_config.h
deleted file mode 100644
index 5c55204..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_config.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/**************************************************************************//**
- * @file    cimax+usb_config.h
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- ******************************************************************************/
-
-#ifndef __CIMAXPLUS_USB_CFG_H
-#define __CIMAXPLUS_USB_CFG_H
-
-/******************************************************************************
- * Include
- ******************************************************************************/
-#include "cimax+usb_handle.h"
-
-/******************************************************************************
- * Defines
- ******************************************************************************/
-#define CIMAX_CONFIG_NAME   "cimax+usb.cfg"
-
-/******************************************************************************
- * Enums
- ******************************************************************************/
-/******************************************************************************
- * Structures
- ******************************************************************************/
-
-/******************************************************************************
- * Functions
- ******************************************************************************/
-
-/******************************************************************************
- * @brief
- *   read configuration file ( CIMAX_CONFIG_NAME) and set in CIMaX+ chip.
- *
- * @param   bus_adap
- *   Pointer to usb device.
- *
- * @return
- *   None.
- ******************************************************************************/
-int cimaxusb_configuration_setting(struct device_s *bus_adap);
-
-#endif
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_fw.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_fw.c
deleted file mode 100644
index 6bccf4b..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_fw.c
+++ /dev/null
@@ -1,325 +0,0 @@
-/**************************************************************************//**
- * @file    cimax+usb_fw.c
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- ******************************************************************************/
-/******************************************************************************
- * Include
- ******************************************************************************/
-#include <linux/slab.h>
-#include <linux/init.h>
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/poll.h>
-#include <linux/usb.h>
-
-#include <linux/errno.h>
-#include <linux/firmware.h>
-
-#include <linux/uaccess.h>
-#include <linux/mutex.h>
-
-#include <linux/printk.h>
-
-#include "cimax+usb-driver.h"
-#include "cimax+usb_fw.h"
-
-/******************************************************************************
- * Structures
- ******************************************************************************/
-/******************************************************************************
- * Globals
- ******************************************************************************/
-char cimax_fw[] = CIMAX_FIRMWARE_NAME;
-
-/******************************************************************************
- * Functions
- ******************************************************************************/
-/******************************************************************************
- * @brief
- *   Start & check Bistrom.
- *
- * @param   dev
- *   Pointer to usb device.
- *
- * @param   startAddr
- *   start address of firmware to compute
- *
- * @param   endAddr
- *   stop address of firmware to compute
- *
- * @param   FWSign
- *   Current signature to check
- *
- *
- * @return
- *   None.
- ******************************************************************************/
-int checkBistRom(struct device_s *bus_adap,
-	int startAddr, int endAddr, int signature)
-{
-	unsigned char *Val;
-	int rv;
-
-	struct usb_device *dev = bus_adap->usbdev;
-
-	Val = kcalloc(2, sizeof(unsigned char), GFP_KERNEL);
-	if (!Val) {
-		pr_err("%s-%s: out of memory.\n", DRIVER_NAME, __func__);
-		return -ENOMEM;
-	}
-
-	/* Write "Flash" Size
-	   (!) BistRom is computed since D000-flashSize to D0000-6
-	*/
-	Val[0] = (0xD000-startAddr)&0x00ff;
-	Val[1] = (0xD000-startAddr)>>8;
-	if (bus_adap->ops->write_ctrl_message(dev, 0x008D, Val, 2) != 2) {
-		kfree(Val);
-		return -1;
-	}
-
-	/* Write Signature*/
-	Val[0] = signature&0x00ff;
-	Val[1] = signature>>8;
-	if (bus_adap->ops->write_ctrl_message(dev, 0x0080, Val, 2) != 2) {
-		kfree(Val);
-		return -1;
-	}
-
-	/* Launch BistRom [(D000-flashSize)..CFF9]+[FFFA..FFFF] computation*/
-	Val[0] = 0x0F;
-	if (bus_adap->ops->write_ctrl_message(dev, 0x0082, Val, 1) != 1) {
-		kfree(Val);
-		return -1;
-	}
-
-	pr_info("\n>>Read Signature\n");
-
-	/* Read Signature*/
-	if (bus_adap->ops->read_ctrl_message(dev, 0x0041, Val, 2) != 2) {
-		kfree(Val);
-		return -1;
-	}
-
-	pr_info("\n>> Bistrom computed = %04X\n",  Val[0]|Val[1]<<8);
-
-	/* Read Boot status*/
-	if (bus_adap->ops->read_ctrl_message(dev, 0x0009, Val, 1) != 1) {
-		kfree(Val);
-		return -1;
-	}
-
-	pr_info("\n>> BootRom Status = %02X\n",  Val[0]);
-	rv = Val[0];
-	kfree(Val);
-
-	return rv;
-}
-
-/******************************************************************************
- * @brief
- *   Compute BistRom.
- *
- * @param   ptr
- *   Pointer to buffer with register data
- *
- * @param   size
- *   Number of register to process
- *
- * @param   FWSign
- *   Current signature
- *
- * @return
- *   None.
- ******************************************************************************/
-unsigned int MISR(const unsigned char *ptr, int size, unsigned int FWSign)
-{
-	int k, i;
-
-	unsigned short mySign;
-
-	for (k = 0; k < size; k++) {
-		mySign = ptr[k]&0x01;
-
-		for (i = 0; i < 16; i++) {
-			if (0x88B7 & (1<<i))
-				mySign ^= (FWSign>>i) & 0x01;
-		}
-
-		mySign |= ((FWSign<<1)^(ptr[k])) & 0x00FE;
-		mySign |= (FWSign<<1) & 0x00FF00;
-
-		FWSign = mySign;
-	}
-
-	return FWSign;
-}
-
-
-/******************************************************************************
- * @brief
- *   upload firmware in CIMaX+ chip.
- *
- * @param   dev
- *   Pointer to usb device.
- *
- * @param   fw_data
- *   Pointer to buffer with firmware data.
- *
- * @param   FWSign
- *   Pointer to store computed signature.
- *
- * @return
- *   None.
- ******************************************************************************/
-int cimaxusb_firmware_upload(struct device_s *bus_adap,
-	const unsigned char *fw_data, unsigned int *FWSign)
-{
-	int errno = -EFAULT;
-	const unsigned char *ptr;
-	int startAddr = START_FW_ADDR;
-	unsigned char *recv;
-	int size;
-
-	struct usb_device *dev = bus_adap->usbdev;
-
-	/* data firmware */
-	ptr = fw_data;
-	ptr += START_FW_ADDR;
-
-	recv = kcalloc(300, sizeof(unsigned char), GFP_KERNEL);
-	if (!recv) {
-		pr_err("%s-%s: out of memory.\n", DRIVER_NAME, __func__);
-		return -ENOMEM;
-	}
-
-	do {
-		/* compute the size to send to CIMaX+ */
-		size = (startAddr <= (STOP_FW_ADDR + 1 - MAX_FW_PKT_SIZE)) ?
-			(MAX_FW_PKT_SIZE) : (STOP_FW_ADDR + 1 - startAddr);
-		/* compute Signature */
-		*FWSign = MISR(ptr, size, *FWSign);
-
-		pr_info("%s: firmware start address %08x size %d\n",
-			DRIVER_NAME, startAddr, size);
-
-		/* upload data firmware */
-		if (bus_adap->ops->write_ctrl_message(
-				dev, startAddr, (void *)ptr, size) != size) {
-			pr_err("Failed to load CIMaX+ firmware\n");
-			errno = -ENODEV;
-			break;
-		}
-		if (bus_adap->ops->read_ctrl_message(
-				dev, startAddr, (void *)recv, size) != size) {
-			pr_err("Failed to load CIMaX+ firmware\n");
-			errno = -ENODEV;
-			break;
-		}
-		if (memcmp(ptr, recv, size)) {
-			pr_err("Failed compare at Address 0x%04x\n",
-				startAddr);
-			errno = -ENODEV;
-			break;
-		}
-		/* update size sent to CIMaX+ */
-		startAddr += size;
-		ptr += size;
-		if (startAddr >= STOP_FW_ADDR)
-			break;
-	} while (1);
-
-	kfree(recv);
-
-	if (errno == -EFAULT) {
-		/* upload interrupt vector*/
-		ptr = fw_data;
-		ptr += START_INTVECT_ADDR;
-		startAddr =  START_INTVECT_ADDR;
-
-		/* continue to compute Signature */
-		*FWSign = MISR(ptr, 6, *FWSign);
-
-		/* upload interrupt vector data*/
-		if (bus_adap->ops->write_ctrl_message(
-				dev, startAddr, (void *)ptr, 6) != 6) {
-			pr_err("Failed to load CIMaX firmware(Int vector)\n");
-			errno = -ENODEV;
-		}
-	}
-	return (errno == -EFAULT) ? 0 : errno;
-}
-
-/******************************************************************************
- * @brief
- *   upload and start firmware in CIMaX+ chip.
- *
- * @param   bus_adap
- *   Pointer to usb device.
- *
- * @return
- *   None.
- ******************************************************************************/
-int cimaxusb_fw_upload(struct device_s *bus_adap)
-{
-	int errno = -EFAULT;
-	const struct firmware *firmware;
-	char *fw = cimax_fw;
-	unsigned int FWSign = 0;
-	int ret;
-
-	struct usb_device *dev = bus_adap->usbdev;
-
-	/* request kernel to locate firmware file */
-	errno = request_firmware(&firmware, fw, &dev->dev);
-	if (errno < 0) {
-		pr_err("%s: unable to locate firmware file: %s\n",
-				DRIVER_NAME, fw);
-		goto error;
-	}
-
-	errno = cimaxusb_firmware_upload(bus_adap, firmware->data, &FWSign);
-	if (errno < 0) {
-		pr_err("%s: unable to upload firmware file: %s\n",
-				DRIVER_NAME, fw);
-		goto error;
-	}
-
-	pr_info("%s: firmware: %s loaded with success. Current Bistrom %04X\n",
-			DRIVER_NAME, fw, FWSign);
-
-	ret = checkBistRom(bus_adap, START_FW_ADDR, STOP_FW_ADDR, FWSign);
-	if (ret != 0x02) {
-		pr_err("\nError: Fail on compare BistRom (%02X) !\n", ret);
-		errno = -ENODEV;
-		goto error;
-	}
-
-	if (bus_adap->ops->init_fw(dev) != 0) {
-		pr_err("\nError: Fail on INIT command !\n");
-		errno = -ENODEV;
-		goto error;
-	}
-
-error:
-	/* release firmware if needed */
-	if (firmware != NULL)
-		release_firmware(firmware);
-	return errno;
-}
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_fw.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_fw.h
deleted file mode 100644
index bf3f64c..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_fw.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/**************************************************************************//**
- * @file    cimax+usb_fw.h
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- ******************************************************************************/
-
-#ifndef __CIMAXPLUS_USB_FW_H
-#define __CIMAXPLUS_USB_FW_H
-
-/******************************************************************************
- * Include
- ******************************************************************************/
-#include "cimax+usb_handle.h"
-
-/******************************************************************************
- * Defines
- ******************************************************************************/
-#define CIMAX_FIRMWARE_NAME   "cimax+_usbdvb.bin"
-#define START_FW_ADDR	      0x8000
-#define STOP_FW_ADDR	         0xCFF9
-#define START_INTVECT_ADDR	   0xFFFA
-#define MAX_FW_PKT_SIZE	      256
-
-/******************************************************************************
- * Enums
- ******************************************************************************/
-/******************************************************************************
- * Structures
- ******************************************************************************/
-
-/******************************************************************************
- * Functions
- ******************************************************************************/
-/******************************************************************************
- * @brief
- *   upload firmware in CIMaX+ chip.
- *
- * @param   bus_adap
- *   Pointer to usb device.
- *
- * @return
- *   None.
- ******************************************************************************/
-int cimaxusb_fw_upload(struct device_s *bus_adap);
-
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_handle.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_handle.h
deleted file mode 100644
index 936b9cf..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_handle.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**************************************************************************//**
- * @file    cimax+usb_handle.h
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- ******************************************************************************/
-
-#ifndef __CIMAXPLUS_USB_HDLE_H
-#define __CIMAXPLUS_USB_HDLE_H
-
-#ifdef __KERNEL__
-
-struct cimaxusb_priv_ops_t {
-	int (*write_ctrl_message)(
-		struct usb_device *dev, int addr, void *data, int size);
-
-	int (*read_ctrl_message)(
-		struct usb_device *dev, int addr, void *data, int size);
-
-	int (*init_fw)(
-		struct usb_device *dev);
-
-	int (*write_ep6_message)(
-		struct usb_device *dev, void *data, int size);
-
-	int (*read_ep5_message)(
-		struct usb_device *dev, void *data, int size);
-};
-
-#endif
-
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_time.c b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_time.c
deleted file mode 100644
index ea80b5e..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_time.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/**************************************************************************//**
- * @file    cimax+usb_fw.c
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- ******************************************************************************/
-
-/*#define TIMESTAMP*/
-
-/******************************************************************************
- * Include
- ******************************************************************************/
-#include <linux/delay.h>
-
-#include "cimax+usb_time.h"
-
-/******************************************************************************
- * Structures
- ******************************************************************************/
-#define err(format, arg...)\
-	pr_err("cimax+usb_time: %s> ERROR " format "\n" , \
-		__func__, ## arg)
-#define info(format, arg...) pr_info("time> " format "\n", ## arg)
-/******************************************************************************
- * Globals
- ******************************************************************************/
-#ifdef TIMESTAMP
-struct item_array_s gstArray;
-#endif
-/******************************************************************************
- * Functions
- ******************************************************************************/
-/******************************************************************************
- * @brief
- *   Init timestamp.
- *
- * @param
- *   None
- *
- * @return
- *   None.
- ******************************************************************************/
-void InitTimestamp(void)
-{
-#ifdef TIMESTAMP
-	gstArray.count = 0;
-#endif
-	return;
-}
-
-/******************************************************************************
- * @brief
- *   Set timestamp.
- *
- * @param   pcFormat
- *   Printf-like format
- *
- * @return
- *   None.
- ******************************************************************************/
-void SetTimestamp(const char *pcFormat, ...)
-{
-#ifdef TIMESTAMP
-	va_list stArgs;
-
-	if (gstArray.count >= MAX_ITEMS) {
-		if (gstArray.count++ == MAX_ITEMS)
-			ShowTimestamp();
-		return;
-	}
-	ktime_get_ts(&gstArray.stItem[gstArray.count].stTime);
-	va_start(stArgs, pcFormat);
-	vsprintf(gstArray.stItem[gstArray.count++].pcLine, pcFormat, stArgs);
-	va_end(stArgs);
-#endif
-	return;
-}
-
-/******************************************************************************
- * @brief
- *   Display all timestamps.
- *
- * @param
- *   None
- *
- * @return
- *   None.
- ******************************************************************************/
-void ShowTimestamp(void)
-{
-#ifdef TIMESTAMP
-	int i;
-
-	if (gstArray.count == 0) {
-		err("No timestamps available");
-		return;
-	}
-
-	info("===============================================================");
-	info("                         TIMESTAMPS");
-	info("===============================================================");
-
-	for (i = 0; i < gstArray.count; i++) {
-		info("[%04d] [%03d.%09d] %s",
-				i,
-				gstArray.stItem[i].stTime.tv_sec,
-				gstArray.stItem[i].stTime.tv_nsec,
-				gstArray.stItem[i].pcLine);
-		if ((i % 100) == 0)
-			msleep(20);
-	}
-	info("===============================================================");
-	gstArray.count = 0;
-
-#endif
-	return;
-}
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_time.h b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_time.h
deleted file mode 100644
index 0012c64..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/SRC/cimax+usb_time.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/**************************************************************************//**
- * @file    cimax+usb_time.h
- *
- * @brief   CIMaX+ USB Driver for linux based operating systems.
- *
- * Copyright (C) 2009-2011    Bruno Tonelli   <bruno.tonelli@smardtv.com>
- *                          & Franck Descours <franck.descours@smardtv.com>
- *                            for SmarDTV France, La Ciotat
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- ******************************************************************************/
-
-#ifndef __CIMAXPLUS_USB_TIME_H
-#define __CIMAXPLUS_USB_TIME_H
-
-/******************************************************************************
- * Include
- ******************************************************************************/
-#include <linux/ktime.h>
-
-/******************************************************************************
- * Defines
- ******************************************************************************/
-#define MAX_ITEMS     100000
-#define MAX_LINE_SIZE    128
-
-/******************************************************************************
- * Enums
- ******************************************************************************/
-/******************************************************************************
- * Structures
- ******************************************************************************/
-struct item_s {
-	struct timespec stTime;
-	char            pcLine[MAX_LINE_SIZE];
-};
-
-struct item_array_s {
-	int  count;
-	item_s stItem[MAX_ITEMS];
-};
-
-extern struct item_array_s gstArray;
-
-/******************************************************************************
- * Functions
- ******************************************************************************/
-/******************************************************************************
- * @brief
- *   Init timestamp.
- *
- * @param
- *   None
- *
- * @return
- *   None.
- ******************************************************************************/
-void InitTimestamp(void);
-
-/******************************************************************************
- * @brief
- *   Set timestamp.
- *
- * @param   pcFormat
- *   Printf-like format
- *
- * @return
- *   None.
- ******************************************************************************/
-void SetTimestamp(const char *pcFormat, ...);
-
-/******************************************************************************
- * @brief
- *   Display all timestamps.
- *
- * @param
- *   None
- *
- * @return
- *   None.
- ******************************************************************************/
-void ShowTimestamp(void);
-
-#endif
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/firmware/cimax+_usbdvb.bin b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/firmware/cimax+_usbdvb.bin
deleted file mode 100644
index 315fe5e..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/firmware/cimax+_usbdvb.bin
+++ /dev/null
@@ -1,81 +0,0 @@
-                         @ /  
- @ 	  	       	      	          	      	    	"S D T V   T B D                 "C I M A X   T B D               "S N 0 0 0   T B D                  
-
-آ ᆨ < Lކ 
-  i i  	$ y| 
-ㅑ7{  ͆  ㅑ7{ ͆B
- ` `Lކ`)8y|-y| %ʩ   `HHH9{1O{)&r!qp D{9{ O{)ߍL 9{(  || KA_CSD.EyF4GMHIJL܇MNPPQRSVSWXوî1Ōvιf6 ;0ʕ  u  u  LL9L9 ;0ʕ  u  u  L$L9ʕ     ʕ     8.ʭm m  LL9ʕ     ʕ     8.ʭm m  LL9 ;Kʕ  ʕ   i i  u  u  LXL9ʭi i    L9 L9 L9 L9 L9L9L9ʕ     ʕ   譪 ʭi i     8 7 iiLLL9ʕ     ʕ   譪 ʭi i     8 7 iiLLSL9ʕ     ʕ   譪 ʭi i     8 7 iiLJLL9L9L9 L9 L9 L9 L9 L9L9 ;0ʕ  u  u  LL9ʕ     ʕ     8.ʭm m  L6L9ʕ     ʕ     8.ʭm m  LL9L9L9 ;0ʕ  u  u  LL9L9K>NQSː.ΰ* ||ʕ   i||i }|Lʕ     ʕ   { i||i }|Lhhh`  @@.  Q  ÓLF{b͐|ZSLE-=V|  	@ Ó D{LG{g͑|_ɁXQJ-B-	V|  	@ Ó D{L K  8l8
-2&Ryj!, :L _L YL LJ{)J{ H{~|  LJ{)J{ I{~| L~|  L~| L~|ʕ      mLc  ʭ ʕ   i i ΰV-  ?- s|L8s|?-t|LX@-w|LXɀLXLXL䐭  GL~|ʕ      mLf  ʭ ʕ   i i ΰV-  ?- u|L;u|?-v|L[@-x|L[ɀL[L[L瑭 GL~|   |L~|  |L~|  L~| LH{~|  Ġ H{LI{~| Ġ I{L~|  }ǍL~| }ǍL L /L
-	@ Ó`y|)	-y|L$ 8{ [ Z}|]||\	XX	X8 ||}| 	 `  ):h	h 0)8y|0-y|	l | |)Ls |)L | | | 9{h)h|iX | |-y| 	)҄ts	)|WP)
-
-|h)hLS)|h)hLS) |h)h|
-|L|L.||)
-||L畭|UD{P-y|CK{L{|K{L{|| E 	@ Ó||=|8-y|0H{&H{    N  Ó |L}|JD{E-y|8 K{ L{ || E 	@ Ó ||LL|LL||)
-||L|P-y|CM{N{|M{N{||  	@ Ó||=|8-y|0I{&I{      Ó |L|E-y|8 M{ N{ ||  	@ Ó |7{-y|D{  7{-y|EO{)&r!qp9{ O{ D{)ߍp)9{
-8{8{D{K<{={A:{ X  Ó<{ <{h)h={ ={h)hLʩ   `HHHHHHHxj)7{)||9{j)LB{q>{d>{gC{ p@{|)@{@{|)@{@{|)|L
- | | F{) B{C{q?{d?{gB{ pA{|)A{A{|)A{A{|)|L | | G{) C{҄tsj)L|Ll)||#B{ p >{p@{pLB{ p >{|e>{p @{p))||#C{ p ?{pA{pLiC{ p ?{|e?{p A{p)L|
-|L)Li)gB{)|| p >{p@{pL p >{|e>{p @{)J{)J{p|o)gC{)|| p ?{pA{pLi p ?{|e?{p A{p)J{)J{))L)Lk)Lk|	)))ʕ -J{J{||Lf||	L||)	ʭo|i p|i   -')||	|LX|	|)Lk|)7|2)*	))ʕ -J{J{|k) sk):YO{-O{-	  Xrqp)ߍ9{ D{k) )7{j)@:{<{h	@hj);{={h	hjLrkLrXhhhhhhh@r ʭ     qʕ   ʭ `|| | |p` ʩ ҕ o ΰ'8||||||pLp` p oʩ   ΰL(p P  Ţc @-|| `  c`}}	}} } }`}}	}}}}}}` 
-} } ` Ϡ ͒0 LϞLϠ ,} Ǟ)L` d  ) ݝLVp 
-`)	 
-L
-`d  ) L" ݝ)Lp`) ! }`"}`HHH}} } }}m}}m}8}}}}Lu8}}}}  8V)L䠭}@ L 񟭔  }}L}m}}}m}}hhh`HHH L硠 !	 L !) ͓>"}}*}} }i}}i}}}LM@}}L)LL䡭L硭}}Lܡ)Lhhh`  d  a )Ls)+)#	 )Ls)Ls ݝLp`6 ʭ})? }) 8}}}}	  `)Lڢ`)	 D)}Hh r) 	 L!L!L!3-} ! LX !	 )Lo !	`) 	)\))
- 	L⣭))L⣠ 		)	 ۢ)-9{ 8{	  8{-	)	)@	@)	)	a)  Ţ a`HHH	 ͎L;ʕ  ou  {u  ŗl{mL;ʕ  pu  {u  ʱ ʩ  ]Hl{ʕ hu mLhhh` -} 1|@Lm }	   L$
-}}}    LLLʭ} }    , E }   _)    L)J   L)JJ   L)JJJ   L)JJJJ   L) Hh r΍   L)@Hh r΍   LLLL `}L L-}L} KQ8j	@	 i)iL	 	i)iYL		i)iL		i)iL		i)iL		i)iLLLL`} L-}L} KC*u\	@	 i)iL	 	i)iYL		i)iL		i)iL		i)iL		i)iLLLL`d  ) ݝ	Lp 
-}L
-}`}}}P{} Ǟ} } !}/"} #} $}} } `b}{}
-} } ` p)@ p)@s{s{-t{|	@|L p)@I-s{s{l}{}} } `}{}	} } `} }|}} }Lƪ;p) p
-| Ǟ}|}"} }Lƪ;p) "p,| Ǟ*}|}"} }Lƪ;p) BpN| ǞL}|}"} }Lƪ	Lƪ `  } K1.F LN TLN r LN LNLN ީ	LNLN	 ~`  }l}{} L` 
-} L   `}
-}L᫭}
-}L᫠` 
-}}}	n| L
- `HHH}  I[Rdmv HL L L L תL bL L L 嫍L
-}L}}L}n|n| LLuLn|+  
- 	 LUn| ʕ  pu  {u  ʕ  qu  {u  1JJJi
-
-
-ʕ  qu  {u  1ʕ  wu  {u  ʕ  xu  {u  1JJJi
-
-
-ʕ  xu  {u  1	ʕ  ~u  {u  
-ʕ  u  {u  1JJJi
-
-
-ʕ  u  {u  1ʕ  u  {u  ʕ  u  {u  1JJJi
-
-
-ʕ  u  {u  1				 tu	 	@	 L	LLLhhh`E{ii&ΎD{ՠ E{`yΪ!ΨΩ뭪`HHHʕ  ʩ
-   ε (|o|p|JIVL|q|r|ʌɌ֌ ʭi i   1LW
- ii")L
- Hh L<)L, Hh  Li/9{}}   L09{}}}   L0 V F{L걠 G{h<{h)h={h)h9{      L0hhh`    K `HHHʕ     ʕ   ʕ  ʩ   ΐ/}}}L LQ ;ʕ  u  u H }hL}L h)hhhh`HHHʕ     ʕ    L  M h)hhhh`HHH  hx|O	|JI@h	   |)ߍL    I LL o|I	|ʌɌh	   |)ߍL      L8L L:)L6 Hh  )L)Lp Hh  )-L
- L  m83|Lⵠ|     L.}}}  LP      F{La G{s|
-t|w|Lu|
-v|x|hhhh` Ϡ  hxh	@hL`|||&	|JIAL]|+}}} J L>    I h<{h)h={h)hXLDL	L	|+|&	|ʌɌL	|+}}}  L귩     h<{h)h={h)hXLD}L 
-  ii ii ʭ ʩ  ε   
-ʭ) )  i i  ii Lfii ʭ ʩ  ε   
-ʭ) )  i i ii Lܸ8 N}}}   
-h<{h)h={h)hXLDii ʭ ʩ  ε   
-ʭ) )  i i  L- L׺ ii ʭ Vv    Hh r΍ʭ Vv    詌} L     L#}}}   
-h<{h)h={h)hXLύHHHxF{
-G{hh	@hLx } } o|p||L3|L3)L3	|JIBF{Vs|t|	E}ʭ ʩ  ε   }ʭ) )  i o|ip|o|p|Lu    I  F{h<{h)h={h)hXLLL } } q|r||LF|LF)LF	|ʌɌG{֌u|v|	E}ʭ ʩ  ε   }ʭ) )  i q|ir|q|r|L      G{h<{h)h={h)hXLLʕ     ʕ   ʭ ʩ  ε   
-ʭ) )  i i )@w
- 	}
-LD	}
-
- ʭi i    ʭi i    F{|LG{|Uʭi i  @ 1.9{}}  XLL0@ (XL F{LB G{      
-F{ G{h<{h)h={h)hXhhh`HHHh|=|8	|JIC}
-o|p|L    I  LLwe|=|8	|ʌɌÌ}
-q|r|Lw      Lʭi i     ( Lʭi i   ʭi i   ʕ     ʕ  u u /}}}   Lĭ ʕ       mʭi i    ʕ     ʕ  u u8ʭ L>ʭ  ʭi i    @ ( LĠ  8
- ʭi i   ʭi i   @-L)é ʭi i   Lʭi i   @-/}}}   Lʭi i   ʭi i    -Hh -Hh ʭi i    ʭi i    )@"׍  Lĭ)2--ۍ  Lĩ-- 
-hhh`HHHxs|I|D	|JIFw|}
-o|p|L9ũ    I XLuLťLŭ|Lŭ||	|ʌɌƌx|}
-q|r|)/}}  	XLuLũ     XLuʭi i   -Lʭi i   ʭi i    $ʭi i   Lʭi i    J{Lǭ}}}  		Lǭ | 
- A	||	Ltǥ	||	Xhhh`HHH xʕ     ʕ  u ut|H|C	|JIDTw|}
-o|p|L9ȩ    I XLLȭq|H|C	|ʌɌČԌx|}
-q|r|Lȩ     XLʭi i   ʭi i  詀 1u8H{+H{ |    N L4ɠ LlɭI{+I{ |     Llɠ L1ʭi i   ʭi i   @-Lʭi i   ʭi i     8 Lʭ$ʭi i   Lʭi i         L1˭$ʭi i   Lʭi i    "     L1˩      
- C	||	L˭	||	Xhhh`HHHf|=|8	|JIW}
-o|p|L̩    I LLx̭c|=|8	|ʌɌ׌}
-q|r|Lx̩     Lʭi i   }}   
-hhh`) ))|L̠|Lͭ	)|L͠|`HHHLέ       R Б  Б S L!Ω     h)hhhh`}} Q h)h` VuLm` J`  ` 8  ` Vv uuLε 
-6ڵ `8vv `Vv `II`hh8ѕ 8
-e斠Hhl L8ϕhhȱiLZȱHhl hhȱȱ ȱiLȱHhl hhHHHHl hhhh`@%]
\ No newline at end of file
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/firmware/cimax+usb.cfg b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/firmware/cimax+usb.cfg
deleted file mode 100644
index 7e792d8..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/firmware/cimax+usb.cfg
+++ /dev/null
@@ -1,97 +0,0 @@
-;
-; ************************
-; *  INIT_TS.TXT SCRIPT  *
-; ************************
-;
-; *** CLOSE INPUT ***
-;
-IN_SEL 0x00
-;
-; *** CLOSE OUPUT ***
-;
-OUT_SEL 0x00
-;
-; *** RESET FIFO ***
-;
-FIFO_CTRL 0x0f
-SYNC_RTV_CTRL 0x0f
-;
-;
-; *************************
-; *  INIT_USB.TXT SCRIPT  *
-; *************************
-;
-; *** Endpoint Config ***
-;
-DMA_ACC_EPS	0x3f
-EPS_ENABLE 0x7f
-;
-; *** FIFO Control ***
-;
-USB2TS_CTRL	0x0f
-TS2USB_CTRL	0x0f
-;
-; *** FREQ Control ***
-;
-USB2TS0_RDL	0x80
-USB2TS1_RDL	0x80
-;
-;-----------------------------------------------------------------------------
-; Set CAM power
-;-----------------------------------------------------------------------------
-;
-GPIO0_DATA_OUT	0x00
-;
-; unlock CFG
-CFG_2	0x00
-;
-; 1) DVB/CI/CI+/SCARD 2slot
-CFG_1	0x00
-;
-; 2) Set the Default "power off" state such as VCC_MODA=VCC_MODB=VPPx_MODA=VPPx_MODB='Z'
-GPIO0_DFT 0x00
-;
-; 3) Set GPIO3 as external power switch driver
-GPIO0_MASK_DATA 0x07
-;
-; 4) Set "power on" state (VCC=VPP1=VPP2= 5V)
-GPIO0_DATA_OUT	0x01
-;
-; 5) Lock config
-CFG_2	0x01
-;
-; 6) Write in the GPIO0_DIR_REG: defines the GPIOs, which
-;    are used to drive the external power switch, in output mode.
-GPIO0_DIR 0x07
-;
-; 7) Check VCCENable
-?CFG_1 0x20
-;
-; 8) Set & wait for PcmciaOutputEnable
-|CFG_1 0x08
-?CFG_1 0x08
-;
-;---------------------------------------
-; Set Router CAM
-;---------------------------------------
-;
-;
-GAP_REMOVER_CH0_CTRL 0x0C
-GAP_REMOVER_CH1_CTRL 0x0C
-
-; 9) CH0 & CH1 from CAM A & B, CAM A & B from CH0 & CH1
-;
-ROUTER_CAM_MOD	0x21
-ROUTER_CAM_CH	0x00
-;
-;_Wait	200
-;---------------------------------------
-; ROUTER CAM
-;---------------------------------------
-OUT_SEL 0x03
-;
-USB2TS0_RDL	0x80
-USB2TS1_RDL	0x80
-;
-IN_SEL 0x22
-
diff --git a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/firmware/cimax+usb_ms.cfg b/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/firmware/cimax+usb_ms.cfg
deleted file mode 100644
index 5c38429..0000000
--- a/drivers/stream_input/parser/hw_demux/dvb_ci/cimax/usb/firmware/cimax+usb_ms.cfg
+++ /dev/null
@@ -1,136 +0,0 @@
-;
-; ************************
-; *  INIT_TS.TXT SCRIPT  *
-; ************************
-;
-; *** CLOSE INPUT ***
-;
-IN_SEL 0x00
-;
-; *** CLOSE OUPUT ***
-;
-OUT_SEL 0x00
-;
-; *** RESET FIFO ***
-;
-FIFO_CTRL 0x0f
-SYNC_RTV_CTRL 0x0f
-;
-;
-; *************************
-; *  INIT_USB.TXT SCRIPT  *
-; *************************
-;
-; *** Endpoint Config ***
-;
-DMA_ACC_EPS	0x3f
-EPS_ENABLE 0x7f
-;
-; *** FIFO Control ***
-;
-USB2TS_CTRL	0x0f
-TS2USB_CTRL	0x0f
-;
-; *** FREQ Control ***
-;
-USB2TS0_RDL	0x80
-USB2TS1_RDL	0x80
-;
-;-----------------------------------------------------------------------------
-; Set CAM power
-;-----------------------------------------------------------------------------
-;
-GPIO0_DATA_OUT	0x00
-;
-; unlock CFG
-CFG_2	0x00
-;
-; 1) DVB/CI/CI+/SCARD 2slot
-CFG_1	0x00
-;
-; 2) Set the Default "power off" state such as VCC_MODA=VCC_MODB=VPPx_MODA=VPPx_MODB='Z'
-GPIO0_DFT 0x00
-;
-; 3) Set GPIO3 as external power switch driver
-GPIO0_MASK_DATA 0x07
-;
-; 4) Set "power on" state (VCC=VPP1=VPP2= 5V)
-GPIO0_DATA_OUT	0x01
-;
-; 5) Lock config
-CFG_2	0x01
-;
-; 6) Write in the GPIO0_DIR_REG: defines the GPIOs, which
-;    are used to drive the external power switch, in output mode.
-GPIO0_DIR 0x07
-;
-; 7) Check VCCENable
-?CFG_1 0x20
-;
-; 8) Set & wait for PcmciaOutputEnable
-|CFG_1 0x08
-?CFG_1 0x08
-;
-;---------------------------------------
-; Set Router CAM
-;---------------------------------------
-;
-;
-GAP_REMOVER_CH0_CTRL 0x0C
-GAP_REMOVER_CH1_CTRL 0x0C
-
-; 9) CH0 & CH1 from CAM A & B, CAM A & B from CH0 & CH1
-;
-ROUTER_CAM_MOD	0x21
-ROUTER_CAM_CH	0x00
-;
-;_Wait	200
-;---------------------------------------
-; ROUTER CAM
-;---------------------------------------
-OUT_SEL 0x03
-;
-USB2TS0_RDL	0x80
-USB2TS1_RDL	0x80
-;
-IN_SEL 0x22
-
-; ***************************
-; *  MuliStream.TXT SCRIPT  *
-; ***************************
-;
-; *** CLOSE INPUT ***
-;
-IN_SEL 0x00
-;
-; *** CLOSE OUPUT ***
-;
-OUT_SEL 0x00
-;
-; *** RESET FIFO ***
-;
-FIFO_CTRL 0x0f
-SYNC_RTV_CTRL 0x0f
-;
-; ***   ***
-;
-CkMan_Config 0x1f
-CkMan_Select 0x00
-MERGER_DIV_MICLK 0x02
-SYNC_SYMBOL 0x0d
-PID_AND_SYNC_REMAPPER_INV_CTRL 0x01
-
-FIFO_CTRL 0x0f
-ROUTER_CAM_MOD 0x03
-ROUTER_CAM_CH 0x80
-
-USB2TS_CTRL 0x0f
-TS2USB_CTRL 0x0f
-USB2TS0_RDL 0x20
-USB2TS1_RDL 0x20
-
-OUT_SEL 0x03
-IN_SEL 0x22
-;
-; ************************
-;
